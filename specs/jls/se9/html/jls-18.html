
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;18.&nbsp;Type Inference</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-17.html" title="Chapter&nbsp;17.&nbsp;Threads and Locks">
      <link rel="next" href="jls-19.html" title="Chapter&nbsp;19.&nbsp;Syntax">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="../../../../webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="../../../../9/">Java SE</a> &gt; <a href="../../../index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;18.&nbsp;Type Inference</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-17.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-19.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;18.&nbsp;Type Inference">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-18"></a>Chapter&nbsp;18.&nbsp;Type Inference
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-18.html#jls-18.1">18.1. Concepts and Notation</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-18.html#jls-18.1.1">18.1.1. Inference Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.1.2">18.1.2. Constraint Formulas</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.1.3">18.1.3. Bounds</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-18.html#jls-18.2">18.2. Reduction</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.1">18.2.1. Expression Compatibility Constraints</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.2">18.2.2. Type Compatibility Constraints</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.3">18.2.3. Subtyping Constraints</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.4">18.2.4. Type Equality Constraints</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.5">18.2.5. Checked Exception Constraints</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-18.html#jls-18.3">18.3. Incorporation</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-18.html#jls-18.3.1">18.3.1. Complementary Pairs of Bounds</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.3.2">18.3.2. Bounds Involving Capture Conversion</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-18.html#jls-18.4">18.4. Resolution</a></span></dt>
               <dt><span class="section"><a href="jls-18.html#jls-18.5">18.5. Uses of Inference</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-18.html#jls-18.5.1">18.5.1. Invocation Applicability Inference</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.5.2">18.5.2. Invocation Type Inference</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-18.html#jls-18.5.2.1">18.5.2.1. Poly Method Invocation Compatibility</a></span></dt>
                           <dt><span class="section"><a href="jls-18.html#jls-18.5.2.2">18.5.2.2. Additional Argument Constraints</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-18.html#jls-18.5.3">18.5.3. Functional Interface Parameterization Inference</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.5.4">18.5.4. More Specific Method Inference</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <p class="norm"><a name="jls-18-100"></a>A variety of compile-time
            analyses require reasoning about types that are not yet
            known. Principal among these are generic method applicability testing
            (<a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>) and generic method invocation type
            inference (<a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>). In general, we refer to the
            process of reasoning about unknown types as <span class="emphasis"><em>type
                  inference</em></span>.
         </p>
         <p class="norm"><a name="jls-18-200"></a>At a high level, type inference
            can be decomposed into three processes:
         </p>
         <div class="norm">
            <ul class="norm" type="disc">
               <li class="listitem">
                  <p class="norm"><a name="jls-18-200-A"></a>
                           <span class="emphasis"><em>Reduction</em></span> takes a compatibility assertion
                           about an expression or type, called a <span class="emphasis"><em>constraint
                                 formula</em></span>, and reduces it to a set
                           of <span class="emphasis"><em>bounds</em></span> on <span class="emphasis"><em>inference
                                 variables</em></span>. Often, a constraint formula reduces
                           to <span class="emphasis"><em>other</em></span> constraint formulas, which must be
                           recursively reduced.  A procedure is followed to identify these
                           additional constraint formulas and, ultimately, to express via a
                           bound set the conditions under which the choices for inferred
                           types would render each constraint formula true.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-200-B"></a>
                           <span class="emphasis"><em>Incorporation</em></span> maintains a set of inference
                           variable bounds, ensuring that these are consistent as new
                           bounds are added.  Because the bounds on one variable can
                           sometimes impact the possible choices for another variable, this
                           process propagates bounds between such interdependent
                           variables.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-200-C"></a>
                           <span class="emphasis"><em>Resolution</em></span> examines the bounds on an
                           inference variable and determines
                           an <span class="emphasis"><em>instantiation</em></span> that is compatible with
                           those bounds. It also decides the order in which interdependent
                           inference variables are to be resolved.
                  </p>
               </li>
            </ul>
         </div>
         <p class="norm"><a name="jls-18-300"></a>These processes interact
            closely: reduction can trigger incorporation; incorporation may lead
            to further reduction; and resolution may cause further
            incorporation.
         </p>
         <div class="norm">
            <ul class="norm" type="disc">
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-A"></a>
                           <a class="xref" href="jls-18.html#jls-18.1" title="18.1.&nbsp;Concepts and Notation">&sect;18.1</a> more precisely defines the concepts
                           used as intermediate results and the notation used to express
                           them.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-B"></a>
                           <a class="xref" href="jls-18.html#jls-18.2" title="18.2.&nbsp;Reduction">&sect;18.2</a> describes reduction in detail.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-C"></a>
                           <a class="xref" href="jls-18.html#jls-18.3" title="18.3.&nbsp;Incorporation">&sect;18.3</a> describes incorporation in
                           detail.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-D"></a>
                           <a class="xref" href="jls-18.html#jls-18.4" title="18.4.&nbsp;Resolution">&sect;18.4</a> describes resolution in
                           detail.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-E"></a>
                           <a class="xref" href="jls-18.html#jls-18.5" title="18.5.&nbsp;Uses of Inference">&sect;18.5</a> defines how these inference tools are
                           used to solve certain compile-time analysis problems.
                  </p>
               </li>
            </ul>
         </div>
         <p class="note">In comparison to the Java SE 7 Edition of <em class="citetitle">The <span class="trademark">Java</span>&reg; Language Specification</em>,
            important changes to inference include:
         </p>
         <div class="note">
            <ul class="note" type="disc">
               <li class="listitem">
                  <p class="note">Adding support for lambda expressions and method
                           references as method invocation arguments.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Generalizing to define inference in terms of
                           poly expressions, which may not have well-defined types
                           until <span class="emphasis"><em>after</em></span> inference is complete.  This
                           has the notable effect of improving inference for nested generic
                           method and diamond constructor invocations.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Describing how inference is used to handle
                           wildcard-parameterized functional interface target types and
                           most specific method analysis.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Clarifying the distinction between invocation
                           applicability testing (which involves only the invocation
                           arguments) and invocation type inference (which incorporates a
                           target type).
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Delaying resolution of all inference variables,
                           even those with lower bounds, until invocation type inference,
                           in order to get better results.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Improving inference behavior for interdependent
                           (or self-dependent) variables.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Eliminating bugs and potential sources of
                           confusion.  This revision more carefully and precisely handles
                           the distinction between specific conversion contexts and
                           subtyping, and describes reduction by paralleling the
                           corresponding non-inference relations.  Where there are
                           intentional departures from the non-inference relations, these
                           are explicitly identified as such.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Laying a foundation for future evolution:
                           enhancements to or new applications of inference will be easier
                           to integrate into the specification.
                  </p>
               </li>
            </ul>
         </div>
         <div class="section" title="18.1.&nbsp;Concepts and Notation">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.1"></a>18.1.&nbsp;Concepts and Notation
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-18.1-100"></a>This section
               defines <span class="emphasis"><em>inference variables</em></span>, <span class="emphasis"><em>constraint
                     formulas</em></span>, and <span class="emphasis"><em>bounds</em></span>, as the terms
               will be used throughout this chapter. It also presents
               notation.
            </p>
            <div class="section" title="18.1.1.&nbsp;Inference Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.1.1"></a>18.1.1.&nbsp;Inference Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-18.1.1-100"></a><span class="emphasis"><em>Inference
                        variables</em></span> are <span class="emphasis"><em>meta-variables</em></span> for types
                  - that is, they are special names that allow abstract reasoning about
                  types. To distinguish them from <span class="emphasis"><em>type variables</em></span>,
                  inference variables are represented with Greek letters, principally
                  <span class="symbol">&#945;</span>.
               </p>
               <p class="norm"><a name="jls-18.1.1-110"></a>The term "type" is used
                  loosely in this chapter to include type-like syntax that contains
                  inference variables. The term <span class="emphasis"><em>proper type</em></span>
                  excludes such "types" that mention inference variables. Assertions
                  that involve inference variables are assertions about every proper
                  type that can be produced by replacing each inference variable with a
                  proper type.
               </p>
            </div>
            <div class="section" title="18.1.2.&nbsp;Constraint Formulas">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.1.2"></a>18.1.2.&nbsp;Constraint Formulas
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.1.2-100"></a>
                  <span class="emphasis"><em>Constraint formulas</em></span> are assertions of
                  compatibility or subtyping that may involve inference variables. The
                  formulas may take one of the following forms:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-A"></a>
                                 &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;: An expression is
                                 compatible in a loose invocation context with type <span class="type">T</span>
                                 (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-B"></a>
                                 &#8249;<span class="type">S</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;: A type <span class="type">S</span> is compatible in a
                                 loose invocation context with type <span class="type">T</span>
                                 (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-C"></a>
                                 &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;: A reference type <span class="type">S</span> is a
                                 subtype of a reference type <span class="type">T</span>
                                 (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-D"></a>
                                 &#8249;<span class="type">S</span> <code class="literal">&lt;=</code> <span class="type">T</span>&#8250;: A type argument <span class="type">S</span> is
                                 contained by a type argument <span class="type">T</span>
                                 (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-E"></a>
                                 &#8249;<span class="type">S</span> = <span class="type">T</span>&#8250;: A  type <span class="type">S</span> is the same as a
                                  type <span class="type">T</span> (<a class="xref" href="jls-4.html#jls-4.3.4" title="4.3.4.&nbsp;When Reference Types Are the Same">&sect;4.3.4</a>), or a
                                 type argument <span class="type">S</span> is the same as type argument <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-F"></a>
                                 &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;: The checked
                                 exceptions thrown by the body of the <span class="emphasis"><em>LambdaExpression</em></span> are
                                 declared by the <code class="literal">throws</code> clause of the function type derived
                                 from <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-G"></a>
                                 &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;: The checked
                                 exceptions thrown by the referenced method are declared by the
                                 <code class="literal">throws</code> clause of the function type derived from <span class="type">T</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="informalexample">
                  <p class="note">Examples of constraint formulas:</p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">From <code class="literal">Collections.singleton("hi")</code>,
                                    we have the constraint formula &#8249;<code class="literal">"hi"</code>
                                    <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250;. Through reduction, this will become the
                                    constraint formula: &#8249;<code class="literal">String</code> <code class="literal">&lt;:</code>
                                    <span class="symbol">&#945;</span>&#8250;.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">From <code class="literal">Arrays.asList(1, 2.0)</code>,
                                    we have the constraint formulas &#8249;<code class="literal">1</code> <span class="symbol">&#8594;</span>
                                    <span class="symbol">&#945;</span>&#8250; and &#8249;<code class="literal">2.0</code> <span class="symbol">&#8594;</span>
                                    <span class="symbol">&#945;</span>&#8250;. Through reduction, these will become the
                                    constraint formulas &#8249;<code class="literal">int</code> <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250; and
                                    &#8249;<code class="literal">double</code> <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250;, and then &#8249;<code class="literal">Integer</code>
                                    <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>&#8250; and &#8249;<code class="literal">Double</code> <code class="literal">&lt;:</code>
                                    <span class="symbol">&#945;</span>&#8250;.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">From the target type of the constructor
                                    invocation <code class="literal">List&lt;Thread&gt; lt = new
                                       ArrayList<code class="literal">&lt;&gt;</code>()</code>, we have the constraint formula
                                    &#8249;<code class="literal">ArrayList</code><code class="literal">&lt;</code><span class="symbol">&#945;</span><code class="literal">&gt;</code>
                                    <span class="symbol">&#8594;</span> <code class="literal">List</code><code class="literal">&lt;</code><code class="literal">Thread</code><code class="literal">&gt;</code>&#8250;. Through
                                    reduction, this will become the constraint formula
                                    &#8249;<span class="symbol">&#945;</span> <code class="literal">&lt;=</code> <code class="literal">Thread</code>&#8250;, and then
                                    &#8249;<span class="symbol">&#945;</span> = <code class="literal">Thread</code>&#8250;.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="section" title="18.1.3.&nbsp;Bounds">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.1.3"></a>18.1.3.&nbsp;Bounds
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.1.3-100"></a>During
                  the inference process, a set of <span class="emphasis"><em>bounds</em></span> on
                  inference variables is maintained. A bound has one of the following
                  forms:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-A"></a>
                                 <span class="type">S</span> = <span class="type">T</span>, where at least one of <span class="type">S</span> or <span class="type">T</span> is an inference
                                 variable: <span class="type">S</span> is the same as <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-B"></a>
                                 <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>, where at least one of <span class="type">S</span> or <span class="type">T</span> is an
                                 inference variable: <span class="type">S</span> is a subtype of <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-C"></a>
                                 <span class="emphasis"><em>false</em></span>: No valid choice of inference variables
                                 exists.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-D"></a>
                                 <span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> =
                                 capture(<span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>): The variables
                                 <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> represent the result of capture
                                 conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) applied to
                                 <span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code> (where <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span> may be
                                 types or wildcards and may mention inference variables).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-E"></a>
                                 <code class="literal">throws</code> <span class="symbol">&#945;</span>: The inference variable <span class="symbol">&#945;</span> appears in a
                                 <code class="literal">throws</code> clause.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.1.3-200"></a>A bound
                  is <span class="emphasis"><em>satisfied</em></span> by an inference variable
                  substitution if, after applying the substitution, the assertion is
                  true. The bound <span class="emphasis"><em>false</em></span> can never be satisfied.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-300"></a>Some
                  bounds relate an inference variable to a proper type. Let <span class="type">T</span> be a
                  proper type. Given a bound of the form <span class="symbol">&#945;</span> = <span class="type">T</span> or <span class="type">T</span> = <span class="symbol">&#945;</span>,
                  we say <span class="type">T</span> is an <span class="emphasis"><em>instantiation</em></span> of <span class="symbol">&#945;</span>.
                  Similarly, given a bound of the form <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span>, we say <span class="type">T</span>
                  is a <span class="emphasis"><em>proper upper bound</em></span> of <span class="symbol">&#945;</span>, and given a
                  bound of the form <span class="type">T</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, we say <span class="type">T</span> is
                  a <span class="emphasis"><em>proper lower bound</em></span> of <span class="symbol">&#945;</span>.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-310"></a>Other
                  bounds relate two inference variables, or an inference variable to a
                  type that contains inference variables. Such bounds, of the form <span class="type">S</span> =
                  <span class="type">T</span> or <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>, are called 
                  <span class="emphasis"><em>dependencies</em></span>.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-320"></a>A bound
                  of the form <span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> =
                  capture(<span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>) indicates that <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>,
                  ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> are placeholders for the results of capture
                  conversion. This is necessary because capture conversion can only be
                  performed on a proper type, and the inference variables in <span class="type">A<sub>1</sub></span>, ...,
                  <span class="type">A<sub>n</sub></span> may not yet be resolved.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-330"></a>A bound
                  of the form <code class="literal">throws</code> <span class="symbol">&#945;</span> is purely informational: it directs
                  resolution to optimize the instantiation of <span class="symbol">&#945;</span> so that, if
                  possible, it is not a checked exception type.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-400"></a>An
                  important intermediate result of inference is a <span class="emphasis"><em>bound
                        set</em></span>. It is sometimes convenient to refer to
                  an <span class="emphasis"><em>empty</em></span> bound set with the symbol <span class="emphasis"><em>true</em></span>;
                  this is merely out of convenience, and the two are
                  interchangeable.
               </p>
               <div class="informalexample">
                  <p class="note">Examples of bound sets:</p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">{ <span class="symbol">&#945;</span> = <code class="literal">String</code> } contains a single bound,
                                    instantiating <span class="symbol">&#945;</span> as <code class="literal">String</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">{ <code class="literal">Integer</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, <code class="literal">Double</code>
                                    <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code> } describes two
                                    proper lower bounds and one proper upper bound for
                                    <span class="symbol">&#945;</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">{ <span class="symbol">&#945;</span>
                                    <code class="literal">&lt;:</code> <code class="literal">Iterable&lt;?&gt;</code>, <span class="symbol">&#946;</span> <code class="literal">&lt;:</code>
                                    <code class="literal">Object</code>, <span class="symbol">&#945;</span>
                                    <code class="literal">&lt;:</code> <code class="literal">List</code><code class="literal">&lt;</code><span class="symbol">&#946;</span><code class="literal">&gt;</code> }
                                    describes a proper upper bound for each of <span class="symbol">&#945;</span> and <span class="symbol">&#946;</span>,
                                    along with a dependency between them.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">{ } contains no bounds nor dependencies, and can
                                    be referred to as <span class="emphasis"><em>true</em></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">{ <span class="emphasis"><em>false</em></span> } expresses the fact that no
                                    satisfactory instantiation exists.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.1.3-410"></a>
                  When inference begins, a bound set is typically generated from a list
                  of type parameter declarations <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span> and associated
                  inference variables <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>p</sub></span>. Such a bound set is
                  generated as follows. For each <span class="emphasis"><em>l</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>l</em></span> <span class="symbol">&#8804;</span>
                  <span class="emphasis"><em>p</em></span>):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-410-A"></a>If
                                 <span class="type">P<sub>l</sub></span> has no <span class="emphasis"><em>TypeBound</em></span>, the
                                 bound <span class="emphasis"><em><span class="symbol">&#945;</span><span class="type"><sub>l</sub></span> <code class="literal">&lt;:</code> <code class="literal">Object</code></em></span> appears
                                 in the set.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.4-410-B"></a>
                                 Otherwise, for each type <span class="type">T</span> delimited by <code class="literal">&amp;</code> in
                                 the <span class="emphasis"><em>TypeBound</em></span>, the bound <span class="symbol">&#945;</span><span class="type"><sub>l</sub></span> <code class="literal">&lt;:</code>
                                 <span class="type">T</span><code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>p</sub></span><code class="literal">]</code> appears
                                 in the set; if this results in no proper upper bounds for
                                 <span class="symbol">&#945;</span><span class="type"><sub>l</sub></span> (only dependencies), then the bound <span class="symbol">&#945;</span><span class="type"><sub>l</sub></span> <code class="literal">&lt;:</code>
                                 <code class="literal">Object</code> also appears in the set.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="18.2.&nbsp;Reduction">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.2"></a>18.2.&nbsp;Reduction
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-18.2-100"></a>
               <span class="emphasis"><em>Reduction</em></span> is the process by which a set of
               constraint formulas (<a class="xref" href="jls-18.html#jls-18.1.2" title="18.1.2.&nbsp;Constraint Formulas">&sect;18.1.2</a>) is simplified to
               produce a bound set (<a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>).
            </p>
            <p class="norm-static"><a name="jls-18.2-200"></a>Each
               constraint formula is considered in turn. The rules in this section
               specify how the formula is reduced to one or both of:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.2-200-A"></a>
                              A bound or bound set, which is to be incorporated with the
                              "current" bound set. Initially, the current bound set is
                              empty.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.2-200-B"></a>
                              Further constraint formulas, which are to be reduced
                              recursively.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-18.2-210"></a>Reduction
               completes when no further constraint formulas remain to be
               reduced.
            </p>
            <p class="note">The results of a reduction step are
               always <span class="emphasis"><em>soundness-preserving</em></span>: if an inference
               variable instantiation satisfies the reduced constraints and bounds,
               it will also satisfy the original constraint.  On the other hand,
               reduction is not <span class="emphasis"><em>completeness-preserving</em></span>: there
               may exist inference variable instantiations that satisfy the original
               constraint but <span class="emphasis"><em>do not</em></span> satisfy a reduced
               constraint or bound. This is due to inherent limitations of the
               algorithm, along with a desire to avoid undue complexity. One effect
               is that there are expressions for which type argument inference fails
               to find a solution, but that can be well-typed if the programmer
               explicitly inserts appropriate types.
            </p>
            <div class="section" title="18.2.1.&nbsp;Expression Compatibility Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.1"></a>18.2.1.&nbsp;Expression Compatibility Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.1-100"></a>
                  A constraint formula of the form &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;
                  is reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-100-A"></a>
                                 If <span class="type">T</span> is a proper type, the constraint reduces to <span class="emphasis"><em>true</em></span> if
                                 the expression is compatible in a loose invocation context with
                                 <span class="type">T</span> (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>), and <span class="emphasis"><em>false</em></span> otherwise.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-100-B"></a>
                                 Otherwise, if the expression is a standalone expression
                                 (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>) of type <span class="type">S</span>, the constraint reduces
                                 to &#8249;<span class="type">S</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-100-C"></a>
                                 Otherwise, the expression is a poly expression
                                 (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>). The result depends on the form of
                                 the expression:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-A"></a>
                                    	  If the expression is a parenthesized expression of the form
                                    	  <code class="literal">(</code> <span class="emphasis"><em>Expression</em></span>' <code class="literal">)</code>, the constraint reduces to
                                    	  &#8249;<span class="emphasis"><em>Expression</em></span>' <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-B"></a>
                                    	  If the expression is a class instance creation expression or
                                    	  a method invocation expression, the constraint reduces to
                                    	  the bound set <span class="type">B<sub>3</sub></span> which would be used to determine the
                                    	  expression's 
                                    	  compatibility with target type <span class="type">T</span>, as defined in
                                    	  <a class="xref" href="jls-18.html#jls-18.5.2.1" title="18.5.2.1.&nbsp;Poly Method Invocation Compatibility">&sect;18.5.2.1</a>. (For a class instance creation
                                    	  expression, the corresponding "method" used for inference is
                                    	  defined in <a class="xref" href="jls-15.html#jls-15.9.3" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">&sect;15.9.3</a>.)
                                 </p>
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-B.1"></a>
                                    	  This bound set may contain new inference variables, as well
                                    	  as dependencies between these new variables and the
                                    	  inference variables in <span class="type">T</span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-C"></a>
                                    	  If the expression is a conditional expression of the form
                                    	  <code class="varname">e<sub>1</sub></code> <code class="literal">?</code> <code class="varname">e<sub>2</sub></code> <code class="literal">:</code> <code class="varname">e<sub>3</sub></code>, the constraint reduces to two
                                    	  constraint formulas, &#8249;<code class="varname">e<sub>2</sub></code> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; and
                                    	  &#8249;<code class="varname">e<sub>3</sub></code> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-D"></a>
                                    	  If the expression is a lambda expression or a method
                                    	  reference expression, the result is specified below.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">By treating nested generic method invocations as
                  poly expressions, we improve the behavior of inference for nested
                  invocations. For example, the following is illegal in Java SE 7 but
                  legal in Java SE 8:
               </p><pre class="screen">
ProcessBuilder b = new ProcessBuilder(Collections.emptyList());
  // ProcessBuilder's constructor expects a List&lt;String&gt;
</pre><p class="note">When <span class="emphasis"><em>both</em></span> the outer and the
                  nested invocation require inference, the problem is more difficult.
                  For example:
               </p><pre class="screen">List&lt;String&gt; ls = new ArrayList&lt;&gt;(Collections.emptyList());</pre><p class="note">Our approach is to "lift" the bounds inferred for
                  the nested invocation (simply { <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code> } in the
                  case of <code class="literal">emptyList</code>) into the outer inference process
                  (in this case, trying to infer <span class="symbol">&#946;</span> where the constructor is for
                  type <code class="literal">ArrayList</code><code class="literal">&lt;</code><span class="symbol">&#946;</span><code class="literal">&gt;</code>). We also
                  infer dependencies between the nested inference variables and the
                  outer inference variables (the constraint
                  &#8249;<code class="literal">List</code><code class="literal">&lt;</code><span class="symbol">&#945;</span><code class="literal">&gt;</code>
                  <span class="symbol">&#8594;</span> <code class="literal">Collection</code><code class="literal">&lt;</code><span class="symbol">&#946;</span><code class="literal">&gt;</code>&#8250;
                  would reduce to the dependency <span class="symbol">&#945;</span> = <span class="symbol">&#946;</span>). In this way,
                  resolution of the inference variables in the nested invocation can
                  wait until additional information can be inferred from the outer
                  invocation (based on the assignment target, <span class="symbol">&#946;</span> = <code class="literal">String</code>).
               </p>
               <p class="norm-static"><a name="jls-18.2.1-200"></a>
                  A constraint formula of the form &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span>
                  <span class="type">T</span>&#8250;, where <span class="type">T</span> mentions at least one inference variable, is
                  reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-200-A"></a>
                                 If <span class="type">T</span> is not a functional interface type (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>), 
                                 the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-200-B"></a>
                                 Otherwise, let <span class="type">T'</span> be the ground target type derived from
                                 <span class="type">T</span>, as specified in <a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>. If
                                 <a class="xref" href="jls-18.html#jls-18.5.3" title="18.5.3.&nbsp;Functional Interface Parameterization Inference">&sect;18.5.3</a> is used to derive a functional
                                 interface type which is parameterized, then the test that
                                 <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code> is a subtype of
                                 <span class="type">F</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>m</sub></span><code class="literal">&gt;</code> is not performed (instead, it
                                 is asserted with a constraint formula below). Let the target
                                 function type for the lambda expression be the function type of
                                 <span class="type">T'</span>. Then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-200-B-A"></a>
                                    	  If no valid function type can be found, the constraint
                                    	  reduces to <span class="emphasis"><em>false</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-200-B-B"></a>
                                    	  Otherwise, the congruence of <span class="emphasis"><em>LambdaExpression</em></span> with the
                                    	  target function type is asserted as follows:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-A"></a>
                                             	      If the number of lambda parameters differs from the
                                             	      number of parameter types of the function type, the
                                             	      constraint reduces to <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-B"></a>
                                             	      If the lambda expression is implicitly typed and one or
                                             	      more of the function type's parameter types is not a
                                             	      proper type, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                                          </p>
                                          <p class="note">
                                             	      This condition never arises in practice, due to the
                                             	      handling of implicitly typed lambda expressions in
                                             	      <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a> and the substitution
                                             	      applied to the target type in <a class="xref" href="jls-18.html#jls-18.5.2.2" title="18.5.2.2.&nbsp;Additional Argument Constraints">&sect;18.5.2.2</a>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-C"></a>
                                             	      If the function type's result is <code class="literal">void</code> and the lambda
                                             	      body is neither a statement expression nor a
                                             	      void-compatible block, the constraint reduces to
                                             	      <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-D"></a>
                                             	      If the function type's result is not <code class="literal">void</code> and the
                                             	      lambda body is a block that is not value-compatible, the
                                             	      constraint reduces to <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-E"></a>
                                             	      Otherwise, the constraint reduces to all of the following
                                             	      constraint formulas:
                                          </p>
                                          <div class="norm">
                                             <ul class="norm" type="disc">
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.2.1-200-B-B-E-A"></a>
                                                      		  If the lambda parameters have explicitly declared types
                                                      		  <span class="type">F<sub>1</sub></span>, ..., <span class="type">F<sub>n</sub></span> and the function type has parameter types
                                                      		  <span class="type">G<sub>1</sub></span>, ..., <span class="type">G<sub>n</sub></span>, then i) for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                                      		  <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">F<sub>i</sub></span> = <span class="type">G<sub>i</sub></span>&#8250;, and ii)
                                                      		  &#8249;<span class="type">T'</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.2.1-200-B-B-E-B"></a>
                                                      		  If the function type's return type is a (non-<code class="literal">void</code>) type
                                                      		  <span class="type">R</span>, assume the lambda's parameter types are the same as the
                                                      		  function type's parameter types. Then:
                                                   </p>
                                                   <div class="">
                                                      <ul class="" type="circle">
                                                         <li class="listitem">
                                                            <p class="norm-static"><a name="jls-18.2.1-200-B-B-E-B-A"></a>
                                                               		      If <span class="type">R</span> is a proper type, and if the lambda body or some
                                                               		      result expression in the lambda body is not compatible
                                                               		      in an assignment context with <span class="type">R</span>, then <span class="emphasis"><em>false</em></span>.
                                                            </p>
                                                         </li>
                                                         <li class="listitem">
                                                            <p class="norm-static"><a name="jls-18.2.1-200-B-B-E-B-B"></a>
                                                               		      Otherwise, if <span class="type">R</span> is not a proper type, then where the
                                                               		      lambda body has the form <span class="emphasis"><em>Expression</em></span>, the constraint
                                                               		      &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">R</span>&#8250;; or where the
                                                               		      lambda body is a block with result expressions <code class="varname">e<sub>1</sub></code>,
                                                               		      ..., <code class="varname">e<sub>m</sub></code>, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>m</em></span>),
                                                               		      &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span> <span class="type">R</span>&#8250;.
                                                            </p>
                                                         </li>
                                                      </ul>
                                                   </div>
                                                </li>
                                             </ul>
                                          </div>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">The key piece of information to derive from a
                  compatibility constraint involving a lambda expression is the set of
                  bounds on inference variables appearing in the target function type's
                  return type. This is crucial, because functional interfaces are often
                  generic, and many methods operating on these types are generic,
                  too.
               </p>
               <p class="note">In the simplest case, a lambda expression may simply
                  provide a lower bound for an inference variable:
               </p><pre class="screen">
&lt;T&gt; List&lt;T&gt; makeThree(Factory&lt;T&gt; factory) { ... }
String s = makeThree(() <code class="literal">-&gt;</code> "abc").get(2);
</pre><p class="note">In more complex cases, a result expression may be a
                  poly expression - perhaps even another lambda expression - and so the
                  inference variable might be passed through multiple constraint
                  formulas with different target types before a bound is
                  produced.
               </p>
               <p class="note">Most of the work described in this section precedes
                  assertions about the result expressions; its purpose is to derive the
                  lambda expression's function type, and to check for expressions that
                  are clearly disqualified from compatibility.
               </p>
               <p class="note">We do <span class="emphasis"><em>not</em></span> attempt to produce
                  bounds on inference variables that appear in the target function
                  type's <code class="literal">throws</code> clause. This is because exception containment is not
                  part of compatibility (<a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>) - in particular,
                  it must not influence method applicability
                  (<a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>). However, we <span class="emphasis"><em>do</em></span>
                  get bounds on these variables later, because invocation type inference
                  (<a class="xref" href="jls-18.html#jls-18.5.2.2" title="18.5.2.2.&nbsp;Additional Argument Constraints">&sect;18.5.2.2</a>) produces exception containment
                  constraint formulas (<a class="xref" href="jls-18.html#jls-18.2.5" title="18.2.5.&nbsp;Checked Exception Constraints">&sect;18.2.5</a>).
               </p>
               <p class="note">Note that if the target type is an inference
                  variable, or if the target type's parameter types contain inference
                  variables, we produce <span class="emphasis"><em>false</em></span>. During invocation type inference
                  (<a class="xref" href="jls-18.html#jls-18.5.2.2" title="18.5.2.2.&nbsp;Additional Argument Constraints">&sect;18.5.2.2</a>), extra substitutions are performed in
                  order to instantiate these inference variables, thus avoiding this
                  scenario. (In other words, reduction will, in practice, never be
                  "invoked" with a target type of one of these forms.)
               </p>
               <p class="note">Finally, note that the result expressions of a
                  lambda expression are required by <a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a> to be
                  compatible in an assignment context with the target type's return
                  type, <span class="type">R</span>. If <span class="type">R</span> is a proper type, such as <code class="literal">Byte</code> derived
                  from <code class="literal">Function<code class="literal">&lt;</code><span class="symbol">&#945;</span>,<code class="literal">Byte</code><code class="literal">&gt;</code></code>, then
                  assignability is easy enough to test, and reduction does so above. If
                  <span class="type">R</span> is not a proper type, such as <span class="symbol">&#945;</span> derived from
                  <code class="literal">Function<code class="literal">&lt;</code>String,<span class="symbol">&#945;</span><code class="literal">&gt;</code></code>, then we
                  make the simplifying assumption above that loose invocation
                  compatibility will be sufficient. The difference between assignment
                  compatibility and loose invocation compatibility is that only
                  assignment allows narrowing of constant expressions, such
                  as <code class="literal">Byte b = 100;</code>. Consequently, our simplifying
                  assumption is not completeness-preserving: given target return type
                  <span class="symbol">&#945;</span> and an integer literal result expression
                  <code class="literal">100</code>, it is conceivable that <span class="symbol">&#945;</span> could be
                  instantiated to <code class="literal">Byte</code>, but reduction will not in fact produce such a
                  bound.
               </p>
               <p class="norm-static"><a name="jls-18.2.1-300"></a>
                  A constraint formula of the form &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span>
                  <span class="type">T</span>&#8250;, where <span class="type">T</span> mentions at least one inference variable, is
                  reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-300-A"></a>
                                 If <span class="type">T</span> is not a functional interface type, or if <span class="type">T</span> is a
                                 functional interface type that does not have a function type
                                 (<a class="xref" href="jls-9.html#jls-9.9" title="9.9.&nbsp;Function Types">&sect;9.9</a>), the constraint reduces to
                                 <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-300-B"></a>
                                 Otherwise, if there does not exist a potentially applicable
                                 method for the method reference when targeting <span class="type">T</span>, the
                                 constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-300-C"></a>
                                 Otherwise, if the method reference is exact
                                 (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>), then let <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span> be the
                                 parameter types of the function type of <span class="type">T</span>, and let <span class="type">F<sub>1</sub></span>, ...,
                                 <span class="type">F<sub>k</sub></span> be the parameter types of the potentially applicable
                                 method. The constraint reduces to a new set of constraints, as
                                 follows:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-300-C-A"></a>
                                    	  In the special case where <span class="emphasis"><em>n</em></span> = <span class="emphasis"><em>k</em></span>+1, the parameter
                                              of type <span class="type">P<sub>1</sub></span> is to act as the target reference of the
                                              invocation. The method reference expression necessarily has
                                              the form <span class="emphasis"><em>ReferenceType <code class="literal">::</code>
                                                    [TypeArguments] Identifier</em></span>. The constraint
                                              reduces to &#8249;<span class="type">P<sub>1</sub></span> <code class="literal">&lt;:</code> <span class="emphasis"><em>ReferenceType</em></span>&#8250; and,
                                              for all <span class="emphasis"><em>i</em></span> (2 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">P<sub>i</sub></span>
                                              <span class="symbol">&#8594;</span> <span class="type">F<sub>i-1</sub></span>&#8250;.
                                 </p>
                                 <p class="norm-static"><a name="jls-18.2.1-300-C-A.1"></a>
                                    	  In all other cases, <span class="emphasis"><em>n</em></span> = <span class="emphasis"><em>k</em></span>, and the constraint
                                    	  reduces to, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>),
                                    	  &#8249;<span class="type">P<sub>i</sub></span> <span class="symbol">&#8594;</span> <span class="type">F<sub>i</sub></span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-300-C-B"></a>
                                    	  If the function type's result is not <code class="literal">void</code>, let <span class="type">R</span> be its
                                    	  return type. Then, if the result of the potentially
                                    	  applicable compile-time declaration is <code class="literal">void</code>, the
                                    	  constraint reduces to <span class="emphasis"><em>false</em></span>. Otherwise, the constraint
                                    	  reduces to &#8249;<span class="type">R</span>' <span class="symbol">&#8594;</span> <span class="type">R</span>&#8250;, where <span class="type">R</span>' is the
                                    	  result of applying capture conversion
                                    	  (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to the return type of the
                                    	  potentially applicable compile-time declaration.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-300-D"></a>
                                 Otherwise, the method reference is inexact, and:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-300-D-A"></a>
                                    	  If one or more of the function type's parameter types is not
                                    	  a proper type, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                                 </p>
                                 <p class="note">
                                    	  This condition never arises in practice, due to the handling
                                    	  of inexact method references in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>
                                    	  and the substitution applied to the target type in
                                    	  <a class="xref" href="jls-18.html#jls-18.5.2.2" title="18.5.2.2.&nbsp;Additional Argument Constraints">&sect;18.5.2.2</a>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-300-D-B"></a>
                                    	  Otherwise, a search for a compile-time declaration is
                                    	  performed, as specified in <a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>. If
                                    	  there is no compile-time declaration for the method
                                    	  reference, the constraint reduces to <span class="emphasis"><em>false</em></span>. Otherwise,
                                    	  there is a compile-time declaration, and: (let <span class="type">R</span> be the
                                    	  result of the function type)
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-300-D-B-A"></a>
                                             	      If <span class="type">R</span> is <code class="literal">void</code>, the constraint reduces to <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-300-D-B-B"></a>
                                             	      Otherwise, if the method reference expression elides
                                             	      <span class="emphasis"><em>TypeArguments</em></span>, and the compile-time declaration is a
                                             	      generic method, and the return type of the compile-time
                                             	      declaration mentions at least one of the method's type
                                             	      parameters, then:
                                          </p>
                                          <div class="norm">
                                             <ul class="norm" type="disc">
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.2.1-300-D-B-B-A"></a>
                                                      		  If <span class="type">R</span> mentions one of the type parameters of the
                                                      		  function type, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                                                   </p>
                                                   <p class="note">
                                                      		  In this case, a constraint in terms of <span class="type">R</span> might
                                                      		  lead an inference variable to be bound by an
                                                      		  out-of-scope type variable. Since instantiating an
                                                      		  inference variable with an out-of-scope type
                                                      		  variable is nonsensical, we prefer to avoid the
                                                      		  situation by giving up immediately whenever the
                                                      		  possibility arises. This simplification is not
                                                      		  completeness-preserving.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.2.1-300-D-B-B-B"></a>
                                                      		  If <span class="type">R</span> does not mention one of the type parameters
                                                      		  of the function type, then the constraint reduces
                                                      		  to the bound set <span class="type">B<sub>3</sub></span> which would be used to
                                                      		  determine the method reference's  
                                                      		  compatibility when targeting the return type of the function
                                                      		  type, as defined in <a class="xref" href="jls-18.html#jls-18.5.2.1" title="18.5.2.1.&nbsp;Poly Method Invocation Compatibility">&sect;18.5.2.1</a>.
                                                      		  <span class="type">B<sub>3</sub></span> may contain new inference variables, as well
                                                      		  as dependencies between these new variables and
                                                      		  the inference variables in <span class="type">T</span>.
                                                   </p>
                                                   <p class="note">The strategy used to determine a
                                                      		  return type for a generic referenced method follows
                                                      		  the pattern used earlier in this section for generic
                                                      		  method invocations. This may involve "lifting"
                                                      		  bounds into the outer context and inferring
                                                      		  dependencies between the two sets of inference variables.
                                                   </p>
                                                </li>
                                             </ul>
                                          </div>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-300-D-B-C"></a>
                                             	      Otherwise, let <span class="type">R</span>' be the result of applying capture
                                             	      conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to the return
                                             	      type of the invocation type (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>) 
                                             	      of the compile-time declaration.
                                             
                                             	      If <span class="type">R</span>' is <code class="literal">void</code>, the constraint reduces to <span class="emphasis"><em>false</em></span>;
                                             	      otherwise, the constraint reduces to &#8249;<span class="type">R</span>' <span class="symbol">&#8594;</span>
                                             	      <span class="type">R</span>&#8250;.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="18.2.2.&nbsp;Type Compatibility Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.2"></a>18.2.2.&nbsp;Type Compatibility Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.2-100"></a>
                  A constraint formula of the form &#8249;<span class="type">S</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; is
                  reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-A"></a>
                                 If <span class="type">S</span> and <span class="type">T</span> are proper types, the constraint reduces to
                                 <span class="emphasis"><em>true</em></span> if <span class="type">S</span> is compatible in a loose invocation context
                                 with <span class="type">T</span> (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>), and <span class="emphasis"><em>false</em></span>
                                 otherwise.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-B"></a>
                                 Otherwise, if <span class="type">S</span> is a primitive type, let <span class="type">S'</span> be the
                                 result of applying boxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to <span class="type">S</span>. Then the constraint
                                 reduces to &#8249;<span class="type">S'</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-C"></a>
                                 Otherwise, if <span class="type">T</span> is a primitive type, let <span class="type">T'</span> be the
                                 result of applying boxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to <span class="type">T</span>. Then the constraint
                                 reduces to &#8249;<span class="type">S</span> = <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-D"></a>
                                 Otherwise, if <span class="type">T</span> is a parameterized type of the form
                                 <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>, and there exists no type of
                                 the form <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code> that is a supertype of <span class="type">S</span>, but
                                 the raw type <span class="type">G</span> is a supertype of <span class="type">S</span>, then the constraint
                                 reduces to <span class="emphasis"><em>true</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-E"></a>
                                 Otherwise, if <span class="type">T</span> is an array type of the form <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,
                                 ..., <span class="type">T<sub>n</sub></span><code class="literal">&gt;</code><code class="literal">[]</code><sup>k</sup>, and
                                 there exists no type of the form
                                 <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code><code class="literal">[]</code><sup>k</sup>
                                 that is a supertype of <span class="type">S</span>, but the raw type
                                 <span class="type">G</span><code class="literal">[]</code><sup>k</sup> is a supertype of <span class="type">S</span>,
                                 then the constraint reduces to <span class="emphasis"><em>true</em></span>. (The notation
                                 <code class="literal">[]</code><sup>k</sup> indicates an array type
                                 of <span class="emphasis"><em>k</em></span> dimensions.)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-F"></a>
                                 Otherwise, the constraint reduces to &#8249;<span class="type">S</span> <code class="literal">&lt;:</code>
                                 <span class="type">T</span>&#8250;.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.2.2-110"></a>The
                  fourth and fifth cases are implicit uses of unchecked conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>). These, along with any use of unchecked
                  conversion in the first case, may result in compile-time unchecked
                  warnings, and may influence a method's invocation type
                  (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>).
               </p>
               <p class="note">Boxing <span class="type">T</span> to <span class="type">T'</span> is not
                  completeness-preserving; for example, if <span class="type">T</span> were <code class="literal">long</code>, <span class="type">S</span> might be
                  instantiated to <code class="literal">Integer</code>, which is not a subtype of <code class="literal">Long</code> but could
                  be unboxed and then widened to <code class="literal">long</code>. We avoid this problem in most
                  cases by giving special treatment to inference-variable return types
                  that we know are already constrained to be certain boxed primitive
                  types; see <a class="xref" href="jls-18.html#jls-18.5.2.1" title="18.5.2.1.&nbsp;Poly Method Invocation Compatibility">&sect;18.5.2.1</a>.
               </p>
               <p class="note">Similarly, the treatment of unchecked conversion
                  sacrifices completeness in cases in which <span class="type">T</span> is not a parameterized
                  type (for example, if <span class="type">T</span> is an inference variable). It is not usually
                  clear in such situations whether the unchecked conversion is necessary
                  or not. Since unchecked conversions introduce unchecked warnings,
                  inference prefers to avoid them unless it is clearly necessary.
               </p>
            </div>
            <div class="section" title="18.2.3.&nbsp;Subtyping Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.3"></a>18.2.3.&nbsp;Subtyping Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.3-100"></a>A
                  constraint formula of the form &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250; is
                  reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-A"></a>
                                 If <span class="type">S</span> and <span class="type">T</span> are proper types, the constraint reduces to
                                 <span class="emphasis"><em>true</em></span> if <span class="type">S</span> is a subtype of <span class="type">T</span>
                                 (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>), and <span class="emphasis"><em>false</em></span> otherwise.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-B"></a>
                                 Otherwise, if <span class="type">S</span> is the null type, the constraint reduces to
                                 <span class="emphasis"><em>true</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-C"></a>
                                 Otherwise, if <span class="type">T</span> is the null type, the constraint reduces to
                                 <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-D"></a>
                                 Otherwise, if <span class="type">S</span> is an inference variable, <span class="symbol">&#945;</span>, the
                                 constraint reduces to the bound <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-E"></a>
                                 Otherwise, if <span class="type">T</span> is an inference variable, <span class="symbol">&#945;</span>, the
                                 constraint reduces to the bound <span class="type">S</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-F"></a>
                                 Otherwise, the constraint is reduced according to the form of
                                 <span class="type">T</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-A"></a>
                                    	  If <span class="type">T</span> is a parameterized class or interface type, or an
                                    	  inner class type of a parameterized class or interface type
                                    	  (directly or indirectly), let <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span> be the type
                                    	  arguments of <span class="type">T</span>. Among the supertypes of <span class="type">S</span>, a
                                    	  corresponding class or interface type is identified, with
                                    	  type arguments <span class="type">B<sub>1</sub></span>, ..., <span class="type">B<sub>n</sub></span>. If no such type exists, the
                                    	  constraint reduces to <span class="emphasis"><em>false</em></span>. Otherwise, the constraint
                                    	  reduces to the following new constraints: for all <span class="emphasis"><em>i</em></span> (1
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">B<sub>i</sub></span> <code class="literal">&lt;=</code>
                                    	  <span class="type">A<sub>i</sub></span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-B"></a>
                                    	  If <span class="type">T</span> is any other class or interface type, then the
                                    	  constraint reduces to <span class="emphasis"><em>true</em></span> if <span class="type">T</span> is among the
                                    	  supertypes of <span class="type">S</span>, and <span class="emphasis"><em>false</em></span> otherwise.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-C"></a>
                                    	  If <span class="type">T</span> is an array type, <span class="type">T'</span><code class="literal">[]</code>, then among the
                                    	  supertypes of <span class="type">S</span> that are array types, a most specific type
                                    	  is identified, <span class="type">S'</span><code class="literal">[]</code> (this may be <span class="type">S</span>
                                    	  itself). If no such array type exists, the constraint
                                    	  reduces to <span class="emphasis"><em>false</em></span>. Otherwise:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-C-A"></a>
                                             	      If neither <span class="type">S'</span> nor <span class="type">T'</span> is a primitive type, the
                                             	      constraint reduces to &#8249;<span class="type">S'</span> <code class="literal">&lt;:</code>
                                             	      <span class="type">T'</span>&#8250;.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-C-B"></a>
                                             	      Otherwise, the constraint reduces to <span class="emphasis"><em>true</em></span> if <span class="type">S'</span>
                                             	      and <span class="type">T'</span> are the same primitive type, and <span class="emphasis"><em>false</em></span>
                                             	      otherwise.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-D"></a>
                                    	  If <span class="type">T</span> is a type variable, there are three cases:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-D-A"></a>
                                             	      If <span class="type">S</span> is an intersection type of which <span class="type">T</span> is an
                                             	      element, the constraint reduces to <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-D-B"></a>
                                             	      Otherwise, if <span class="type">T</span> has a lower bound, <span class="type">B</span>, the constraint
                                             	      reduces to &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">B</span>&#8250;.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-D-C"></a>
                                             	      Otherwise, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-E"></a>
                                    	  If <span class="type">T</span> is an intersection type, <span class="type">I<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">I<sub>n</sub></span>,
                                    	  the constraint reduces to the following new constraints: for
                                    	  all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">S</span>
                                    	  <code class="literal">&lt;:</code> <span class="type">I<sub>i</sub></span>&#8250;.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.2.3-200"></a>A
                  constraint formula of the form &#8249;<span class="type">S</span> <code class="literal">&lt;=</code> <span class="type">T</span>&#8250;, where
                  <span class="type">S</span> and <span class="type">T</span> are type arguments (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>), is
                  reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-200-A"></a>
                                 If <span class="type">T</span> is a type:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-A-A"></a>
                                    	  If <span class="type">S</span> is a type, the constraint reduces to &#8249;<span class="type">S</span> =
                                    	  <span class="type">T</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-A-B"></a>
                                    	  If <span class="type">S</span> is a wildcard, the constraint reduces to
                                    	  <span class="emphasis"><em>false</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-200-B"></a>
                                 If <span class="type">T</span> is a wildcard of the form <code class="literal">?</code>, the constraint reduces
                                 to <span class="emphasis"><em>true</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-200-C"></a>
                                 If <span class="type">T</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T'</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-C-A"></a>
                                    	  If <span class="type">S</span> is a type, the constraint reduces to &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T'</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-C-B"></a>
                                    	  If <span class="type">S</span> is a wildcard of the form <code class="literal">?</code>, the constraint
                                    	  reduces to &#8249;<code class="literal">Object</code> <code class="literal">&lt;:</code> <span class="type">T'</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-C-C"></a>
                                    	  If <span class="type">S</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">S'</span>, the
                                    	  constraint reduces to &#8249;<span class="type">S'</span> <code class="literal">&lt;:</code> <span class="type">T'</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-C-D"></a>
                                    	  If <span class="type">S</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">S'</span>,
                                    	  the constraint reduces to &#8249;<code class="literal">Object</code> = <span class="type">T'</span>&#8250;.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-200-D"></a>
                                 If <span class="type">T</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">T'</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-D-A"></a>
                                    	  If <span class="type">S</span> is a type, the constraint reduces to &#8249;<span class="type">T'</span>
                                    	  <code class="literal">&lt;:</code> <span class="type">S</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-D-B"></a>
                                    	  If <span class="type">S</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">S'</span>,
                                    	  the constraint reduces to &#8249;<span class="type">T'</span> <code class="literal">&lt;:</code>
                                    	  <span class="type">S'</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-D-C"></a>
                                    	  Otherwise, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="18.2.4.&nbsp;Type Equality Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.4"></a>18.2.4.&nbsp;Type Equality Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.4-100"></a>
                  A constraint formula of the form &#8249;<span class="type">S</span> = <span class="type">T</span>&#8250;, where <span class="type">S</span>
                  and <span class="type">T</span> are types, is reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-A"></a>
                                 If <span class="type">S</span> and <span class="type">T</span> are proper types, the constraint reduces to
                                 <span class="emphasis"><em>true</em></span> if <span class="type">S</span> is the same as <span class="type">T</span>
                                 (<a class="xref" href="jls-4.html#jls-4.3.4" title="4.3.4.&nbsp;When Reference Types Are the Same">&sect;4.3.4</a>), and <span class="emphasis"><em>false</em></span> otherwise.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-B"></a>
                                 Otherwise, if <span class="type">S</span> or <span class="type">T</span> is the null type, the constraint
                                 reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-C"></a>
                                 Otherwise, if <span class="type">S</span> is an inference variable, <span class="symbol">&#945;</span>, and <span class="type">T</span> is
                                 not a primitive type, the constraint reduces to the bound
                                 <span class="symbol">&#945;</span> = <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-D"></a>
                                 Otherwise, if <span class="type">T</span> is an inference variable, <span class="symbol">&#945;</span>, and <span class="type">S</span> is
                                 not a primitive type, the constraint reduces to the bound <span class="type">S</span> =
                                 <span class="symbol">&#945;</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-E"></a>
                                 Otherwise, if <span class="type">S</span> and <span class="type">T</span> are class or interface types with the
                                 same erasure, where <span class="type">S</span> has type arguments <span class="type">B<sub>1</sub></span>, ..., <span class="type">B<sub>n</sub></span> and
                                 <span class="type">T</span> has type arguments <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span>, the constraint reduces
                                 to the following new constraints: for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                 <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">B<sub>i</sub></span> = <span class="type">A<sub>i</sub></span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-F"></a>
                                 Otherwise, if <span class="type">S</span> and <span class="type">T</span> are array types, <span class="type">S'</span><code class="literal">[]</code>
                                 and <span class="type">T'</span><code class="literal">[]</code>, the constraint reduces to
                                 &#8249;<span class="type">S'</span> = <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-G"></a>
                                 Otherwise, if <span class="type">S</span> and <span class="type">T</span> are intersection types, a
                                 correspondence between the elements of <span class="type">S</span> and the elements of
                                 <span class="type">T</span> is established. An element of <span class="type">S</span>, <span class="type">S<sub>i</sub></span>, corresponds to an
                                 element of <span class="type">T</span>, <span class="type">T<sub>j</sub></span>, if <span class="type">S<sub>i</sub></span> and <span class="type">T<sub>j</sub></span> are either the same type,
                                 or both parameterizations of the same generic class or
                                 interface, or both array types.
                        </p>
                        <p class="norm-static"><a name="jls-18.2.4-100-G.1"></a>
                                 If each element of <span class="type">S</span> corresponds to exactly one element of
                                 <span class="type">T</span>, and vice versa, then the constraint reduces to the
                                 following new constraints: for each element <span class="type">S<sub>i</sub></span> of <span class="type">S</span> and the
                                 corresponding element <span class="type">T<sub>j</sub></span> of <span class="type">T</span>, &#8249;<span class="type">S<sub>i</sub></span> = <span class="type">T<sub>j</sub></span>&#8250;. If
                                 not, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                        <p class="note">This rule does not accommodate inference
                                 variables appearing directly as elements of an intersection type
                                 (rather than nested in a parameterized type). Due to the
                                 restrictions on type parameter declarations
                                 (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>), such intersection types do not
                                 arise in practice.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-H"></a>
                                 Otherwise, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.2.4-200"></a>A
                  constraint formula of the form &#8249;<span class="type">S</span> = <span class="type">T</span>&#8250;, where <span class="type">S</span> and
                  <span class="type">T</span> are type arguments (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>), is reduced as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-A"></a>
                                 If <span class="type">S</span> and <span class="type">T</span> are types, the constraint is reduced as described
                                 above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-B"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> and <span class="type">T</span> has the form <code class="literal">?</code>, the
                                 constraint reduces to <span class="emphasis"><em>true</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-C"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> and <span class="type">T</span> has the form <code class="literal">?</code> <code class="literal">extends</code>
                                 <span class="type">T'</span>, the constraint reduces to &#8249;<code class="literal">Object</code> =
                                 <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-D"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">S'</span> and <span class="type">T</span> has the
                                 form <code class="literal">?</code>, the constraint reduces to &#8249;<span class="type">S'</span> =
                                 <code class="literal">Object</code>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-E"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">S'</span> and <span class="type">T</span> has the
                                 form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T'</span>, the constraint reduces to
                                 &#8249;<span class="type">S'</span> = <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-F"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">S'</span> and <span class="type">T</span> has the form
                                 <code class="literal">?</code> <code class="literal">super</code> <span class="type">T'</span>, the constraint reduces to
                                 &#8249;<span class="type">S'</span> = <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-G"></a>
                                 Otherwise, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="18.2.5.&nbsp;Checked Exception Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.5"></a>18.2.5.&nbsp;Checked Exception Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.5-100"></a>
                  A constraint formula of the form &#8249;<span class="emphasis"><em>LambdaExpression</em></span>
                  <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250; is reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-A"></a>
                                 If <span class="type">T</span> is not a functional interface type
                                 (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>), the constraint reduces to
                                 <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-B"></a>
                                 Otherwise, let the target function type for the lambda
                                 expression be determined as specified in
                                 <a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>. If no valid function type can be
                                 found, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-C"></a>
                                 Otherwise, if the lambda expression is implicitly typed, and one
                                 or more of the function type's parameter types is not a proper
                                 type, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                        <p class="note">
                                 This condition never arises in practice, due to the substitution
                                 applied to the target type in <a class="xref" href="jls-18.html#jls-18.5.2.2" title="18.5.2.2.&nbsp;Additional Argument Constraints">&sect;18.5.2.2</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-D"></a>
                                 Otherwise, if the function type's return type is neither <code class="literal">void</code>
                                 nor a proper type, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                        <p class="note">
                                 This condition never arises in practice, due to the substitution
                                 applied to the target type in <a class="xref" href="jls-18.html#jls-18.5.2.2" title="18.5.2.2.&nbsp;Additional Argument Constraints">&sect;18.5.2.2</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-F"></a>
                                 Otherwise, let <span class="type">E<sub>1</sub></span>, ..., <span class="type">E<sub>n</sub></span> be the types in the function
                                 type's <code class="literal">throws</code> clause that are <span class="emphasis"><em>not</em></span> proper
                                 types. If the lambda expression is implicitly typed, let its
                                 parameter types be the function type's parameter types. If the
                                 lambda body is a poly expression or a block containing a poly
                                 result expression, let the targeted return type be the function
                                 type's return type. Let <span class="type">X<sub>1</sub></span>, ..., <span class="type">X<sub>m</sub></span> be the checked exception
                                 types that the lambda body can throw
                                 (<a class="xref" href="jls-11.html#jls-11.2" title="11.2.&nbsp;Compile-Time Checking of Exceptions">&sect;11.2</a>). Then there are two cases:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.5-100-F-A"></a>
                                    	  If <span class="emphasis"><em>n</em></span> = <code class="literal">0</code> (the function type's <code class="literal">throws</code> clause
                                    	  consists only of proper types), then if there exists some
                                    	  <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>m</em></span>) such that <span class="type">X<sub>i</sub></span> is not a
                                    	  subtype of any proper type in the <code class="literal">throws</code> clause, the
                                    	  constraint reduces to <span class="emphasis"><em>false</em></span>; otherwise, the constraint
                                    	  reduces to <span class="emphasis"><em>true</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.5-100-F-B"></a>
                                    	  If <span class="emphasis"><em>n</em></span> &gt; <code class="literal">0</code>, the constraint reduces to a set of
                                    	  subtyping constraints: for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                    	  <span class="emphasis"><em>m</em></span>), if <span class="type">X<sub>i</sub></span> is not a subtype of any proper type in the
                                    	  <code class="literal">throws</code> clause, then the constraints include, for all
                                    	  <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">X<sub>i</sub></span> <code class="literal">&lt;:</code>
                                    	  <span class="type">E<sub>j</sub></span>&#8250;. In addition, for all <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span>
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), the constraint reduces to the bound <code class="literal">throws</code>
                                    	  <span class="type">E<sub>j</sub></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.2.5-200"></a>A
                  constraint formula of the form &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub>
                  <span class="type">T</span>&#8250; is reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-200-A"></a>
                                 If <span class="type">T</span> is not a functional interface type, or if <span class="type">T</span> is a
                                 functional interface type but does not have a function type
                                 (<a class="xref" href="jls-9.html#jls-9.9" title="9.9.&nbsp;Function Types">&sect;9.9</a>), the constraint reduces to
                                 <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-200-B"></a>
                                 Otherwise, let the target function type for the method reference
                                 expression be the function type of <span class="type">T</span>. If the method reference
                                 is inexact (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>) and one or more of
                                 the function type's parameter types is not a proper type, the
                                 constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-200-C"></a>
                                 Otherwise, if the method reference is inexact and the function
                                 type's result is neither <code class="literal">void</code> nor a proper type, the
                                 constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-200-D"></a>
                                 Otherwise, let <span class="type">E<sub>1</sub></span>, ..., <span class="type">E<sub>n</sub></span> be the types in the function
                                 type's <code class="literal">throws</code> clause that are <span class="emphasis"><em>not</em></span> proper
                                 types. Let <span class="type">X<sub>1</sub></span>, ..., <span class="type">X<sub>m</sub></span> be the checked exceptions in the
                                 <code class="literal">throws</code> clause of the invocation type of the method reference's
                                 compile-time declaration (<a class="xref" href="jls-15.html#jls-15.13.2" title="15.13.2.&nbsp;Type of a Method Reference">&sect;15.13.2</a>) (as
                                 derived from the function type's parameter types and return
                                 type). Then there are two cases:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.5-200-D-A"></a>
                                    	  If <span class="emphasis"><em>n</em></span> = <code class="literal">0</code> (the function type's <code class="literal">throws</code> clause
                                    	  consists only of proper types), then if there exists some
                                    	  <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>m</em></span>) such that <span class="type">X<sub>i</sub></span> is not a
                                    	  subtype of any proper type in the <code class="literal">throws</code> clause, the
                                    	  constraint reduces to <span class="emphasis"><em>false</em></span>; otherwise, the constraint
                                    	  reduces to <span class="emphasis"><em>true</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.5-200-D-B"></a>
                                    	  If <span class="emphasis"><em>n</em></span> &gt; <code class="literal">0</code>, the constraint reduces to a set of
                                    	  subtyping constraints: for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                    	  <span class="emphasis"><em>m</em></span>), if <span class="type">X<sub>i</sub></span> is not a subtype of any proper type in the
                                    	  <code class="literal">throws</code> clause, then the constraints include, for all
                                    	  <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">X<sub>i</sub></span> <code class="literal">&lt;:</code>
                                    	  <span class="type">E<sub>j</sub></span>&#8250;. In addition, for all <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span>
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), the constraint reduces to the bound <code class="literal">throws</code>
                                    	  <span class="type">E<sub>j</sub></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">Constraints on checked exceptions are handled
                  separately from constraints on return types, because return type
                  compatibility influences applicability of methods
                  (<a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>), while exceptions only influence the
                  invocation type after overload resolution is complete
                  (<a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>). This could be simplified by including
                  exception compatibility in the definition of lambda expression
                  compatibility (<a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>), but this would lead to
                  possibly surprising cases in which exceptions that can be thrown by an
                  explicitly typed lambda body change overload resolution.
               </p>
               <p class="note">The exceptions thrown by a lambda body cannot be
                  determined until i) the parameter types of the lambda are known, and
                  ii) the target type of result expressions in the body is known. (The
                  second requirement is to account for generic method invocations in
                  which, for example, the same type parameter appears in the return type
                  and the <code class="literal">throws</code> clause.) Hence, we require both of these, as derived
                  from the target type <span class="type">T</span>, to be proper types.
               </p>
               <p class="note">One consequence is that lambda expressions returned
                  from <span class="emphasis"><em>other</em></span> lambda expressions cannot generate
                  constraints from their thrown exceptions. These constraints can only
                  be generated from top-level lambda expressions.
               </p>
               <p class="note">Note that the handling of the case in which more
                  than one inference variable appears in a function type's <code class="literal">throws</code>
                  clause is not completeness-preserving.  Either variable may, on its
                  own, satisfy the constraint that each checked exception be declared,
                  but we cannot be sure which one is intended. So, for predictability,
                  we constrain them both.
               </p>
            </div>
         </div>
         <div class="section" title="18.3.&nbsp;Incorporation">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.3"></a>18.3.&nbsp;Incorporation
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-18.3-100"></a>
               As bound sets are generated and grown during inference, it is possible
               that new bounds can be inferred based on the assertions of the
               original bounds. The process of <span class="emphasis"><em>incorporation</em></span>
               identifies these new bounds and adds them to the bound set.
            </p>
            <p class="norm-static"><a name="jls-18.3-110"></a>
               Incorporation can happen in two scenarios. One scenario is that the
               bound set contains complementary pairs of bounds; this implies new
               constraint formulas, as specified in <a class="xref" href="jls-18.html#jls-18.3.1" title="18.3.1.&nbsp;Complementary Pairs of Bounds">&sect;18.3.1</a>. The
               other scenario is that the bound set contains a bound involving
               capture conversion; this implies new bounds and may imply new
               constraint formulas, as specified in <a class="xref" href="jls-18.html#jls-18.3.2" title="18.3.2.&nbsp;Bounds Involving Capture Conversion">&sect;18.3.2</a>. In
               both scenarios, any new constraint formulas are reduced, and any new
               bounds are added to the bound set. This may trigger further
               incorporation; ultimately, the set will reach a fixed point and no
               further bounds can be inferred.
            </p>
            <p class="norm-static"><a name="jls-18.3-200"></a>
               If incorporation of a bound set has reached a fixed point, and the set
               does not contain the bound <span class="emphasis"><em>false</em></span>, then the bound set has the
               following properties:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.3-200-A"></a>
                              For each combination of a proper lower bound <code class="varname">L</code> and a proper
                              upper bound <span class="type">U</span> of an inference variable, <code class="varname">L</code> <code class="literal">&lt;:</code>
                              <span class="type">U</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.3-200-B"></a>
                              If every inference variable mentioned by a bound has an
                              instantiation, the bound is satisfied by the corresponding
                              substitution.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.3-200-C"></a>
                              Given a dependency <span class="symbol">&#945;</span> = <span class="symbol">&#946;</span>, every bound of <span class="symbol">&#945;</span>
                              matches a bound of <span class="symbol">&#946;</span>, and vice versa.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.3-300-D"></a>
                              Given a dependency <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="symbol">&#946;</span>, every lower bound
                              of <span class="symbol">&#945;</span> is a lower bound of <span class="symbol">&#946;</span>, and every upper bound of
                              <span class="symbol">&#946;</span> is an upper bound of <span class="symbol">&#945;</span>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">The assertion that incorporation reaches a fixed
               point oversimplifies the matter slightly. Building on the work of
               Kennedy and Pierce,
               <span class="emphasis"><em><a class="link" href="http://research.microsoft.com/apps/pubs/default.aspx?id=64041" target="_top">On
                        Decidability of Nominal Subtyping with Variance</a></em></span>,
               this property can be proven by making the argument that the set of
               types that may appear in the bound set is finite.  The argument relies
               on two assumptions:
            </p>
            <div class="note">
               <ul class="note" type="disc">
                  <li class="listitem">
                     <p class="note">New capture variables are not generated when
                              reducing subtyping constraints (<a class="xref" href="jls-18.html#jls-18.2.3" title="18.2.3.&nbsp;Subtyping Constraints">&sect;18.2.3</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">Expansive inheritance paths are not pursued.</p>
                  </li>
               </ul>
            </div>
            <p class="note">This specification does not currently guarantee
               these properties (it is imprecise about the handling of wildcards when
               reducing subtyping constraints, and does not detect expansive
               inheritance paths), but may do so in a future version. (This is not a
               new problem: the Java subtyping algorithm is also at risk of
               non-termination.)
            </p>
            <div class="section" title="18.3.1.&nbsp;Complementary Pairs of Bounds">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.3.1"></a>18.3.1.&nbsp;Complementary Pairs of Bounds
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.3.1-100"></a>
                  (In this section, <span class="type">S</span> and <span class="type">T</span> are inference variables or types, and
                  <span class="type">U</span> is a proper type. For conciseness, a bound of the form <span class="symbol">&#945;</span> =
                  <span class="type">T</span> may also match a bound of the form <span class="type">T</span> = <span class="symbol">&#945;</span>.)
               </p>
               <p class="norm-static"><a name="jls-18.3.1-200"></a>When a
                  bound set contains a pair of bounds that match one of the following
                  rules, a new constraint formula is implied:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-A"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">S</span> and <span class="symbol">&#945;</span> = <span class="type">T</span> imply &#8249;<span class="type">S</span> = <span class="type">T</span>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-B"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">S</span> and <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span> imply &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-C"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">S</span> and <span class="type">T</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> imply &#8249;<span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">S</span>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-D"></a>
                                 <span class="type">S</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> and <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span> imply &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-E"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">U</span> and <span class="type">S</span> = <span class="type">T</span> imply &#8249;<span class="type">S</span><code class="literal">[</code><span class="symbol">&#945;</span>:=<span class="type">U</span><code class="literal">]</code> = <span class="type">T</span><code class="literal">[</code><span class="symbol">&#945;</span>:=<span class="type">U</span><code class="literal">]</code>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-F"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">U</span> and <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span> imply &#8249;<span class="type">S</span><code class="literal">[</code><span class="symbol">&#945;</span>:=<span class="type">U</span><code class="literal">]</code> <code class="literal">&lt;:</code> <span class="type">T</span><code class="literal">[</code><span class="symbol">&#945;</span>:=<span class="type">U</span><code class="literal">]</code>&#8250;
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.3.1-300"></a>
                  When a bound set contains a pair of bounds <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">S</span> and
                  <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span>, and there exists a supertype of <span class="type">S</span> of the form
                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>n</sub></span><code class="literal">&gt;</code> and a supertype of <span class="type">T</span> of the form
                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> (for some generic class or
                  interface, <span class="type">G</span>), then for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), if
                  <span class="type">S<sub>i</sub></span> and <span class="type">T<sub>i</sub></span> are types (not wildcards), the constraint formula
                  &#8249;<span class="type">S<sub>i</sub></span> = <span class="type">T<sub>i</sub></span>&#8250; is implied.
               </p>
            </div>
            <div class="section" title="18.3.2.&nbsp;Bounds Involving Capture Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.3.2"></a>18.3.2.&nbsp;Bounds Involving Capture Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.3.2-100"></a>When a
                  bound set contains a bound of the form <span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ...,
                  <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> = capture(<span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>), new
                  bounds are implied and new constraint formulas may be implied, as
                  follows.
               </p>
               <p class="norm-static"><a name="jls-18.3.2-200"></a>Let <span class="type">P<sub>1</sub></span>,
                  ..., <span class="type">P<sub>n</sub></span> represent the type parameters of <span class="type">G</span> and let <span class="type">B<sub>1</sub></span>, ..., <span class="type">B<sub>n</sub></span>
                  represent the bounds of these type parameters. Let <span class="symbol">&#952;</span> represent
                  the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>n</sub></span><code class="literal">]</code>.
                  Let <span class="type">R</span> be a type that is <span class="emphasis"><em>not</em></span> an inference
                  variable (but is not necessarily a proper type).
               </p>
               <p class="norm-static"><a name="jls-18.3.2-210"></a>
                  A set of bounds on <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> is implied, generated from
                  the declared bounds of <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span> as specified in
                  <a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>.
               </p>
               <p class="norm-static"><a name="jls-18.3.2-220"></a>
                  In addition, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.2-220-A"></a>
                                 If <span class="type">A<sub>i</sub></span> is not a wildcard, then the bound <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> = <span class="type">A<sub>i</sub></span> is implied.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.2-220-B"></a>
                                 If <span class="type">A<sub>i</sub></span> is a wildcard of the form <code class="literal">?</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-B-A"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> = <span class="type">R</span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-B-B"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">R</span> implies the constraint formula &#8249;<span class="type">B<sub>i</sub></span> <span class="symbol">&#952;</span> <code class="literal">&lt;:</code> <span class="type">R</span>&#8250;
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-B-C"></a>
                                    	  <span class="type">R</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.2-220-C"></a>
                                 If <span class="type">A<sub>i</sub></span> is a wildcard of the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-C-A"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> = <span class="type">R</span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-C-B"></a>
                                    	  If <span class="type">B<sub>i</sub></span> is <code class="literal">Object</code>, then <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">R</span> implies the constraint formula &#8249;<span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">R</span>&#8250;
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-C-C"></a>
                                    	  If <span class="type">T</span> is <code class="literal">Object</code>, then <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">R</span> implies the constraint formula &#8249;<span class="type">B<sub>i</sub></span> <span class="symbol">&#952;</span> <code class="literal">&lt;:</code> <span class="type">R</span>&#8250;
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-C-D"></a>
                                    	  <span class="type">R</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.2-220-D"></a>
                                 If <span class="type">A<sub>i</sub></span> is a wildcard of the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">T</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-D-A"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> = <span class="type">R</span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-D-B"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">R</span> implies the constraint formula &#8249;<span class="type">B<sub>i</sub></span> <span class="symbol">&#952;</span> <code class="literal">&lt;:</code> <span class="type">R</span>&#8250;
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-D-C"></a>
                                    	  <span class="type">R</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> implies the constraint formula &#8249;<span class="type">R</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="18.4.&nbsp;Resolution">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.4"></a>18.4.&nbsp;Resolution
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-18.4-100"></a>Given a
               bound set that does not contain the bound <span class="emphasis"><em>false</em></span>, a subset of the
               inference variables mentioned by the bound set may
               be <span class="emphasis"><em>resolved</em></span>. This means that a satisfactory
               instantiation may be added to the set for each inference variable,
               until all the requested variables have instantiations.
            </p>
            <p class="norm-static"><a name="jls-18.4-200"></a>
               Dependencies in the bound set may require that the variables be
               resolved in a particular order, or that additional variables be
               resolved. Dependencies are specified as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-200-A"></a>
                              Given a bound of one of the following forms, where <span class="type">T</span> is either
                              an inference variable <span class="symbol">&#946;</span> or a type that mentions
                              <span class="symbol">&#946;</span>:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-200-A-A"></a><span class="symbol">&#945;</span> = <span class="type">T</span></p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-200-A-B"></a><span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span></p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-200-A-C"></a><span class="type">T</span> = <span class="symbol">&#945;</span></p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-200-A-D"></a><span class="type">T</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span></p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm-static"><a name="jls-18.4-200-A.1"></a>
                              If <span class="symbol">&#945;</span> appears on the left-hand side of another bound of the
                              form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="symbol">&#945;</span>, ...<code class="literal">&gt;</code> =
                              capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>), then <span class="symbol">&#946;</span> depends on the
                              resolution of <span class="symbol">&#945;</span>. Otherwise, <span class="symbol">&#945;</span> depends on the
                              resolution of <span class="symbol">&#946;</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-200-B"></a>
                              An inference variable <span class="symbol">&#945;</span> appearing on the left-hand side of
                              a bound of the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="symbol">&#945;</span>, ...<code class="literal">&gt;</code> =
                              capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>) depends on the resolution of
                              every other inference variable mentioned in this bound (on both
                              sides of the = sign).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-200-C"></a>
                              An inference variable <span class="symbol">&#945;</span> depends on the resolution of an
                              inference variable <span class="symbol">&#946;</span> if there exists an inference variable
                              <span class="symbol">&#947;</span> such that <span class="symbol">&#945;</span> depends on the resolution of <span class="symbol">&#947;</span>
                              and <span class="symbol">&#947;</span> depends on the resolution of <span class="symbol">&#946;</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-200-D"></a>
                              An inference variable <span class="symbol">&#945;</span> depends on the resolution of itself.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-18.4-300"></a>Given a set
               of inference variables to resolve, let <span class="type">V</span> be the union of this set
               and all variables upon which the resolution of at least one variable
               in this set depends.
            </p>
            <p class="norm-static"><a name="jls-18.4-310"></a>If every
               variable in <span class="type">V</span> has an instantiation, then resolution succeeds and
               this procedure terminates.
            </p>
            <p class="norm-static"><a name="jls-18.4-320"></a>Otherwise,
               let { <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> } be a non-empty subset of
               uninstantiated variables in <span class="type">V</span> such that i) for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span>
               <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), if <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> depends on the resolution of a
               variable <span class="symbol">&#946;</span>, then either <span class="symbol">&#946;</span> has an instantiation or there is
               some <span class="emphasis"><em>j</em></span> such that <span class="symbol">&#946;</span> = <span class="symbol">&#945;</span><span class="type"><sub>j</sub></span>; and ii) there exists no
               non-empty proper subset of { <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> } with this
               property. Resolution proceeds by generating an instantiation for each
               of <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> based on the bounds in the bound
               set:
            </p>
            <div class="">
               <ul class="" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-320-A"></a>
                              If the bound set does not contain a bound of the form
                              <span class="type">G</span><code class="literal">&lt;</code>..., <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, ...<code class="literal">&gt;</code> =
                              capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>) for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                              <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), then a candidate instantiation <span class="type">T<sub>i</sub></span> is defined
                              for each <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-A-A"></a>
                                 	  If <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> has one or more <span class="emphasis"><em>proper</em></span>
                                 	  lower bounds, <code class="varname">L<sub>1</sub></code>, ..., <code class="varname">L<sub>k</sub></code>, then <span class="type">T<sub>i</sub></span> = lub(<code class="varname">L<sub>1</sub></code>, ...,
                                 	  <code class="varname">L<sub>k</sub></code>) (<a class="xref" href="jls-4.html#jls-4.10.4" title="4.10.4.&nbsp;Least Upper Bound">&sect;4.10.4</a>).
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-A-B"></a>
                                 	  Otherwise, if the bound set contains <code class="literal">throws</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, and
                                 	  each proper upper bound of <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> is a supertype of 
                                 	  <code class="literal">RuntimeException</code>, then <span class="type">T<sub>i</sub></span> = <code class="literal">RuntimeException</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-A-C"></a>
                                 	  Otherwise, where <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> has <span class="emphasis"><em>proper</em></span>
                                 	  upper bounds <span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span>, <span class="type">T<sub>i</sub></span> = glb(<span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span>)
                                 	  (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm-static"><a name="jls-18.4-320-A.1"></a>
                              The bounds <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span> = <span class="type">T<sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> = <span class="type">T<sub>n</sub></span> are
                              incorporated with the current bound set.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-A.2"></a>
                              If the result does not contain the bound <span class="emphasis"><em>false</em></span>, then the
                              result becomes the new bound set, and resolution proceeds by
                              selecting a new set of variables to instantiate (if necessary),
                              as described above.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-A.3"></a>
                              Otherwise, the result contains the bound <span class="emphasis"><em>false</em></span>, so a second
                              attempt is made to instantiate { <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> } by
                              performing the step below.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-320-B"></a>
                              If the bound set contains a bound of the form <span class="type">G</span><code class="literal">&lt;</code>...,
                              <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, ...<code class="literal">&gt;</code> = capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>) for some
                              <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), or;
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.1"></a>
                              If the bound set produced in the step above contains the bound
                              <span class="emphasis"><em>false</em></span>;
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.2"></a>
                              then let <span class="type">Y<sub>1</sub></span>, ..., <span class="type">Y<sub>n</sub></span> be fresh type variables whose bounds
                              are as follows:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-B.2-A"></a>
                                 	  For all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), if <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>
                                 	  has one or more <span class="emphasis"><em>proper</em></span> lower bounds
                                 	  <code class="varname">L<sub>1</sub></code>, ..., <code class="varname">L<sub>k</sub></code>, then let the lower bound of <span class="type">Y<sub>i</sub></span> be
                                 	  lub(<code class="varname">L<sub>1</sub></code>, ..., <code class="varname">L<sub>k</sub></code>); if not, then <span class="type">Y<sub>i</sub></span> has no lower
                                 	  bound.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-B.2-B"></a>
                                 	  For all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), where <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>
                                 	  has upper bounds <span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span>, let the upper bound of
                                 	  <span class="type">Y<sub>i</sub></span> be glb(<span class="type">U<sub>1</sub></span> <span class="symbol">&#952;</span>, ..., <span class="type">U<sub>k</sub></span> <span class="symbol">&#952;</span>), where <span class="symbol">&#952;</span> is
                                 	  the substitution <code class="literal">[</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>:=<span class="type">Y<sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span>:=<span class="type">Y<sub>n</sub></span><code class="literal">]</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm-static"><a name="jls-18.4-320-B.3"></a>
                              If the type variables <span class="type">Y<sub>1</sub></span>, ..., <span class="type">Y<sub>n</sub></span> do not have well-formed
                              bounds (that is, a lower bound is not a subtype of an upper
                              bound, or an intersection type is inconsistent), then resolution
                              fails.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.4"></a>
                              Otherwise, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), all
                              bounds of the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, ...<code class="literal">&gt;</code> =
                              capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>) are removed from the current
                              bound set, and the bounds <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span> = <span class="type">Y<sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> = <span class="type">Y<sub>n</sub></span>
                              are incorporated.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.5"></a>
                              If the result does not contain the bound <span class="emphasis"><em>false</em></span>, then the
                              result becomes the new bound set, and resolution proceeds by
                              selecting a new set of variables to instantiate (if necessary),
                              as described above.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.6"></a>
                              Otherwise, the result contains the bound <span class="emphasis"><em>false</em></span>, and
                              resolution fails.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">The first method of instantiating an inference
               variable derives the instantiation from that variable's
               bounds. Sometimes, however, complex dependencies mean that the result
               is not within the variable's bounds. In that case, a different method
               of instantiation is performed, analogous to capture conversion
               (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>): fresh type variables are introduced,
               with bounds derived from the bounds of the inference variables. Note
               that the lower bounds of these "capture" variables are computed using
               only proper types: this is important in order to avoid attempts to
               perform typing computations on uninstantiated type variables.
            </p>
         </div>
         <div class="section" title="18.5.&nbsp;Uses of Inference">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.5"></a>18.5.&nbsp;Uses of Inference
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm">Using the inference processes defined above, the
               following analyses are performed at compile time.
            </p>
            <div class="section" title="18.5.1.&nbsp;Invocation Applicability Inference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.5.1"></a>18.5.1.&nbsp;Invocation Applicability Inference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.5.1-100"></a>Given a
                  method invocation that provides no explicit type arguments, the
                  process to determine whether a potentially applicable generic method
                  <code class="varname">m</code> is applicable is as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-A"></a>
                                 Where <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span> (<span class="emphasis"><em>p</em></span> <span class="symbol">&#8805;</span> 1) are the type parameters
                                 of <code class="varname">m</code>, let <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>p</sub></span> be inference variables, and
                                 let <span class="symbol">&#952;</span> be the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ...,
                                 <span class="type">P<sub>p</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>p</sub></span><code class="literal">]</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-B"></a>
                                 An initial bound set, <span class="type">B<sub>0</sub></span>, is generated from the declared
                                 bounds of <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>, as described in <a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-C"></a>
                                 For all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>), if <span class="type">P<sub>i</sub></span> appears in
                                 the <code class="literal">throws</code> clause of <code class="varname">m</code>, then the bound <code class="literal">throws</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> is
                                 implied. These bounds, if any, are incorporated with <span class="type">B<sub>0</sub></span> to
                                 produce a new bound set, <span class="type">B<sub>1</sub></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-D"></a>
                                 A set of constraint formulas, <span class="type">C</span>, is generated as follows.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.1-100-D.1"></a>
                                 Let <span class="type">F<sub>1</sub></span>, ..., <span class="type">F<sub>n</sub></span> be the formal parameter types of <code class="varname">m</code>, and
                                 let <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>k</sub></code> be the actual argument expressions of the
                                 invocation. Then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-A"></a>
                                    	  To test for <span class="emphasis"><em>applicability by strict invocation</em></span>:
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-A.1"></a>
                                    	  If <span class="emphasis"><em>k</em></span> <span class="symbol">&#8800;</span> <span class="emphasis"><em>n</em></span>, or if there exists an <span class="emphasis"><em>i</em></span> (1
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) such that <code class="varname">e<sub>i</sub></code> is pertinent to
                                    	  applicability (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>) and either
                                    	  i) <code class="varname">e<sub>i</sub></code> is a standalone expression of a primitive type but
                                    	  <span class="type">F<sub>i</sub></span> is a reference type, or ii) <span class="type">F<sub>i</sub></span> is a primitive type
                                    	  but <code class="varname">e<sub>i</sub></code> is not a standalone expression of a primitive type;
                                    	  then the method is not applicable and there is no need to
                                    	  proceed with inference.
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-A.2"></a>
                                    	  Otherwise, <span class="type">C</span> includes, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>) where <code class="varname">e<sub>i</sub></code> is pertinent to applicability,
                                    	  &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span> <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-B"></a>
                                    	  To test for <span class="emphasis"><em>applicability by loose invocation</em></span>:
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-B.1"></a>
                                    	  If <span class="emphasis"><em>k</em></span> <span class="symbol">&#8800;</span> <span class="emphasis"><em>n</em></span>, the method is not applicable and
                                    	  there is no need to proceed with inference.
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-B.2"></a>
                                    	  Otherwise, <span class="type">C</span> includes, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>) where <code class="varname">e<sub>i</sub></code> is pertinent to applicability,
                                    	  &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span> <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-C"></a>
                                    	  To test for <span class="emphasis"><em>applicability by variable arity invocation</em></span>:
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-C.1"></a>
                                    	  Let <span class="type">F'<sub>1</sub></span>, ..., <span class="type">F'<sub>k</sub></span> be the first <span class="emphasis"><em>k</em></span> variable
                                    	  arity parameter types of <code class="varname">m</code>
                                    	  (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>).  <span class="type">C</span> includes, for all
                                    	  <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>) where <code class="varname">e<sub>i</sub></code> is pertinent
                                    	  to applicability, &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span> <span class="type">F'<sub>i</sub></span>
                                    	  <span class="symbol">&#952;</span>&#8250;.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-E"></a>
                                 <span class="type">C</span> is reduced (<a class="xref" href="jls-18.html#jls-18.2" title="18.2.&nbsp;Reduction">&sect;18.2</a>) and the resulting
                                 bounds are incorporated with <span class="type">B<sub>1</sub></span> to produce a new bound set,
                                 <span class="type">B<sub>2</sub></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-F"></a>
                                 Finally, the method <code class="varname">m</code> is applicable if <span class="type">B<sub>2</sub></span> does not contain
                                 the bound <span class="emphasis"><em>false</em></span> and resolution of all the inference
                                 variables in <span class="type">B<sub>2</sub></span> succeeds (<a class="xref" href="jls-18.html#jls-18.4" title="18.4.&nbsp;Resolution">&sect;18.4</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="informalexample">
                  <p class="note">Consider the following method invocation and
                     assignment:
                  </p><pre class="screen">List&lt;Number&gt; ln = Arrays.asList(1, 2.0);</pre><p class="note">A most specific applicable method for the invocation
                     must be identified as described in <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>. The
                     only potentially applicable method (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>)
                     is declared as follows:
                  </p><pre class="screen">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</pre><p class="note">Trivially (because of its arity), this method is
                     neither applicable by strict invocation
                     (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>) nor applicable by loose invocation
                     (<a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">&sect;15.12.2.3</a>). But since there are no other
                     candidates, in a third phase the method is checked for applicability
                     by variable arity invocation.
                  </p>
                  <p class="note">The initial bound set, <span class="type">B</span>, is a trivial upper bound
                     for a single inference variable, <span class="symbol">&#945;</span>:
                  </p>
                  <p class="note">{ <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code> }
                  </p>
                  <p class="note">The initial constraint formula set is as follows:</p>
                  <p class="note">{ &#8249;<code class="literal">1</code> <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250;,
                     &#8249;<code class="literal">2.0</code> <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250; }
                  </p>
                  <p class="note">These are reduced to a new bound set, <span class="type">B<sub>1</sub></span>:
                  </p>
                  <p class="note">{ <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code>, 
                     <code class="literal">Integer</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, 
                     <code class="literal">Double</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> }
                  </p>
                  <p class="note">Then, to test whether the method is applicable, we
                     attempt to resolve these bounds.  We succeed, producing the rather
                     complex instantiation
                  </p>
                  <p class="note"><span class="symbol">&#945;</span> = <code class="literal">Number &amp; Comparable&lt;?
                        extends Number &amp; Comparable&lt;?&gt;&gt;</code></p>
                  <p class="note">We have thus demonstrated that the method is
                     applicable; since no other candidates exist, it is the most specific
                     applicable method. Still, the type of the method invocation, and its
                     compatibility with the target type in the assignment, is not
                     determined until further inference can occur, as described in the next
                     section.
                  </p>
               </div>
            </div>
            <div class="section" title="18.5.2.&nbsp;Invocation Type Inference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.5.2"></a>18.5.2.&nbsp;Invocation Type Inference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.5.2-100"></a>
                  Given a method invocation expression that provides no explicit type
                  arguments, and a corresponding most specific applicable generic method
                  <code class="varname">m</code>, the process to infer the invocation type
                  (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>) of the chosen method may require
                  resolving additional constraints, both to assert compatibility with a
                  target type and to assert validity of the method invocation's argument
                  expressions.
               </p>
               <p class="note">It is important to note that multiple "rounds" of
                  inference are involved in finding the type of a method
                  invocation. This is necessary, for example, to allow a target type to
                  influence the type of the invocation without allowing it to influence
                  the choice of an applicable method. The first round
                  (<a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>) produces a bound set and tests that a
                  resolution exists, but does not commit to that resolution. Subsequent
                  rounds reduce additional constraints until a final resolution step
                  determines the "real" type of the expression.
               </p>
               <div class="section" title="18.5.2.1.&nbsp;Poly Method Invocation Compatibility">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-18.5.2.1"></a>18.5.2.1.&nbsp;Poly Method Invocation Compatibility
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-18.5.2.1-100"></a>
                     If the method invocation expression is a poly expression
                     (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), its compatibility with a target type
                     <span class="type">T</span> is determined as follows.
                  </p>
                  <p class="norm-static"><a name="jls-18.5.2.1-110"></a>
                     If the method invocation expression appears in a strict invocation
                     context and <span class="type">T</span> is a primitive type, the expression is not compatible
                     with <span class="type">T</span>.
                  </p>
                  <p class="norm-static"><a name="jls-18.5.2.1-200"></a>
                     Otherwise:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.1-200-A"></a>
                                    Let <span class="type">B<sub>2</sub></span> be the bound set produced by reduction in order to
                                    demonstrate that <code class="varname">m</code> is applicable in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>.
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.1-200-A.1"></a>
                                    (While it was necessary in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a> to
                                    demonstrate that the inference variables in <span class="type">B<sub>2</sub></span> could be
                                    resolved, in order to establish applicability, the
                                    instantiations produced by this resolution step
                                    are <span class="emphasis"><em>not</em></span> considered part of <span class="type">B<sub>2</sub></span>.)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.1-200-B"></a>
                                    Let <span class="type">B<sub>3</sub></span> be the bound set derived from <span class="type">B<sub>2</sub></span> as follows.
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.1-200-B.1"></a>
                                    Let <span class="type">R</span> be the return type of <code class="varname">m</code>,
                                    and let <span class="symbol">&#952;</span> be the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ...,
                                    <span class="type">P<sub>p</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>p</sub></span><code class="literal">]</code> defined in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>
                                    to replace the type parameters of <code class="varname">m</code> with inference variables,
                                    and let <span class="type">T</span> be the invocation's target type. Then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.1-200-B.1-A"></a>
                                       	  If unchecked conversion was necessary for the method to be
                                       	  applicable during constraint set reduction in
                                       	  <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>, the constraint formula
                                       	  &#8249;|<span class="type">R</span>| <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; is reduced and incorporated
                                       	  with <span class="type">B<sub>2</sub></span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.1-200-B.1-B"></a>
                                       	  Otherwise, if <span class="type">R</span> <span class="symbol">&#952;</span> is a parameterized type,
                                       	  <span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>, and one of <span class="type">A<sub>1</sub></span>, ...,
                                       	  <span class="type">A<sub>n</sub></span> is a wildcard, then, for fresh inference variables
                                       	  <span class="symbol">&#946;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#946;</span><span class="type"><sub>n</sub></span>, the constraint formula
                                       	  &#8249;<span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#946;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#946;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> <span class="symbol">&#8594;</span>
                                       	  <span class="type">T</span>&#8250; is reduced and incorporated, along with the bound
                                       	  <span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#946;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#946;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> =
                                       	  capture(<span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>), with
                                       	  <span class="type">B<sub>2</sub></span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.1-200-B.1-C"></a>
                                       	  Otherwise, if <span class="type">R</span> <span class="symbol">&#952;</span> is an inference variable <span class="symbol">&#945;</span>,
                                       	  and one of the following is true:
                                    </p>
                                    <div class="norm">
                                       <ul class="norm" type="square">
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.1-200-B.1-C-A"></a>
                                                	      <span class="type">T</span> is a reference type, but is not a
                                                	      wildcard-parameterized type, and either i) <span class="type">B<sub>2</sub></span> contains
                                                	      a bound of one of the forms <span class="symbol">&#945;</span> = <span class="type">S</span> or <span class="type">S</span>
                                                	      <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, where <span class="type">S</span> is a wildcard-parameterized
                                                	      type, or ii) <span class="type">B<sub>2</sub></span> contains two bounds of the forms <span class="type">S<sub>1</sub></span>
                                                	      <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> and <span class="type">S<sub>2</sub></span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, where <span class="type">S<sub>1</sub></span>
                                                	      and <span class="type">S<sub>2</sub></span> have supertypes that are two different
                                                	      parameterizations of the same generic class or
                                                	      interface.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.1-200-B.1-C-B"></a>
                                                	      <span class="type">T</span> is a parameterization of a generic class or
                                                	      interface, <span class="type">G</span>, and <span class="type">B<sub>2</sub></span> contains a bound of one of the
                                                	      forms <span class="symbol">&#945;</span> = <span class="type">S</span> or <span class="type">S</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, where
                                                	      there exists no type of the form <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>
                                                	      that is a supertype of <span class="type">S</span>, but the raw type
                                                	      |<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>| is a supertype of <span class="type">S</span>.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.1-200-B.1-C-C"></a>
                                                	      <span class="type">T</span> is a primitive type, and one of the primitive
                                                	      wrapper classes mentioned in <a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>
                                                	      is an instantiation, upper bound, or lower bound for
                                                	      <span class="symbol">&#945;</span> in <span class="type">B<sub>2</sub></span>.
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                    <p class="norm-static"><a name="jls-18.5.2.1-200-B.1-C.1"></a>
                                       	  then <span class="symbol">&#945;</span> is resolved in <span class="type">B<sub>2</sub></span>, and where the capture of
                                       	  the resulting instantiation of <span class="symbol">&#945;</span> is <span class="type">U</span>, the
                                       	  constraint formula &#8249;<span class="type">U</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; is reduced
                                       	  and incorporated with <span class="type">B<sub>2</sub></span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.1-200-B.1-D"></a>
                                       	  Otherwise, the constraint formula &#8249;<span class="type">R</span> <span class="symbol">&#952;</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; 
                                       	  is reduced and incorporated with <span class="type">B<sub>2</sub></span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.1-200-C"></a>
                                    The method invocation expression is compatible with <span class="type">T</span> if <span class="type">B<sub>3</sub></span>
                                    does not contain the bound <span class="emphasis"><em>false</em></span> and resolution of all the
                                    inference variables in <span class="type">B<sub>3</sub></span> succeeds (<a class="xref" href="jls-18.html#jls-18.4" title="18.4.&nbsp;Resolution">&sect;18.4</a>).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="informalexample">
                     <p class="note">Consider the example from the previous section:</p><pre class="screen">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code> ln = Arrays.asList(1, 2.0);</pre><p class="note">The most specific applicable method was identified as:</p><pre class="screen">public static <code class="literal">&lt;</code>T<code class="literal">&gt;</code> List<code class="literal">&lt;</code>T<code class="literal">&gt;</code> asList(T... a)</pre><p class="note">In order to complete type-checking of the method
                        invocation, we must determine whether it is compatible with its target
                        type, <code class="literal">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code></code>.
                     </p>
                     <p class="note">The bound set used to demonstrate applicability in
                        the previous section, <span class="type">B<sub>2</sub></span>, was:
                     </p>
                     <p class="note">{ <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code>, 
                        <code class="literal">Integer</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, 
                        <code class="literal">Double</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> }
                     </p>
                     <p class="note">The new constraint formula set is as follows:</p>
                     <p class="note">{ &#8249;<code class="literal">List<code class="literal">&lt;</code><span class="symbol">&#945;</span><code class="literal">&gt;</code></code> <span class="symbol">&#8594;</span> <code class="literal">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code></code>&#8250; }
                     </p>
                     <p class="note">This compatibility constraint produces an equality
                        bound for <span class="symbol">&#945;</span>, which is included in the new bound set, <span class="type">B<sub>3</sub></span>:
                     </p>
                     <p class="note">{ <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code>, 
                        <code class="literal">Integer</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, 
                        <code class="literal">Double</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, 
                        <span class="symbol">&#945;</span> = <code class="literal">Number</code> }
                     </p>
                     <p class="note">These bounds are trivially resolved:</p>
                     <p class="note"><span class="symbol">&#945;</span> = <code class="literal">Number</code></p>
                     <p class="note">Finally, we perform a substitution on the declared
                        return type of <code class="literal">asList</code> to determine that the method
                        invocation has type <code class="literal">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code></code>;
                        clearly, this is compatible with the target type.
                     </p>
                     <p class="note">This inference strategy is different than the Java
                        SE 7 Edition of <em class="citetitle">The <span class="trademark">Java</span>&reg; Language Specification</em>, which would have instantiated <span class="symbol">&#945;</span> based
                        on its lower bounds (before even considering the invocation's target
                        type), as we did in the previous section. This would result in a type
                        error, since the resulting type is not a subtype
                        of <code class="literal">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code></code>.
                     </p>
                  </div>
                  <p class="note">Under various special circumstances, based on the
                     bounds appearing in <span class="type">B<sub>2</sub></span>, we eagerly resolve an inference variable
                     that appears as the return type of the invocation. This is to avoid
                     unfortunate situations in which the usual constraint, 
                     &#8249;<span class="type">R</span> <span class="symbol">&#952;</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, is not completeness-preserving. 
                     It is, unfortunately, possible that by eagerly resolving the variable,
                     we are unable to make use of bounds that would be inferred later. It
                     is also possible that, in some cases, bounds that will later be
                     inferred from the invocation arguments (such as implicitly typed
                     lambda expressions) would have caused a different outcome if they had
                     been present in <span class="type">B<sub>2</sub></span>. Despite these limitations, the strategy allows
                     for reasonable outcomes in typical use cases, and is backwards
                     compatible with the algorithm in the Java SE 7 Edition of
                     <em class="citetitle">The <span class="trademark">Java</span>&reg; Language Specification</em>.
                  </p>
               </div>
               <div class="section" title="18.5.2.2.&nbsp;Additional Argument Constraints">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-18.5.2.2"></a>18.5.2.2.&nbsp;Additional Argument Constraints
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-18.5.2.2-100"></a>
                     The invocation type for the chosen method is determined after
                     considering additional constraints that may be implied by the argument
                     expressions of the method invocation expression, as follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-100-A"></a>
                                    If the method invocation expression is a poly expression, let
                                    <span class="type">B<sub>3</sub></span> be the bound set generated in
                                    <a class="xref" href="jls-18.html#jls-18.5.2.1" title="18.5.2.1.&nbsp;Poly Method Invocation Compatibility">&sect;18.5.2.1</a> to demonstrate compatibility with
                                    the actual target type of the method invocation.
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.2-100-A.1"></a>
                                    If the method invocation expression is not a poly expression,
                                    let <span class="type">B<sub>3</sub></span> be the same as the bound set produced by reduction in
                                    order to demonstrate that <code class="varname">m</code> is applicable in
                                    <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>.
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.2-100-A.2"></a>
                                    (While it was necessary in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a> and
                                    <a class="xref" href="jls-18.html#jls-18.5.2.1" title="18.5.2.1.&nbsp;Poly Method Invocation Compatibility">&sect;18.5.2.1</a> to demonstrate that the inference
                                    variables in the bound set could be resolved, the instantiations
                                    produced by these resolution steps are <span class="emphasis"><em>not</em></span>
                                    considered part of <span class="type">B<sub>3</sub></span>.)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-100-B"></a>
                                    A set of constraint formulas, <span class="type">C</span>, is generated as follows.
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.2-100-B.1"></a>
                                    Let <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>k</sub></code> be the actual argument expressions of the
                                    method invocation expression.
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.2-100-B.2"></a>
                                    If <code class="varname">m</code> is applicable by strict or loose invocation, let <span class="type">F<sub>1</sub></span>,
                                    ..., <span class="type">F<sub>k</sub></span> be the formal parameter types of <code class="varname">m</code>; if <code class="varname">m</code> is
                                    applicable by variable arity invocation, let <span class="type">F<sub>1</sub></span>, ..., <span class="type">F<sub>k</sub></span> the
                                    first <span class="emphasis"><em>k</em></span> variable arity parameter types of <code class="varname">m</code>
                                    (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>).
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.2-100-B.3"></a>
                                    Let <span class="symbol">&#952;</span> be the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ...,
                                    <span class="type">P<sub>p</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>p</sub></span><code class="literal">]</code> defined in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>
                                    to replace the type parameters of <code class="varname">m</code> with inference
                                    variables.
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.2-100-B.4"></a>
                                    Then, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>):
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-A"></a>
                                       	  If <code class="varname">e<sub>i</sub></code> is not pertinent to applicability, <span class="type">C</span> contains
                                       	  &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span> <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B"></a>
                                       	  Additional constraints may be included, depending on the
                                       	  form of <code class="varname">e<sub>i</sub></code>:
                                    </p>
                                    <div class="norm">
                                       <ul class="norm" type="square">
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-A"></a>	    
                                                	      If <code class="varname">e<sub>i</sub></code> is a <span class="emphasis"><em>LambdaExpression</em></span>,
                                                	      <span class="type">C</span> contains &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;, 
                                                	      and the lambda body is searched for additional constraints:
                                             </p>
                                             <div class="norm">
                                                <ul class="norm" type="disc">
                                                   <li class="listitem">
                                                      <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-A-A"></a>
                                                         		  For a block lambda body,
                                                         		  the search is applied recursively to each result expression.
                                                      </p>
                                                   </li>
                                                   <li class="listitem">
                                                      <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-A-B"></a>
                                                         		  For a poly class instance creation expression or a
                                                         		  poly method invocation expression , <span class="type">C</span> contains all
                                                         		  the constraint formulas that would appear in the set
                                                         		  <span class="type">C</span> generated by <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a> when
                                                         		  inferring the poly expression's invocation type.
                                                      </p>
                                                   </li>
                                                   <li class="listitem">
                                                      <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-A-C"></a>
                                                         		  For a parenthesized expression,
                                                         		  the search is applied recursively to the contained expression.
                                                      </p>
                                                   </li>
                                                   <li class="listitem">
                                                      <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-A-D"></a>
                                                         		  For a conditional expression,
                                                         		  the search is applied recursively to the second and third operands.
                                                      </p>
                                                   </li>
                                                   <li class="listitem">
                                                      <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-A-E"></a>
                                                         		  For a lambda expression,
                                                         		  the search is applied recursively to the lambda body.
                                                      </p>
                                                   </li>
                                                </ul>
                                             </div>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-B"></a>
                                                	      If <code class="varname">e<sub>i</sub></code> is a <span class="emphasis"><em>MethodReference</em></span>,
                                                	      <span class="type">C</span> contains &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-C"></a>
                                                	      If <code class="varname">e<sub>i</sub></code> is a poly class instance creation expression or
                                                	      a poly method invocation expression, <span class="type">C</span> contains all
                                                	      the constraint formulas that would appear in the set <span class="type">C</span>
                                                	      generated by <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a> when inferring
                                                	      the poly expression's invocation type.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-D"></a>
                                                	      If <code class="varname">e<sub>i</sub></code> is a parenthesized expression,
                                                	      these rules are applied recursively to the contained expression.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.2-100-B.4-B-E"></a>
                                                	      If <code class="varname">e<sub>i</sub></code> is a conditional expression,
                                                	      these rules are applied recursively to the second and third operands.
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-100-C"></a>
                                    While <span class="type">C</span> is not empty, the following process is repeated,
                                    starting with the bound set <span class="type">B<sub>3</sub></span> and accumulating new bounds
                                    into a "current" bound set, ultimately producing a new bound
                                    set, <span class="type">B<sub>4</sub></span>:
                           </p>
                           <div class="orderedlist">
                              <ol class="orderedlist" type="1">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-C-A"></a>
                                       	  A subset of constraints is selected in <span class="type">C</span>, satisfying the
                                       	  property that, for each constraint, no input variable
                                       	   can influence an output variable of
                                       	  another constraint in <span class="type">C</span>. The terms <span class="emphasis"><em>input
                                             	  variable</em></span> and <span class="emphasis"><em>output variable</em></span>
                                       	  are defined below. An inference variable
                                       	  <span class="symbol">&#945;</span> <span class="emphasis"><em>can influence</em></span> an inference
                                       	  variable <span class="symbol">&#946;</span> if <span class="symbol">&#945;</span> depends on the resolution of
                                       	  <span class="symbol">&#946;</span> (<a class="xref" href="jls-18.html#jls-18.4" title="18.4.&nbsp;Resolution">&sect;18.4</a>), or vice versa; or if
                                       	  there exists a third inference variable <span class="symbol">&#947;</span> such that
                                       	  <span class="symbol">&#945;</span> can influence <span class="symbol">&#947;</span> and <span class="symbol">&#947;</span> can influence
                                       	  <span class="symbol">&#946;</span>.
                                    </p>
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-C-A.1"></a>
                                       	  If this subset is empty, then there is a cycle (or cycles)
                                       	  in the graph of dependencies between constraints. In this
                                       	  case, the constraints in <span class="type">C</span> that participate in a
                                       	  dependency cycle (or cycles) and do not depend on any
                                       	  constraints outside of the cycle (or cycles) are
                                       	  considered. A single constraint is selected from these
                                       	  considered constraints, as follows:
                                    </p>
                                    <div class="norm">
                                       <ul class="norm" type="circle">
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.2-100-C-A.1-A"></a>
                                                	      If any of the considered constraints have the form
                                                	      &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, then the selected
                                                	      constraint is the considered constraint of this form
                                                	      that contains the expression to the left
                                                	      (<a class="xref" href="jls-3.html#jls-3.5" title="3.5.&nbsp;Input Elements and Tokens">&sect;3.5</a>) of the expression of every
                                                	      other considered constraint of this form.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm-static"><a name="jls-18.5.2.2-100-C-A.1-B"></a>
                                                	      If no considered constraint has the form
                                                	      &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, then the selected
                                                	      constraint is the considered constraint that contains
                                                	      the expression to the left of the expression of every
                                                	      other considered constraint.
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-C-B"></a>
                                       	  The selected constraint(s) are removed from <span class="type">C</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-C-C"></a>
                                       	  The input variables <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span> of all the
                                       	  selected constraint(s) are resolved.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-C-D"></a>
                                       	  Where <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>m</sub></span> are the instantiations of <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>,
                                       	  ..., <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span>, the substitution <code class="literal">[</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>, ...,
                                       	  <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span>:=<span class="type">T<sub>m</sub></span><code class="literal">]</code> is applied to every constraint.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-C-E"></a>
                                       	  The constraint(s) resulting from substitution are reduced
                                       	  and incorporated with the current bound set.
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-100-D"></a>
                                    Finally, if <span class="type">B<sub>4</sub></span> does not contain the bound <span class="emphasis"><em>false</em></span>, the
                                    inference variables in <span class="type">B<sub>4</sub></span> are resolved.
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.2-100-D.1"></a>
                                    If resolution succeeds with instantiations <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>p</sub></span> for
                                    inference variables <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>p</sub></span>, let <span class="symbol">&#952;</span>' be
                                    the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>:=<span class="type">T<sub>p</sub></span><code class="literal">]</code>. Then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-D.1-A"></a>
                                       	  If unchecked conversion was necessary for the method to be
                                       	  applicable during constraint set reduction in
                                       	  <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>, then the parameter types of
                                       	  the invocation type of <code class="varname">m</code> are obtained by applying
                                       	  <span class="symbol">&#952;</span>' to the parameter types of <code class="varname">m</code>'s type, and the
                                       	  return type and thrown types of the invocation type of <code class="varname">m</code>
                                       	  are given by the erasure of the return type and thrown types
                                       	  of <code class="varname">m</code>'s type.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-100-D.1-B"></a>
                                       	  If unchecked conversion was not necessary for the method to
                                       	  be applicable, then the invocation type of <code class="varname">m</code> is obtained
                                       	  by applying <span class="symbol">&#952;</span>' to the type of <code class="varname">m</code>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <p class="norm-error"><a name="jls-18.5.2.2-100-D.2"></a>
                                    If <span class="type">B<sub>4</sub></span> contains the bound <span class="emphasis"><em>false</em></span>, or if resolution fails,
                                    then a compile-time error occurs.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-18.5.2.2-200"></a>
                     The process of reducing additional argument constraints may require
                     carefully ordering constraint formulas of the forms
                     &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, &#8249;<span class="emphasis"><em>LambdaExpression</em></span>
                     <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;, and &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub>
                     <span class="type">T</span>&#8250;. To facilitate this ordering, the <span class="emphasis"><em>input
                           variables</em></span> of these constraints are defined as
                     follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-200-A"></a>
                                    For &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-A-A"></a>
                                       	  If <span class="type">T</span> is an inference variable, it is the (only) input
                                       	  variable.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-A-B"></a>
                                       	  If <span class="type">T</span> is a functional interface type, and a function type
                                       	  can be derived from <span class="type">T</span> (<a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>),
                                       	  then the input variables include i) if the lambda expression
                                       	  is implicitly typed, the inference variables mentioned by
                                       	  the function type's parameter types; and ii) if the function
                                       	  type's return type, <span class="type">R</span>, is not <code class="literal">void</code>, then for each result
                                       	  expression <code class="varname">e</code> in the lambda body (or for the body itself if
                                       	  it is an expression), the input variables of &#8249;<code class="varname">e</code>
                                       	  <span class="symbol">&#8594;</span> <span class="type">R</span>&#8250;.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-A-C"></a>
                                       	  Otherwise, there are no input variables.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-200-B"></a>
                                    For &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-B-A"></a>
                                       	  If <span class="type">T</span> is an inference variable, it is the (only) input variable.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-B-B"></a>
                                       	  If <span class="type">T</span> is a functional interface type, and a function type
                                       	  can be derived, as described in
                                       	  <a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>, the input variables include
                                       	  i) if the lambda expression is implicitly typed, the
                                       	  inference variables mentioned by the function type's
                                       	  parameter types; and ii) the inference variables mentioned
                                       	  by the function type's return type.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-B-C"></a>
                                       	  Otherwise, there are no input variables.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-200-C"></a>
                                    For &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-C-A"></a>
                                       	  If <span class="type">T</span> is an inference variable, it is the (only) input variable.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-C-B"></a>
                                       	  If <span class="type">T</span> is a functional interface type with a function type,
                                       	  and if the method reference is inexact
                                       	  (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>), the input variables are the
                                       	  inference variables mentioned by the function type's
                                       	  parameter types.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-C-C"></a>
                                       	  Otherwise, there are no input variables.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-200-D"></a>
                                    For &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-D-A"></a>
                                       	  If <span class="type">T</span> is an inference variable, it is the (only) input variable.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-D-B"></a>
                                       	  If <span class="type">T</span> is a functional interface type with a function type,
                                       	  and if the method reference is inexact
                                       	  (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>), the input variables are the
                                       	  inference variables mentioned by the function type's
                                       	  parameter types and the function type's return type.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-18.5.2.2-200-D-C"></a>
                                       	  Otherwise, there are no input variables.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-200-E"></a>
                                    For &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, if <span class="emphasis"><em>Expression</em></span> is a
                                    parenthesized expression:
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.2-200-E.1"></a>
                                    Where the contained expression of <span class="emphasis"><em>Expression</em></span> is <span class="emphasis"><em>Expression</em></span>',
                                    the input variables are the input variables of
                                    &#8249;<span class="emphasis"><em>Expression</em></span>' <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-200-F"></a>
                                    For &#8249;<span class="emphasis"><em>ConditionalExpression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;:
                           </p>
                           <p class="norm-static"><a name="jls-18.5.2.2-200-F.1"></a>
                                    Where the conditional expression has the form <code class="varname">e<sub>1</sub></code> <code class="literal">?</code> <code class="varname">e<sub>2</sub></code>
                                    <code class="literal">:</code> <code class="varname">e<sub>3</sub></code>, the input variables are the input variables of
                                    &#8249;<code class="varname">e<sub>2</sub></code> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; and &#8249;<code class="varname">e<sub>3</sub></code> <span class="symbol">&#8594;</span>
                                    <span class="type">T</span>&#8250;.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-18.5.2.2-200-G"></a>
                                    For all other constraint formulas, there are no input variables.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-18.5.2.2-300"></a>
                     The <span class="emphasis"><em>output variables</em></span> of these constraints are all
                     inference variables mentioned by the type on the right-hand side of
                     the constraint, <span class="type">T</span>, that are not input variables.
                  </p>
               </div>
            </div>
            <div class="section" title="18.5.3.&nbsp;Functional Interface Parameterization Inference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.5.3"></a>18.5.3.&nbsp;Functional Interface Parameterization Inference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.5.3-100"></a>
                  Where a lambda expression with explicit parameter types <span class="type">P<sub>1</sub></span>, ...,
                  <span class="type">P<sub>n</sub></span> targets a functional interface type <span class="type">F</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ...,
                  <span class="type">A<sub>m</sub></span><code class="literal">&gt;</code> with at least one wildcard type argument, then a
                  parameterization of <span class="type">F</span> may be derived as the ground target type of
                  the lambda expression as follows.
               </p>
               <p class="norm-static"><a name="jls-18.5.3-200"></a>
                  Let <span class="type">Q<sub>1</sub></span>, ..., <span class="type">Q<sub>k</sub></span> be the parameter types of the function type of the
                  type <span class="type">F</span><code class="literal">&lt;</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span><code class="literal">&gt;</code>, where <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ...,
                  <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span> are fresh inference variables.
               </p>
               <p class="norm-static"><a name="jls-18.5.3-210"></a>
                  If <span class="emphasis"><em>n</em></span> <span class="symbol">&#8800;</span> <span class="emphasis"><em>k</em></span>, no valid parameterization exists. Otherwise, a
                  set of constraint formulas is formed with, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span>
                  <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">P<sub>i</sub></span> = <span class="type">Q<sub>i</sub></span>&#8250;. This constraint
                  formula set is reduced to form the bound set <span class="type">B</span>.
               </p>
               <p class="norm-static"><a name="jls-18.5.3-220"></a>
                  If <span class="type">B</span> contains the bound <span class="emphasis"><em>false</em></span>, no valid parameterization
                  exists. Otherwise, a new parameterization of the functional interface
                  type, <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code>, is constructed as
                  follows, for 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>m</em></span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.3-220-A"></a>
                                 If <span class="type">B</span> contains an instantiation (<a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>)
                                 for <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, <span class="type">T</span>, then <span class="type">A'<sub>i</sub></span> = <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.3-220-B"></a>
                                 Otherwise, <span class="type">A'<sub>i</sub></span> = <span class="type">A<sub>i</sub></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.5.3-230"></a>
                  If <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code> is not a well-formed
                  type (that is, the type arguments are not within their bounds), or if
                  <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code> is not a subtype of
                  <span class="type">F</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>m</sub></span><code class="literal">&gt;</code>, no valid parameterization
                  exists. Otherwise, the inferred parameterization is either
                  <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code>, if all the type
                  arguments are types, or the non-wildcard parameterization
                  (<a class="xref" href="jls-9.html#jls-9.9" title="9.9.&nbsp;Function Types">&sect;9.9</a>) of <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ...,
                  <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code>, if one or more type arguments are still
                  wildcards.
               </p>
               <p class="note">In order to determine the function type of a
                  wildcard-parameterized functional interface, we have to "instantiate"
                  the wildcard type arguments with specific types. The "default"
                  approach is to simply replace the wildcards with their bounds, as
                  described in <a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>, but this produces spurious
                  errors in cases where a lambda expression has explicit parameter types
                  that do <span class="emphasis"><em>not</em></span> correspond to the wildcard bounds.
                  For example:
               </p><pre class="screen">Predicate&lt;? super Integer&gt; p = (Number n) <code class="literal">-&gt;</code> n.equals(23);</pre><p class="note">The lambda expression is
                  a <code class="literal">Predicate&lt;Number&gt;</code>, which is a subtype
                  of <code class="literal">Predicate&lt;? super Integer&gt;</code> but
                  not <code class="literal">Predicate&lt;Integer&gt;</code>. The analysis in this
                  section is used to infer that <code class="literal">Number</code> is an
                  appropriate choice for the type argument
                  to <code class="literal">Predicate</code>.
               </p>
               <p class="note">That said, the analysis here, while described in
                  terms of general type inference, is intentionally quite simple.  The
                  only constraints are equality constraints, which means that reduction
                  amounts to simple pattern matching. A more powerful strategy might
                  also infer constraints from the body of the lambda expression. But,
                  given possible interactions with inference for surrounding and/or
                  nested generic method invocations, this would introduce a lot of extra
                  complexity.
               </p>
            </div>
            <div class="section" title="18.5.4.&nbsp;More Specific Method Inference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.5.4"></a>18.5.4.&nbsp;More Specific Method Inference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.5.4-100"></a>
                  When testing that one applicable method is <span class="emphasis"><em>more
                        specific</em></span> than another (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>),
                  where the second method is generic, it is necessary to test whether
                  some instantiation of the second method's type parameters can be
                  inferred to make the first method more specific than the
                  second.
               </p>
               <p class="norm-static"><a name="jls-18.5.4-200"></a>
                  Let <code class="varname">m<sub>1</sub></code> be the first method and <code class="varname">m<sub>2</sub></code> be the second method. Where <code class="varname">m<sub>2</sub></code>
                  has type parameters <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>, let <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>p</sub></span> be
                  inference variables, and let <span class="symbol">&#952;</span> be the substitution
                  <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>p</sub></span><code class="literal">]</code>.
               </p>
               <p class="norm-static"><a name="jls-18.5.4-210"></a>
                  Let <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>k</sub></code> be the argument expressions of the corresponding
                  invocation. Then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-210-A"></a>
                                 If <code class="varname">m<sub>1</sub></code> and <code class="varname">m<sub>2</sub></code> are applicable by strict or loose invocation
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>,
                                 <a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">&sect;15.12.2.3</a>), then let <span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>k</sub></span> be
                                 the formal parameter types of <code class="varname">m<sub>1</sub></code>, and let <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>k</sub></span> be
                                 the result of <span class="symbol">&#952;</span> applied to the formal parameter types of
                                 <code class="varname">m<sub>2</sub></code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-210-B"></a>
                                 If <code class="varname">m<sub>1</sub></code> and <code class="varname">m<sub>2</sub></code> are applicable by variable arity invocation
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>), then let <span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>k</sub></span> be
                                 the first <span class="emphasis"><em>k</em></span> variable arity parameter types of <code class="varname">m<sub>1</sub></code>, and let
                                 <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>k</sub></span> be the result of <span class="symbol">&#952;</span> applied to the first
                                 <span class="emphasis"><em>k</em></span> variable arity parameter types of <code class="varname">m<sub>2</sub></code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">Note that no substitution is applied to <span class="type">S<sub>1</sub></span>, ...,
                  <span class="type">S<sub>k</sub></span>; even if <code class="varname">m<sub>1</sub></code> is generic, the type parameters of <code class="varname">m<sub>1</sub></code> are treated
                  as type variables, not inference variables.
               </p>
               <p class="norm-static"><a name="jls-18.5.4-300"></a>
                  The process to determine if <code class="varname">m<sub>1</sub></code> is more specific than <code class="varname">m<sub>2</sub></code> is as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-300-A"></a>
                                 First, an initial bound set, <span class="type">B</span>, is generated from the declared
                                 bounds of <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>, as specified in <a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-300-B"></a>
                                 Second, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>), a set of
                                 constraint formulas or bounds is generated.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-B.1"></a>
                                 If <span class="type">T<sub>i</sub></span> is a proper type, the result is <span class="emphasis"><em>true</em></span> if <span class="type">S<sub>i</sub></span> is
                                 more specific than <span class="type">T<sub>i</sub></span> for <code class="varname">e<sub>i</sub></code>
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>), and <span class="emphasis"><em>false</em></span>
                                 otherwise. (Note that <span class="type">S<sub>i</sub></span> is always a proper type.)
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-B.2"></a>
                                 Otherwise, if <span class="type">S<sub>i</sub></span> and <span class="type">T<sub>i</sub></span> are not both functional interface
                                 types, the constraint formula &#8249;<span class="type">S<sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">T<sub>i</sub></span>&#8250;
                                 is generated.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-B.3"></a>
                                 Otherwise, if the interface of <span class="type">S<sub>i</sub></span> is a superinterface or a
                                 subinterface of the interface of <span class="type">T<sub>i</sub></span> (or, where <span class="type">S<sub>i</sub></span> or <span class="type">T<sub>i</sub></span> is
                                 an intersection type, some interface of <span class="type">S<sub>i</sub></span> is a superinterface
                                 or a subinterface of some interface of <span class="type">T<sub>i</sub></span>), the constraint
                                 formula &#8249;<span class="type">S<sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">T<sub>i</sub></span>&#8250; is generated.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-B.4"></a>
                                 Otherwise, let <span class="type">MT<sub>S</sub></span> be the function type of the capture of
                                 <span class="type">S<sub>i</sub></span>, let <span class="type">MT<sub>S</sub></span>' be the function type of <span class="type">S<sub>i</sub></span> (without capture),
                                 and let <span class="type">MT<sub>T</sub></span> be the function type of <span class="type">T<sub>i</sub></span>. If <span class="type">MT<sub>S</sub></span> and <span class="type">MT<sub>T</sub></span>
                                 have a different number of formal parameters or type parameters,
                                 or if <span class="type">MT<sub>S</sub></span> and <span class="type">MT<sub>S</sub></span>' do not have the same type parameters
                                 (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>), the result is
                                 <span class="emphasis"><em>false</em></span>. Otherwise, the following constraint formulas or
                                 bounds are generated from the type parameters, formal parameter
                                 types, and return types of <span class="type">MT<sub>S</sub></span> and <span class="type">MT<sub>T</sub></span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.4-A"></a>
                                    	  Let <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span> be the type parameters of <span class="type">MT<sub>S</sub></span>, and let
                                    	  <span class="type">B<sub>1</sub></span>, ..., <span class="type">B<sub>n</sub></span> be the type parameters of <span class="type">MT<sub>T</sub></span>.
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.4-A.1"></a>
                                    	  Let <span class="symbol">&#952;</span>' be the substitution <code class="literal">[</code><span class="type">B<sub>1</sub></span>:=<span class="type">A<sub>1</sub></span>, ...,
                                    	  <span class="type">B<sub>n</sub></span>:=<span class="type">A<sub>n</sub></span><code class="literal">]</code>. Then, for all <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span>
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>):
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-A.1-A"></a>
                                             	      If the bound of <span class="type">A<sub>j</sub></span> mentions one of <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span>, 
                                             	      and the bound of <span class="type">B<sub>j</sub></span> is a not proper type, <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-A.1-B"></a>
                                             	      Otherwise, where <span class="type">X</span> is the bound of <span class="type">A<sub>j</sub></span> and <span class="type">Y</span> is the
                                             	      bound of <span class="type">B<sub>j</sub></span>, &#8249;<span class="type">X</span> = <span class="type">Y</span> <span class="symbol">&#952;</span>'&#8250;.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                                 <p class="note">If the bound <span class="type">A<sub>j</sub></span> mentions one of <span class="type">A<sub>1</sub></span>, ...,
                                    	  <span class="type">A<sub>n</sub></span>, and the bound of <span class="type">B<sub>j</sub></span> is not a proper type, then
                                    	  producing an equality constraint would raise the possibility
                                    	  of an inference variable being bounded by an out-of-scope
                                    	  type variable. Since instantiating an inference variable
                                    	  with an out-of-scope type variable is nonsensical, we prefer
                                    	  to avoid the situation by giving up immediately whenever the
                                    	  possibility arises. This simplification is not
                                    	  completeness-preserving. (The same comment applies to the
                                    	  treatment of formal parameter types and return types below.)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.4-B"></a>
                                    	  Let <span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span> be the formal parameter types of <span class="type">MT<sub>S</sub></span>,
                                    	  and let <span class="type">V<sub>1</sub></span>, ..., <span class="type">V<sub>k</sub></span> be the formal parameter types of <span class="type">MT<sub>T</sub></span>.
                                    	  Then, for all <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>):
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-B-A"></a>
                                             	      If <span class="type">U<sub>j</sub></span> mentions one of <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span>,
                                             	      and <span class="type">V<sub>j</sub></span> is not a proper type,
                                             	      <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-B-B"></a>
                                             	      Otherwise,
                                             	      &#8249;<span class="type">V<sub>j</sub></span> <span class="symbol">&#952;</span>' <code class="literal">&lt;:</code> <span class="type">U<sub>j</sub></span>&#8250;, and,
                                             	      where <span class="type">U<sub>1</sub></span>', ..., <span class="type">U<sub>k</sub></span>' are the formal parameter types of <span class="type">MT<sub>S</sub></span>',
                                             	      and <span class="type">A<sub>1</sub></span>', ..., <span class="type">A<sub>n</sub></span>' are the type parameters of <span class="type">MT<sub>S</sub></span>',
                                             	      &#8249;<span class="type">V<sub>j</sub></span><code class="literal">[</code><span class="type">B<sub>1</sub></span>:=<span class="type">A<sub>1</sub></span>', ..., <span class="type">B<sub>n</sub></span>:=<span class="type">A<sub>n</sub></span>'<code class="literal">]</code> = <span class="type">U<sub>j</sub></span>'&#8250;
                                             	    
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.4-C"></a>
                                    	  Let <span class="type">R<sub>S</sub></span> be the return type of <span class="type">MT<sub>S</sub></span>, and let <span class="type">R<sub>T</sub></span> be the
                                    	  return type of <span class="type">MT<sub>T</sub></span>. Then:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-A"></a>
                                             	      If <span class="type">R<sub>S</sub></span> mentions one of <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span>, and <span class="type">R<sub>T</sub></span> is not
                                             	      a proper type, <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-B"></a>
                                             	      Otherwise, if <code class="varname">e<sub>i</sub></code> is an explicitly typed lambda expression:
                                          </p>
                                          <div class="norm">
                                             <ul class="norm" type="disc">
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-B-A"></a>
                                                      		  If <span class="type">R<sub>T</sub></span> is <code class="literal">void</code>, <span class="emphasis"><em>true</em></span>.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-B-B"></a>
                                                      		  
                                                      		  Otherwise, if <span class="type">R<sub>S</sub></span> and <span class="type">R<sub>T</sub></span> are functional interface
                                                      		  types, and <code class="varname">e<sub>i</sub></code> has at least one result expression,
                                                      		  then for each result expression in <code class="varname">e<sub>i</sub></code>, this entire
                                                      		  second step is repeated to infer constraints under
                                                      		  which <span class="type">R<sub>S</sub></span> is more specific than <span class="type">R<sub>T</sub></span> <span class="symbol">&#952;</span>' for
                                                      		  the given result expression.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-B-C"></a>
                                                      		  
                                                      		  Otherwise, if <span class="type">R<sub>S</sub></span> is a primitive type and <span class="type">R<sub>T</sub></span> is not,
                                                      		  and <code class="varname">e<sub>i</sub></code> has at least one result expression,
                                                      		  and each result expression of <code class="varname">e<sub>i</sub></code> is a standalone
                                                      		  expression (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>) of a primitive
                                                      		  type, <span class="emphasis"><em>true</em></span>.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-B-D"></a>
                                                      		  
                                                      		  Otherwise, if <span class="type">R<sub>T</sub></span> is a primitive type and <span class="type">R<sub>S</sub></span> is not,
                                                      		  and <code class="varname">e<sub>i</sub></code> has at least one result expression,
                                                      		  and each result expression of <code class="varname">e<sub>i</sub></code> is either a
                                                      		  standalone expression of a reference type or a poly
                                                      		  expression, <span class="emphasis"><em>true</em></span>.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-B-E"></a>
                                                      		  Otherwise, &#8249;<span class="type">R<sub>S</sub></span> <code class="literal">&lt;:</code> <span class="type">R<sub>T</sub></span> <span class="symbol">&#952;</span>'&#8250;.
                                                   </p>
                                                </li>
                                             </ul>
                                          </div>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-C"></a>
                                             	      Otherwise, if <code class="varname">e<sub>i</sub></code> is an exact method reference:
                                          </p>
                                          <div class="norm">
                                             <ul class="norm" type="disc">
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-C-A"></a>
                                                      		  If <span class="type">R<sub>T</sub></span> is <code class="literal">void</code>, <span class="emphasis"><em>true</em></span>.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-C-B"></a>
                                                      		  Otherwise, if <span class="type">R<sub>S</sub></span> is a primitive type and <span class="type">R<sub>T</sub></span> is not,
                                                      		  and the compile-time declaration for <code class="varname">e<sub>i</sub></code> has a
                                                      		  primitive return type, <span class="emphasis"><em>true</em></span>.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-C-C"></a>
                                                      		  Otherwise if <span class="type">R<sub>T</sub></span> is a primitive type and <span class="type">R<sub>S</sub></span> is not,
                                                      		  and the compile-time declaration for <code class="varname">e<sub>i</sub></code> has a
                                                      		  reference return type, <span class="emphasis"><em>true</em></span>.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-C-D"></a>
                                                      		  Otherwise, &#8249;<span class="type">R<sub>S</sub></span> <code class="literal">&lt;:</code> <span class="type">R<sub>T</sub></span> <span class="symbol">&#952;</span>'&#8250;.
                                                   </p>
                                                </li>
                                             </ul>
                                          </div>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-D"></a>
                                             	      Otherwise, if <code class="varname">e<sub>i</sub></code> is a parenthesized expression, these
                                             	      rules for constraints derived from <span class="type">R<sub>S</sub></span> and <span class="type">R<sub>T</sub></span> are
                                             	      applied recursively for the contained expression.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-E"></a>
                                             	      Otherwise, if <code class="varname">e<sub>i</sub></code> is a conditional expression, these
                                             	      rules for constraints derived from <span class="type">R<sub>S</sub></span> and <span class="type">R<sub>T</sub></span> are
                                             	      applied recursively for each of the second and third operands.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-C-F"></a>
                                             	      Otherwise, <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-300-C"></a>
                                 Third, if <code class="varname">m<sub>2</sub></code> is applicable by variable arity invocation and
                                 has <span class="emphasis"><em>k</em></span>+1 parameters, then where <span class="type">S<sub>k+1</sub></span> is the <span class="emphasis"><em>k</em></span>+1'th
                                 variable arity parameter type of <code class="varname">m<sub>1</sub></code> and <span class="type">T<sub>k+1</sub></span> is the
                                 result of <span class="symbol">&#952;</span> applied to the <span class="emphasis"><em>k</em></span>+1'th variable arity
                                 parameter type of <code class="varname">m<sub>2</sub></code>, the constraint &#8249;<span class="type">S<sub>k+1</sub></span>
                                 <code class="literal">&lt;:</code> <span class="type">T<sub>k+1</sub></span>&#8250; is generated.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-300-D"></a>
                                 Fourth, the generated bounds and constraint formulas are reduced
                                 and incorporated with <span class="type">B</span> to produce a bound set
                                 <span class="type">B'</span>.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-D.1"></a>
                                 If <span class="type">B'</span> does not contain the bound <span class="emphasis"><em>false</em></span>, and
                                 resolution of all the inference variables in <span class="type">B'</span> succeeds,
                                 then <code class="varname">m<sub>1</sub></code> is more specific than <code class="varname">m<sub>2</sub></code>.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-D.2"></a>
                                 Otherwise, <code class="varname">m<sub>1</sub></code> is not more specific than <code class="varname">m<sub>2</sub></code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-17.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-19.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;17.&nbsp;Threads and Locks&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;19.&nbsp;Syntax</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>