
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;8.&nbsp;Classes</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-7.html" title="Chapter&nbsp;7.&nbsp;Packages and Modules">
      <link rel="next" href="jls-9.html" title="Chapter&nbsp;9.&nbsp;Interfaces">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="../../../../webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="../../../../9/">Java SE</a> &gt; <a href="../../../index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;8.&nbsp;Classes</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-7.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-9.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;8.&nbsp;Classes">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-8"></a>Chapter&nbsp;8.&nbsp;Classes
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-8.html#jls-8.1">8.1. Class Declarations</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-8.html#jls-8.1.1">8.1.1. Class Modifiers</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-8.html#jls-8.1.1.1">8.1.1.1. <code class="literal">abstract</code> Classes</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.1.1.2">8.1.1.2. <code class="literal">final</code> Classes</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.1.1.3">8.1.1.3. <code class="literal">strictfp</code> Classes</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-8.html#jls-8.1.2">8.1.2. Generic Classes and Type Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.1.3">8.1.3. Inner Classes and Enclosing Instances</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.1.4">8.1.4. Superclasses and Subclasses</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.1.5">8.1.5. Superinterfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.1.6">8.1.6. Class Body and Member Declarations</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-8.html#jls-8.2">8.2. Class Members</a></span></dt>
               <dt><span class="section"><a href="jls-8.html#jls-8.3">8.3. Field Declarations</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-8.html#jls-8.3.1">8.3.1. Field Modifiers</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-8.html#jls-8.3.1.1">8.3.1.1. <code class="literal">static</code> Fields</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.3.1.2">8.3.1.2. <code class="literal">final</code> Fields</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.3.1.3">8.3.1.3. <code class="literal">transient</code> Fields</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.3.1.4">8.3.1.4. <code class="literal">volatile</code> Fields</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-8.html#jls-8.3.2">8.3.2. Field Initialization</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.3.3">8.3.3. Restrictions on Field References in Initializers</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-8.html#jls-8.4">8.4. Method Declarations</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-8.html#jls-8.4.1">8.4.1. Formal Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.4.2">8.4.2. Method Signature</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.4.3">8.4.3. Method Modifiers</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.3.1">8.4.3.1. <code class="literal">abstract</code> Methods</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.3.2">8.4.3.2. <code class="literal">static</code> Methods</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.3.3">8.4.3.3. <code class="literal">final</code> Methods</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.3.4">8.4.3.4. <code class="literal">native</code> Methods</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.3.5">8.4.3.5. <code class="literal">strictfp</code> Methods</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.3.6">8.4.3.6. <code class="literal">synchronized</code> Methods</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-8.html#jls-8.4.4">8.4.4. Generic Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.4.5">8.4.5. Method Result</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.4.6">8.4.6. Method Throws</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.4.7">8.4.7. Method Body</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.4.8">8.4.8. Inheritance, Overriding, and Hiding</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.8.1">8.4.8.1. Overriding (by Instance Methods)</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.8.2">8.4.8.2. Hiding (by Class Methods)</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.8.3">8.4.8.3. Requirements in Overriding and Hiding</a></span></dt>
                           <dt><span class="section"><a href="jls-8.html#jls-8.4.8.4">8.4.8.4. Inheriting Methods with Override-Equivalent Signatures</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-8.html#jls-8.4.9">8.4.9. Overloading</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-8.html#jls-8.5">8.5. Member Type Declarations</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-8.html#jls-8.5.1">8.5.1. Static Member Type Declarations</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-8.html#jls-8.6">8.6. Instance Initializers</a></span></dt>
               <dt><span class="section"><a href="jls-8.html#jls-8.7">8.7. Static Initializers</a></span></dt>
               <dt><span class="section"><a href="jls-8.html#jls-8.8">8.8. Constructor Declarations</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.1">8.8.1. Formal Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.2">8.8.2. Constructor Signature</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.3">8.8.3. Constructor Modifiers</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.4">8.8.4. Generic Constructors</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.5">8.8.5. Constructor Throws</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.6">8.8.6. The Type of a Constructor</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.7">8.8.7. Constructor Body</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-8.html#jls-8.8.7.1">8.8.7.1. Explicit Constructor Invocations</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.8">8.8.8. Constructor Overloading</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.9">8.8.9. Default Constructor</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.8.10">8.8.10. Preventing Instantiation of a Class</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-8.html#jls-8.9">8.9. Enum Types</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-8.html#jls-8.9.1">8.9.1. Enum Constants</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.9.2">8.9.2. Enum Body Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-8.html#jls-8.9.3">8.9.3. Enum Members</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <p class="norm"><a name="jls-8-100"></a>Class declarations define new
            reference types and describe how they are implemented
            (<a class="xref" href="jls-8.html#jls-8.1" title="8.1.&nbsp;Class Declarations">&sect;8.1</a>).
         </p>
         <p class="norm"><a name="jls-8-110"></a>A <span class="emphasis"><em>top level
                  class</em></span> is a class that is not a nested class.
         </p>
         <p class="norm"><a name="jls-8-120"></a>A <span class="emphasis"><em>nested
                  class</em></span> is any class whose declaration occurs within the body
            of another class or interface.
         </p>
         <p class="norm"><a name="jls-8-130"></a>This chapter discusses the common
            semantics of all classes - top level (<a class="xref" href="jls-7.html#jls-7.6" title="7.6.&nbsp;Top Level Type Declarations">&sect;7.6</a>) and
            nested (including member classes (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>,
            <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>), local classes (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class Declarations">&sect;14.3</a>)
            and anonymous classes (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>)). Details that
            are specific to particular kinds of classes are discussed in the
            sections dedicated to these constructs.
         </p>
         <p class="norm"><a name="jls-8-200"></a>
            A named class may be declared <code class="literal">abstract</code> (<a class="xref" href="jls-8.html#jls-8.1.1.1" title="8.1.1.1.&nbsp;abstract Classes">&sect;8.1.1.1</a>) 
            and must be declared abstract if it is incompletely implemented; such
            a class cannot be instantiated, but can be extended by subclasses. A
            class may be declared <code class="literal">final</code> (<a class="xref" href="jls-8.html#jls-8.1.1.2" title="8.1.1.2.&nbsp;final Classes">&sect;8.1.1.2</a>), in
            which case it cannot have subclasses. If a class is declared <code class="literal">public</code>,
            then it can be referred to from code in  any package of its
            module and potentially from code in other modules. Each
            class except <code class="literal">Object</code> is an extension of (that is, a subclass of) a
            single existing class (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>) and may implement
            interfaces (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>). Classes may
            be <span class="emphasis"><em>generic</em></span> (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>), that
            is, they may declare type variables whose bindings may differ among
            different instances of the class.
         </p>
         <p class="norm"><a name="jls-8-210"></a>Classes may be decorated with
            annotations (<a class="xref" href="jls-9.html#jls-9.7" title="9.7.&nbsp;Annotations">&sect;9.7</a>) just like any other kind of
            declaration.
         </p>
         <p class="norm"><a name="jls-8-300"></a>The body of a class declares
            members (fields and methods and nested classes and interfaces),
            instance and static initializers, and constructors
            (<a class="xref" href="jls-8.html#jls-8.1.6" title="8.1.6.&nbsp;Class Body and Member Declarations">&sect;8.1.6</a>). The scope (<a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a>)
            of a member (<a class="xref" href="jls-8.html#jls-8.2" title="8.2.&nbsp;Class Members">&sect;8.2</a>) is the entire body of the
            declaration of the class to which the member belongs. Field, method,
            member class, member interface, and constructor declarations may
            include the access modifiers (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) <code class="literal">public</code>,
            <code class="literal">protected</code>, or <code class="literal">private</code>. The members of a class include both
            declared and inherited members (<a class="xref" href="jls-8.html#jls-8.2" title="8.2.&nbsp;Class Members">&sect;8.2</a>). Newly
            declared fields can hide fields declared in a superclass or
            superinterface. Newly declared class members and interface members can
            hide class or interface members declared in a superclass or
            superinterface. Newly declared methods can hide, implement, or
            override methods declared in a superclass or superinterface.
         </p>
         <p class="norm"><a name="jls-8-310"></a>Field declarations
            (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>) describe class variables, which are
            incarnated once, and instance variables, which are freshly incarnated
            for each instance of the class. A field may be declared <code class="literal">final</code>
            (<a class="xref" href="jls-8.html#jls-8.3.1.2" title="8.3.1.2.&nbsp;final Fields">&sect;8.3.1.2</a>), in which case it can be assigned to
            only once. Any field declaration may include an initializer.
         </p>
         <p class="norm"><a name="jls-8-320"></a>Member class declarations
            (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>) describe nested classes that are members
            of the surrounding class. Member classes may be <code class="literal">static</code>, in which
            case they have no access to the instance variables of the surrounding
            class; or they may be inner classes
            (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>).
         </p>
         <p class="norm"><a name="jls-8-330"></a>Member interface declarations
            (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>) describe nested interfaces that are
            members of the surrounding class.
         </p>
         <p class="norm"><a name="jls-8-340"></a>Method declarations
            (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>) describe code that may be invoked by
            method invocation expressions (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>). A class
            method is invoked relative to the class type; an instance method is
            invoked with respect to some particular object that is an instance of
            a class type. A method whose declaration does not indicate how it is
            implemented must be declared <code class="literal">abstract</code>. A method may be declared
            <code class="literal">final</code> (<a class="xref" href="jls-8.html#jls-8.4.3.3" title="8.4.3.3.&nbsp;final Methods">&sect;8.4.3.3</a>), in which case it cannot be
            hidden or overridden. A method may be implemented by
            platform-dependent <code class="literal">native</code> code (<a class="xref" href="jls-8.html#jls-8.4.3.4" title="8.4.3.4.&nbsp;native Methods">&sect;8.4.3.4</a>). A
            <code class="literal">synchronized</code> method (<a class="xref" href="jls-8.html#jls-8.4.3.6" title="8.4.3.6.&nbsp;synchronized Methods">&sect;8.4.3.6</a>) automatically
            locks an object before executing its body and automatically unlocks
            the object on return, as if by use of a <code class="literal">synchronized</code> statement
            (<a class="xref" href="jls-14.html#jls-14.19" title="14.19.&nbsp;The synchronized Statement">&sect;14.19</a>), thus allowing its activities to be
            synchronized with those of other threads
            (<a class="xref" href="jls-17.html" title="Chapter&nbsp;17.&nbsp;Threads and Locks">&sect;17 (<i>Threads and Locks</i>)</a>).
         </p>
         <p class="norm"><a name="jls-8-350"></a>Method names may be overloaded
            (<a class="xref" href="jls-8.html#jls-8.4.9" title="8.4.9.&nbsp;Overloading">&sect;8.4.9</a>).
         </p>
         <p class="norm"><a name="jls-8-400"></a>Instance initializers
            (<a class="xref" href="jls-8.html#jls-8.6" title="8.6.&nbsp;Instance Initializers">&sect;8.6</a>) are blocks of executable code that may be
            used to help initialize an instance when it is created
            (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>).
         </p>
         <p class="norm"><a name="jls-8-410"></a>Static initializers
            (<a class="xref" href="jls-8.html#jls-8.7" title="8.7.&nbsp;Static Initializers">&sect;8.7</a>) are blocks of executable code that may be
            used to help initialize a class.
         </p>
         <p class="norm"><a name="jls-8-420"></a>Constructors
            (<a class="xref" href="jls-8.html#jls-8.8" title="8.8.&nbsp;Constructor Declarations">&sect;8.8</a>) are similar to methods, but cannot be
            invoked directly by a method call; they are used to initialize new
            class instances. Like methods, they may be overloaded
            (<a class="xref" href="jls-8.html#jls-8.8.8" title="8.8.8.&nbsp;Constructor Overloading">&sect;8.8.8</a>).
         </p>
         <div class="section" title="8.1.&nbsp;Class Declarations">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-8.1"></a>8.1.&nbsp;Class Declarations
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-8.1-100"></a>A class
               declaration specifies a new named reference type.
            </p>
            <p class="norm-static"><a name="jls-8.1-110"></a>There are
               two kinds of class declarations: <span class="emphasis"><em>normal class
                     declarations</em></span> and <span class="emphasis"><em>enum
                     declarations</em></span>.
            </p>
            <div id="jls-8.1-120" class="productionset"><a name="jls-8.1-120"></a>
                 
               <div class="production"><a name="jls-ClassDeclaration"></a>
                      
                  <div class="lhs">ClassDeclaration:</div>
                      
                  <div class="rhs">
                           <a href="jls-8.html#jls-NormalClassDeclaration" title="NormalClassDeclaration">NormalClassDeclaration</a> <br>
                           <a href="jls-8.html#jls-EnumDeclaration" title="EnumDeclaration">EnumDeclaration</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-NormalClassDeclaration"></a>
                      
                  <div class="lhs">NormalClassDeclaration:</div>
                      
                  <div class="rhs">
                           {<a href="jls-8.html#jls-ClassModifier" title="ClassModifier">ClassModifier</a>}
                           <code class="literal">class</code> <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           [<a href="jls-8.html#jls-TypeParameters" title="TypeParameters">TypeParameters</a>]
                           
                           [<a href="jls-8.html#jls-Superclass" title="Superclass">Superclass</a>]
                           [<a href="jls-8.html#jls-Superinterfaces" title="Superinterfaces">Superinterfaces</a>]
                           <a href="jls-8.html#jls-ClassBody" title="ClassBody">ClassBody</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm"><a name="jls-8.1-130"></a>The rules in this section apply
               to all class declarations, including enum declarations. However,
               special rules apply to enum declarations with regard to class
               modifiers, inner classes, and superclasses; these rules are stated in
               <a class="xref" href="jls-8.html#jls-8.9" title="8.9.&nbsp;Enum Types">&sect;8.9</a>.
            </p>
            <p class="norm-static"><a name="jls-8.1-200"></a>The
               <span class="emphasis"><em>Identifier</em></span> in a class declaration specifies the name of the
               class.
            </p>
            <p class="norm-error"><a name="jls-8.1-210"></a>It is a
               compile-time error if a class has the same simple name as any of its
               enclosing classes or interfaces.
            </p>
            <p class="norm-static"><a name="jls-8.1-300"></a>The scope and shadowing of a class
               declaration is specified in <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and
               <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
            </p>
            <div class="section" title="8.1.1.&nbsp;Class Modifiers">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.1.1"></a>8.1.1.&nbsp;Class Modifiers
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-8.1.1-100"></a>
                  A class declaration may include <span class="emphasis"><em>class modifiers</em></span>.
               </p>
               <div id="jls-8.1.1-110" class="productionset"><a name="jls-8.1.1-110"></a>
                    
                  <div class="production"><a name="jls-ClassModifier"></a>
                         
                     <div class="lhs">ClassModifier:</div>
                         
                     <div class="rhs">
                              (one of) <br>
                              <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <code class="literal">public</code> <code class="literal">protected</code> <code class="literal">private</code> <br>
                              <code class="literal">abstract</code> <code class="literal">static</code> <code class="literal">final</code> <code class="literal">strictfp</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.1.1-120"></a>
                  The rules for annotation modifiers on a class declaration are
                  specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Type">&sect;9.7.5</a>.
               </p>
               <p class="norm-static"><a name="jls-8.1.1-200"></a>
                  The access modifier <code class="literal">public</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) pertains only
                  to top level classes (<a class="xref" href="jls-7.html#jls-7.6" title="7.6.&nbsp;Top Level Type Declarations">&sect;7.6</a>) and member classes
                  (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>), not to local classes
                  (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class Declarations">&sect;14.3</a>) or anonymous classes
                  (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>).
               </p>
               <p class="norm-static"><a name="jls-8.1.1-210"></a>
                  The access modifiers <code class="literal">protected</code> and <code class="literal">private</code> pertain only to member
                  classes within a directly enclosing class declaration
                  (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>).
               </p>
               <p class="norm-static"><a name="jls-8.1.1-220"></a>
                  The modifier <code class="literal">static</code> pertains only to member classes
                  (<a class="xref" href="jls-8.html#jls-8.5.1" title="8.5.1.&nbsp;Static Member Type Declarations">&sect;8.5.1</a>), not to top level or local or anonymous
                  classes.
               </p>
               <p class="norm-error"><a name="jls-8.1.1-300"></a>
                  It is a compile-time error if the same keyword appears more than once
                  as a modifier for a class declaration, or if a class declaration has
                  more than one of the access modifiers <code class="literal">public</code>, <code class="literal">protected</code>, and
                  <code class="literal">private</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>).
               </p>
               <p class="note">If two or more (distinct) class modifiers appear in
                  a class declaration, then it is customary, though not required, that
                  they appear in the order consistent with that shown above in the
                  production for <span class="emphasis"><em>ClassModifier</em></span>.
               </p>
               <div class="section" title="8.1.1.1.&nbsp;abstract Classes">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.1.1.1"></a>8.1.1.1.&nbsp;<code class="literal">abstract</code> Classes
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-8.1.1.1-100"></a>An <code class="literal">abstract</code> class is a
                     class that is incomplete, or to be considered incomplete.
                  </p>
                  <p class="norm"><a name="jls-8.1.1.1-110"></a>It is a compile-time error
                     if an attempt is made to create an instance of an <code class="literal">abstract</code> class
                     using a class instance creation expression
                     (<a class="xref" href="jls-15.html#jls-15.9.1" title="15.9.1.&nbsp;Determining the Class being Instantiated">&sect;15.9.1</a>).
                  </p>
                  <p class="norm-dynamic"><a name="jls-8.1.1.1-120"></a>A
                     subclass of an <code class="literal">abstract</code> class that is not itself <code class="literal">abstract</code> may be
                     instantiated, resulting in the execution of a constructor for the
                     <code class="literal">abstract</code> class and, therefore, the execution of the field
                     initializers for instance variables of that class.
                  </p>
                  <p class="norm-error"><a name="jls-8.1.1.1-200"></a>A normal
                     class may have <code class="literal">abstract</code> methods, that is, methods that are declared
                     but not yet implemented (<a class="xref" href="jls-8.html#jls-8.4.3.1" title="8.4.3.1.&nbsp;abstract Methods">&sect;8.4.3.1</a>), only if it is
                     an <code class="literal">abstract</code> class. It is a compile-time error if a normal class that
                     is not <code class="literal">abstract</code> has an <code class="literal">abstract</code> method.
                  </p>
                  <p class="norm"><a name="jls-8.1.1.1-210"></a>A class <span class="type">C</span> has <code class="literal">abstract</code> methods if
                     either of the following is true:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.1.1.1-210-A"></a>
                                    Any of the member methods (<a class="xref" href="jls-8.html#jls-8.2" title="8.2.&nbsp;Class Members">&sect;8.2</a>) of <span class="type">C</span> -
                                    either declared or inherited - is <code class="literal">abstract</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.1.1.1-210-B"></a>
                                    Any of <span class="type">C</span>'s superclasses has an <code class="literal">abstract</code> method declared with
                                    package access, and there exists no method that overrides the
                                    <code class="literal">abstract</code> method from <span class="type">C</span> or from a superclass of <span class="type">C</span>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-error"><a name="jls-8.1.1.1-400"></a>It is a
                     compile-time error to declare an <code class="literal">abstract</code> class type such that it is
                     not possible to create a subclass that implements all of its
                     <code class="literal">abstract</code> methods. This situation can occur if the class would have
                     as members two <code class="literal">abstract</code> methods that have the same method signature
                     (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) but return types for which no type is
                     return-type-substitutable with both
                     (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>).
                  </p>
                  <div class="example"><a name="d5e11360"></a><p class="title"><b>Example&nbsp;8.1.1.1-1.&nbsp;Abstract Class Declaration</b></p>
                     <div class="example-contents"><pre class="programlisting">
abstract class Point {
    int x = 1, y = 1;
    void move(int dx, int dy) {
        x += dx;
        y += dy;
        alert();
    }
    abstract void alert();
}
abstract class ColoredPoint extends Point {
    int color;
}
class SimplePoint extends Point {
    void alert() { }
}
</pre><p class="note">Here, a class <code class="literal">Point</code> is declared
                           that must be declared <code class="literal">abstract</code>, because it contains a declaration of
                           an <code class="literal">abstract</code> method named <code class="literal">alert</code>. The subclass
                           of <code class="literal">Point</code> named <code class="literal">ColoredPoint</code>
                           inherits the <code class="literal">abstract</code> method <code class="literal">alert</code>, so it must
                           also be declared <code class="literal">abstract</code>. On the other hand, the subclass
                           of <code class="literal">Point</code> named <code class="literal">SimplePoint</code>
                           provides an implementation of <code class="literal">alert</code>, so it need not
                           be <code class="literal">abstract</code>.
                        </p>
                        <p class="note">The statement:</p><pre class="screen">
Point p = new Point();
</pre><p class="note">would result in a compile-time error; the
                           class <code class="literal">Point</code> cannot be instantiated because it is
                           <code class="literal">abstract</code>. However, a <code class="literal">Point</code> variable could
                           correctly be initialized with a reference to any subclass
                           of <code class="literal">Point</code>, and the
                           class <code class="literal">SimplePoint</code> is not <code class="literal">abstract</code>, so the
                           statement:
                        </p><pre class="screen">
Point p = new SimplePoint();
</pre><p class="note">would be correct. Instantiation of
                           a <code class="literal">SimplePoint</code> causes the default constructor and
                           field initializers for <code class="literal">x</code> and <code class="literal">y</code>
                           of <code class="literal">Point</code> to be executed.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e11392"></a><p class="title"><b>Example&nbsp;8.1.1.1-2.&nbsp;Abstract Class Declaration that Prohibits Subclasses</b></p>
                     <div class="example-contents"><pre class="programlisting">
interface Colorable {
    void setColor(int color);
}
abstract class Colored implements Colorable {
    public abstract int setColor(int color);
}
</pre><p class="note">These declarations result in a compile-time error:
                           it would be impossible for any subclass of
                           class <code class="literal">Colored</code> to provide an implementation of a
                           method named <code class="literal">setColor</code>, taking one argument of type
                           <code class="literal">int</code>, that can satisfy both abstract method specifications, because
                           the one in interface <code class="literal">Colorable</code> requires the same
                           method to return no value, while the one in
                           class <code class="literal">Colored</code> requires the same method to return a
                           value of type <code class="literal">int</code> (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>).
                        </p>
                     </div>
                  </div><br class="example-break"><p class="note">A class type should be declared <code class="literal">abstract</code> only if
                     the intent is that subclasses can be created to complete the
                     implementation. If the intent is simply to prevent instantiation of a
                     class, the proper way to express this is to declare a constructor
                     (<a class="xref" href="jls-8.html#jls-8.8.10" title="8.8.10.&nbsp;Preventing Instantiation of a Class">&sect;8.8.10</a>) of no arguments, make it <code class="literal">private</code>,
                     never invoke it, and declare no other constructors. A class of this
                     form usually contains class methods and variables.
                  </p>
                  <div class="informalexample">
                     <p class="note">The class <code class="literal">Math</code> is an example of a
                        class that cannot be instantiated; its declaration looks like
                        this:
                     </p><pre class="programlisting">

public final class Math {
    private Math() { }  // never instantiate this class
    . . . declarations of class variables and methods . . .
}

</pre></div>
               </div>
               <div class="section" title="8.1.1.2.&nbsp;final Classes">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.1.1.2"></a>8.1.1.2.&nbsp;<code class="literal">final</code> Classes
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-8.1.1.2-100"></a>A class can be declared
                     <code class="literal">final</code> if its definition is complete and no subclasses are desired or
                     required.
                  </p>
                  <p class="norm-error"><a name="jls-8.1.1.2-200"></a>It is a
                     compile-time error if the name of a <code class="literal">final</code> class appears in the
                     <code class="literal">extends</code> clause (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>) of another class
                     declaration; this implies that a <code class="literal">final</code> class cannot have any
                     subclasses.
                  </p>
                  <p class="norm-error"><a name="jls-8.1.1.2-210"></a>It is a
                     compile-time error if a class is declared both <code class="literal">final</code> and <code class="literal">abstract</code>,
                     because the implementation of such a class could never be completed
                     (<a class="xref" href="jls-8.html#jls-8.1.1.1" title="8.1.1.1.&nbsp;abstract Classes">&sect;8.1.1.1</a>).
                  </p>
                  <p class="norm-static"><a name="jls-8.1.1.2-300"></a>Because
                     a <code class="literal">final</code> class never has any subclasses, the methods of a <code class="literal">final</code>
                     class are never overridden (<a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a>).
                  </p>
               </div>
               <div class="section" title="8.1.1.3.&nbsp;strictfp Classes">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.1.1.3"></a>8.1.1.3.&nbsp;<code class="literal">strictfp</code> Classes
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.1.1.3-100"></a>The
                     effect of the <code class="literal">strictfp</code> modifier is to make all <code class="literal">float</code> or <code class="literal">double</code>
                     expressions within the class declaration (including within variable
                     initializers, instance initializers, static initializers, and
                     constructors) be explicitly FP-strict
                     (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>).
                  </p>
                  <p class="norm-static"><a name="jls-8.1.1.3-110"></a>This
                     implies that all methods declared in the class, and all nested types
                     declared in the class, are implicitly <code class="literal">strictfp</code>.
                  </p>
               </div>
            </div>
            <div class="section" title="8.1.2.&nbsp;Generic Classes and Type Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.1.2"></a>8.1.2.&nbsp;Generic Classes and Type Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-8.1.2-100"></a>A class
                  is <span class="emphasis"><em>generic</em></span> if it declares one or more type
                  variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>).
               </p>
               <p class="norm"><a name="jls-8.1.2-110"></a>These type variables are
                  known as the <span class="emphasis"><em>type parameters</em></span> of the class. The
                  type parameter section follows the class name and is delimited by
                  angle brackets.
               </p>
               <div id="jls-8.1.2-120" class="productionset"><a name="jls-8.1.2-120"></a>
                    
                  <div class="production"><a name="jls-TypeParameters"></a>
                         
                     <div class="lhs">TypeParameters:</div>
                         
                     <div class="rhs">
                              <code class="literal">&lt;</code> <a href="jls-8.html#jls-TypeParameterList" title="TypeParameterList">TypeParameterList</a> <code class="literal">&gt;</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-TypeParameterList"></a>
                         
                     <div class="lhs">TypeParameterList:</div>
                         
                     <div class="rhs">
                              <a href="jls-4.html#jls-TypeParameter" title="TypeParameter">TypeParameter</a> {<code class="literal">,</code> <a href="jls-4.html#jls-TypeParameter" title="TypeParameter">TypeParameter</a>}
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">The following productions from
                  <a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a> are shown here for convenience:
               </p>
               <div id="d5e11461" class="productionset"><a name="d5e11461"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">TypeParameter:</div>
                            
                        <div class="rhs">
                                 {<a href="jls-4.html#jls-TypeParameterModifier" title="TypeParameterModifier">TypeParameterModifier</a>}
                                 <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                                 [<a href="jls-4.html#jls-TypeBound" title="TypeBound">TypeBound</a>]
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">TypeParameterModifier:</div>
                            
                        <div class="rhs">
                                 <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">TypeBound:</div>
                            
                        <div class="rhs">
                                 <code class="literal">extends</code> <a href="jls-4.html#jls-TypeVariable" title="TypeVariable">TypeVariable</a> <br>
                                 <code class="literal">extends</code> <a href="jls-4.html#jls-ClassOrInterfaceType" title="ClassOrInterfaceType">ClassOrInterfaceType</a> {<a href="jls-4.html#jls-AdditionalBound" title="AdditionalBound">AdditionalBound</a>}
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">AdditionalBound:</div>
                            
                        <div class="rhs">
                                 <code class="literal">&amp;</code> <a href="jls-4.html#jls-InterfaceType" title="InterfaceType">InterfaceType</a>
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.1.2-130"></a>The rules for
                  annotation modifiers on a type parameter declaration are specified in
                  <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Type">&sect;9.7.5</a>.
               </p>
               <p class="norm"><a name="jls-8.1.2-200"></a>In a class's type parameter
                  section, a type variable <span class="type">T</span> <span class="emphasis"><em>directly depends</em></span> on
                  a type variable <span class="type">S</span> if <span class="type">S</span> is the bound of <span class="type">T</span>, while
                  <span class="type">T</span> <span class="emphasis"><em>depends</em></span> on <span class="type">S</span> if either <span class="type">T</span> directly depends
                  on <span class="type">S</span> or <span class="type">T</span> directly depends on a type variable <span class="type">U</span> that depends on
                  <span class="type">S</span> (using this definition recursively). It is a compile-time error if
                  a type variable in a class's type parameter section depends on
                  itself.
               </p>
               <p class="norm-static"><a name="jls-8.1.2-210"></a>The scope
                  and shadowing of a class's type parameter is specified in
                  <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
               </p>
               <p class="norm-static"><a name="jls-8.1.2-300"></a>A generic
                  class declaration defines a set of parameterized types
                  (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>), one for each possible parameterization of
                  the type parameter section by type arguments. All of these
                  parameterized types share the same class at run time.
               </p>
               <div class="informalexample">
                  <p class="note">For instance, executing the code:</p><pre class="programlisting">

Vector&lt;String&gt;  x = new Vector&lt;String&gt;();
Vector&lt;Integer&gt; y = new Vector&lt;Integer&gt;();
boolean b = x.getClass() == y.getClass();

</pre><p class="note">will result in the variable <code class="literal">b</code>
                     holding the value <code class="literal">true</code>.
                  </p>
               </div>
               <p class="norm-error"><a name="jls-8.1.2-310"></a>It is a
                  compile-time error if a generic class is a direct or indirect subclass
                  of <code class="literal">Throwable</code> (<a class="xref" href="jls-11.html#jls-11.1.1" title="11.1.1.&nbsp;The Kinds of Exceptions">&sect;11.1.1</a>).
               </p>
               <p class="note">This restriction is needed since the catch mechanism
                  of the Java Virtual Machine works only with non-generic classes.
               </p>
               <p class="norm-error"><a name="jls-8.1.2-320"></a>It is a
                  compile-time error to refer to a type parameter of a generic class <span class="type">C</span>
                  in any of the following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.2-320-A"></a>the declaration of a
                                 <code class="literal">static</code> member of <span class="type">C</span> (<a class="xref" href="jls-8.html#jls-8.3.1.1" title="8.3.1.1.&nbsp;static Fields">&sect;8.3.1.1</a>,
                                 <a class="xref" href="jls-8.html#jls-8.4.3.2" title="8.4.3.2.&nbsp;static Methods">&sect;8.4.3.2</a>,
                                 <a class="xref" href="jls-8.html#jls-8.5.1" title="8.5.1.&nbsp;Static Member Type Declarations">&sect;8.5.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.2-320-B"></a>the declaration of a
                                 <code class="literal">static</code> member of any type declaration nested within
                                 <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.2-320-C"></a>a static initializer of
                                 <span class="type">C</span> (<a class="xref" href="jls-8.html#jls-8.7" title="8.7.&nbsp;Static Initializers">&sect;8.7</a>), or
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.2-320-D"></a>a static initializer of
                                 any class declaration nested within <span class="type">C</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e11519"></a><p class="title"><b>Example&nbsp;8.1.2-1.&nbsp;Mutually Recursive Type Variable Bounds</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface ConvertibleTo&lt;T&gt; {
    T convert();
}
class ReprChange&lt;T extends ConvertibleTo&lt;S&gt;,
                 S extends ConvertibleTo&lt;T&gt;&gt; { 
    T t; 
    void set(S s) { t = s.convert();    } 
    S get()       { return t.convert(); } 
}
</pre></div>
               </div><br class="example-break"><div class="example"><a name="d5e11522"></a><p class="title"><b>Example&nbsp;8.1.2-2.&nbsp;Nested Generic Classes</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Seq&lt;T&gt; { 
    T      head;
    Seq&lt;T&gt; tail;

    Seq() { this(null, null); } 
    Seq(T head, Seq&lt;T&gt; tail) {
        this.head = head;
        this.tail = tail;
    }
    boolean isEmpty() { return tail == null; }

    class Zipper&lt;S&gt; { 
        Seq&lt;Pair&lt;T,S&gt;&gt; zip(Seq&lt;S&gt; that) { 
            if (isEmpty() || that.isEmpty()) {
                return new Seq&lt;Pair&lt;T,S&gt;&gt;(); 
            } else {
                Seq&lt;T&gt;.Zipper&lt;S&gt; tailZipper =
                    tail.new Zipper&lt;S&gt;();
                return new Seq&lt;Pair&lt;T,S&gt;&gt;( 
                    new Pair&lt;T,S&gt;(head, that.head),
                    tailZipper.zip(that.tail));
            }
        }
    }
}
class Pair&lt;T, S&gt; {
    T fst; S snd;
    Pair(T f, S s) { fst = f; snd = s; }
}
class Test {
    public static void main(String[] args) {
        Seq&lt;String&gt; strs =
            new Seq&lt;String&gt;(
                "a",
                new Seq&lt;String&gt;("b",
                                new Seq&lt;String&gt;()));
        Seq&lt;Number&gt; nums =
            new Seq&lt;Number&gt;(
                new Integer(1),
                new Seq&lt;Number&gt;(new Double(1.5),
                                new Seq&lt;Number&gt;()));

        Seq&lt;String&gt;.Zipper&lt;Number&gt; zipper =
            strs.new Zipper&lt;Number&gt;();

        Seq&lt;Pair&lt;String,Number&gt;&gt; combined =
            zipper.zip(nums);
    }
}
</pre></div>
               </div><br class="example-break"></div>
            <div class="section" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.1.3"></a>8.1.3.&nbsp;Inner Classes and Enclosing Instances
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-8.1.3-100"></a>An <span class="emphasis"><em>inner
                        class</em></span> is a nested class that is not explicitly or
                  implicitly declared <code class="literal">static</code>.
               </p>
               <p class="norm"><a name="jls-8.1.3-110"></a>An inner class may be a
                  non-<code class="literal">static</code> member class (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>), a local class
                  (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class Declarations">&sect;14.3</a>), or an anonymous class
                  (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>). A member class of an interface is
                  implicitly <code class="literal">static</code> (<a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>) so is never considered
                  to be an inner class.
               </p>
               <p class="norm-error"><a name="jls-8.1.3-120"></a>It is a
                  compile-time error if an inner class declares a static initializer
                  (<a class="xref" href="jls-8.html#jls-8.7" title="8.7.&nbsp;Static Initializers">&sect;8.7</a>).
               </p>
               <p class="norm-error"><a name="jls-8.1.3-130"></a>It is a
                  compile-time error if an inner class declares a member that is
                  explicitly or implicitly <code class="literal">static</code>, unless the member is
                  a  constant variable
                  (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>).
               </p>
               <p class="norm-static"><a name="jls-8.1.3-140"></a>An inner
                  class may inherit <code class="literal">static</code> members that are
                  not  constant variables even though it
                  cannot declare them.
               </p>
               <p class="norm-static"><a name="jls-8.1.3-150"></a>A nested
                  class that is not an inner class may declare <code class="literal">static</code> members freely,
                  in accordance with the usual rules of the Java programming language.
               </p>
               <div class="example"><a name="d5e11546"></a><p class="title"><b>Example&nbsp;8.1.3-1.&nbsp;Inner Class Declarations and Static Members</b></p>
                  <div class="example-contents"><pre class="programlisting">
class HasStatic {
    static int j = 100;
}
class Outer {
    class Inner extends HasStatic {
        static final int x = 3;  // OK: constant variable
        static int y = 4;  // Compile-time error: an inner class
    }
    static class NestedButNotInner{
        static int z = 5;    // OK: not an inner class
    }
    interface NeverInner {}  // Interfaces are never inner
}
</pre></div>
               </div><br class="example-break"><p class="norm"><a name="jls-8.1.3-200"></a>A statement or
                  expression <span class="emphasis"><em>occurs in a static context</em></span> if and only
                  if the innermost method, constructor, instance initializer, static
                  initializer, field initializer, or explicit constructor invocation
                  statement enclosing the statement or expression is a static method, a
                  static initializer, the variable initializer of a static variable, or
                  an explicit constructor invocation statement
                  (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>).
               </p>
               <p class="norm-static"><a name="jls-8.1.3-300"></a>An inner class
                  <span class="type">C</span> is a <span class="emphasis"><em>direct inner class of a class or interface
                        <span class="type">O</span></em></span> if <span class="type">O</span> is the immediately enclosing type declaration of
                  <span class="type">C</span> and the declaration of <span class="type">C</span> does not occur in a static
                  context.
               </p>
               <p class="norm-static"><a name="jls-8.1.3-310"></a>A class <span class="type">C</span> is
                  an <span class="emphasis"><em>inner class of class or interface <span class="type">O</span></em></span> if it is
                  either a direct inner class of <span class="type">O</span> or an inner class of an inner class
                  of <span class="type">O</span>.
               </p>
               <p class="note">It is unusual, but possible, for the immediately
                  enclosing type declaration of an inner class to be an interface. This
                  only occurs if the class is declared in a default method body
                  (<a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>). Specifically, it occurs if an anonymous
                  or local class is declared in a default method body, or a member class
                  is declared in the body of an anonymous class that is declared in a
                  default method body.
               </p>
               <p class="norm-static"><a name="jls-8.1.3-320"></a>A class or
                  interface <span class="type">O</span> is the <span class="emphasis"><em>zeroth lexically enclosing type
                        declaration of itself</em></span>.
               </p>
               <p class="norm-static"><a name="jls-8.1.3-330"></a>A class <span class="type">O</span> is
                  the <span class="emphasis"><em>n'th lexically enclosing type declaration of a class
                        <span class="type">C</span></em></span> if it is the immediately enclosing type declaration of
                  the <span class="emphasis"><em>n-1</em></span>'th lexically enclosing type declaration
                  of <span class="type">C</span>.
               </p>
               <p class="norm-static"><a name="jls-8.1.3-400"></a>An instance <code class="varname">i</code>
                  of a direct inner class <span class="type">C</span> of a class or interface <span class="type">O</span> is associated
                  with an instance of <span class="type">O</span>, known as the <span class="emphasis"><em>immediately enclosing
                        instance of <code class="varname">i</code></em></span>. The immediately enclosing instance of an
                  object, if any, is determined when the object is created
                  (<a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>).
               </p>
               <p class="norm-static"><a name="jls-8.1.3-410"></a>An object
                  <code class="varname">o</code> is the <span class="emphasis"><em>zeroth lexically enclosing instance of
                        itself</em></span>.
               </p>
               <p class="norm-static"><a name="jls-8.1.3-420"></a>An object
                  <code class="varname">o</code> is the <span class="emphasis"><em>n'th lexically enclosing instance of an instance
                        <code class="varname">i</code></em></span> if it is the immediately enclosing instance of
                  the <span class="emphasis"><em>n-1</em></span>'th lexically enclosing instance of
                  <code class="varname">i</code>.
               </p>
               <p class="norm-static"><a name="jls-8.1.3-430"></a>An
                  instance of an inner class <span class="type">I</span> whose declaration occurs in a static
                  context has no lexically enclosing instances. However, if <span class="type">I</span> is
                  immediately declared within a static method or static initializer then
                  <span class="type">I</span> does have an <span class="emphasis"><em>enclosing block</em></span>, which is the
                  innermost block statement lexically enclosing the declaration of
                  <span class="type">I</span>.
               </p>
               <p class="norm-static"><a name="jls-8.1.3-440"></a>For every
                  superclass <span class="type">S</span> of <span class="type">C</span> which is itself a direct inner class of a class
                  or interface <span class="type">SO</span>, there is an instance of <span class="type">SO</span>
                  associated with <code class="varname">i</code>, known as the <span class="emphasis"><em>immediately enclosing
                        instance of <code class="varname">i</code> with respect to <span class="type">S</span></em></span>. The immediately
                  enclosing instance of an object with respect to its class' direct
                  superclass, if any, is determined when the superclass constructor is
                  invoked via an explicit constructor invocation statement
                  (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-8.1.3-500"></a>When an
                  inner class (whose declaration does not occur in a static context)
                  refers to an instance variable that is a member of a lexically
                  enclosing type declaration, the variable of the corresponding
                  lexically enclosing instance is used.
               </p>
               <p class="norm-error"><a name="jls-8.1.3-510"></a>Any local
                  variable, formal parameter, or exception parameter used but not
                  declared in an inner class must either be declared <code class="literal">final</code> or be
                  effectively final (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>), or a compile-time
                  error occurs where the use is attempted.
               </p>
               <p class="norm-error"><a name="jls-8.1.3-520"></a>Any local
                  variable used but not declared in an inner class must be definitely
                  assigned (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>) before the body of the inner
                  class, or a compile-time error occurs.
               </p>
               <p class="note">Similar rules on variable use apply in the body of a
                  lambda expression (<a class="xref" href="jls-15.html#jls-15.27.2" title="15.27.2.&nbsp;Lambda Body">&sect;15.27.2</a>).
               </p>
               <p class="norm-error"><a name="jls-8.1.3-530"></a>A blank
                  <code class="literal">final</code> field (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>) of a lexically enclosing
                  type declaration may not be assigned within an inner class, or a
                  compile-time error occurs.
               </p>
               <div class="example"><a name="d5e11620"></a><p class="title"><b>Example&nbsp;8.1.3-2.&nbsp;Inner Class Declarations</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Outer {
    int i = 100;
    static void classMethod() {
        final int l = 200;
        class LocalInStaticContext {
            int k = i;  // Compile-time error
            int m = l;  // OK
        }
    }
    void foo() {
        class Local {  // A local class
            int j = i;
        }
    }
}
</pre><p class="note">The declaration of
                        class <code class="literal">LocalInStaticContext</code> occurs in a static
                        context due to being within the static
                        method <code class="literal">classMethod</code>. Instance variables of
                        class <code class="literal">Outer</code> are not available within the body of a
                        static method. In particular, instance variables
                        of <code class="literal">Outer</code> are not available inside the body
                        of <code class="literal">LocalInStaticContext</code>. However, local variables
                        from the surrounding method may be referred to without error (provided
                        they are marked <code class="literal">final</code>).
                     </p>
                     <p class="note">Inner classes whose declarations do not occur in a
                        static context may freely refer to the instance variables of their
                        enclosing type declaration. An instance variable is always defined
                        with respect to an instance. In the case of instance variables of an
                        enclosing type declaration, the instance variable must be defined with
                        respect to an enclosing instance of that declared type. For example,
                        the class <code class="literal">Local</code> above has an enclosing instance of
                        class <code class="literal">Outer</code>. As a further example:
                     </p><pre class="programlisting">
class WithDeepNesting {
    boolean toBe;
    WithDeepNesting(boolean b) { toBe = b; }

    class Nested {
        boolean theQuestion;
        class DeeplyNested {
            DeeplyNested(){
                theQuestion = toBe || !toBe;
            }
        }
    }
}
</pre><p class="note">Here, every instance
                        of <code class="literal">WithDeepNesting.Nested.DeeplyNested</code> has an
                        enclosing instance of class <code class="literal">WithDeepNesting.Nested</code>
                        (its immediately enclosing instance) and an enclosing instance of
                        class <code class="literal">WithDeepNesting</code> (its 2nd lexically enclosing
                        instance).
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="8.1.4.&nbsp;Superclasses and Subclasses">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.1.4"></a>8.1.4.&nbsp;Superclasses and Subclasses
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.1.4-100"></a>
                  The optional <code class="literal">extends</code> clause in a normal class declaration specifies
                  the <span class="emphasis"><em>direct superclass</em></span> of the current class.
               </p>
               <div id="jls-8.1.4-110" class="productionset"><a name="jls-8.1.4-110"></a>
                    
                  <div class="production"><a name="jls-Superclass"></a>
                         
                     <div class="lhs">Superclass:</div>
                         
                     <div class="rhs">
                              <code class="literal">extends</code> <a href="jls-4.html#jls-ClassType" title="ClassType">ClassType</a>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.1.4-200"></a>
                  The <code class="literal">extends</code> clause must not appear in the definition of the class
                  <code class="literal">Object</code>, or a compile-time error occurs, because it is the primordial
                  class and has no direct superclass.
               </p>
               <p class="norm-error"><a name="jls-8.1.4-210"></a>
                  The <span class="emphasis"><em>ClassType</em></span> must name an accessible class type
                  (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>), or a compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-8.1.4-220"></a>
                  It is a compile-time error if the <span class="emphasis"><em>ClassType</em></span> names a class that is
                  <code class="literal">final</code>, because <code class="literal">final</code> classes are not allowed to have subclasses
                  (<a class="xref" href="jls-8.html#jls-8.1.1.2" title="8.1.1.2.&nbsp;final Classes">&sect;8.1.1.2</a>).
               </p>
               <p class="norm-error"><a name="jls-8.1.4-230"></a>
                  It is a compile-time error if the <span class="emphasis"><em>ClassType</em></span> names the class <code class="literal">Enum</code>
                  or any invocation of <code class="literal">Enum</code> (<a class="xref" href="jls-8.html#jls-8.9" title="8.9.&nbsp;Enum Types">&sect;8.9</a>).
               </p>
               <p class="norm-error"><a name="jls-8.1.4-240"></a>
                  If the <span class="emphasis"><em>ClassType</em></span> has type arguments, it must denote a well-formed
                  parameterized type (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>), and none of the type
                  arguments may be wildcard type arguments, or a compile-time error
                  occurs.
               </p>
               <p class="norm-static"><a name="jls-8.1.4-300"></a>Given a
                  (possibly generic) class declaration <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code>
                  (<span class="emphasis"><em>n</em></span> <span class="symbol">&#8805;</span> 0, <span class="type">C</span> <span class="symbol">&#8800;</span> <code class="literal">Object</code>), the <span class="emphasis"><em>direct
                        superclass</em></span> of the class type
                  <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> is the type given in the <code class="literal">extends</code>
                  clause of the declaration of <span class="type">C</span> if an <code class="literal">extends</code> clause is present, or
                  <code class="literal">Object</code> otherwise.
               </p>
               <p class="norm-static"><a name="jls-8.1.4-310"></a>Given a
                  generic class declaration <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> (<span class="emphasis"><em>n</em></span>
                  &gt; 0), the <span class="emphasis"><em>direct superclass</em></span> of the
                  parameterized class type <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>, where <span class="type">T<sub>i</sub></span>
                  (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) is a type, is <span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>
                  <span class="symbol">&#952;</span>,...,<span class="type">U<sub>k</sub></span> <span class="symbol">&#952;</span><code class="literal">&gt;</code>, where
                  <span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>,...,<span class="type">U<sub>k</sub></span><code class="literal">&gt;</code> is the direct superclass of
                  <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> and <span class="symbol">&#952;</span> is the
                  substitution <code class="literal">[<span class="type">F<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>:=<span class="type">T<sub>n</sub></span>]</code>.
               </p>
               <p class="norm"><a name="jls-8.1.4-330"></a>A class is said to be
                  a <span class="emphasis"><em>direct subclass</em></span> of its direct superclass. The
                  direct superclass is the class from whose implementation the
                  implementation of the current class is derived.
               </p>
               <p class="norm"><a name="jls-8.1.4-400"></a>The 
                  <span class="emphasis"><em>subclass</em></span> relationship is the transitive closure
                  of the direct subclass relationship. A class <span class="type">A</span> is a subclass of
                  class <span class="type">C</span> if either of the following is true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.4-400-A"></a>
                                 <span class="type">A</span> is the direct subclass of <span class="type">C</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.4-400-B"></a>
                                 There exists a class <span class="type">B</span> such that <span class="type">A</span> is a subclass of <span class="type">B</span>, and
                                 <span class="type">B</span> is a subclass of <span class="type">C</span>, applying this definition
                                 recursively.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-8.1.4-410"></a>Class <span class="type">C</span> is said to be
                  a <span class="emphasis"><em>superclass</em></span> of class <span class="type">A</span> whenever <span class="type">A</span> is a
                  subclass of <span class="type">C</span>.
               </p>
               <div class="example"><a name="d5e11773"></a><p class="title"><b>Example&nbsp;8.1.4-1.&nbsp;Direct Superclasses and Subclasses</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point { int x, y; }
final class ColoredPoint extends Point { int color; }
class Colored3DPoint extends ColoredPoint { int z; }  // error
</pre><p class="note">Here, the relationships are as follows:</p>
                     <div class="note">
                        <ul class="note" type="disc">
                           <li class="listitem">
                              <p class="note">The class <code class="literal">Point</code> is a direct
                                     subclass of <code class="literal">Object</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The class <code class="literal">Object</code> is the direct superclass of
                                       the class <code class="literal">Point</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The class <code class="literal">ColoredPoint</code> is a
                                       direct subclass of class <code class="literal">Point</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The class <code class="literal">Point</code> is the direct
                                       superclass of
                                       class <code class="literal">ColoredPoint</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="note">The declaration of
                        class <code class="literal">Colored3dPoint</code> causes a compile-time error
                        because it attempts to extend the final
                        class <code class="literal">ColoredPoint</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e11797"></a><p class="title"><b>Example&nbsp;8.1.4-2.&nbsp;Superclasses and Subclasses</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point { int x, y; }
class ColoredPoint extends Point { int color; }
final class Colored3dPoint extends ColoredPoint { int z; }
</pre><p class="note">Here, the relationships are as follows:</p>
                     <div class="note">
                        <ul class="note" type="disc">
                           <li class="listitem">
                              <p class="note">The class <code class="literal">Point</code> is a
                                       superclass of class <code class="literal">ColoredPoint</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The class <code class="literal">Point</code> is a
                                       superclass of class <code class="literal">Colored3dPoint</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The class <code class="literal">ColoredPoint</code> is a
                                       subclass of class <code class="literal">Point</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The class <code class="literal">ColoredPoint</code> is a
                                       superclass of class <code class="literal">Colored3dPoint</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The class <code class="literal">Colored3dPoint</code> is a
                                       subclass of class <code class="literal">ColoredPoint</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The class <code class="literal">Colored3dPoint</code> is a
                                       subclass of class <code class="literal">Point</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><br class="example-break"><p class="norm-static"><a name="jls-8.1.4-500"></a>
                  A class <span class="type">C</span> <span class="emphasis"><em>directly depends</em></span> on a type <span class="type">T</span> if <span class="type">T</span>
                  is mentioned in the <code class="literal">extends</code> or <code class="literal">implements</code> clause of <span class="type">C</span> either as
                  a superclass or superinterface, or as a qualifier in the
                  fully qualified form of a superclass or superinterface
                  name.
               </p>
               <p class="norm-static"><a name="jls-8.1.4-510"></a>A class
                  <span class="type">C</span> <span class="emphasis"><em>depends</em></span> on a reference type <span class="type">T</span> if any of the
                  following is true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.4-510-A"></a>
                                 <span class="type">C</span> directly depends on <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.4-510-B"></a>
                                 <span class="type">C</span> directly depends on an interface <span class="type">I</span> that depends
                                 (<a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>) on <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.4-510-C"></a>
                                 <span class="type">C</span> directly depends on a class <span class="type">D</span> that depends on
                                 <span class="type">T</span> (using this definition recursively).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-error"><a name="jls-8.1.4-520"></a>It is a
                  compile-time error if a class depends on itself.
               </p>
               <p class="norm-dynamic"><a name="jls-8.1.4-530"></a>If
                  circularly declared classes are detected at run time, as classes are
                  loaded, then a <code class="literal">ClassCircularityError</code> is thrown
                  (<a class="xref" href="jls-12.html#jls-12.2.1" title="12.2.1.&nbsp;The Loading Process">&sect;12.2.1</a>).
               </p>
               <div class="example"><a name="d5e11858"></a><p class="title"><b>Example&nbsp;8.1.4-3.&nbsp;Class Depends on Itself</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point extends ColoredPoint { int x, y; }
class ColoredPoint extends Point { int color; }
</pre><p class="note">This program causes a compile-time error because
                        class <code class="literal">Point</code> depends on itself.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="8.1.5.&nbsp;Superinterfaces">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.1.5"></a>8.1.5.&nbsp;Superinterfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.1.5-100"></a>
                  The optional <code class="literal">implements</code> clause in a class declaration lists the
                  names of interfaces that are direct superinterfaces of the class being
                  declared.
               </p>
               <div id="jls-8.1.5-110" class="productionset"><a name="jls-8.1.5-110"></a>
                    
                  <div class="production"><a name="jls-Superinterfaces"></a>
                         
                     <div class="lhs">Superinterfaces:</div>
                         
                     <div class="rhs">
                              <code class="literal">implements</code> <a href="jls-8.html#jls-InterfaceTypeList" title="InterfaceTypeList">InterfaceTypeList</a>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-InterfaceTypeList"></a>
                         
                     <div class="lhs">InterfaceTypeList:</div>
                         
                     <div class="rhs">
                              <a href="jls-4.html#jls-InterfaceType" title="InterfaceType">InterfaceType</a> {<code class="literal">,</code> <a href="jls-4.html#jls-InterfaceType" title="InterfaceType">InterfaceType</a>}
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.1.5-200"></a>
                  Each <span class="emphasis"><em>InterfaceType</em></span> must name an accessible interface 
                  type (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>), or a compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-8.1.5-210"></a>
                  If an <span class="emphasis"><em>InterfaceType</em></span> has type arguments, it must
                  denote a well-formed parameterized type (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>),
                  and none of the type arguments may be wildcard type arguments, or a
                  compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-8.1.5-220"></a>
                  It is a compile-time error if the same interface is mentioned as a
                  direct superinterface more than once in a single <code class="literal">implements</code>
                  clause. This is true even if the interface is named in different
                  ways.
               </p>
               <div class="example"><a name="d5e11887"></a><p class="title"><b>Example&nbsp;8.1.5-1.&nbsp;Illegal Superinterfaces</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Redundant implements java.lang.Cloneable, Cloneable {
    int x;
}

</pre><p class="note">This program results in a compile-time error because
                        the names <code class="literal">java.lang.Cloneable</code> and <code class="literal">Cloneable</code> refer
                        to the same interface.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm-static"><a name="jls-8.1.5-300"></a>Given a
                  (possibly generic) class declaration <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code>
                  (<span class="emphasis"><em>n</em></span> <span class="symbol">&#8805;</span> 0, <span class="type">C</span> <span class="symbol">&#8800;</span> <code class="literal">Object</code>), the <span class="emphasis"><em>direct
                        superinterfaces</em></span> of the class type
                  <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> are the types given in the
                  <code class="literal">implements</code> clause of the declaration of <span class="type">C</span>, if an <code class="literal">implements</code>
                  clause is present.
               </p>
               <p class="norm-static"><a name="jls-8.1.5-310"></a>Given a
                  generic class declaration <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> (<span class="emphasis"><em>n</em></span>
                  &gt; 0), the <span class="emphasis"><em>direct superinterfaces</em></span> of the
                  parameterized class type <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>, where <span class="type">T<sub>i</sub></span>
                  (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) is a type, are all types <span class="type">I</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>
                  <span class="symbol">&#952;</span>,...,<span class="type">U<sub>k</sub></span> <span class="symbol">&#952;</span><code class="literal">&gt;</code>, where
                  <span class="type">I</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>,...,<span class="type">U<sub>k</sub></span><code class="literal">&gt;</code> is a direct superinterface of
                  <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> and <span class="symbol">&#952;</span> is the
                  substitution <code class="literal">[<span class="type">F<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>:=<span class="type">T<sub>n</sub></span>]</code>.
               </p>
               <p class="norm-static"><a name="jls-8.1.5-400"></a>An
                  interface type <span class="type">I</span> is a <span class="emphasis"><em>superinterface</em></span> of class
                  type <span class="type">C</span> if any of the following is true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.5-400-A"></a><span class="type">I</span> is a direct
                               superinterface of <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.5-400-B"></a><span class="type">C</span> has some direct
                                 superinterface <span class="type">J</span> for which <span class="type">I</span> is a superinterface,
                                 using the definition of "superinterface of an interface" given
                                 in <a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.1.5-400-C"></a><span class="type">I</span> is a superinterface
                                 of the direct superclass of <span class="type">C</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-8.1.5-410"></a>A class
                  can have a superinterface in more than one way.
               </p>
               <p class="norm"><a name="jls-8.1.5-420"></a>A class is said
                  to <span class="emphasis"><em>implement</em></span> all its superinterfaces.
               </p>
               <p class="norm-error"><a name="jls-8.1.5-430"></a>A class may
                  not at the same time be a subtype of two interface types which are
                  different parameterizations of the same generic interface
                  (<a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>), or a subtype of a parameterization of a
                  generic interface and a raw type naming that same generic interface,
                  or a compile-time error occurs.
               </p>
               <p class="note">This requirement was introduced in order to support
                  translation by type erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>).
               </p>
               <div class="example"><a name="d5e11999"></a><p class="title"><b>Example&nbsp;8.1.5-2.&nbsp;Superinterfaces</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface Colorable {
    void setColor(int color);
    int getColor();
}
enum Finish { MATTE, GLOSSY }
interface Paintable extends Colorable {
    void setFinish(Finish finish);
    Finish getFinish();
}

class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
    public int getColor() { return color; }
}
class PaintedPoint extends ColoredPoint implements Paintable {
    Finish finish;
    public void setFinish(Finish finish) {
        this.finish = finish;
    }
    public Finish getFinish() { return finish; }
}
</pre><p class="note">Here, the relationships are as follows:</p>
                     <div class="note">
                        <ul class="note" type="disc">
                           <li class="listitem">
                              <p class="note">The interface <code class="literal">Paintable</code> is a
                                       superinterface of class <code class="literal">PaintedPoint</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The interface <code class="literal">Colorable</code> is a
                                       superinterface of class <code class="literal">ColoredPoint</code> and of
                                       class <code class="literal">PaintedPoint</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The interface <code class="literal">Paintable</code> is a
                                       subinterface of the interface <code class="literal">Colorable</code>,
                                       and <code class="literal">Colorable</code> is a superinterface
                                       of <code class="literal">Paintable</code>, as defined in
                                       <a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="note">The class <code class="literal">PaintedPoint</code>
                        has <code class="literal">Colorable</code> as a superinterface both because it
                        is a superinterface of <code class="literal">ColoredPoint</code> and because it
                        is a superinterface of <code class="literal">Paintable</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e12025"></a><p class="title"><b>Example&nbsp;8.1.5-3.&nbsp;Illegal Multiple Inheritance of an Interface</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface I&lt;T&gt; {}
class B implements I&lt;Integer&gt; {}
class C extends B implements I&lt;String&gt; {}
</pre><p class="note">Class <code class="literal">C</code> causes a compile-time
                        error because it attempts to be a subtype of both <span class="type">I</span>&lt;<code class="literal">Integer</code>&gt;
                        and <span class="type">I</span>&lt;<code class="literal">String</code>&gt;.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm-static"><a name="jls-8.1.5-500"></a>
                  Unless the class being declared is <code class="literal">abstract</code>, all the <code class="literal">abstract</code>
                  member methods of each direct superinterface must be implemented
                  (<a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a>) either by a declaration in this class
                  or by an existing method declaration inherited from the direct
                  superclass or a direct superinterface, because a class that is not
                  <code class="literal">abstract</code> is not permitted to have <code class="literal">abstract</code> methods
                  (<a class="xref" href="jls-8.html#jls-8.1.1.1" title="8.1.1.1.&nbsp;abstract Classes">&sect;8.1.1.1</a>).
               </p>
               <p class="norm-static"><a name="jls-8.1.5-510"></a>
                  Each default method (<a class="xref" href="jls-9.html#jls-9.4.3" title="9.4.3.&nbsp;Interface Method Body">&sect;9.4.3</a>) of a superinterface
                  of the class may optionally be overridden by a method in the class; if
                  not, the default method is typically inherited and its behavior is as
                  specified by its default body.
               </p>
               <p class="norm-static"><a name="jls-8.1.5-520"></a>
                  It is permitted for a single method declaration in a class to
                  implement methods of more than one superinterface.
               </p>
               <div class="example"><a name="d5e12044"></a><p class="title"><b>Example&nbsp;8.1.5-3.&nbsp;Implementing Methods of a Superinterface</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface Colorable {
    void setColor(int color);
    int getColor();
}
class Point { int x, y; };
class ColoredPoint extends Point implements Colorable {
    int color;
}
</pre><p class="note">This program causes a compile-time error,
                        because <code class="literal">ColoredPoint</code> is not an <code class="literal">abstract</code> class but
                        fails to provide an implementation of
                        methods <code class="literal">setColor</code> and <code class="literal">getColor</code> of
                        the interface <code class="literal">Colorable</code>.
                     </p>
                     <p class="note">In the following program:</p><pre class="programlisting">
interface Fish  { int getNumberOfScales(); }
interface Piano { int getNumberOfScales(); }
class Tuna implements Fish, Piano {
    // You can tune a piano, but can you tuna fish?
    public int getNumberOfScales() { return 91; }
}
</pre><p class="note">the method <code class="literal">getNumberOfScales</code> in
                        class <code class="literal">Tuna</code> has a name, signature, and return type
                        that matches the method declared in interface <code class="literal">Fish</code>
                        and also matches the method declared in
                        interface <code class="literal">Piano</code>; it is considered to implement
                        both.
                     </p>
                     <p class="note">On the other hand, in a situation such as
                        this:
                     </p><pre class="programlisting">
interface Fish       { int    getNumberOfScales(); }
interface StringBass { double getNumberOfScales(); }
class Bass implements Fish, StringBass {
    // This declaration cannot be correct,
    // no matter what type is used.
    public ?? getNumberOfScales() { return 91; }
}
</pre><p class="note">it is impossible to declare a method
                        named <code class="literal">getNumberOfScales</code> whose signature and return
                        type are compatible with those of both the methods declared in
                        interface <code class="literal">Fish</code> and in
                        interface <code class="literal">StringBass</code>, because a class cannot have
                        multiple methods with the same signature and different primitive
                        return types (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>). Therefore, it is impossible
                        for a single class to implement both interface <code class="literal">Fish</code>
                        and interface <code class="literal">StringBass</code>
                        (<a class="xref" href="jls-8.html#jls-8.4.8" title="8.4.8.&nbsp;Inheritance, Overriding, and Hiding">&sect;8.4.8</a>).
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="8.1.6.&nbsp;Class Body and Member Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.1.6"></a>8.1.6.&nbsp;Class Body and Member Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.1.6-100"></a>
                  A <span class="emphasis"><em>class body</em></span> may contain declarations of members
                  of the class, that is, fields (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>), methods
                  (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>), classes (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>), and
                  interfaces (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>).
               </p>
               <p class="norm-static"><a name="jls-8.1.6-110"></a>
                  A class body may also contain instance initializers
                  (<a class="xref" href="jls-8.html#jls-8.6" title="8.6.&nbsp;Instance Initializers">&sect;8.6</a>), static initializers
                  (<a class="xref" href="jls-8.html#jls-8.7" title="8.7.&nbsp;Static Initializers">&sect;8.7</a>), and declarations of constructors
                  (<a class="xref" href="jls-8.html#jls-8.8" title="8.8.&nbsp;Constructor Declarations">&sect;8.8</a>) for the class.
               </p>
               <div id="jls-8.1.6-120" class="productionset"><a name="jls-8.1.6-120"></a>
                    
                  <div class="production"><a name="jls-ClassBody"></a>
                         
                     <div class="lhs">ClassBody:</div>
                         
                     <div class="rhs">
                              <code class="literal">{</code> {<a href="jls-8.html#jls-ClassBodyDeclaration" title="ClassBodyDeclaration">ClassBodyDeclaration</a>} <code class="literal">}</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ClassBodyDeclaration"></a>
                         
                     <div class="lhs">ClassBodyDeclaration:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-ClassMemberDeclaration" title="ClassMemberDeclaration">ClassMemberDeclaration</a> <br>
                              <a href="jls-8.html#jls-InstanceInitializer" title="InstanceInitializer">InstanceInitializer</a> <br>
                              <a href="jls-8.html#jls-StaticInitializer" title="StaticInitializer">StaticInitializer</a> <br>
                              <a href="jls-8.html#jls-ConstructorDeclaration" title="ConstructorDeclaration">ConstructorDeclaration</a>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ClassMemberDeclaration"></a>
                         
                     <div class="lhs">ClassMemberDeclaration:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-FieldDeclaration" title="FieldDeclaration">FieldDeclaration</a> <br>
                              <a href="jls-8.html#jls-MethodDeclaration" title="MethodDeclaration">MethodDeclaration</a> <br>
                              <a href="jls-8.html#jls-ClassDeclaration" title="ClassDeclaration">ClassDeclaration</a> <br>
                              <a href="jls-9.html#jls-InterfaceDeclaration" title="InterfaceDeclaration">InterfaceDeclaration</a> <br>
                              <code class="literal">;</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-8.1.6-200"></a>
                  The scope and shadowing of a declaration of a
                  member <code class="varname">m</code> declared in or inherited by a class type
                  <span class="type">C</span> is specified in <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and
                  <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
               </p>
               <p class="note">If <span class="type">C</span> itself is a nested class, there may be
                  definitions of the same kind (variable, method, or type) and name
                  as <code class="varname">m</code> in enclosing scopes. (The scopes may be
                  blocks, classes, or packages.) In all such cases, the
                  member <code class="varname">m</code> declared in or inherited by <span class="type">C</span> shadows
                  (<a class="xref" href="jls-6.html#jls-6.4.1" title="6.4.1.&nbsp;Shadowing">&sect;6.4.1</a>) the other definitions of the same kind
                  and name.
               </p>
            </div>
         </div>
         <div class="section" title="8.2.&nbsp;Class Members">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-8.2"></a>8.2.&nbsp;Class Members
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-8.2-100"></a>
               The members of a class type are all of the following:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-8.2-100-A"></a>
                              Members inherited from its direct superclass
                              (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>), except in class <code class="literal">Object</code>, which
                              has no direct superclass
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-8.2-100-B"></a>
                              Members inherited from any direct superinterfaces
                              (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-8.2-100-C"></a>
                              Members declared in the body of the class
                              (<a class="xref" href="jls-8.html#jls-8.1.6" title="8.1.6.&nbsp;Class Body and Member Declarations">&sect;8.1.6</a>)
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-8.2-110"></a>
               Members of a class that are declared <code class="literal">private</code> are not inherited by
               subclasses of that class.
            </p>
            <p class="norm-static"><a name="jls-8.2-120"></a>
               Only members of a class that are declared <code class="literal">protected</code> or <code class="literal">public</code> are
               inherited by subclasses declared in a package other than the one in
               which the class is declared.
            </p>
            <p class="norm-static"><a name="jls-8.2-130"></a>
               Constructors, static initializers, and instance initializers are not
               members and therefore are not inherited.
            </p>
            <p class="norm"><a name="jls-8.2-200"></a>
               We use the phrase <span class="emphasis"><em>the type of a member</em></span> to denote:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-8.2-200-A"></a>
                              For a field, its type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-8.2-200-B"></a>
                              For a method, an ordered 4-tuple consisting of:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-8.2-200-B-A"></a>
                                 	  type parameters: the declarations of any type parameters of
                                           the method member.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-8.2-200-B-B"></a>
                                 	  argument types: a list of the types of the arguments to the
                                           method member.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-8.2-200-B-C"></a>
                                 	  return type: the return type of the method member.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-8.2-200-B-D"></a>
                                 	  <code class="literal">throws</code> clause: exception types declared in the <code class="literal">throws</code>
                                           clause of the method member.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-8.2-210"></a>Fields, methods, and member
               types of a class type may have the same name, since they are used in
               different contexts and are disambiguated by different lookup
               procedures (<a class="xref" href="jls-6.html#jls-6.5" title="6.5.&nbsp;Determining the Meaning of a Name">&sect;6.5</a>). However, this is discouraged
               as a matter of style.
            </p>
            <div class="example"><a name="d5e12155"></a><p class="title"><b>Example&nbsp;8.2-1.&nbsp;Use of Class Members</b></p>
               <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y;
    private Point() { reset(); }
    Point(int x, int y) { this.x = x; this.y = y; }
    private void reset() { this.x = 0; this.y = 0; }
}
class ColoredPoint extends Point {
    int color;
    void clear() { reset(); }  // error
}
class Test {
    public static void main(String[] args) {
        ColoredPoint c = new ColoredPoint(0, 0);  // error
        c.reset();  // error
    }
}
</pre><p class="note">This program causes four compile-time errors.</p>
                  <p class="note">One error occurs
                     because <code class="literal">ColoredPoint</code> has no constructor declared
                     with two <code class="literal">int</code> parameters, as requested by the use
                     in <code class="literal">main</code>. This illustrates the fact
                     that <code class="literal">ColoredPoint</code> does not inherit the constructors
                     of its superclass <code class="literal">Point</code>.
                  </p>
                  <p class="note">Another error occurs
                     because <code class="literal">ColoredPoint</code> declares no constructors, and
                     therefore a default constructor for it is implicitly declared
                     (<a class="xref" href="jls-8.html#jls-8.8.9" title="8.8.9.&nbsp;Default Constructor">&sect;8.8.9</a>), and this default constructor is
                     equivalent to:
                  </p><pre class="screen">
ColoredPoint() { super(); }
</pre><p class="note">which invokes the constructor, with no arguments,
                     for the direct superclass of the
                     class <code class="literal">ColoredPoint</code>. The error is that the
                     constructor for <code class="literal">Point</code> that takes no arguments is
                     <code class="literal">private</code>, and therefore is not accessible outside the
                     class <code class="literal">Point</code>, even through a superclass constructor
                     invocation (<a class="xref" href="jls-8.html#jls-8.8.7" title="8.8.7.&nbsp;Constructor Body">&sect;8.8.7</a>).
                  </p>
                  <p class="note">Two more errors occur because the
                     method <code class="literal">reset</code> of class <code class="literal">Point</code> is
                     <code class="literal">private</code>, and therefore is not inherited by
                     class <code class="literal">ColoredPoint</code>. The method invocations in
                     method <code class="literal">clear</code> of
                     class <code class="literal">ColoredPoint</code> and in
                     method <code class="literal">main</code> of class <code class="literal">Test</code> are
                     therefore not correct.
                  </p>
               </div>
            </div><br class="example-break"><div class="example"><a name="d5e12184"></a><p class="title"><b>Example&nbsp;8.2-2.&nbsp;Inheritance of Class Members with Package Access</b></p>
               <div class="example-contents">
                  <p class="note">Consider the example where
                     the <code class="literal">points</code> package declares two compilation
                     units:
                  </p><pre class="programlisting">
package points;
public class Point {
    int x, y;
    public void move(int dx, int dy) { x += dx; y += dy; }
}
</pre><p class="note">and:</p><pre class="programlisting">
package points;
public class Point3d extends Point {
    int z;
    public void move(int dx, int dy, int dz) {
        x += dx; y += dy; z += dz;
    }
}
</pre><p class="note">and a third compilation unit, in another package,
                     is:
                  </p><pre class="programlisting">
import points.Point3d;
class Point4d extends Point3d {
    int w;
    public void move(int dx, int dy, int dz, int dw) {
        x += dx; y += dy; z += dz; w += dw; // compile-time errors
    }
}
</pre><p class="note">Here both classes in the <code class="literal">points</code>
                     package compile. The class <code class="literal">Point3d</code> inherits the
                     fields <code class="literal">x</code> and <code class="literal">y</code> of
                     class <code class="literal">Point</code>, because it is in the same package
                     as <code class="literal">Point</code>. The class <code class="literal">Point4d</code>,
                     which is in a different package, does not inherit the
                     fields <code class="literal">x</code> and <code class="literal">y</code> of
                     class <code class="literal">Point</code> or the field <code class="literal">z</code> of
                     class <code class="literal">Point3d</code>, and so fails to compile.
                  </p>
                  <p class="note">A better way to write the third compilation unit
                     would be:
                  </p><pre class="programlisting">

import points.Point3d;
class Point4d extends Point3d {
    int w;
    public void move(int dx, int dy, int dz, int dw) {
        super.move(dx, dy, dz); w += dw;
    }
}

</pre><p class="note">using the <code class="literal">move</code> method of the
                     superclass <code class="literal">Point3d</code> to
                     process <code class="literal">dx</code>, <code class="literal">dy</code>,
                     and <code class="literal">dz</code>. If <code class="literal">Point4d</code> is written in
                     this way, it will compile without errors.
                  </p>
               </div>
            </div><br class="example-break"><div class="example"><a name="d5e12215"></a><p class="title"><b>Example&nbsp;8.2-3.&nbsp;Inheritance of <code class="literal">public</code> and <code class="literal">protected</code> Class Members</b></p>
               <div class="example-contents">
                  <p class="note">Given the class <code class="literal">Point</code>:
                  </p><pre class="programlisting">
package points;
public class Point {
    public int x, y;
    protected int useCount = 0;
    static protected int totalUseCount = 0;
    public void move(int dx, int dy) {
        x += dx; y += dy; useCount++; totalUseCount++;
    }
}
</pre><p class="note">the <code class="literal">public</code> and <code class="literal">protected</code>
                     fields <code class="literal">x</code>, <code class="literal">y</code>, 
                     <code class="literal">useCount</code>, and <code class="literal">totalUseCount</code> are
                     inherited in all subclasses of <code class="literal">Point</code>.
                  </p>
                  <p class="note">Therefore, this test program, in another package,
                     can be compiled successfully:
                  </p><pre class="programlisting">
class Test extends points.Point {
    public void moveBack(int dx, int dy) {
        x -= dx; y -= dy; useCount++; totalUseCount++;
    }
}
</pre></div>
            </div><br class="example-break"><div class="example"><a name="d5e12232"></a><p class="title"><b>Example&nbsp;8.2-4.&nbsp;Inheritance of <code class="literal">private</code> Class Members</b></p>
               <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y;
    void move(int dx, int dy) {
        x += dx; y += dy; totalMoves++;
    }
    private static int totalMoves;
    void printMoves() { System.out.println(totalMoves); }
}
class Point3d extends Point {
    int z;
    void move(int dx, int dy, int dz) {
        super.move(dx, dy); z += dz; totalMoves++; // error
    }
}
</pre><p class="note">Here, the class
                     variable <code class="literal">totalMoves</code> can be used only within the
                     class <code class="literal">Point</code>; it is not inherited by the
                     subclass <code class="literal">Point3d</code>. A compile-time error occurs
                     because method move of class <code class="literal">Point3d</code> tries to
                     increment <code class="literal">totalMoves</code>.
                  </p>
               </div>
            </div><br class="example-break"><div class="example"><a name="d5e12242"></a><p class="title"><b>Example&nbsp;8.2-5.&nbsp;Accessing Members of Inaccessible Classes</b></p>
               <div class="example-contents">
                  <p class="note">Even though a class might not be declared <code class="literal">public</code>,
                     instances of the class might be available at run time to code outside
                     the package in which it is declared by means of a <code class="literal">public</code> superclass
                     or superinterface. An instance of the class can be assigned to a
                     variable of such a <code class="literal">public</code> type. An invocation of a <code class="literal">public</code> method
                     of the object referred to by such a variable may invoke a method of
                     the class if it implements or overrides a method of the <code class="literal">public</code>
                     superclass or superinterface. (In this situation, the method is
                     necessarily declared <code class="literal">public</code>, even though it is declared in a class
                     that is not <code class="literal">public</code>.)
                  </p>
                  <p class="note">Consider the compilation unit:</p><pre class="programlisting">
package points;
public class Point {
    public int x, y;
    public void move(int dx, int dy) {
        x += dx; y += dy;
    }
}
</pre><p class="note">and another compilation unit of another
                     package:
                  </p><pre class="programlisting">
package morePoints;
class Point3d extends points.Point {
    public int z;
    public void move(int dx, int dy, int dz) {
        super.move(dx, dy); z += dz;
    }
    public void move(int dx, int dy) {
        move(dx, dy, 0);
    }
}
public class OnePoint {
    public static points.Point getOne() { 
        return new Point3d(); 
    }
}
</pre><p class="note">An
                     invocation <code class="literal">morePoints.OnePoint.getOne()</code> in yet a
                     third package would return a <code class="literal">Point3d</code> that can be
                     used as a <code class="literal">Point</code>, even though the
                     type <code class="literal">Point3d</code> is not available outside the
                     package <code class="literal">morePoints</code>. The two-argument version of
                     method <code class="literal">move</code> could then be invoked for that object,
                     which is permissible because method <code class="literal">move</code>
                     of <code class="literal">Point3d</code> is <code class="literal">public</code> (as it must be, for any
                     method that overrides a <code class="literal">public</code> method must itself be <code class="literal">public</code>,
                     precisely so that situations such as this will work out
                     correctly). The fields <code class="literal">x</code> and <code class="literal">y</code>
                     of that object could also be accessed from such a third
                     package.
                  </p>
                  <p class="note">While the field <code class="literal">z</code> of
                     class <code class="literal">Point3d</code> is <code class="literal">public</code>, it is not possible to
                     access this field from code outside the
                     package <code class="literal">morePoints</code>, given only a reference to an
                     instance of class <code class="literal">Point3d</code> in a
                     variable <code class="literal">p</code> of type <code class="literal">Point</code>. This
                     is because the expression <code class="literal">p.z</code> is not correct,
                     as <code class="literal">p</code> has type <code class="literal">Point</code> and
                     class <code class="literal">Point</code> has no field
                     named <code class="literal">z</code>; also, the
                     expression <code class="literal">((Point3d)p).z</code> is not correct, because
                     the class type <code class="literal">Point3d</code> cannot be referred to
                     outside package <code class="literal">morePoints</code>.
                  </p>
                  <p class="note">The declaration of the field <code class="literal">z</code> as
                     <code class="literal">public</code> is not useless, however. If there were to be, in
                     package <code class="literal">morePoints</code>, a <code class="literal">public</code>
                     subclass <code class="literal">Point4d</code> of the
                     class <code class="literal">Point3d</code>:
                  </p><pre class="programlisting">
package morePoints;
public class Point4d extends Point3d {
    public int w;
    public void move(int dx, int dy, int dz, int dw) {
        super.move(dx, dy, dz); w += dw;
    }
}
</pre><p class="note">then class <code class="literal">Point4d</code> would inherit
                     the field <code class="literal">z</code>, which, being <code class="literal">public</code>, could then be
                     accessed by code in packages other than <code class="literal">morePoints</code>,
                     through variables and expressions of the <code class="literal">public</code>
                     type <code class="literal">Point4d</code>.
                  </p>
               </div>
            </div><br class="example-break"></div>
         <div class="section" title="8.3.&nbsp;Field Declarations">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-8.3"></a>8.3.&nbsp;Field Declarations
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-8.3-100"></a>
               The variables of a class type are introduced by <span class="emphasis"><em>field
                     declarations</em></span>.
            </p>
            <div id="jls-8.3-110" class="productionset"><a name="jls-8.3-110"></a>
                 
               <div class="production"><a name="jls-FieldDeclaration"></a>
                      
                  <div class="lhs">FieldDeclaration:</div>
                      
                  <div class="rhs">
                           {<a href="jls-8.html#jls-FieldModifier" title="FieldModifier">FieldModifier</a>}
                           <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a>
                           <a href="jls-8.html#jls-VariableDeclaratorList" title="VariableDeclaratorList">VariableDeclaratorList</a> <code class="literal">;</code>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-VariableDeclaratorList"></a>
                      
                  <div class="lhs">VariableDeclaratorList:</div>
                      
                  <div class="rhs">
                           <a href="jls-8.html#jls-VariableDeclarator" title="VariableDeclarator">VariableDeclarator</a> {<code class="literal">,</code> <a href="jls-8.html#jls-VariableDeclarator" title="VariableDeclarator">VariableDeclarator</a>}
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-VariableDeclarator"></a>
                      
                  <div class="lhs">VariableDeclarator:</div>
                      
                  <div class="rhs">
                           <a href="jls-8.html#jls-VariableDeclaratorId" title="VariableDeclaratorId">VariableDeclaratorId</a> [<code class="literal">=</code> <a href="jls-8.html#jls-VariableInitializer" title="VariableInitializer">VariableInitializer</a>]
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-VariableDeclaratorId"></a>
                      
                  <div class="lhs">VariableDeclaratorId:</div>
                      
                  <div class="rhs">
                           <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> [<a href="jls-4.html#jls-Dims" title="Dims">Dims</a>]
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-VariableInitializer"></a>
                      
                  <div class="lhs">VariableInitializer:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> <br>
                           <a href="jls-10.html#jls-ArrayInitializer" title="ArrayInitializer">ArrayInitializer</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <div id="jls-8.3-120" class="productionset"><a name="jls-8.3-120"></a>
                 
               <div class="production"><a name="jls-UnannType"></a>
                      
                  <div class="lhs">UnannType:</div>
                      
                  <div class="rhs">
                           <a href="jls-8.html#jls-UnannPrimitiveType" title="UnannPrimitiveType">UnannPrimitiveType</a> <br>
                           <a href="jls-8.html#jls-UnannReferenceType" title="UnannReferenceType">UnannReferenceType</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-UnannPrimitiveType"></a>
                      
                  <div class="lhs">UnannPrimitiveType:</div>
                      
                  <div class="rhs">
                           <a href="jls-4.html#jls-NumericType" title="NumericType">NumericType</a> <br>
                           <code class="literal">boolean</code>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-UnannReferenceType"></a>
                      
                  <div class="lhs">UnannReferenceType:</div>
                      
                  <div class="rhs">
                           <a href="jls-8.html#jls-UnannClassOrInterfaceType" title="UnannClassOrInterfaceType">UnannClassOrInterfaceType</a> <br>
                           <a href="jls-8.html#jls-UnannTypeVariable" title="UnannTypeVariable">UnannTypeVariable</a> <br>
                           <a href="jls-8.html#jls-UnannArrayType" title="UnannArrayType">UnannArrayType</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-UnannClassOrInterfaceType"></a>
                      
                  <div class="lhs">UnannClassOrInterfaceType:</div>
                      
                  <div class="rhs">
                           <a href="jls-8.html#jls-UnannClassType" title="UnannClassType">UnannClassType</a> <br>
                           <a href="jls-8.html#jls-UnannInterfaceType" title="UnannInterfaceType">UnannInterfaceType</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-UnannClassType"></a>
                      
                  <div class="lhs">UnannClassType:</div>
                      
                  <div class="rhs">
                           <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <br>
                     
                           <a href="jls-8.html#jls-UnannClassOrInterfaceType" title="UnannClassOrInterfaceType">UnannClassOrInterfaceType</a> <code class="literal">.</code>
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>}
                           <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>]
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-UnannInterfaceType"></a>
                      
                  <div class="lhs">UnannInterfaceType:</div>
                      
                  <div class="rhs">
                           <a href="jls-8.html#jls-UnannClassType" title="UnannClassType">UnannClassType</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-UnannTypeVariable"></a>
                      
                  <div class="lhs">UnannTypeVariable:</div>
                      
                  <div class="rhs">
                           <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-UnannArrayType"></a>
                      
                  <div class="lhs">UnannArrayType:</div>
                      
                  <div class="rhs">
                           <a href="jls-8.html#jls-UnannPrimitiveType" title="UnannPrimitiveType">UnannPrimitiveType</a> <a href="jls-4.html#jls-Dims" title="Dims">Dims</a> <br>
                           <a href="jls-8.html#jls-UnannClassOrInterfaceType" title="UnannClassOrInterfaceType">UnannClassOrInterfaceType</a> <a href="jls-4.html#jls-Dims" title="Dims">Dims</a> <br>
                           <a href="jls-8.html#jls-UnannTypeVariable" title="UnannTypeVariable">UnannTypeVariable</a> <a href="jls-4.html#jls-Dims" title="Dims">Dims</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="note">The following production from
               <a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a> is shown here for convenience:
            </p>
            <div id="d5e12386" class="productionset"><a name="d5e12386"></a>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">Dims:</div>
                         
                     <div class="rhs">
                              {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code> {{<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code>}
                            
                     </div>
                       
                  </div>
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-8.3-200"></a>
               Each declarator in a <span class="emphasis"><em>FieldDeclaration</em></span> declares
               one field. The <span class="emphasis"><em>Identifier</em></span> in a declarator may be used in a name to
               refer to the field.
            </p>
            <p class="norm-static"><a name="jls-8.3-210"></a>
               More than one field may be declared in a single 
               <span class="emphasis"><em>FieldDeclaration</em></span> by using more than one
               declarator; the <span class="emphasis"><em>FieldModifier</em></span>s
               and <span class="emphasis"><em>UnannType</em></span> apply to all the declarators in the
               declaration.
            </p>
            <p class="norm-static"><a name="jls-8.3-220"></a>
               The <span class="emphasis"><em>FieldModifier</em></span> clause is described in
               <a class="xref" href="jls-8.html#jls-8.3.1" title="8.3.1.&nbsp;Field Modifiers">&sect;8.3.1</a>.
            </p>
            <p class="norm-static"><a name="jls-8.3-230"></a>
               
               The declared type of a field is denoted by <span class="emphasis"><em>UnannType</em></span> 
               if no bracket pairs appear in <span class="emphasis"><em>UnannType</em></span>
               and <span class="emphasis"><em>VariableDeclaratorId</em></span>, and is specified by
               <a class="xref" href="jls-10.html#jls-10.2" title="10.2.&nbsp;Array Variables">&sect;10.2</a> otherwise.
            </p>
            <p class="norm-static"><a name="jls-8.3-300"></a>
               The scope and shadowing of a field declaration is specified in
               <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
            </p>
            <p class="norm-error"><a name="jls-8.3-310"></a>
               It is a compile-time error for the body of a class declaration to
               declare two fields with the same name.
            </p>
            <p class="norm-static"><a name="jls-8.3-320"></a>
               If a class declares a field with a certain name, then the declaration
               of that field is said to <span class="emphasis"><em>hide</em></span> any and all
               accessible declarations of fields with the same name in superclasses,
               and superinterfaces of the class.
            </p>
            <p class="note">In this respect, hiding of fields differs from
               hiding of methods (<a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>), for there is no
               distinction drawn between <code class="literal">static</code> and non-<code class="literal">static</code> fields in field
               hiding whereas a distinction is drawn between <code class="literal">static</code> and
               non-<code class="literal">static</code> methods in method hiding.
            </p>
            <p class="norm-static"><a name="jls-8.3-330"></a>
               A hidden field can be accessed by using a qualified name
               (<a class="xref" href="jls-6.html#jls-6.5.6.2" title="6.5.6.2.&nbsp;Qualified Expression Names">&sect;6.5.6.2</a>) if it is <code class="literal">static</code>, or by using a field
               access expression that contains the keyword <code class="literal">super</code>
               (<a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>) or a cast to a superclass type.
            </p>
            <p class="note">In this respect, hiding of fields is similar to
               hiding of methods.
            </p>
            <p class="norm-static"><a name="jls-8.3-340"></a>
               If a field declaration hides the declaration of another field, the two
               fields need not have the same type.
            </p>
            <p class="norm-static"><a name="jls-8.3-400"></a>
               A class inherits from its direct superclass and direct superinterfaces
               all the non-<code class="literal">private</code> fields of the superclass and superinterfaces
               that are both accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) to code in the
               class and not hidden by a declaration in the class.
            </p>
            <p class="norm-static"><a name="jls-8.3-410"></a>
               A <code class="literal">private</code> field of a superclass might be accessible to a subclass -
               for example, if both classes are members of the same class. 
               Nevertheless, a <code class="literal">private</code> field is never inherited by a subclass.
            </p>
            <p class="norm-error"><a name="jls-8.3-420"></a>
               It is possible for a class to inherit more than one field with the
               same name, either from its superclass and superinterfaces or from its
               superinterfaces alone. Such a situation does not in itself cause a
               compile-time error. However, any attempt within the body of the class
               to refer to any such field by its simple name will result in a
               compile-time error, because the reference is ambiguous.
            </p>
            <p class="norm-static"><a name="jls-8.3-430"></a>
               There might be several paths by which the same field declaration is
               inherited from an interface. In such a situation, the field is
               considered to be inherited only once, and it may be referred to by its
               simple name without ambiguity.
            </p>
            <p class="norm-static"><a name="jls-8.3-500"></a>
               A value stored in a field of type <code class="literal">float</code> is always an element of the
               float value set (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>); similarly, a value
               stored in a field of type <code class="literal">double</code> is always an element of the double
               value set. It is not permitted for a field of type <code class="literal">float</code> to contain
               an element of the float-extended-exponent value set that is not also
               an element of the float value set, nor for a field of type <code class="literal">double</code> to
               contain an element of the double-extended-exponent value set that is
               not also an element of the double value set.
            </p>
            <div class="example"><a name="d5e12437"></a><p class="title"><b>Example&nbsp;8.3-1.&nbsp;Multiply Inherited Fields</b></p>
               <div class="example-contents">
                  <p class="note">A class may inherit two or more fields with the same
                     name, either from its superclass and a superinterface or from two
                     superinterfaces. A compile-time error occurs on any attempt to refer
                     to any ambiguously inherited field by its simple name. A qualified
                     name or a field access expression that contains the keyword <code class="literal">super</code>
                     (<a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>) may be used to access such fields
                     unambiguously. In the program:
                  </p><pre class="programlisting">
interface Frob  { float v = 2.0f; }
class SuperTest { int   v = 3; }
class Test extends SuperTest implements Frob {
    public static void main(String[] args) {
        new Test().printV();
    }
    void printV() { System.out.println(v); }
}
</pre><p class="note">the class <code class="literal">Test</code> inherits two
                     fields named <code class="literal">v</code>, one from its
                     superclass <code class="literal">SuperTest</code> and one from its
                     superinterface <code class="literal">Frob</code>. This in itself is permitted,
                     but a compile-time error occurs because of the use of the simple
                     name <code class="literal">v</code> in method <code class="literal">printV</code>: it
                     cannot be determined which <code class="literal">v</code> is intended.
                  </p>
                  <p class="note">The following variation uses the field access
                     expression <code class="literal">super.v</code> to refer to the field
                     named <code class="literal">v</code> declared in
                     class <code class="literal">SuperTest</code> and uses the qualified
                     name <code class="literal">Frob.v</code> to refer to the field
                     named <code class="literal">v</code> declared in
                     interface <code class="literal">Frob</code>:
                  </p><pre class="programlisting">
interface Frob  { float v = 2.0f; }
class SuperTest { int   v = 3; }
class Test extends SuperTest implements Frob {
    public static void main(String[] args) {
        new Test().printV();
    }
    void printV() {
        System.out.println((super.v + Frob.v)/2);
    }
}
</pre><p class="note">It compiles and prints:</p><pre class="screen">
2.5
</pre><p class="note">Even if two distinct inherited fields have the same
                     type, the same value, and are both <code class="literal">final</code>, any reference to either
                     field by simple name is considered ambiguous and results in a
                     compile-time error. In the program:
                  </p><pre class="programlisting">
interface Color        { int RED=0, GREEN=1,  BLUE=2;  }
interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; }
class Test implements Color, TrafficLight {
    public static void main(String[] args) {
        System.out.println(GREEN);  // compile-time error
        System.out.println(RED);    // compile-time error
    }
}
</pre><p class="note">it is not astonishing that the reference
                     to <code class="literal">GREEN</code> should be considered ambiguous, because
                     class <code class="literal">Test</code> inherits two different declarations
                     for <code class="literal">GREEN</code> with different values. The point of this
                     example is that the reference to <code class="literal">RED</code> is also
                     considered ambiguous, because two distinct declarations are
                     inherited. The fact that the two fields named <code class="literal">RED</code>
                     happen to have the same type and the same unchanging value does not
                     affect this judgment.
                  </p>
               </div>
            </div><br class="example-break"><div class="example"><a name="d5e12470"></a><p class="title"><b>Example&nbsp;8.3-2.&nbsp;Re-inheritance of Fields</b></p>
               <div class="example-contents">
                  <p class="note">If the same field declaration is inherited from an
                     interface by multiple paths, the field is considered to be inherited
                     only once. It may be referred to by its simple name without
                     ambiguity. For example, in the code:
                  </p><pre class="programlisting">
interface Colorable {
    int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff;
}
interface Paintable extends Colorable {
    int MATTE = 0, GLOSSY = 1;
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {}
class PaintedPoint extends ColoredPoint implements Paintable {
    int p = RED;
}
</pre><p class="note">the
                     fields <code class="literal">RED</code>, <code class="literal">GREEN</code>,
                     and <code class="literal">BLUE</code> are inherited by the
                     class <code class="literal">PaintedPoint</code> both through its direct
                     superclass <code class="literal">ColoredPoint</code> and through its direct
                     superinterface <code class="literal">Paintable</code>. The simple
                     names <code class="literal">RED</code>, <code class="literal">GREEN</code>,
                     and <code class="literal">BLUE</code> may nevertheless be used without ambiguity
                     within the class <code class="literal">PaintedPoint</code> to refer to the
                     fields declared in interface <code class="literal">Colorable</code>.
                  </p>
               </div>
            </div><br class="example-break"><div class="section" title="8.3.1.&nbsp;Field Modifiers">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.3.1"></a>8.3.1.&nbsp;Field Modifiers
                        </h3>
                     </div>
                  </div>
               </div>
               <div id="jls-8.3.1-100" class="productionset"><a name="jls-8.3.1-100"></a>
                    
                  <div class="production"><a name="jls-FieldModifier"></a>
                         
                     <div class="lhs">FieldModifier:</div>
                         
                     <div class="rhs">
                              (one of) <br>
                              <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <code class="literal">public</code> <code class="literal">protected</code> <code class="literal">private</code> <br>
                              <code class="literal">static</code> <code class="literal">final</code> <code class="literal">transient</code> <code class="literal">volatile</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.3.1-110"></a>
                  The rules for annotation modifiers on a field declaration are
                  specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Type">&sect;9.7.5</a>.
               </p>
               <p class="norm-error"><a name="jls-8.3.1-200"></a>
                  It is a compile-time error if the same keyword appears more than once
                  as a modifier for a field declaration, or if a field declaration
                  has more than one of the access modifiers <code class="literal">public</code>, <code class="literal">protected</code>, and
                  <code class="literal">private</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>).
               </p>
               <p class="note">If two or more (distinct) field modifiers appear in
                  a field declaration, it is customary, though not required, that they
                  appear in the order consistent with that shown above in the production
                  for <span class="emphasis"><em>FieldModifier</em></span>.
               </p>
               <div class="section" title="8.3.1.1.&nbsp;static Fields">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.3.1.1"></a>8.3.1.1.&nbsp;<code class="literal">static</code> Fields
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.3.1.1-100"></a>
                     If a field is declared <code class="literal">static</code>, there exists exactly one incarnation
                     of the field, no matter how many instances (possibly zero) of the
                     class may eventually be created. A <code class="literal">static</code> field, sometimes called a
                     class variable, is incarnated when the class is initialized
                     (<a class="xref" href="jls-12.html#jls-12.4" title="12.4.&nbsp;Initialization of Classes and Interfaces">&sect;12.4</a>).
                  </p>
                  <p class="norm-static"><a name="jls-8.3.1.1-110"></a>
                     A field that is not declared <code class="literal">static</code> (sometimes called a non-<code class="literal">static</code>
                     field) is called an <span class="emphasis"><em>instance variable</em></span>. Whenever a
                     new instance of a class is created (<a class="xref" href="jls-12.html#jls-12.5" title="12.5.&nbsp;Creation of New Class Instances">&sect;12.5</a>), a new
                     variable associated with that instance is created for every instance
                     variable declared in that class or any of its superclasses.
                  </p>
                  <div class="example"><a name="d5e12522"></a><p class="title"><b>Example&nbsp;8.3.1.1-1.&nbsp;<code class="literal">static</code> Fields</b></p>
                     <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y, useCount;
    Point(int x, int y) { this.x = x; this.y = y; }
    static final Point origin = new Point(0, 0);
}
class Test {
    public static void main(String[] args) {
        Point p = new Point(1,1);
        Point q = new Point(2,2);
        p.x = 3;
        p.y = 3;
        p.useCount++;
        p.origin.useCount++;
        System.out.println("(" + q.x + "," + q.y + ")");
        System.out.println(q.useCount);
        System.out.println(q.origin == Point.origin);
        System.out.println(q.origin.useCount);
    }
}
</pre><p class="note">This program prints:</p><pre class="screen">
(2,2)
0
true
1
</pre><p class="note">showing that changing the
                           fields <code class="literal">x</code>, <code class="literal">y</code>,
                           and <code class="literal">useCount</code> of <code class="literal">p</code> does not
                           affect the fields of <code class="literal">q</code>, because these fields are
                           instance variables in distinct objects. In this example, the class
                           variable <code class="literal">origin</code> of the
                           class <code class="literal">Point</code> is referenced both using the class name
                           as a qualifier, in <code class="literal">Point.origin</code>, and using
                           variables of the class type in field access expressions
                           (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>), as in <code class="literal">p.origin</code>
                           and <code class="literal">q.origin</code>. These two ways of accessing
                           the <code class="literal">origin</code> class variable access the same object,
                           evidenced by the fact that the value of the reference equality
                           expression (<a class="xref" href="jls-15.html#jls-15.21.3" title="15.21.3.&nbsp;Reference Equality Operators == and !=">&sect;15.21.3</a>):
                        </p><pre class="screen">
q.origin==Point.origin
</pre><p class="note">is true. Further evidence is that the
                           incrementation:
                        </p><pre class="screen">
p.origin.useCount++;
</pre><p class="note">causes the value
                           of <code class="literal">q.origin.useCount</code> to be <code class="literal">1</code>;
                           this is so because <code class="literal">p.origin</code>
                           and <code class="literal">q.origin</code> refer to the same variable.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e12550"></a><p class="title"><b>Example&nbsp;8.3.1.1-2.&nbsp;Hiding of Class Variables</b></p>
                     <div class="example-contents"><pre class="programlisting">
class Point {
    static int x = 2;
}
class Test extends Point {
    static double x = 4.7;
    public static void main(String[] args) {
        new Test().printX();
    }
    void printX() {
        System.out.println(x + " " + super.x);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
4.7 2
</pre><p class="note">because the declaration of <code class="literal">x</code> in
                           class <code class="literal">Test</code> hides the definition
                           of <code class="literal">x</code> in class <code class="literal">Point</code>, so
                           class <code class="literal">Test</code> does not inherit the
                           field <code class="literal">x</code> from its
                           superclass <code class="literal">Point</code>. Within the declaration of
                           class <code class="literal">Test</code>, the simple name <code class="literal">x</code>
                           refers to the field declared within
                           class <code class="literal">Test</code>. Code in class <code class="literal">Test</code>
                           may refer to the field <code class="literal">x</code> of
                           class <code class="literal">Point</code> as <code class="literal">super.x</code> (or,
                           because <code class="literal">x</code> is <code class="literal">static</code>,
                           as <code class="literal">Point.x</code>). If the declaration
                           of <code class="literal">Test.x</code> is deleted:
                        </p><pre class="programlisting">
class Point {
    static int x = 2;
}
class Test extends Point {
    public static void main(String[] args) {
        new Test().printX();
    }
    void printX() {
        System.out.println(x + " " + super.x);
    }
}
</pre><p class="note">then the field <code class="literal">x</code> of
                           class <code class="literal">Point</code> is no longer hidden within
                           class <code class="literal">Test</code>; instead, the simple
                           name <code class="literal">x</code> now refers to the
                           field <code class="literal">Point.x</code>. Code in
                           class <code class="literal">Test</code> may still refer to that same field
                           as <code class="literal">super.x</code>. Therefore, the output from this variant
                           program is:
                        </p><pre class="screen">
2 2
</pre></div>
                  </div><br class="example-break"><div class="example"><a name="d5e12584"></a><p class="title"><b>Example&nbsp;8.3.1.1-3.&nbsp;Hiding of Instance Variables</b></p>
                     <div class="example-contents"><pre class="programlisting">
class Point {
    int x = 2;
}
class Test extends Point {
    double x = 4.7;
    void printBoth() {
        System.out.println(x + " " + super.x);
    }
    public static void main(String[] args) {
        Test sample = new Test();
        sample.printBoth();
        System.out.println(sample.x + " " + ((Point)sample).x);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
4.7 2
4.7 2
</pre><p class="note">because the declaration of <code class="literal">x</code> in
                           class <code class="literal">Test</code> hides the definition
                           of <code class="literal">x</code> in class <code class="literal">Point</code>, so
                           class <code class="literal">Test</code> does not inherit the
                           field <code class="literal">x</code> from its
                           superclass <code class="literal">Point</code>. It must be noted, however, that
                           while the field <code class="literal">x</code> of class <code class="literal">Point</code>
                           is not inherited by class <code class="literal">Test</code>, it is
                           nevertheless <span class="emphasis"><em>implemented</em></span> by instances of
                           class <code class="literal">Test</code>. In other words, every instance of
                           class <code class="literal">Test</code> contains two fields, one of type <code class="literal">int</code>
                           and one of type <code class="literal">double</code>. Both fields bear the
                           name <code class="literal">x</code>, but within the declaration of
                           class <code class="literal">Test</code>, the simple name <code class="literal">x</code>
                           always refers to the field declared within
                           class <code class="literal">Test</code>. Code in instance methods of
                           class <code class="literal">Test</code> may refer to the instance
                           variable <code class="literal">x</code> of class <code class="literal">Point</code>
                           as <code class="literal">super.x</code>.
                        </p>
                        <p class="note">Code that uses a field access expression to access
                           field <code class="literal">x</code> will access the field
                           named <code class="literal">x</code> in the class indicated by the type of
                           reference expression. Thus, the expression <code class="literal">sample.x</code>
                           accesses a <code class="literal">double</code> value, the instance variable declared in
                           class <code class="literal">Test</code>, because the type of the
                           variable <code class="literal">sample</code> is <code class="literal">Test</code>, but the
                           expression <code class="literal">((Point)sample).x</code> accesses an <code class="literal">int</code>
                           value, the instance variable declared in
                           class <code class="literal">Point</code>, because of the cast to
                           type <code class="literal">Point</code>.
                        </p>
                        <p class="note">If the declaration of <code class="literal">x</code> is
                           deleted from class <code class="literal">Test</code>, as in the program:
                        </p><pre class="programlisting">
class Point {
    static int x = 2;
}
class Test extends Point {
    void printBoth() {
        System.out.println(x + " " + super.x);
    }
    public static void main(String[] args) {
        Test sample = new Test();
        sample.printBoth();
        System.out.println(sample.x + " " +	((Point)sample).x);
    }
}
</pre><p class="note">then the field <code class="literal">x</code> of
                           class <code class="literal">Point</code> is no longer hidden within
                           class <code class="literal">Test</code>. Within instance methods in the
                           declaration of class <code class="literal">Test</code>, the simple
                           name <code class="literal">x</code> now refers to the field declared within
                           class <code class="literal">Point</code>. Code in class <code class="literal">Test</code>
                           may still refer to that same field as <code class="literal">super.x</code>. The
                           expression <code class="literal">sample.x</code> still refers to the
                           field <code class="literal">x</code> within type <code class="literal">Test</code>, but
                           that field is now an inherited field, and so refers to the
                           field <code class="literal">x</code> declared in
                           class <code class="literal">Point</code>. The output from this variant program
                           is:
                        </p><pre class="screen">
2 2
2 2
</pre></div>
                  </div><br class="example-break"></div>
               <div class="section" title="8.3.1.2.&nbsp;final Fields">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.3.1.2"></a>8.3.1.2.&nbsp;<code class="literal">final</code> Fields
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.3.1.2-100"></a>
                     A field can be declared <code class="literal">final</code> (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>). Both
                     class and instance variables (<code class="literal">static</code> and non-<code class="literal">static</code> fields) may be
                     declared <code class="literal">final</code>.
                  </p>
                  <p class="norm-error"><a name="jls-8.3.1.2-110"></a>
                     A blank <code class="literal">final</code> class variable must be definitely assigned by a static
                     initializer of the class in which it is declared, or a compile-time
                     error occurs (<a class="xref" href="jls-8.html#jls-8.7" title="8.7.&nbsp;Static Initializers">&sect;8.7</a>,
                     <a class="xref" href="jls-16.html#jls-16.8" title="16.8.&nbsp;Definite Assignment and Static Initializers">&sect;16.8</a>).
                  </p>
                  <p class="norm-error"><a name="jls-8.3.1.2-120"></a>
                     A blank <code class="literal">final</code> instance variable must be definitely assigned and
                     moreover not definitely unassigned at the end of every constructor of
                     the class in which it is declared, or a compile-time error occurs
                     (<a class="xref" href="jls-8.html#jls-8.8" title="8.8.&nbsp;Constructor Declarations">&sect;8.8</a>, <a class="xref" href="jls-16.html#jls-16.9" title="16.9.&nbsp;Definite Assignment, Constructors, and Instance Initializers">&sect;16.9</a>).
                  </p>
               </div>
               <div class="section" title="8.3.1.3.&nbsp;transient Fields">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.3.1.3"></a>8.3.1.3.&nbsp;<code class="literal">transient</code> Fields
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.3.1.3-100"></a>Variables may be marked <code class="literal">transient</code> to
                     indicate that they are not part of the persistent state of an
                     object.
                  </p>
                  <div class="example"><a name="d5e12666"></a><p class="title"><b>Example&nbsp;8.3.1.3-1.&nbsp;Persistence of <code class="literal">transient</code> Fields</b></p>
                     <div class="example-contents">
                        <p class="note">If an instance of the
                           class <code class="literal">Point</code>:
                        </p><pre class="programlisting">

class Point {
    int x, y;
    transient float rho, theta;
}

</pre><p class="note">were saved to persistent storage by a system
                           service, then only the fields <code class="literal">x</code>
                           and <code class="literal">y</code> would be saved. This specification does not
                           specify details of such services; see the specification of
                           <code class="literal">java.io.Serializable</code> for an example of such a service.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
               <div class="section" title="8.3.1.4.&nbsp;volatile Fields">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.3.1.4"></a>8.3.1.4.&nbsp;<code class="literal">volatile</code> Fields
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-8.3.1.4-100"></a>The Java programming language allows
                     threads to access shared variables (<a class="xref" href="jls-17.html#jls-17.1" title="17.1.&nbsp;Synchronization">&sect;17.1</a>). As a
                     rule, to ensure that shared variables are consistently and reliably
                     updated, a thread should ensure that it has exclusive use of such
                     variables by obtaining a lock that, conventionally, enforces mutual
                     exclusion for those shared variables.
                  </p>
                  <p class="norm"><a name="jls-8.3.1.4-110"></a>The Java programming language provides a
                     second mechanism, <code class="literal">volatile</code> fields, that is more convenient than
                     locking for some purposes.
                  </p>
                  <p class="norm-dynamic"><a name="jls-8.3.1.4-200"></a>A field
                     may be declared <code class="literal">volatile</code>, in which case the Java Memory Model
                     ensures that all threads see a consistent value for the variable
                     (<a class="xref" href="jls-17.html#jls-17.4" title="17.4.&nbsp;Memory Model">&sect;17.4</a>).
                  </p>
                  <p class="norm-error"><a name="jls-8.3.1.4-210"></a>It is a
                     compile-time error if a <code class="literal">final</code> variable is also declared
                     <code class="literal">volatile</code>.
                  </p>
                  <div class="example"><a name="d5e12689"></a><p class="title"><b>Example&nbsp;8.3.1.4-1.&nbsp;<code class="literal">volatile</code> Fields</b></p>
                     <div class="example-contents">
                        <p class="note">If, in the following example, one thread repeatedly
                           calls the method <code class="literal">one</code> (but no more
                           than <code class="literal">Integer.MAX_VALUE</code> times in all), and another
                           thread repeatedly calls the method <code class="literal">two</code>:
                        </p><pre class="programlisting">
class Test {
    static int i = 0, j = 0;
    static void one() { i++; j++; }
    static void two() {
        System.out.println("i=" + i + " j=" + j);
    }
}
</pre><p class="note">then method <code class="literal">two</code> could
                           occasionally print a value for <code class="literal">j</code> that is greater
                           than the value of <code class="literal">i</code>, because the example includes
                           no synchronization and, under the rules explained in
                           <a class="xref" href="jls-17.html#jls-17.4" title="17.4.&nbsp;Memory Model">&sect;17.4</a>, the shared values of <code class="literal">i</code>
                           and <code class="literal">j</code> might be updated out of order.
                        </p>
                        <p class="note">One way to prevent this out-or-order behavior would
                           be to declare methods <code class="literal">one</code>
                           and <code class="literal">two</code> to be <code class="literal">synchronized</code>
                           (<a class="xref" href="jls-8.html#jls-8.4.3.6" title="8.4.3.6.&nbsp;synchronized Methods">&sect;8.4.3.6</a>):
                        </p><pre class="programlisting">
class Test {
    static int i = 0, j = 0;
    static synchronized void one() { i++; j++; }
    static synchronized void two() {
        System.out.println("i=" + i + " j=" + j);
    }
}
</pre><p class="note">This prevents method <code class="literal">one</code> and
                           method <code class="literal">two</code> from being executed concurrently, and
                           furthermore guarantees that the shared values of <code class="literal">i</code>
                           and <code class="literal">j</code> are both updated before
                           method <code class="literal">one</code> returns. Therefore
                           method <code class="literal">two</code> never observes a value
                           for <code class="literal">j</code> greater than that for <code class="literal">i</code>;
                           indeed, it always observes the same value for <code class="literal">i</code>
                           and <code class="literal">j</code>.
                        </p>
                        <p class="note">Another approach would be to
                           declare <code class="literal">i</code> and <code class="literal">j</code> to be
                           <code class="literal">volatile</code>:
                        </p><pre class="programlisting">
class Test {
    static volatile int i = 0, j = 0;
    static void one() { i++; j++; }
    static void two() {
        System.out.println("i=" + i + " j=" + j);
    }
}
</pre><p class="note">This allows method <code class="literal">one</code> and
                           method <code class="literal">two</code> to be executed concurrently, but
                           guarantees that accesses to the shared values for <code class="literal">i</code>
                           and <code class="literal">j</code> occur exactly as many times, and in exactly
                           the same order, as they appear to occur during execution of the
                           program text by each thread. Therefore, the shared value
                           for <code class="literal">j</code> is never greater than that
                           for <code class="literal">i</code>, because each update to <code class="literal">i</code>
                           must be reflected in the shared value for <code class="literal">i</code> before
                           the update to <code class="literal">j</code> occurs. It is possible, however,
                           that any given invocation of method <code class="literal">two</code> might
                           observe a value for <code class="literal">j</code> that is much greater than the
                           value observed for <code class="literal">i</code>, because
                           method <code class="literal">one</code> might be executed many times between the
                           moment when method <code class="literal">two</code> fetches the value
                           of <code class="literal">i</code> and the moment when method two fetches the
                           value of <code class="literal">j</code>.
                        </p>
                        <p class="note">See <a class="xref" href="jls-17.html#jls-17.4" title="17.4.&nbsp;Memory Model">&sect;17.4</a> for more discussion
                           and examples.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
            </div>
            <div class="section" title="8.3.2.&nbsp;Field Initialization">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.3.2"></a>8.3.2.&nbsp;Field Initialization
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.3.2-100"></a>
                  If a declarator in a field declaration has a <span class="emphasis"><em>variable
                        initializer</em></span>, then the declarator has the semantics of an
                  assignment (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>) to the declared variable.
               </p>
               <p class="norm-static"><a name="jls-8.3.2-200"></a>
                  If the declarator is for a class variable (that is, a <code class="literal">static</code> field),
                  then the following rules apply to its initializer:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-8.3.2-200-A"></a>
                                 It is a compile-time error if a reference by simple name to any
                                 instance variable occurs in the initializer.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-8.3.2-200-B"></a>
                                 It is a compile-time error if the keyword <code class="literal">this</code>
                                 (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>) or the keyword <code class="literal">super</code>
                                 (<a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>, <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
                                 occurs in the initializer.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-8.3.2-200-C"></a>
                                 At run time, the initializer is evaluated and the assignment
                                 performed exactly once, when the class is initialized
                                 (<a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>).
                        </p>
                        <p class="norm-dynamic"><a name="jls-8.3.2-200-C.1"></a>
                                 
                                 Note that <code class="literal">static</code> fields that are
                                 
                                 constant variables (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>) are
                                 initialized before other <code class="literal">static</code> fields (<a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>).
                                 This also applies in interfaces (<a class="xref" href="jls-9.html#jls-9.3.1" title="9.3.1.&nbsp;Initialization of Fields in Interfaces">&sect;9.3.1</a>).
                           
                                 When such fields are referenced by simple name, they will never
                                 be observed to have their default initial values
                                 (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-8.3.2-300"></a>
                  If the declarator is for an instance variable (that is, a field that
                  is not <code class="literal">static</code>), then the following rules apply to its initializer:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.2-300-A"></a>
                                 The initializer may refer by simple name to any class variable
                                 declared in or inherited by the class, even one whose
                                 declaration occurs  to the right of the
                                 initializer (<a class="xref" href="jls-3.html#jls-3.5" title="3.5.&nbsp;Input Elements and Tokens">&sect;3.5</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.2-300-B"></a>
                                 The initializer may refer to the current object using the
                                 keyword <code class="literal">this</code> (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>) or the keyword
                                 <code class="literal">super</code> (<a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>, <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-8.3.2-300-C"></a>
                                 At run time, the initializer is evaluated and the assignment
                                 performed each time an instance of the class is created
                                 (<a class="xref" href="jls-12.html#jls-12.5" title="12.5.&nbsp;Creation of New Class Instances">&sect;12.5</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-8.3.2-310"></a>
                  References from variable initializers to fields that may not yet be
                  initialized are subject to additional restrictions, as specified in
                  <a class="xref" href="jls-8.html#jls-8.3.3" title="8.3.3.&nbsp;Restrictions on Field References in Initializers">&sect;8.3.3</a> and <a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>.
               </p>
               <p class="norm-static"><a name="jls-8.3.2-400"></a>
                  Exception checking for a variable initializer in a field declaration
                  is specified in <a class="xref" href="jls-11.html#jls-11.2.3" title="11.2.3.&nbsp;Exception Checking">&sect;11.2.3</a>.
               </p>
               <p class="note">Variable initializers are also used in local
                  variable declaration statements (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>), where
                  the initializer is evaluated and the assignment performed each time
                  the local variable declaration statement is executed.
               </p>
               <div class="example"><a name="d5e12796"></a><p class="title"><b>Example&nbsp;8.3.2-1.&nbsp;Field Initialization</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    int x = 1, y = 5;
}
class Test {
    public static void main(String[] args) {
        Point p = new Point();
        System.out.println(p.x + ", " + p.y);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
1, 5
</pre><p class="note">because the assignments to <code class="literal">x</code>
                        and <code class="literal">y</code> occur whenever a new <code class="literal">Point</code>
                        is created.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e12805"></a><p class="title"><b>Example&nbsp;8.3.2-2.&nbsp;Forward Reference to a Class Variable</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    float f = j;
    static int j = 1;
}
</pre><p class="note">This program compiles without error; it
                        initializes <code class="literal">j</code> to <code class="literal">1</code> when
                        class <code class="literal">Test</code> is initialized, and
                        initializes <code class="literal">f</code> to the current value
                        of <code class="literal">j</code> every time an instance of
                        class <code class="literal">Test</code> is created.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="8.3.3.&nbsp;Restrictions on Field References in Initializers">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.3.3"></a>8.3.3.&nbsp;Restrictions on Field References in Initializers
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-8.3.3-100"></a>
                  References to a field are sometimes restricted, even through the field
                  is in scope. The following rules constrain forward references to a
                  field (where the use textually precedes the field declaration)
                  as well as self-reference (where the field is used in its own initializer).
               </p>
               <p class="norm-error"><a name="jls-8.3.3-200"></a>
                  For a reference by simple name to a class variable <code class="varname">f</code> declared in
                  class or interface <span class="type">C</span>, it is a compile-time error if:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.3-200-A"></a>
                                 The reference appears either in a class variable initializer of
                                 <span class="type">C</span> or in a static initializer of <span class="type">C</span>
                                 (<a class="xref" href="jls-8.html#jls-8.7" title="8.7.&nbsp;Static Initializers">&sect;8.7</a>); and
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.3-200-B"></a>
                                 The reference appears either in the initializer of <code class="varname">f</code>'s own
                                 declarator or at a point to the left of <code class="varname">f</code>'s declarator;
                                 and
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.3-200-C"></a>
                                 The reference is <span class="emphasis"><em>not</em></span> on the left hand side
                                 of an assignment expression (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>);
                                 and
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.3-200-D"></a>
                                 The innermost class or interface enclosing the reference is <span class="type">C</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-error"><a name="jls-8.3.3-300"></a>
                  For a reference by simple name to an instance variable <code class="varname">f</code> declared in
                  class <span class="type">C</span>, it is a compile-time error if:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.3-300-A"></a>
                                 The reference appears either in an instance variable initializer
                                 of <span class="type">C</span> or in an instance initializer of <span class="type">C</span>
                                 (<a class="xref" href="jls-8.html#jls-8.6" title="8.6.&nbsp;Instance Initializers">&sect;8.6</a>); and
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.3-300-B"></a>
                                 The reference appears in the initializer of <code class="varname">f</code>'s own declarator
                                 or at a point to the left of <code class="varname">f</code>'s declarator; and
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.3-300-C"></a>
                                 The reference is <span class="emphasis"><em>not</em></span> on the left hand side
                                 of an assignment expression (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>);
                                 and
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.3.3-300-D"></a>
                                 The innermost class enclosing the reference is <span class="type">C</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e12858"></a><p class="title"><b>Example&nbsp;8.3.3-1.&nbsp;Restrictions on Field References</b></p>
                  <div class="example-contents">
                     <p class="note">A compile-time error occurs for this program:</p><pre class="programlisting">
class Test1 {
    int i = j;  // compile-time error:
                // incorrect forward reference
    int j = 1;
}
</pre><p class="note">whereas the following program compiles without
                        error:
                     </p><pre class="programlisting">
class Test2 {
    Test2() { k = 2; }
    int j = 1;
    int i = j;
    int k;
}
</pre><p class="note">even though the constructor
                        for <code class="literal">Test2</code> (<a class="xref" href="jls-8.html#jls-8.8" title="8.8.&nbsp;Constructor Declarations">&sect;8.8</a>) refers to the
                        field <code class="literal">k</code> that is declared three lines later.
                     </p>
                     <p class="note">The restrictions above are designed to catch, at
                        compile time, circular or otherwise malformed initializations. Thus,
                        both:
                     </p><pre class="programlisting">
class Z {
    static int i = j + 2; 
    static int j = 4;
}
</pre><p class="note">and:</p><pre class="programlisting">
class Z {
    static { i = j + 2; }
    static int i, j;
    static { j = 4; }
}
</pre><p class="note">result in compile-time errors. Accesses by methods
                        are not checked in this way, so:
                     </p><pre class="programlisting">
class Z {
    static int peek() { return j; }
    static int i = peek();
    static int j = 1;
}
class Test {
    public static void main(String[] args) {
        System.out.println(Z.i);
    }
}
</pre><p class="note">produces the output:</p><pre class="screen">
0
</pre><p class="note">because the variable initializer
                        for <code class="literal">i</code> uses the class method <code class="literal">peek</code>
                        to access the value of the variable <code class="literal">j</code>
                        before <code class="literal">j</code> has been initialized by its variable
                        initializer, at which point it still has its default value
                        (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>).
                     </p>
                     <p class="note">A more elaborate example is:</p><pre class="programlisting">
class UseBeforeDeclaration {
    static {
        x = 100;
          // ok - assignment
        int y = x + 1;
          // error - read before declaration
        int v = x = 3;
          // ok - x at left hand side of assignment
        int z = UseBeforeDeclaration.x * 2;
          // ok - not accessed via simple name

        Object o = new Object() { 
            void foo() { x++; }
              // ok - occurs in a different class
            { x++; }
              // ok - occurs in a different class
        };
    }

    {
        j = 200;
          // ok - assignment
        j = j + 1;
          // error - right hand side reads before declaration
        int k = j = j + 1;
          // error - illegal forward reference to j
        int n = j = 300;
          // ok - j at left hand side of assignment
        int h = j++;
          // error - read before declaration
        int l = this.j * 3;
          // ok - not accessed via simple name

        Object o = new Object() { 
            void foo(){ j++; }
              // ok - occurs in a different class
            { j = j + 1; }
              // ok - occurs in a different class
        };
    }

    int w = x = 3;
      // ok - x at left hand side of assignment
    int p = x;
      // ok - instance initializers may access static fields

    static int u =
        (new Object() { int bar() { return x; } }).bar();
	    // ok - occurs in a different class

    static int x;

    int m = j = 4;
      // ok - j at left hand side of assignment
    int o =
        (new Object() { int bar() { return j; } }).bar(); 
        // ok - occurs in a different class
    int j;
}
</pre></div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="8.4.&nbsp;Method Declarations">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-8.4"></a>8.4.&nbsp;Method Declarations
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-8.4-100"></a>
               A <span class="emphasis"><em>method</em></span> declares executable code that can be
               invoked, passing a fixed number of values as arguments.
            </p>
            <div id="jls-8.4-110" class="productionset"><a name="jls-8.4-110"></a>
                 
               <div class="production"><a name="jls-MethodDeclaration"></a>
                      
                  <div class="lhs">MethodDeclaration:</div>
                      
                  <div class="rhs">
                           {<a href="jls-8.html#jls-MethodModifier" title="MethodModifier">MethodModifier</a>} <a href="jls-8.html#jls-MethodHeader" title="MethodHeader">MethodHeader</a> <a href="jls-8.html#jls-MethodBody" title="MethodBody">MethodBody</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-MethodHeader"></a>
                      
                  <div class="lhs">MethodHeader:</div>
                      
                  <div class="rhs">
                           <a href="jls-8.html#jls-Result" title="Result">Result</a> <a href="jls-8.html#jls-MethodDeclarator" title="MethodDeclarator">MethodDeclarator</a> [<a href="jls-8.html#jls-Throws" title="Throws">Throws</a>] <br>
                     
                           <a href="jls-8.html#jls-TypeParameters" title="TypeParameters">TypeParameters</a> {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>}
                           <a href="jls-8.html#jls-Result" title="Result">Result</a> <a href="jls-8.html#jls-MethodDeclarator" title="MethodDeclarator">MethodDeclarator</a> [<a href="jls-8.html#jls-Throws" title="Throws">Throws</a>]
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-MethodDeclarator"></a>
                      
                  <div class="lhs">MethodDeclarator:</div>
                      
                  <div class="rhs">
                            <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                            <code class="literal">(</code> [<a href="jls-8.html#jls-FormalParameterList" title="FormalParameterList">FormalParameterList</a>] <code class="literal">)</code>
                            [<a href="jls-4.html#jls-Dims" title="Dims">Dims</a>]
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="note">The following production from
               <a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a> is shown here for convenience:
            </p>
            <div id="d5e12916" class="productionset"><a name="d5e12916"></a>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">Dims:</div>
                         
                     <div class="rhs">
                              {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code> {{<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code>}
                            
                     </div>
                       
                  </div>
               </div>
               
            </div>
            <p class="norm"><a name="jls-8.4-120"></a>
               The <span class="emphasis"><em>FormalParameterList</em></span> is described in
               <a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>, the <span class="emphasis"><em>MethodModifier</em></span>
               clause in <a class="xref" href="jls-8.html#jls-8.4.3" title="8.4.3.&nbsp;Method Modifiers">&sect;8.4.3</a>,
               the <span class="emphasis"><em>TypeParameters</em></span> clause in
               <a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>, the <span class="emphasis"><em>Result</em></span> clause in
               <a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>, the <span class="emphasis"><em>Throws</em></span> clause in
               <a class="xref" href="jls-8.html#jls-8.4.6" title="8.4.6.&nbsp;Method Throws">&sect;8.4.6</a>, and the <span class="emphasis"><em>MethodBody</em></span>
               in <a class="xref" href="jls-8.html#jls-8.4.7" title="8.4.7.&nbsp;Method Body">&sect;8.4.7</a>.
            </p>
            <p class="norm-static"><a name="jls-8.4-200"></a>
               The <span class="emphasis"><em>Identifier</em></span> in a <span class="emphasis"><em>MethodDeclarator</em></span> may be
               used in a name to refer to the method (<a class="xref" href="jls-6.html#jls-6.5.7.1" title="6.5.7.1.&nbsp;Simple Method Names">&sect;6.5.7.1</a>,
               <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>).
            </p>
            <p class="norm-error"><a name="jls-8.4-210"></a>
               It is a compile-time error for the body of a class declaration to
               declare as members two methods with override-equivalent signatures
               (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>).
            </p>
            <p class="norm-static"><a name="jls-8.4-300"></a>
               The scope and shadowing of a method declaration is specified in
               <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
            </p>
            <p class="norm-static"><a name="jls-8.4-400"></a>
               The declaration of a method that returns an array is allowed to place
               some or all of the bracket pairs that denote the array type after the
               formal parameter list. This syntax is supported for compatibility with
               early versions of the Java programming language. It is very strongly recommended that
               this syntax is not used in new code.
            </p>
            <div class="section" title="8.4.1.&nbsp;Formal Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.4.1"></a>8.4.1.&nbsp;Formal Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.4.1-100"></a>
                  The <span class="emphasis"><em>formal parameters</em></span> of a method or constructor,
                  if any, are specified by a list of comma-separated parameter
                  specifiers. Each parameter specifier consists of a type (optionally
                  preceded by the <code class="literal">final</code> modifier and/or one or more annotations) and
                  an identifier (optionally followed by brackets) that specifies the
                  name of the parameter.
               </p>
               <p class="norm-static"><a name="jls-8.4.1-110"></a>If a
                  method or constructor has no formal parameters, only an empty pair of
                  parentheses appears in the declaration of the method or
                  constructor.
               </p>
               <div id="jls-8.4.1-120" class="productionset"><a name="jls-8.4.1-120"></a>
                    
                  <div class="production"><a name="jls-FormalParameterList"></a>
                         
                     <div class="lhs">FormalParameterList:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-ReceiverParameter" title="ReceiverParameter">ReceiverParameter</a> <br>
                              <a href="jls-8.html#jls-FormalParameters" title="FormalParameters">FormalParameters</a> <code class="literal">,</code> <a href="jls-8.html#jls-LastFormalParameter" title="LastFormalParameter">LastFormalParameter</a> <br>
                              <a href="jls-8.html#jls-LastFormalParameter" title="LastFormalParameter">LastFormalParameter</a>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-FormalParameters"></a>
                         
                     <div class="lhs">FormalParameters:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-FormalParameter" title="FormalParameter">FormalParameter</a> {<code class="literal">,</code> <a href="jls-8.html#jls-FormalParameter" title="FormalParameter">FormalParameter</a>} <br>
                              <a href="jls-8.html#jls-ReceiverParameter" title="ReceiverParameter">ReceiverParameter</a> {<code class="literal">,</code> <a href="jls-8.html#jls-FormalParameter" title="FormalParameter">FormalParameter</a>}
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-FormalParameter"></a>
                         
                     <div class="lhs">FormalParameter:</div>
                         
                     <div class="rhs">
                              {<a href="jls-8.html#jls-VariableModifier" title="VariableModifier">VariableModifier</a>}
                              <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a>
                              <a href="jls-8.html#jls-VariableDeclaratorId" title="VariableDeclaratorId">VariableDeclaratorId</a>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-VariableModifier"></a>
                         
                     <div class="lhs">VariableModifier:</div>
                         
                     <div class="rhs">
                              <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <br>
                              <code class="literal">final</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ReceiverParameter"></a>
                         
                     <div class="lhs">ReceiverParameter:</div>
                         
                     <div class="rhs">
                              {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>}
                              <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a>
                              [<a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <code class="literal">.</code>] <code class="literal">this</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-LastFormalParameter"></a>
                         
                     <div class="lhs">LastFormalParameter:</div>
                         
                     <div class="rhs">
                              {<a href="jls-8.html#jls-VariableModifier" title="VariableModifier">VariableModifier</a>}
                              <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a> {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">...</code>
                              <a href="jls-8.html#jls-VariableDeclaratorId" title="VariableDeclaratorId">VariableDeclaratorId</a> <br>
                        
                              <a href="jls-8.html#jls-FormalParameter" title="FormalParameter">FormalParameter</a>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">The following productions from
                  <a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a> and <a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a> are shown here
                  for convenience:
               </p>
               <div id="d5e12997" class="productionset"><a name="d5e12997"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">VariableDeclaratorId:</div>
                            
                        <div class="rhs">
                                 <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> [<a href="jls-4.html#jls-Dims" title="Dims">Dims</a>]
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">Dims:</div>
                            
                        <div class="rhs">
                                 {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code> {{<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code>}
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-8.4.1-200"></a>
                  The last formal parameter of a method or constructor is special: it
                  may be a <span class="emphasis"><em>variable arity parameter</em></span>, indicated by
                  an ellipsis following the type.
               </p>
               <p class="note">Note that the ellipsis (<code class="literal">...</code>) is a token unto
                  itself (<a class="xref" href="jls-3.html#jls-3.11" title="3.11.&nbsp;Separators">&sect;3.11</a>). It is possible to put whitespace
                  between it and the type, but this is discouraged as a matter of
                  style.
               </p>
               <p class="norm-static"><a name="jls-8.4.1-210"></a>
                  If the last formal parameter is a variable arity parameter,  the method is a <span class="emphasis"><em>variable arity
                        method</em></span>. Otherwise, it is a <span class="emphasis"><em>fixed arity
                        method</em></span>.
               </p>
               <p class="norm"><a name="jls-8.4.1-220"></a>The <span class="emphasis"><em>receiver
                        parameter</em></span> is an optional syntactic device for an instance
                  method or an inner class's constructor. For an instance method, the
                  receiver parameter represents the object for which the method is
                  invoked. For an inner class's constructor, the receiver parameter
                  represents the immediately enclosing instance of the newly constructed
                  object. Either way, the receiver parameter exists solely to allow the
                  type of the represented object to be denoted in source code, so that
                  the type may be annotated. The receiver parameter is not a formal
                  parameter; more precisely, it is not a declaration of any kind of
                  variable (<a class="xref" href="jls-4.html#jls-4.12.3" title="4.12.3.&nbsp;Kinds of Variables">&sect;4.12.3</a>), it is never bound to any
                  value passed as an argument in a method invocation expression or
                  qualified class instance creation expression, and it has no effect
                  whatsoever at run time.
               </p>
               <p class="norm-error"><a name="jls-8.4.1-300"></a>
                  The rules for annotation modifiers on a formal parameter declaration
                  and on a receiver parameter are specified in
                  <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Type">&sect;9.7.5</a>.
               </p>
               <p class="norm-error"><a name="jls-8.4.1-310"></a>
                  It is a compile-time error if <code class="literal">final</code> appears more than once as a
                  modifier for a formal parameter declaration.
               </p>
               <p class="norm-error"><a name="jls-8.4.1-320"></a>
                  It is a compile-time error to use mixed array notation
                  (<a class="xref" href="jls-10.html#jls-10.2" title="10.2.&nbsp;Array Variables">&sect;10.2</a>) for a variable arity parameter.
               </p>
               <p class="norm-static"><a name="jls-8.4.1-330"></a>
                  The scope and shadowing of a formal parameter is specified in
                  <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
               </p>
               <p class="norm-error"><a name="jls-8.4.1-340"></a>
                  It is a compile-time error for a method or constructor to declare two
                  formal parameters with the same name. (That is, their declarations
                  mention the same <span class="emphasis"><em>Identifier</em></span>.)
               </p>
               <p class="norm-error"><a name="jls-8.4.1-350"></a>
                  It is a compile-time error if a formal parameter that is declared
                  <code class="literal">final</code> is assigned to within the body of the method or
                  constructor.
               </p>
               <p class="norm-error"><a name="jls-8.4.1-400"></a>
                  A receiver parameter may appear only in
                  the <span class="emphasis"><em>FormalParameterList</em></span> of an instance method or
                  an inner class's constructor; otherwise, a compile-time error
                  occurs.
               </p>
               <p class="norm-static"><a name="jls-8.4.1-410"></a>
                  Where a receiver parameter is allowed, its type and name are specified
                  as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-8.4.1-410-A"></a>
                                 In an instance method, the type of the receiver parameter must
                                 be the class or interface in which the method is declared, and
                                 the name of the receiver parameter must be <code class="literal">this</code>; otherwise, a
                                 compile-time error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-8.4.1-410-B"></a>
                                 In an inner class's constructor, the type of the receiver
                                 parameter must be the class or interface which is the
                                 immediately enclosing type declaration of the inner class, and
                                 the name of the receiver parameter must be <span class="emphasis"><em>Identifier</em></span> <code class="literal">.</code>
                                 <code class="literal">this</code> where <span class="emphasis"><em>Identifier</em></span> is the simple name of the class or
                                 interface which is the immediately enclosing type declaration of
                                 the inner class; otherwise, a compile-time error occurs.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-8.4.1-500"></a>
                  The declared type of a formal parameter depends on whether it is a
                  variable arity parameter:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.1-500-A"></a>
                                 If the formal parameter is not a variable arity parameter, then
                                 the declared type is denoted by <span class="emphasis"><em>UnannType</em></span>
                                 if no bracket pairs appear in <span class="emphasis"><em>UnannType</em></span>
                                 and <span class="emphasis"><em>VariableDeclaratorId</em></span>, and specified by
                                 <a class="xref" href="jls-10.html#jls-10.2" title="10.2.&nbsp;Array Variables">&sect;10.2</a> otherwise.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.1-500-B"></a>
                                 If the formal parameter is a variable arity parameter, then the
                                 declared type is specified by <a class="xref" href="jls-10.html#jls-10.2" title="10.2.&nbsp;Array Variables">&sect;10.2</a>. (Note
                                 that "mixed notation" is not permitted for variable arity
                                 parameters.)
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-warning"><a name="jls-8.4.1-510"></a>
                  If the declared type of a variable arity parameter has a non-reifiable
                  element type (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>), then a compile-time
                  unchecked warning occurs for the declaration of the variable arity
                  method, unless the method is annotated with <code class="literal">@SafeVarargs</code>
                  (<a class="xref" href="jls-9.html#jls-9.6.4.7" title="9.6.4.7.&nbsp;@SafeVarargs">&sect;9.6.4.7</a>) or the warning is suppressed
                  by <code class="literal">@SuppressWarnings</code> (<a class="xref" href="jls-9.html#jls-9.6.4.5" title="9.6.4.5.&nbsp;@SuppressWarnings">&sect;9.6.4.5</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-8.4.1-600"></a>When the
                  method or constructor is invoked (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), the
                  values of the actual argument expressions initialize newly created
                  parameter variables, each of the declared type, before execution of
                  the body of the method or constructor. The <span class="emphasis"><em>Identifier</em></span> that appears
                  in the <span class="emphasis"><em>DeclaratorId</em></span> may be used as a simple name
                  in the body of the method or constructor to refer to the formal
                  parameter.
               </p>
               <p class="norm-dynamic"><a name="jls-8.4.1-610"></a>
                  Invocations of a variable arity method may contain more actual
                  argument expressions than formal parameters. All the actual argument
                  expressions that do not correspond to the formal parameters preceding
                  the variable arity parameter will be evaluated and the results stored
                  into an array that will be passed to the method invocation
                  (<a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-8.4.1-620"></a>A method
                  or constructor parameter of type <code class="literal">float</code> always contains an element of
                  the float value set (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>); similarly, a method
                  or constructor parameter of type <code class="literal">double</code> always contains an element
                  of the double value set. It is not permitted for a method or
                  constructor parameter of type <code class="literal">float</code> to contain an element of the
                  float-extended-exponent value set that is not also an element of the
                  float value set, nor for a method parameter of type <code class="literal">double</code> to
                  contain an element of the double-extended-exponent value set that is
                  not also an element of the double value set.
               </p>
               <p class="norm-dynamic"><a name="jls-8.4.1-630"></a>Where an
                  actual argument expression corresponding to a parameter variable is
                  not FP-strict (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>), evaluation of that actual
                  argument expression is permitted to use intermediate values drawn from
                  the appropriate extended-exponent value sets. Prior to being stored in
                  the parameter variable, the result of such an expression is mapped to
                  the nearest value in the corresponding standard value set by being
                  subjected to invocation conversion (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>).
               </p>
               <div class="informalexample">
                  <p class="note">Here are some examples of receiver parameters in
                     instance methods and inner classes' constructors:
                  </p><pre class="programlisting">

class Test {
    Test(/* ?? ?? */) {}
      // No receiver parameter is permitted in the constructor of
      // a top level class, as there is no conceivable type or name.

    void m(Test this) {}
      // OK: receiver parameter in an instance method

    static void n(Test this) {}
      // Illegal: receiver parameter in a static method                         

    class A {
        A(Test Test.this) {}
          // OK: the receiver parameter represents the instance
          // of Test which immediately encloses the instance
          // of A being constructed.

        void m(A this) {}
          // OK: the receiver parameter represents the instance 
          // of A for which A.m() is invoked.

        class B {
            B(Test.A A.this) {}
              // OK: the receiver parameter represents the instance 
              // of A which immediately encloses the instance of B 
              // being constructed.

            void m(Test.A.B this) {}
              // OK: the receiver parameter represents the instance 
              // of B for which B.m() is invoked.
        }
    }
}

</pre><p class="note"><code class="literal">B</code>'s constructor and instance
                     method show that the type of the receiver parameter may be denoted
                     with a qualified <span class="emphasis"><em>TypeName</em></span> like any other type;
                     but that the name of the receiver parameter in an inner class's
                     constructor must use the simple name of the enclosing class.
                  </p>
               </div>
            </div>
            <div class="section" title="8.4.2.&nbsp;Method Signature">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.4.2"></a>8.4.2.&nbsp;Method Signature
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.4.2-100"></a>
                  Two methods or constructors, <code class="varname">M</code> and <code class="varname">N</code>, have the <span class="emphasis"><em>same
                        signature</em></span> if they have the same name, the same type
                  parameters (if any) (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>), and, after adapting
                  the formal parameter types of <code class="varname">N</code> to the the type parameters of <code class="varname">M</code>,
                  the same formal parameter types.
               </p>
               <p class="norm"><a name="jls-8.4.2-120"></a>
                  The signature of a method <code class="varname">m<sub>1</sub></code> is a <span class="emphasis"><em>subsignature</em></span>
                  of the signature of a method <code class="varname">m<sub>2</sub></code> if either:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.4.2-120-A"></a>
                                 <code class="varname">m<sub>2</sub></code> has the same signature as <code class="varname">m<sub>1</sub></code>, or
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-8.4.2-120-B"></a>
                                 the signature of <code class="varname">m<sub>1</sub></code> is the same as the erasure
                                 (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the signature of <code class="varname">m<sub>2</sub></code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-8.4.2-130"></a>
                  Two method signatures <code class="varname">m<sub>1</sub></code> and <code class="varname">m<sub>2</sub></code> are 
                  <span class="emphasis"><em>override-equivalent</em></span> iff either <code class="varname">m<sub>1</sub></code> is a
                  subsignature of <code class="varname">m<sub>2</sub></code> or <code class="varname">m<sub>2</sub></code> is a subsignature of <code class="varname">m<sub>1</sub></code>.
               </p>
               <p class="norm-error"><a name="jls-8.4.2-200"></a>
                  It is a compile-time error to declare two methods with
                  override-equivalent signatures in a class.
               </p>
               <div class="example"><a name="d5e13120"></a><p class="title"><b>Example&nbsp;8.4.2-1.&nbsp;Override-Equivalent Signatures</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y;
    abstract void move(int dx, int dy);
    void move(int dx, int dy) { x += dx; y += dy; }
}
</pre><p class="note">This program causes a compile-time error because it
                        declares two <code class="literal">move</code> methods with the same (and hence,
                        override-equivalent) signature. This is an error even though one of
                        the declarations is <code class="literal">abstract</code>.
                     </p>
                  </div>
               </div><br class="example-break"><p class="note">The notion of subsignature is designed to express a
                  relationship between two methods whose signatures are not identical,
                  but in which one may override the other. Specifically, it allows a
                  method whose signature does not use generic types to override any
                  generified version of that method. This is important so that library
                  designers may freely generify methods independently of clients that
                  define subclasses or subinterfaces of the library.
               </p>
               <div class="informalexample">
                  <p class="note">Consider the example:</p><pre class="programlisting">

class CollectionConverter {
    List toList(Collection c) {...}
}
class Overrider extends CollectionConverter {
    List toList(Collection c) {...}
}

</pre><p class="note">Now, assume this code was written before the
                     introduction of generics, and now the author of
                     class <code class="literal">CollectionConverter</code> decides to generify the
                     code, thus:
                  </p><pre class="programlisting">

class CollectionConverter {
    &lt;T&gt; List&lt;T&gt; toList(Collection&lt;T&gt; c) {...}
}

</pre><p class="note">Without special dispensation, 
                     <code class="literal">Overrider.toList</code> would no longer
                     override <code class="literal">CollectionConverter.toList</code>. Instead, the
                     code would be illegal. This would significantly inhibit the use of
                     generics, since library writers would hesitate to migrate existing
                     code.
                  </p>
               </div>
            </div>
            <div class="section" title="8.4.3.&nbsp;Method Modifiers">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.4.3"></a>8.4.3.&nbsp;Method Modifiers
                        </h3>
                     </div>
                  </div>
               </div>
               <div id="jls-8.4.3-100" class="productionset"><a name="jls-8.4.3-100"></a>
                    
                  <div class="production"><a name="jls-MethodModifier"></a>
                         
                     <div class="lhs">MethodModifier:</div>
                         
                     <div class="rhs">
                              (one of) <br>
                              <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <code class="literal">public</code> <code class="literal">protected</code> <code class="literal">private</code> <br>
                              <code class="literal">abstract</code> <code class="literal">static</code> <code class="literal">final</code> <code class="literal">synchronized</code> <code class="literal">native</code> <code class="literal">strictfp</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.4.3-110"></a>
                  The rules for annotation modifiers on a method declaration are
                  specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and
                  <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Type">&sect;9.7.5</a>.
               </p>
               <p class="norm-error"><a name="jls-8.4.3-200"></a>
                  It is a compile-time error if the same keyword appears more than once
                  as a modifier for a method declaration, or if a method
                  declaration has more than one of the access modifiers <code class="literal">public</code>,
                  <code class="literal">protected</code>, and <code class="literal">private</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>).
               </p>
               <p class="norm-error"><a name="jls-8.4.3-210"></a>It is a
                  compile-time error if a method declaration that contains the keyword
                  <code class="literal">abstract</code> also contains any one of the keywords <code class="literal">private</code>, <code class="literal">static</code>,
                  <code class="literal">final</code>, <code class="literal">native</code>, <code class="literal">strictfp</code>, or <code class="literal">synchronized</code>.
               </p>
               <p class="norm-error"><a name="jls-8.4.3-220"></a>
                  It is a compile-time error if a method declaration that contains the
                  keyword <code class="literal">native</code> also contains <code class="literal">strictfp</code>.
               </p>
               <p class="note">If two or more (distinct) method modifiers appear in
                  a method declaration, it is customary, though not required, that they
                  appear in the order consistent with that shown above in the production
                  for <span class="emphasis"><em>MethodModifier</em></span>.
               </p>
               <div class="section" title="8.4.3.1.&nbsp;abstract Methods">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.3.1"></a>8.4.3.1.&nbsp;<code class="literal">abstract</code> Methods
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.4.3.1-100"></a>An
                     <code class="literal">abstract</code> method declaration introduces the method as a member,
                     providing its signature (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>), result
                     (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>), and <code class="literal">throws</code> clause if any
                     (<a class="xref" href="jls-8.html#jls-8.4.6" title="8.4.6.&nbsp;Method Throws">&sect;8.4.6</a>), but does not provide an implementation
                     (<a class="xref" href="jls-8.html#jls-8.4.7" title="8.4.7.&nbsp;Method Body">&sect;8.4.7</a>). A method that is not <code class="literal">abstract</code> may be
                     referred to as a <span class="emphasis"><em>concrete</em></span> method.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.3.1-110"></a>The
                     declaration of an <code class="literal">abstract</code> method <code class="varname">m</code> must appear directly within an
                     <code class="literal">abstract</code> class (call it <span class="type">A</span>) unless it occurs within an enum
                     declaration (<a class="xref" href="jls-8.html#jls-8.9" title="8.9.&nbsp;Enum Types">&sect;8.9</a>); otherwise a compile-time
                     error occurs.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.3.1-120"></a>Every
                     subclass of <span class="type">A</span> that is not <code class="literal">abstract</code> (<a class="xref" href="jls-8.html#jls-8.1.1.1" title="8.1.1.1.&nbsp;abstract Classes">&sect;8.1.1.1</a>)
                     must provide an implementation for <code class="varname">m</code>, or a compile-time error
                     occurs.
                  </p>
                  <p class="norm-static"><a name="jls-8.4.3.1-200"></a>An
                     <code class="literal">abstract</code> class can override an <code class="literal">abstract</code> method by providing
                     another <code class="literal">abstract</code> method declaration.
                  </p>
                  <p class="note">This can provide a place to put a documentation
                     comment, to refine the return type, or to declare that the set of
                     checked exceptions that can be thrown by that method, when it is
                     implemented by its subclasses, is to be more limited.
                  </p>
                  <p class="norm-static"><a name="jls-8.4.3.1-210"></a>An
                     instance method that is not <code class="literal">abstract</code> can be overridden by an
                     <code class="literal">abstract</code> method.
                  </p>
                  <div class="example"><a name="d5e13204"></a><p class="title"><b>Example&nbsp;8.4.3.1-1.&nbsp;Abstract/Abstract Method Overriding</b></p>
                     <div class="example-contents"><pre class="programlisting">
class BufferEmpty extends Exception {
    BufferEmpty() { super(); }
    BufferEmpty(String s) { super(s); }
}
class BufferError extends Exception {
    BufferError() { super(); }
    BufferError(String s) { super(s); }
}
interface Buffer {
    char get() throws BufferEmpty, BufferError;
}
abstract class InfiniteBuffer implements Buffer {
    public abstract char get() throws BufferError;
}
</pre><p class="note">The overriding declaration of
                           method <code class="literal">get</code> in
                           class <code class="literal">InfiniteBuffer</code> states that
                           method <code class="literal">get</code> in any subclass
                           of <code class="literal">InfiniteBuffer</code> never throws
                           a <code class="literal">BufferEmpty</code> exception, putatively because it
                           generates the data in the buffer, and thus can never run out of
                           data.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e13213"></a><p class="title"><b>Example&nbsp;8.4.3.1-2.&nbsp;Abstract/Non-Abstract Overriding</b></p>
                     <div class="example-contents">
                        <p class="note">We can declare an <code class="literal">abstract</code>
                           class <code class="literal">Point</code> that requires its subclasses to
                           implement <code class="literal">toString</code> if they are to be complete,
                           instantiable classes:
                        </p><pre class="programlisting">
abstract class Point {
    int x, y;
    public abstract String toString();
}
</pre><p class="note">This <code class="literal">abstract</code> declaration
                           of <code class="literal">toString</code> overrides the
                           non-<code class="literal">abstract</code> <code class="literal">toString</code> method of class
                           <code class="literal">Object</code>. (Class <code class="literal">Object</code> is the implicit direct superclass of
                           class <code class="literal">Point</code>.) Adding the code:
                        </p><pre class="programlisting">
class ColoredPoint extends Point {
    int color;
    public String toString() {
        return super.toString() + ": color " + color;  // error
    }
}
</pre><p class="note">results in a compile-time error because the
                           invocation <code class="literal">super.toString()</code> refers to
                           method <code class="literal">toString</code> in class <code class="literal">Point</code>,
                           which is <code class="literal">abstract</code> and therefore cannot be
                           invoked. Method <code class="literal">toString</code> of class <code class="literal">Object</code> can be
                           made available to class <code class="literal">ColoredPoint</code> only if
                           class <code class="literal">Point</code> explicitly makes it available through
                           some other method, as in:
                        </p><pre class="programlisting">
abstract class Point {
    int x, y;
    public abstract String toString();
    protected String objString() { return super.toString(); }
}
class ColoredPoint extends Point {
    int color;
    public String toString() {
        return objString() + ": color " + color;  // correct
    }
}
</pre></div>
                  </div><br class="example-break"></div>
               <div class="section" title="8.4.3.2.&nbsp;static Methods">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.3.2"></a>8.4.3.2.&nbsp;<code class="literal">static</code> Methods
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-8.4.3.2-100"></a>
                     A method that is declared <code class="literal">static</code> is called a <span class="emphasis"><em>class
                           method</em></span>.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.3.2-110"></a>
                     It is a compile-time error  to use the
                     name of a type parameter of any surrounding declaration in
                     the header or body of a class method.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.3.2-120"></a>
                     A class method is always invoked without reference to a particular
                     object. It is a compile-time error to attempt to refer to the current
                     object using the keyword <code class="literal">this</code> (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>) or the
                     keyword <code class="literal">super</code> (<a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>).
                  </p>
                  <p class="norm"><a name="jls-8.4.3.2-200"></a>
                     A method that is not declared <code class="literal">static</code> is called an <span class="emphasis"><em>instance
                           method</em></span>, and sometimes called a non-<code class="literal">static</code> method.
                  </p>
                  <p class="norm-static"><a name="jls-8.4.3.2-210"></a>
                     An instance method is always invoked with respect to an object, which
                     becomes the current object to which the keywords <code class="literal">this</code> and <code class="literal">super</code>
                     refer during execution of the method body.
                  </p>
               </div>
               <div class="section" title="8.4.3.3.&nbsp;final Methods">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.3.3"></a>8.4.3.3.&nbsp;<code class="literal">final</code> Methods
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-8.4.3.3-100"></a>A method can be declared
                     <code class="literal">final</code> to prevent subclasses from overriding or hiding it.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.3.3-110"></a>It is a
                     compile-time error to attempt to override or hide a <code class="literal">final</code>
                     method.
                  </p>
                  <p class="norm-static"><a name="jls-8.4.3.3-200"></a>A
                     <code class="literal">private</code> method and all methods declared immediately within a <code class="literal">final</code>
                     class (<a class="xref" href="jls-8.html#jls-8.1.1.2" title="8.1.1.2.&nbsp;final Classes">&sect;8.1.1.2</a>) behave as if they are <code class="literal">final</code>,
                     since it is impossible to override them.
                  </p>
                  <p class="note">At run time, a machine-code generator or optimizer
                     can "inline" the body of a <code class="literal">final</code> method, replacing an invocation of
                     the method with the code in its body. The inlining process must
                     preserve the semantics of the method invocation. In particular, if the
                     target of an instance method invocation is <code class="literal">null</code>, then a <code class="literal">NullPointerException</code> must
                     be thrown even if the method is inlined. A Java compiler must ensure
                     that the exception will be thrown at the correct point, so that the
                     actual arguments to the method will be seen to have been evaluated in
                     the correct order prior to the method invocation.
                  </p>
                  <div class="informalexample">
                     <p class="note">Consider the example:</p><pre class="programlisting">
final class Point {
    int x, y;
    void move(int dx, int dy) { x += dx; y += dy; }
}
class Test {
    public static void main(String[] args) {
        Point[] p = new Point[100];
        for (int i = 0; i &lt; p.length; i++) {
            p[i] = new Point();
            p[i].move(i, p.length-1-i);
        }
    }
}
</pre><p class="note">Inlining the method <code class="literal">move</code> of
                        class <code class="literal">Point</code> in method <code class="literal">main</code> would
                        transform the <code class="literal">for</code> loop to the form:
                     </p><pre class="programlisting">

    for (int i = 0; i &lt; p.length; i++) {
        p[i] = new Point();
        Point pi = p[i];
        int j = p.length-1-i;
        pi.x += i;
        pi.y += j;
    }

</pre><p class="note">The loop might then be subject to further
                        optimizations.
                     </p>
                     <p class="note">Such inlining cannot be done at compile time unless
                        it can be guaranteed that <code class="literal">Test</code>
                        and <code class="literal">Point</code> will always be recompiled together, so
                        that whenever <code class="literal">Point</code> - and specifically
                        its <code class="literal">move</code> method - changes, the code
                        for <code class="literal">Test.main</code> will also be updated.
                     </p>
                  </div>
               </div>
               <div class="section" title="8.4.3.4.&nbsp;native Methods">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.3.4"></a>8.4.3.4.&nbsp;<code class="literal">native</code> Methods
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.4.3.4-100"></a>A method
                     that is <code class="literal">native</code> is implemented in platform-dependent code, typically
                     written in another programming language such as C. The body of a
                     <code class="literal">native</code> method is given as a semicolon only, indicating that the
                     implementation is omitted, instead of a block
                     (<a class="xref" href="jls-8.html#jls-8.4.7" title="8.4.7.&nbsp;Method Body">&sect;8.4.7</a>).
                  </p>
                  <div class="informalexample">
                     <p class="note">For example, the
                        class <code class="literal">RandomAccessFile</code> of the
                        package <code class="literal">java.io</code> might declare the following
                        <code class="literal">native</code> methods:
                     </p><pre class="programlisting">

package java.io;
public class RandomAccessFile
    implements DataOutput, DataInput {
    . . .
    public native void open(String name, boolean writeable)
        throws IOException;
    public native int readBytes(byte[] b, int off, int len)
        throws IOException;
    public native void writeBytes(byte[] b, int off, int len)
        throws IOException;
    public native long getFilePointer() throws IOException;
    public native void seek(long pos) throws IOException;
    public native long length() throws IOException;
    public native void close() throws IOException;
}

</pre></div>
               </div>
               <div class="section" title="8.4.3.5.&nbsp;strictfp Methods">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.3.5"></a>8.4.3.5.&nbsp;<code class="literal">strictfp</code> Methods
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.4.3.5-100"></a>The
                     effect of the <code class="literal">strictfp</code> modifier is to make all <code class="literal">float</code> or <code class="literal">double</code>
                     expressions within the method body be explicitly FP-strict
                     (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>).
                  </p>
               </div>
               <div class="section" title="8.4.3.6.&nbsp;synchronized Methods">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.3.6"></a>8.4.3.6.&nbsp;<code class="literal">synchronized</code> Methods
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-dynamic"><a name="jls-8.4.3.6-100"></a>A
                     <code class="literal">synchronized</code> method acquires a monitor (<a class="xref" href="jls-17.html#jls-17.1" title="17.1.&nbsp;Synchronization">&sect;17.1</a>)
                     before it executes.
                  </p>
                  <p class="norm-dynamic"><a name="jls-8.4.3.6-110"></a>For a
                     class (<code class="literal">static</code>) method, the monitor associated with the <code class="literal">Class</code>
                     object for the method's class is used.
                  </p>
                  <p class="norm-dynamic"><a name="jls-8.4.3.6-120"></a>For an
                     instance method, the monitor associated with <code class="literal">this</code> (the object for
                     which the method was invoked) is used.
                  </p>
                  <div class="example"><a name="d5e13322"></a><p class="title"><b>Example&nbsp;8.4.3.6-1.&nbsp;<code class="literal">synchronized</code> Monitors</b></p>
                     <div class="example-contents">
                        <p class="note">These are the same monitors that can be used by the
                           <code class="literal">synchronized</code> statement (<a class="xref" href="jls-14.html#jls-14.19" title="14.19.&nbsp;The synchronized Statement">&sect;14.19</a>).
                        </p>
                        <p class="note">Thus, the code:</p><pre class="programlisting">
class Test {
    int count;
    synchronized void bump() {
        count++;
    }
    static int classCount;
    static synchronized void classBump() {
        classCount++;
    }
}
</pre><p class="note">has exactly the same effect as:</p><pre class="programlisting">
class BumpTest {
    int count;
    void bump() {
        synchronized (this) { count++; }
    }
    static int classCount;
    static void classBump() {
        try {
            synchronized (Class.forName("BumpTest")) {
                classCount++;
            }
        } catch (ClassNotFoundException e) {}
    }
}
</pre></div>
                  </div><br class="example-break"><div class="example"><a name="d5e13332"></a><p class="title"><b>Example&nbsp;8.4.3.6-2.&nbsp;<code class="literal">synchronized</code> Methods</b></p>
                     <div class="example-contents"><pre class="programlisting">
public class Box {
    private Object boxContents;
    public synchronized Object get() {
        Object contents = boxContents;
        boxContents = null;
        return contents;
    }
    public synchronized boolean put(Object contents) {
        if (boxContents != null) return false;
        boxContents = contents;
        return true;
    }
}
</pre><p class="note">This program defines a class which is designed for
                           concurrent use. Each instance of the class <code class="literal">Box</code> has
                           an instance variable <code class="literal">boxContents</code> that can hold a
                           reference to any object. You can put an object in
                           a <code class="literal">Box</code> by invoking <code class="literal">put</code>, which
                           returns <code class="literal">false</code> if the box is already full. You can
                           get something out of a <code class="literal">Box</code> by
                           invoking <code class="literal">get</code>, which returns a null reference if the
                           box is empty.
                        </p>
                        <p class="note">If <code class="literal">put</code> and <code class="literal">get</code>
                           were not <code class="literal">synchronized</code>, and two threads were executing methods for
                           the same instance of <code class="literal">Box</code> at the same time, then the
                           code could misbehave. It might, for example, lose track of an object
                           because two invocations to put occurred at the same time.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
            </div>
            <div class="section" title="8.4.4.&nbsp;Generic Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.4.4"></a>8.4.4.&nbsp;Generic Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.4.4-100"></a>A method
                  is <span class="emphasis"><em>generic</em></span> if it declares one or more type
                  variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>).
               </p>
               <p class="norm-static"><a name="jls-8.4.4-110"></a>These type
                  variables are known as the <span class="emphasis"><em>type parameters</em></span> of the
                  method. The form of the type parameter section of a generic method is
                  identical to the type parameter section of a generic class
                  (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>).
               </p>
               <p class="norm-static"><a name="jls-8.4.4-120"></a>A generic method declaration
                  defines a set of methods, one for each possible invocation of the type
                  parameter section by type arguments. Type arguments may not need to be
                  provided explicitly when a generic method is invoked, as they can
                  often be inferred (<a class="xref" href="jls-18.html" title="Chapter&nbsp;18.&nbsp;Type Inference">&sect;18 (<i>Type Inference</i>)</a>).
               </p>
               <p class="norm-static"><a name="jls-8.4.4-200"></a>The scope
                  and shadowing of a method's type parameter is specified in
                  <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a>.
               </p>
               <p class="norm-static"><a name="jls-8.4.4-300"></a>Two methods or
                  constructors <code class="varname">M</code> and <code class="varname">N</code> have the <span class="emphasis"><em>same type
                        parameters</em></span> if both of the following are true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.4-300-A"></a>
                                 <code class="varname">M</code> and <code class="varname">N</code> have same number of type parameters (possibly
                                 zero).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.4-300-B"></a>
                                 Where <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span> are the type parameters of <code class="varname">M</code> and <span class="type">B<sub>1</sub></span>,
                                 ..., <span class="type">B<sub>n</sub></span> are the type parameters of <code class="varname">N</code>,
                                 let <span class="emphasis"><em><span class="symbol">&#952;</span>=[<span class="type">B<sub>1</sub></span>:=<span class="type">A<sub>1</sub></span>, ..., <span class="type">B<sub>n</sub></span>:=<span class="type">A<sub>n</sub></span>]</em></span>.
                                 Then, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), the bound of
                                 <span class="type">A<sub>i</sub></span> is the same type as <span class="symbol">&#952;</span> applied to the bound of
                                 <span class="type">B<sub>i</sub></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-8.4.4-310"></a>Where two methods
                  or constructors <code class="varname">M</code> and <code class="varname">N</code> have the same type parameters, a type
                  mentioned in <code class="varname">N</code> can be <span class="emphasis"><em>adapted to the type
                        parameters</em></span> of <code class="varname">M</code> by applying <span class="symbol">&#952;</span>, as defined above, to
                  the type.
               </p>
            </div>
            <div class="section" title="8.4.5.&nbsp;Method Result">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.4.5"></a>8.4.5.&nbsp;Method Result
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.4.5-100"></a>
                  The <span class="emphasis"><em>result</em></span> of a method declaration either
                  declares the type of value that the method returns
                  (the <span class="emphasis"><em>return type</em></span>), or uses the keyword <code class="literal">void</code> to
                  indicate that the method does not return a value.
               </p>
               <div id="jls-8.4.5-110" class="productionset"><a name="jls-8.4.5-110"></a>
                    
                  <div class="production"><a name="jls-Result"></a>
                         
                     <div class="lhs">Result:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a> <br>
                              <code class="literal">void</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-8.4.5-120"></a>
                  If the result is not <code class="literal">void</code>, then the return type of a method is
                  denoted by <span class="emphasis"><em>UnannType</em></span> if no bracket pairs appear
                  after the formal parameter list, and is specified by
                  <a class="xref" href="jls-10.html#jls-10.2" title="10.2.&nbsp;Array Variables">&sect;10.2</a> otherwise.
               </p>
               <p class="norm-static"><a name="jls-8.4.5-200"></a>
                  Return types may vary among methods that override each other if the
                  return types are reference types. The notion of
                  return-type-substitutability supports <span class="emphasis"><em>covariant
                        returns</em></span>, that is, the specialization of the return type to
                  a subtype.
               </p>
               <p class="norm-static"><a name="jls-8.4.5-210"></a>
                  A method declaration <code class="varname">d<sub>1</sub></code> with return type <span class="type">R<sub>1</sub></span> is
                  <span class="emphasis"><em>return-type-substitutable</em></span> for another method <code class="varname">d<sub>2</sub></code>
                  with return type <span class="type">R<sub>2</sub></span> iff any of the following is true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.5-210-A"></a>
                                 If <span class="type">R<sub>1</sub></span> is <code class="literal">void</code> then <span class="type">R<sub>2</sub></span> is <code class="literal">void</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.5-210-B"></a>
                                 If <span class="type">R<sub>1</sub></span> is a primitive type then <span class="type">R<sub>2</sub></span> is identical to <span class="type">R<sub>1</sub></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.5-210-C"></a>
                                 If <span class="type">R<sub>1</sub></span> is a reference type then one of the following is true:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-8.4.5-210-C-A"></a>
                                    	  <span class="type">R<sub>1</sub></span>, adapted to the type parameters of <code class="varname">d<sub>2</sub></code>
                                    	  (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>), is a subtype of <span class="type">R<sub>2</sub></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-8.4.5-210-C-B"></a>
                                    	  <span class="type">R<sub>1</sub></span> can be converted to a subtype of <span class="type">R<sub>2</sub></span> by unchecked
                                              conversion (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>).
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-8.4.5-210-C-C"></a>
                                    	  <code class="varname">d<sub>1</sub></code> does not have the same signature as <code class="varname">d<sub>2</sub></code>
                                    	  (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>), and <span class="type">R<sub>1</sub></span> = |<span class="type">R<sub>2</sub></span>|.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">An unchecked conversion is allowed in the
                  definition, despite being unsound, as a special allowance to allow
                  smooth migration from non-generic to generic code. If an unchecked
                  conversion is used to determine that <span class="type">R<sub>1</sub></span> is return-type-substitutable
                  for <span class="type">R<sub>2</sub></span>, then <span class="type">R<sub>1</sub></span> is necessarily not a subtype of <span class="type">R<sub>2</sub></span> and the rules
                  for overriding (<a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>, <a class="xref" href="jls-9.html#jls-9.4.1" title="9.4.1.&nbsp;Inheritance and Overriding">&sect;9.4.1</a>) 
                  will require a compile-time unchecked warning.
               </p>
            </div>
            <div class="section" title="8.4.6.&nbsp;Method Throws">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.4.6"></a>8.4.6.&nbsp;Method Throws
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.4.6-100"></a>
                  A <code class="literal">throws</code> clause is used to  denote any checked
                  exception classes (<a class="xref" href="jls-11.html#jls-11.1.1" title="11.1.1.&nbsp;The Kinds of Exceptions">&sect;11.1.1</a>) that the statements in a
                  method or constructor body can throw (<a class="xref" href="jls-11.html#jls-11.2.2" title="11.2.2.&nbsp;Exception Analysis of Statements">&sect;11.2.2</a>).
               </p>
               <div id="jls-8.4.6-110" class="productionset"><a name="jls-8.4.6-110"></a>
                    
                  <div class="production"><a name="jls-Throws"></a>
                         
                     <div class="lhs">Throws:</div>
                         
                     <div class="rhs">
                              <code class="literal">throws</code> <a href="jls-8.html#jls-ExceptionTypeList" title="ExceptionTypeList">ExceptionTypeList</a>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ExceptionTypeList"></a>
                         
                     <div class="lhs">ExceptionTypeList:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-ExceptionType" title="ExceptionType">ExceptionType</a> {<code class="literal">,</code> <a href="jls-8.html#jls-ExceptionType" title="ExceptionType">ExceptionType</a>}
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-ExceptionType"></a>
                         
                     <div class="lhs">ExceptionType:</div>
                         
                     <div class="rhs">
                              <a href="jls-4.html#jls-ClassType" title="ClassType">ClassType</a> <br> 
                              <a href="jls-4.html#jls-TypeVariable" title="TypeVariable">TypeVariable</a>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.4.6-200"></a>It is a
                  compile-time error if an <span class="emphasis"><em>ExceptionType</em></span> mentioned
                  in a <code class="literal">throws</code> clause is not a subtype (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>) of
                  <code class="literal">Throwable</code>.
               </p>
               <p class="norm-static"><a name="jls-8.4.6-210"></a>Type
                  variables are allowed in a <code class="literal">throws</code> clause even though they are not
                  allowed in a <code class="literal">catch</code> clause (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>).
               </p>
               <p class="norm-static"><a name="jls-8.4.6-220"></a>It is
                  permitted but not required to mention unchecked exception classes
                  (<a class="xref" href="jls-11.html#jls-11.1.1" title="11.1.1.&nbsp;The Kinds of Exceptions">&sect;11.1.1</a>) in a <code class="literal">throws</code> clause.
               </p>
               <p class="norm-static"><a name="jls-8.4.6-300"></a>The
                  relationship between a <code class="literal">throws</code> clause and the exception checking for
                  a method or constructor body is specified in
                  <a class="xref" href="jls-11.html#jls-11.2.3" title="11.2.3.&nbsp;Exception Checking">&sect;11.2.3</a>.
               </p>
               <p class="note">Essentially, for each checked exception that can
                  result from execution of the body of a method or constructor, a
                  compile-time error occurs unless its exception type or a supertype of
                  its exception type is mentioned in a <code class="literal">throws</code> clause in the
                  declaration of the method or constructor.
               </p>
               <p class="note">The requirement to declare checked exceptions allows
                  a Java compiler to ensure that code for handling such error conditions
                  has been included. Methods or constructors that fail to handle
                  exceptional conditions thrown as checked exceptions in their bodies
                  will normally cause compile-time errors if they lack proper exception
                  types in their <code class="literal">throws</code> clauses. The Java programming language thus encourages a
                  programming style where rare and otherwise truly exceptional
                  conditions are documented in this way.
               </p>
               <p class="norm-static"><a name="jls-8.4.6-400"></a>The
                  relationship between the <code class="literal">throws</code> clause of a method and the <code class="literal">throws</code>
                  clauses of overridden or hidden methods is specified in
                  <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>.
               </p>
               <div class="example"><a name="d5e13543"></a><p class="title"><b>Example&nbsp;8.4.6-1.&nbsp;Type Variables as Thrown Exception Types</b></p>
                  <div class="example-contents"><pre class="programlisting">
import java.io.FileNotFoundException;
interface PrivilegedExceptionAction&lt;E extends Exception&gt; { 
    void run() throws E;
} 
class AccessController {
    public static &lt;E extends Exception&gt; 
    Object doPrivileged(PrivilegedExceptionAction&lt;E&gt; action) throws E {
        action.run();
        return "success";
    }
}
class Test {
    public static void main(String[] args) {
        try {
            AccessController.doPrivileged(
              new PrivilegedExceptionAction&lt;FileNotFoundException&gt;() {
                  public void run() throws FileNotFoundException {
                      // ... delete a file ...
                  } 
              }); 
        } catch (FileNotFoundException f) { /* Do something */ }
    }
}
</pre></div>
               </div><br class="example-break"></div>
            <div class="section" title="8.4.7.&nbsp;Method Body">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.4.7"></a>8.4.7.&nbsp;Method Body
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.4.7-100"></a>A <span class="emphasis"><em>method body</em></span> is either a
                  block of code that implements the method or simply a semicolon,
                  indicating the lack of an implementation.
               </p>
               <div id="jls-8.4.7-110" class="productionset"><a name="jls-8.4.7-110"></a>
                    
                  <div class="production"><a name="jls-MethodBody"></a>
                         
                     <div class="lhs">MethodBody:</div>
                         
                     <div class="rhs">
                              <a href="jls-14.html#jls-Block" title="Block">Block</a> <br>
                              <code class="literal">;</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-8.4.7-200"></a>The body
                  of a method must be a semicolon if the method is <code class="literal">abstract</code> or
                  <code class="literal">native</code> (<a class="xref" href="jls-8.html#jls-8.4.3.1" title="8.4.3.1.&nbsp;abstract Methods">&sect;8.4.3.1</a>,
                  <a class="xref" href="jls-8.html#jls-8.4.3.4" title="8.4.3.4.&nbsp;native Methods">&sect;8.4.3.4</a>). More precisely:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-8.4.7-200-A"></a>It is
                                 a compile-time error if a method declaration is either
                                 <code class="literal">abstract</code> or <code class="literal">native</code> and has a block for its body.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-8.4.7-200-B"></a>It is
                                 a compile-time error if a method declaration is neither
                                 <code class="literal">abstract</code> nor <code class="literal">native</code> and has a semicolon for its body.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">If an implementation is to be provided for a method
                  declared <code class="literal">void</code>, but the implementation requires no executable code,
                  the method body should be written as a block that contains no
                  statements: "<code class="literal">{ }</code>".
               </p>
               <p class="norm-error"><a name="jls-8.4.7-210"></a>The rules
                  for <code class="literal">return</code> statements in a method body are specified in
                  <a class="xref" href="jls-14.html#jls-14.17" title="14.17.&nbsp;The return Statement">&sect;14.17</a>.
               </p>
               <p class="norm-error"><a name="jls-8.4.7-240"></a>If a method
                  is declared to have a return type (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>), then
                  a compile-time error occurs if the body of the method can complete
                  normally (<a class="xref" href="jls-14.html#jls-14.1" title="14.1.&nbsp;Normal and Abrupt Completion of Statements">&sect;14.1</a>).
               </p>
               <p class="note">In other words, a method with a return type must
                  return only by using a <code class="literal">return</code> statement that provides a value
                  return; the method is not allowed to "drop off the end of its
                  body". See <a class="xref" href="jls-14.html#jls-14.17" title="14.17.&nbsp;The return Statement">&sect;14.17</a> for the precise rules about
                  <code class="literal">return</code> statements in a method body.
               </p>
               <div class="informalexample">
                  <p class="note">It is possible for a method to have a return type
                     and yet contain no <code class="literal">return</code> statements. Here is one example:
                  </p><pre class="programlisting">
class DizzyDean {
    int pitch() { throw new RuntimeException("90 mph?!"); }
}
</pre></div>
            </div>
            <div class="section" title="8.4.8.&nbsp;Inheritance, Overriding, and Hiding">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.4.8"></a>8.4.8.&nbsp;Inheritance, Overriding, and Hiding
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.4.8-100"></a>
                  A class <span class="type">C</span> <span class="emphasis"><em>inherits</em></span> from its direct superclass
                  all concrete methods <code class="varname">m</code> (both <code class="literal">static</code> and instance) of the
                  superclass for which all of the following are true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.8-100-A"></a>
                                 <code class="varname">m</code> is a member of the direct superclass of <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.8-100-B"></a>
                                 <code class="varname">m</code> is <code class="literal">public</code>, <code class="literal">protected</code>, or declared with package access in
                                 the same package as <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.8-100-C"></a>
                                 No method declared in <span class="type">C</span> has a signature that is a subsignature
                                 (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of the signature of <code class="varname">m</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-8.4.8-200"></a>
                  A class <span class="type">C</span> <span class="emphasis"><em>inherits</em></span> from its direct superclass
                  and direct superinterfaces all <code class="literal">abstract</code> and default
                  (<a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>) methods <code class="varname">m</code> for which all of the following
                  are true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.8-200-A"></a>
                                 <code class="varname">m</code> is a member of the direct superclass or a direct
                                 superinterface, <span class="type">D</span>, of <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.8-200-B"></a>
                                 <code class="varname">m</code> is <code class="literal">public</code>, <code class="literal">protected</code>, or declared with package access in
                                 the same package as <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.8-200-C"></a>
                                 No method declared in <span class="type">C</span> has a signature that is a subsignature
                                 (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of the signature of <code class="varname">m</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.8-200-D"></a>
                                 No concrete method inherited by <span class="type">C</span> from its direct superclass
                                 has a signature that is a subsignature of the signature of <code class="varname">m</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.4.8-200-E"></a>
                                 There exists no method <code class="varname">m</code>' that is a member of the direct
                                 superclass or a direct superinterface, <span class="type">D</span>', of <span class="type">C</span> (<code class="varname">m</code>
                                 distinct from <code class="varname">m</code>', <span class="type">D</span> distinct from <span class="type">D</span>'), such that <code class="varname">m</code>'
                                 overrides from <span class="type">D</span>' (<a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a>,
                                 <a class="xref" href="jls-9.html#jls-9.4.1.1" title="9.4.1.1.&nbsp;Overriding (by Instance Methods)">&sect;9.4.1.1</a>) the declaration of the method
                                 <code class="varname">m</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-8.4.8-210"></a>
                  
                  A class does not inherit <code class="literal">private</code> or <code class="literal">static</code> methods from its
                  superinterfaces.
               </p>
               <p class="note">Note that methods are overridden or hidden on a
                  signature-by-signature basis. If, for example, a class declares two
                  <code class="literal">public</code> methods with the same name (<a class="xref" href="jls-8.html#jls-8.4.9" title="8.4.9.&nbsp;Overloading">&sect;8.4.9</a>), and
                  a subclass overrides one of them, the subclass still inherits the
                  other method.
               </p>
               <div class="example"><a name="d5e13658"></a><p class="title"><b>Example&nbsp;8.4.8-1.&nbsp;Inheritance</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface I1 {
    int foo();
}

interface I2 {
    int foo();
}

abstract class Test implements I1, I2 {} 
</pre><p class="note">Here, the <code class="literal">abstract</code> class <code class="literal">Test</code>
                        inherits the <code class="literal">abstract</code> method <code class="literal">foo</code> from
                        interface <code class="literal">I1</code> and also the <code class="literal">abstract</code>
                        method <code class="literal">foo</code> from
                        interface <code class="literal">I2</code>. The key question in determining the
                        inheritance of <code class="literal">foo</code> from <code class="literal">I1</code> is:
                        does the method <code class="literal">foo</code> in <code class="literal">I2</code>
                        override "from <code class="literal">I2</code>" (<a class="xref" href="jls-9.html#jls-9.4.1.1" title="9.4.1.1.&nbsp;Overriding (by Instance Methods)">&sect;9.4.1.1</a>)
                        the method <code class="literal">foo</code> in <code class="literal">I1</code>? No,
                        because <code class="literal">I1</code> and <code class="literal">I2</code> are not
                        subinterfaces of each other. Thus, from the viewpoint of
                        class <code class="literal">Test</code>, the inheritance
                        of <code class="literal">foo</code> from <code class="literal">I1</code> is unfettered;
                        similarly for the inheritance of <code class="literal">foo</code>
                        from <code class="literal">I2</code>. Per <a class="xref" href="jls-8.html#jls-8.4.8.4" title="8.4.8.4.&nbsp;Inheriting Methods with Override-Equivalent Signatures">&sect;8.4.8.4</a>,
                        class <code class="literal">Test</code> can inherit both <code class="literal">foo</code>
                        methods; obviously it must be declared <code class="literal">abstract</code>, or else override
                        both <code class="literal">abstract</code> <code class="literal">foo</code> methods with a concrete
                        method.
                     </p>
                  </div>
               </div><br class="example-break"><p class="note">
                  Note that it is possible for an inherited concrete method to prevent
                  the inheritance of an <code class="literal">abstract</code> or default method. (The concrete
                  method will override the <code class="literal">abstract</code> or default method "from <span class="type">C</span>", per
                  <a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a> and <a class="xref" href="jls-9.html#jls-9.4.1.1" title="9.4.1.1.&nbsp;Overriding (by Instance Methods)">&sect;9.4.1.1</a>.)
                  Also, it is possible for one supertype method to prevent the
                  inheritance of another supertype method if the former "already"
                  overrides the latter - this is the same as the rule for interfaces
                  (<a class="xref" href="jls-9.html#jls-9.4.1" title="9.4.1.&nbsp;Inheritance and Overriding">&sect;9.4.1</a>), and prevents conflicts in which
                  multiple default methods are inherited and one implementation is
                  clearly meant to supersede the other.
               </p>
               <div class="section" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.8.1"></a>8.4.8.1.&nbsp;Overriding (by Instance Methods)
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.4.8.1-100"></a>
                     An instance method <code class="varname">m<sub>C</sub></code> declared in or inherited by class
                     <span class="type">C</span>, <span class="emphasis"><em>overrides from <span class="type">C</span></em></span> another method <code class="varname">m<sub>A</sub></code>
                     declared in class <span class="type">A</span>, iff all of the following are true:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.4.8.1-100-A"></a>
                                    <span class="type">C</span> is a subclass of <span class="type">A</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.4.8.1-100-B"></a>
                                    <span class="type">C</span> does not inherit <code class="varname">m<sub>A</sub></code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.4.8.1-100-C"></a>
                                    The signature of <code class="varname">m<sub>C</sub></code> is a subsignature
                                    (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of the signature of <code class="varname">m<sub>A</sub></code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.4.8.1-100-D"></a>
                                    One of the following is true:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-8.4.8.1-100-D-1"></a>
                                       	  <code class="varname">m<sub>A</sub></code> is <code class="literal">public</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-8.4.8.1-100-D-2"></a>
                                                 <code class="varname">m<sub>A</sub></code> is <code class="literal">protected</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-8.4.8.1-100-D-3"></a>
                                       	  <code class="varname">m<sub>A</sub></code> is declared with package access in the same package as
                                                 <span class="type">C</span>, and either <span class="type">C</span> declares <code class="varname">m<sub>C</sub></code> or <code class="varname">m<sub>A</sub></code> is a member of the
                                                 direct superclass of <span class="type">C</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-8.4.8.1-100-D-4"></a>
                                       	  <code class="varname">m<sub>A</sub></code> is declared with package access and <code class="varname">m<sub>C</sub></code> overrides <code class="varname">m<sub>A</sub></code>
                                       	  from some superclass of <span class="type">C</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-8.4.8.1-100-D-5"></a>
                                       	  <code class="varname">m<sub>A</sub></code> is declared with package access and <code class="varname">m<sub>C</sub></code> overrides a
                                       	  method <code class="varname">m'</code> from <span class="type">C</span> (<code class="varname">m'</code> distinct from <code class="varname">m<sub>C</sub></code> and
                                       	  <code class="varname">m<sub>A</sub></code>), such that <code class="varname">m'</code> overrides <code class="varname">m<sub>A</sub></code> from some
                                       	  superclass of <span class="type">C</span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-8.4.8.1-110"></a>
                     If <code class="varname">m<sub>C</sub></code> is non-<code class="literal">abstract</code> and overrides from <span class="type">C</span> an <code class="literal">abstract</code> method <code class="varname">m<sub>A</sub></code>, 
                     then <code class="varname">m<sub>C</sub></code> is said to <span class="emphasis"><em>implement</em></span> <code class="varname">m<sub>A</sub></code> 
                     <span class="emphasis"><em>from <span class="type">C</span></em></span>.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.8.1-120"></a>
                     It is a compile-time error if the overridden method, <code class="varname">m<sub>A</sub></code>, is a
                     <code class="literal">static</code> method.
                  </p>
                  <p class="note">In this respect, overriding of methods differs from
                     hiding of fields (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>), for it is permissible
                     for an instance variable to hide a <code class="literal">static</code> variable.
                  </p>
                  <p class="norm-static"><a name="jls-8.4.8.1-200"></a>
                     
                     An instance method <code class="varname">m<sub>C</sub></code> declared in or inherited by class
                     <span class="type">C</span>, <span class="emphasis"><em>overrides from <span class="type">C</span></em></span> another method <code class="varname">m<sub>I</sub></code>
                     declared in interface <span class="type">I</span>, iff all of the following are true:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.4.8.1-200-A"></a>
                                    <span class="type">I</span> is a superinterface of <span class="type">C</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.4.8.1-200-B"></a>
                                    
                                    <code class="varname">m<sub>I</sub></code> is not <code class="literal">static</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.4.8.1-200-C"></a>
                                    <span class="type">C</span> does not inherit <code class="varname">m<sub>I</sub></code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.4.8.1-200-D"></a>
                                    The signature of <code class="varname">m<sub>C</sub></code> is a subsignature
                                    (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of the signature of <code class="varname">m<sub>I</sub></code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.4.8.1-200-E"></a>
                                    <code class="varname">m<sub>I</sub></code> is <code class="literal">public</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">The signature of an overriding method may differ
                     from the overridden one if a formal parameter in one of the methods
                     has a raw type, while the corresponding parameter in the other has a
                     parameterized type. This accommodates migration of pre-existing code
                     to take advantage of generics.
                  </p>
                  <p class="note">
                     The notion of overriding includes methods that override another from
                     some subclass of their declaring class. This can happen in two ways:
                  </p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">A concrete method in a generic superclass can,
                                    under certain parameterizations, have the same signature as an
                                    abstract method in that class. In this case, the concrete method
                                    is inherited and the <code class="literal">abstract</code> method is not (as described
                                    above). The inherited method should then be considered to
                                    override its abstract peer <span class="emphasis"><em>from <span class="type">C</span></em></span>. (This
                                    scenario is complicated by package access: if <span class="type">C</span> is in a
                                    different package, then <code class="varname">m<sub>A</sub></code> would not have been inherited
                                    anyway, and should not be considered overridden.)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">A method inherited from a class can override a
                                    superinterface method. (Happily, package access is not a concern
                                    here.)
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-8.4.8.1-400"></a>An
                     overridden method can be accessed by using a method invocation
                     expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>) that contains the keyword
                     <code class="literal">super</code>. A qualified name or a cast to a superclass type is not
                     effective in attempting to access an overridden method.
                  </p>
                  <p class="note">In this respect, overriding of methods differs from
                     hiding of fields.
                  </p>
                  <p class="norm-static"><a name="jls-8.4.8.1-500"></a>The
                     presence or absence of the <code class="literal">strictfp</code> modifier has absolutely no
                     effect on the rules for overriding methods and implementing abstract
                     methods. For example, it is permitted for a method that is not
                     FP-strict to override an FP-strict method and it is permitted for an
                     FP-strict method to override a method that is not FP-strict.
                  </p>
                  <div class="example"><a name="d5e13855"></a><p class="title"><b>Example&nbsp;8.4.8.1-1.&nbsp;Overriding</b></p>
                     <div class="example-contents"><pre class="programlisting">
class Point {
    int x = 0, y = 0;
    void move(int dx, int dy) { x += dx; y += dy; }
}
class SlowPoint extends Point {
    int xLimit, yLimit;
    void move(int dx, int dy) {
        super.move(limit(dx, xLimit), limit(dy, yLimit));
    }
    static int limit(int d, int limit) {
        return d &gt; limit ? limit : d &lt; -limit ? -limit : d;
    }
}
</pre><p class="note">Here, the class <code class="literal">SlowPoint</code>
                           overrides the declarations of method <code class="literal">move</code> of
                           class <code class="literal">Point</code> with its own <code class="literal">move</code>
                           method, which limits the distance that the point can move on each
                           invocation of the method. When the <code class="literal">move</code> method is
                           invoked for an instance of class <code class="literal">SlowPoint</code>, the
                           overriding definition in class <code class="literal">SlowPoint</code> will
                           always be called, even if the reference to
                           the <code class="literal">SlowPoint</code> object is taken from a variable whose
                           type is <code class="literal">Point</code>.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e13868"></a><p class="title"><b>Example&nbsp;8.4.8.1-2.&nbsp;Overriding</b></p>
                     <div class="example-contents">
                        <p class="note">Overriding makes it easy for subclasses to extend
                           the behavior of an existing class, as shown in this example:
                        </p><pre class="programlisting">
import java.io.OutputStream;
import java.io.IOException;

class BufferOutput {
    private OutputStream o;
    BufferOutput(OutputStream o) { this.o = o; }
    protected byte[] buf = new byte[512];
    protected int pos = 0;
    public void putchar(char c) throws IOException {
        if (pos == buf.length) flush();
        buf[pos++] = (byte)c;
    }
    public void putstr(String s) throws IOException {
        for (int i = 0; i &lt; s.length(); i++)
            putchar(s.charAt(i));
    }
    public void flush() throws IOException {
        o.write(buf, 0, pos);
        pos = 0;
    }
}
class LineBufferOutput extends BufferOutput {
    LineBufferOutput(OutputStream o) { super(o); }
    public void putchar(char c) throws IOException {
        super.putchar(c);
        if (c == '\n') flush();
    }
}
class Test {
    public static void main(String[] args) throws IOException {
        LineBufferOutput lbo = new LineBufferOutput(System.out);
        lbo.putstr("lbo\nlbo");
        System.out.print("print\n");
        lbo.putstr("\n");
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
lbo
print
lbo
</pre><p class="note">The class <code class="literal">BufferOutput</code> implements
                           a very simple buffered version of an <code class="literal">OutputStream</code>,
                           flushing the output when the buffer is full
                           or <code class="literal">flush</code> is invoked. The
                           subclass <code class="literal">LineBufferOutput</code> declares only a
                           constructor and a single method <code class="literal">putchar</code>, which
                           overrides the method <code class="literal">putchar</code>
                           of <code class="literal">BufferOutput</code>. It inherits the
                           methods <code class="literal">putstr</code> and <code class="literal">flush</code> from
                           class <code class="literal">BufferOutput</code>.
                        </p>
                        <p class="note">In the <code class="literal">putchar</code> method of
                           a <code class="literal">LineBufferOutput</code> object, if the character
                           argument is a newline, then it invokes the <code class="literal">flush</code>
                           method. The critical point about overriding in this example is that
                           the method <code class="literal">putstr</code>, which is declared in
                           class <code class="literal">BufferOutput</code>, invokes
                           the <code class="literal">putchar</code> method defined by the current object
                           <code class="literal">this</code>, which is not necessarily the <code class="literal">putchar</code> method
                           declared in class <code class="literal">BufferOutput</code>.
                        </p>
                        <p class="note">Thus, when <code class="literal">putstr</code> is invoked
                           in <code class="literal">main</code> using
                           the <code class="literal">LineBufferOutput</code> object <code class="literal">lbo</code>,
                           the invocation of <code class="literal">putchar</code> in the body of
                           the <code class="literal">putstr</code> method is an invocation of
                           the <code class="literal">putchar</code> of the object <code class="literal">lbo</code>,
                           the overriding declaration of <code class="literal">putchar</code> that checks
                           for a newline. This allows a subclass
                           of <code class="literal">BufferOutput</code> to change the behavior of
                           the <code class="literal">putstr</code> method without redefining it.
                        </p>
                        <p class="note">Documentation for a class such
                           as <code class="literal">BufferOutput</code>, which is designed to be extended,
                           should clearly indicate what is the contract between the class and its
                           subclasses, and should clearly indicate that subclasses may override
                           the <code class="literal">putchar</code> method in this way. The implementor of
                           the <code class="literal">BufferOutput</code> class would not, therefore, want
                           to change the implementation of <code class="literal">putstr</code> in a future
                           implementation of <code class="literal">BufferOutput</code> not to use the
                           method <code class="literal">putchar</code>, because this would break the
                           pre-existing contract with subclasses. See the discussion of binary
                           compatibility in <a class="xref" href="jls-13.html" title="Chapter&nbsp;13.&nbsp;Binary Compatibility">&sect;13 (<i>Binary Compatibility</i>)</a>, especially
                           <a class="xref" href="jls-13.html#jls-13.2" title="13.2.&nbsp;What Binary Compatibility Is and Is Not">&sect;13.2</a>.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
               <div class="section" title="8.4.8.2.&nbsp;Hiding (by Class Methods)">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.8.2"></a>8.4.8.2.&nbsp;Hiding (by Class Methods)
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.4.8.2-100"></a>
                     If a class <span class="type">C</span> declares or inherits a <code class="literal">static</code> method <code class="varname">m</code>, then <code class="varname">m</code> is
                     said to <span class="emphasis"><em>hide</em></span> any method <code class="varname">m'</code>, where the
                     signature of <code class="varname">m</code> is a subsignature (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of
                     the signature of <code class="varname">m'</code>, in the superclasses and superinterfaces of
                     <span class="type">C</span> that would otherwise be accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) to
                     code in <span class="type">C</span>.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.8.2-110"></a>
                     It is a compile-time error if a <code class="literal">static</code> method hides an instance
                     method.
                  </p>
                  <p class="note">In this respect, hiding of methods differs from
                     hiding of fields (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>), for it is permissible
                     for a <code class="literal">static</code> variable to hide an instance variable. Hiding is also
                     distinct from shadowing (<a class="xref" href="jls-6.html#jls-6.4.1" title="6.4.1.&nbsp;Shadowing">&sect;6.4.1</a>) and obscuring
                     (<a class="xref" href="jls-6.html#jls-6.4.2" title="6.4.2.&nbsp;Obscuring">&sect;6.4.2</a>).
                  </p>
                  <p class="norm-static"><a name="jls-8.4.8.2-200"></a>
                     A hidden method can be accessed by using a qualified name or by using
                     a method invocation expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>) that
                     contains the keyword <code class="literal">super</code> or a cast to a superclass type.
                  </p>
                  <p class="note">In this respect, hiding of methods is similar to
                     hiding of fields.
                  </p>
                  <div class="example"><a name="d5e13942"></a><p class="title"><b>Example&nbsp;8.4.8.2-1.&nbsp;Invocation of Hidden Class Methods</b></p>
                     <div class="example-contents">
                        <p class="note">A class (<code class="literal">static</code>) method that is hidden can be
                           invoked by using a reference whose type is the class that actually
                           contains the declaration of the method. In this respect, hiding of
                           <code class="literal">static</code> methods is different from overriding of instance methods. The
                           example:
                        </p><pre class="programlisting">
class Super {
    static String greeting() { return "Goodnight"; }
    String name() { return "Richard"; }
}
class Sub extends Super {
    static String greeting() { return "Hello"; }
    String name() { return "Dick"; }
}
class Test {
    public static void main(String[] args) {
        Super s = new Sub();
        System.out.println(s.greeting() + ", " + s.name());
    }
}
</pre><p class="note">produces the output:</p><pre class="screen">
Goodnight, Dick
</pre><p class="note">because the invocation
                           of <code class="literal">greeting</code> uses the type of <code class="literal">s</code>,
                           namely <code class="literal">Super</code>, to figure out, at compile time, which
                           class method to invoke, whereas the invocation
                           of <code class="literal">name</code> uses the class of <code class="literal">s</code>,
                           namely <code class="literal">Sub</code>, to figure out, at run time, which
                           instance method to invoke.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
               <div class="section" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.8.3"></a>8.4.8.3.&nbsp;Requirements in Overriding and Hiding
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-error"><a name="jls-8.4.8.3-100"></a>
                     If a method declaration <code class="varname">d<sub>1</sub></code> with return type <span class="type">R<sub>1</sub></span> overrides or hides
                     the declaration of another method <code class="varname">d<sub>2</sub></code> with return type <span class="type">R<sub>2</sub></span>, then
                     <code class="varname">d<sub>1</sub></code> must be return-type-substitutable (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>)
                     for <code class="varname">d<sub>2</sub></code>, or a compile-time error occurs.
                  </p>
                  <p class="note">This rule allows for covariant return types -
                     refining the return type of a method when overriding it.
                  </p>
                  <p class="norm-warning"><a name="jls-8.4.8.3-110"></a>
                     If <span class="type">R<sub>1</sub></span> is not a subtype of <span class="type">R<sub>2</sub></span>, then a compile-time unchecked
                     warning occurs, unless suppressed by <code class="literal">@SuppressWarnings</code>
                     (<a class="xref" href="jls-9.html#jls-9.6.4.5" title="9.6.4.5.&nbsp;@SuppressWarnings">&sect;9.6.4.5</a>).
                  </p>
                  <p class="norm"><a name="jls-8.4.8.3-200"></a>
                     A method that overrides or hides another method, including methods
                     that implement <code class="literal">abstract</code> methods defined in interfaces, may not be
                     declared to throw more checked exceptions than the overridden or
                     hidden method.
                  </p>
                  <p class="note">In this respect, overriding of methods differs from
                     hiding of fields (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>), for it is permissible
                     for a field to hide a field of another type.
                  </p>
                  <p class="norm-static"><a name="jls-8.4.8.3-210"></a>
                     More precisely, suppose that <span class="type">B</span> is a class or interface, and <span class="type">A</span> is a
                     superclass or superinterface of <span class="type">B</span>, and a method declaration <code class="varname">m<sub>2</sub></code> in
                     <span class="type">B</span> overrides or hides a method declaration <code class="varname">m<sub>1</sub></code> in <span class="type">A</span>. Then:
                  </p>
                  <div class="">
                     <ul class="" type="disc">
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.4.8.3-210-A"></a>
                                    If <code class="varname">m<sub>2</sub></code> has a <code class="literal">throws</code> clause that mentions any checked
                                    exception types, then <code class="varname">m<sub>1</sub></code> must have a <code class="literal">throws</code> clause, or a
                                    compile-time error occurs.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.4.8.3-210-B"></a>
                                    For every checked exception type listed in the <code class="literal">throws</code> clause
                                    of <code class="varname">m<sub>2</sub></code>, that same exception class or one of its supertypes must
                                    occur in the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the <code class="literal">throws</code>
                                    clause of <code class="varname">m<sub>1</sub></code>; otherwise, a compile-time error occurs.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-warning"><a name="jls-8.4.8.3-210-C"></a>
                                    If the unerased <code class="literal">throws</code> clause of <code class="varname">m<sub>1</sub></code> does not contain a
                                    supertype of each exception type in the <code class="literal">throws</code> clause of <code class="varname">m<sub>2</sub></code>
                                    (adapted, if necessary, to the type parameters of <code class="varname">m<sub>1</sub></code>), then a
                                    compile-time unchecked warning occurs, unless suppressed by
                                    <code class="literal">@SuppressWarnings</code> (<a class="xref" href="jls-9.html#jls-9.6.4.5" title="9.6.4.5.&nbsp;@SuppressWarnings">&sect;9.6.4.5</a>).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-error"><a name="jls-8.4.8.3-300"></a>
                     It is a compile-time error if a type declaration <span class="type">T</span> has a member
                     method <code class="varname">m<sub>1</sub></code> and there exists a method <code class="varname">m<sub>2</sub></code> declared in <span class="type">T</span> or a
                     supertype of <span class="type">T</span> such that all of the following are true:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.4.8.3-300-A"></a>
                                    <code class="varname">m<sub>1</sub></code> and <code class="varname">m<sub>2</sub></code> have the same name.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.4.8.3-300-B"></a>
                                    <code class="varname">m<sub>2</sub></code> is accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) from <span class="type">T</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.4.8.3-300-C"></a>
                                    The signature of <code class="varname">m<sub>1</sub></code> is not a subsignature
                                    (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of the signature of <code class="varname">m<sub>2</sub></code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.4.8.3-300-D"></a>
                                    The signature of <code class="varname">m<sub>1</sub></code> or some method <code class="varname">m<sub>1</sub></code> overrides (directly or
                                    indirectly) has the same erasure as the signature of <code class="varname">m<sub>2</sub></code> or
                                    some method <code class="varname">m<sub>2</sub></code> overrides (directly or indirectly).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">These restrictions are necessary because generics
                     are implemented via erasure. The rule above implies that methods
                     declared in the same class with the same name must have different
                     erasures. It also implies that a type declaration cannot implement or
                     extend two distinct invocations of the same generic interface.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.8.3-400"></a>
                     The access modifier of an overriding or hiding method must provide at
                     least as much access as the overridden or hidden method, as follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.4.8.3-400-A"></a>
                                    If the overridden or hidden method is <code class="literal">public</code>, then the
                                    overriding or hiding method must be <code class="literal">public</code>; otherwise, a
                                    compile-time error occurs.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.4.8.3-400-B"></a>
                                    If the overridden or hidden method is <code class="literal">protected</code>, then the
                                    overriding or hiding method must be <code class="literal">protected</code> or <code class="literal">public</code>;
                                    otherwise, a compile-time error occurs.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.4.8.3-400-C"></a>
                                    If the overridden or hidden method has package access, then the
                                    overriding or hiding method must <span class="emphasis"><em>not</em></span> be
                                    <code class="literal">private</code>; otherwise, a compile-time error occurs.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">Note that a <code class="literal">private</code> method cannot be overridden or
                     hidden in the technical sense of those terms. This means that a
                     subclass can declare a method with the same signature as a <code class="literal">private</code>
                     method in one of its superclasses, and there is no requirement that
                     the return type or <code class="literal">throws</code> clause of such a method bear any
                     relationship to those of the <code class="literal">private</code> method in the superclass.
                  </p>
                  <div class="example"><a name="d5e14084"></a><p class="title"><b>Example&nbsp;8.4.8.3-1.&nbsp;Covariant Return Types</b></p>
                     <div class="example-contents">
                        <p class="note">The following declarations are legal in the
                           Java programming language from Java SE 5.0 onwards:
                        </p><pre class="programlisting">
class C implements Cloneable { 
    C copy() throws CloneNotSupportedException {
        return (C)clone();
    } 
}
class D extends C implements Cloneable { 
    D copy() throws CloneNotSupportedException {
        return (D)clone();
    } 
}
</pre><p class="note">The relaxed rule for overriding also allows one to
                           relax the conditions on abstract classes implementing
                           interfaces.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e14089"></a><p class="title"><b>Example&nbsp;8.4.8.3-2.&nbsp;Unchecked Warning from Return Type</b></p>
                     <div class="example-contents">
                        <p class="note">Consider:</p><pre class="programlisting">

class StringSorter {
    // turns a collection of strings into a sorted list
    List toList(Collection c) {...} 
}

</pre><p class="note">and assume that someone
                           subclasses <code class="literal">StringSorter</code>:
                        </p><pre class="programlisting">

class Overrider extends StringSorter {
    List toList(Collection c) {...}
}

</pre><p class="note">Now, at some point the author
                           of <code class="literal">StringSorter</code> decides to generify the
                           code:
                        </p><pre class="programlisting">

class StringSorter {
    // turns a collection of strings into a sorted list
    List&lt;String&gt; toList(Collection&lt;String&gt; c) {...}
}

</pre><p class="note">An unchecked warning would be given when
                           compiling <code class="literal">Overrider</code> against the new definition
                           of <code class="literal">StringSorter</code> because the return type
                           of <code class="literal">Overrider.toList</code> is <code class="literal">List</code>,
                           which is not a subtype of the return type of the overridden
                           method, <code class="literal">List&lt;String&gt;</code>.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e14105"></a><p class="title"><b>Example&nbsp;8.4.8.3-3.&nbsp;Incorrect Overriding because of <code class="literal">throws</code></b></p>
                     <div class="example-contents">
                        <p class="note">This program uses the usual and conventional form
                           for declaring a new exception type, in its declaration of the
                           class <code class="literal">BadPointException</code>:
                        </p><pre class="programlisting">
class BadPointException extends Exception {
    BadPointException() { super(); }
    BadPointException(String s) { super(s); }
}
class Point {
    int x, y;
    void move(int dx, int dy) { x += dx; y += dy; }
}
class CheckedPoint extends Point {
    void move(int dx, int dy) throws BadPointException {
        if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
            throw new BadPointException();
        x += dx; y += dy;
    }
}
</pre><p class="note">The program results in a compile-time error, because
                           the override of method <code class="literal">move</code> in
                           class <code class="literal">CheckedPoint</code> declares that it will throw a
                           checked exception that the <code class="literal">move</code> in
                           class <code class="literal">Point</code> has not declared. If this were not
                           considered an error, an invoker of the method <code class="literal">move</code>
                           on a reference of type <code class="literal">Point</code> could find the
                           contract between it and <code class="literal">Point</code> broken if this
                           exception were thrown.
                        </p>
                        <p class="note">Removing the <code class="literal">throws</code> clause does not help:
                        </p><pre class="programlisting">
class CheckedPoint extends Point {
    void move(int dx, int dy) {
        if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
            throw new BadPointException();
        x += dx; y += dy;
    }
}
</pre><p class="note">A different compile-time error now occurs, because
                           the body of the method <code class="literal">move</code> cannot throw a checked
                           exception, namely <code class="literal">BadPointException</code>, that does not
                           appear in the <code class="literal">throws</code> clause for <code class="literal">move</code>.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e14127"></a><p class="title"><b>Example&nbsp;8.4.8.3-4.&nbsp;Erasure Affects Overriding</b></p>
                     <div class="example-contents">
                        <p class="note">A class cannot have two member methods with the same
                           name and type erasure:
                        </p><pre class="programlisting">

class C&lt;T&gt; {
    T id (T x) {...}
}
class D extends C&lt;String&gt; {
    Object id(Object x) {...}
}

</pre><p class="note">This is illegal
                           since <code class="literal">D.id(Object)</code> is a member
                           of <code class="literal">D</code>, <code class="literal">C&lt;String&gt;.id(String)</code>
                           is declared in a supertype of <code class="literal">D</code>, and:
                        </p>
                        <div class="note">
                           <ul class="note" type="disc">
                              <li class="listitem">
                                 <p class="note">The two methods have the same
                                        name, <code class="literal">id</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="note"><code class="literal">C&lt;String&gt;.id(String)</code> is
                                        accessible to <code class="literal">D</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="note">The signature of <code class="literal">D.id(Object)</code>
                                        is not a subsignature of that
                                        of <code class="literal">C&lt;String&gt;.id(String)</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="note">The two methods have the same erasure</p>
                              </li>
                           </ul>
                        </div>
                        <p class="note">Two different methods of a class may not override
                           methods with the same erasure:
                        </p><pre class="programlisting">

class C&lt;T&gt; {
    T id(T x) {...}
}
interface I&lt;T&gt; {
    T id(T x);
}
class D extends C&lt;String&gt; implements I&lt;Integer&gt; {
   public String  id(String x)  {...}
   public Integer id(Integer x) {...}
}

</pre><p class="note">This is also illegal,
                           since <code class="literal">D.id(String)</code> is a member
                           of <code class="literal">D</code>, <code class="literal">D.id(Integer)</code> is declared
                           in <code class="literal">D</code>, and:
                        </p>
                        <div class="note">
                           <ul class="note" type="disc">
                              <li class="listitem">
                                 <p class="note">The two methods have the same
                                        name, <code class="literal">id</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="note"><code class="literal">D.id(Integer)</code> is accessible
                                        to <code class="literal">D</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="note">The two methods have different signatures (and
                                        neither is a subsignature of the other)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="note"><code class="literal">D.id(String)</code>
                                        overrides <code class="literal">C&lt;String&gt;.id(String)</code>
                                        and <code class="literal">D.id(Integer)</code>
                                        overrides <code class="literal">I.id(Integer)</code> yet the two overridden
                                        methods have the same erasure
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><br class="example-break"></div>
               <div class="section" title="8.4.8.4.&nbsp;Inheriting Methods with Override-Equivalent Signatures">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.4.8.4"></a>8.4.8.4.&nbsp;Inheriting Methods with Override-Equivalent Signatures
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-8.4.8.4-100"></a>
                     It is possible for a class to inherit multiple methods with
                     override-equivalent signatures (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>).
                  </p>
                  <p class="norm-error"><a name="jls-8.4.8.4-110"></a>
                     It is a compile-time error if a class <span class="type">C</span> inherits a concrete method
                     whose signature is override-equivalent with another method inherited
                     by <span class="type">C</span>.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.8.4-120"></a>
                     It is a compile-time error if a class <span class="type">C</span> inherits a default method
                     whose signature is override-equivalent with another method inherited
                     by <span class="type">C</span>, unless there exists an <code class="literal">abstract</code> method declared in a
                     superclass of <span class="type">C</span> and inherited by <span class="type">C</span> that is override-equivalent
                     with the two methods.
                  </p>
                  <p class="note">
                     This exception to the strict default-<code class="literal">abstract</code> and default-default
                     conflict rules is made when an <code class="literal">abstract</code> method is declared in a
                     superclass: the assertion of abstract-ness coming from the superclass
                     hierarchy essentially trumps the default method, making the default
                     method act as if it were <code class="literal">abstract</code>. However, the <code class="literal">abstract</code> method
                     from a class does not override the default method(s), because
                     interfaces are still allowed to refine the <span class="emphasis"><em>signature</em></span> 
                     of the <code class="literal">abstract</code> method coming from the class hierarchy.
                  </p>
                  <p class="note">
                     Note that the exception does not apply if all override-equivalent
                     <code class="literal">abstract</code> methods inherited by <span class="type">C</span> were declared in interfaces.
                  </p>
                  <p class="norm-static"><a name="jls-8.4.8.4-130"></a>
                     Otherwise, the set of override-equivalent methods consists of at least
                     one <code class="literal">abstract</code> method and zero or more default methods; then the class
                     is necessarily an <code class="literal">abstract</code> class and is considered to inherit all
                     the methods.
                  </p>
                  <p class="norm-error"><a name="jls-8.4.8.4-200"></a>
                     One of the inherited methods must be return-type-substitutable for
                     every other inherited method; otherwise, a compile-time error
                     occurs. (The <code class="literal">throws</code> clauses do not cause errors in this
                     case.)
                  </p>
                  <p class="norm-static"><a name="jls-8.4.8.4-300"></a>
                     There might be several paths by which the same method declaration is
                     inherited from an interface. This fact causes no difficulty and never,
                     of itself, results in a compile-time error.
                  </p>
               </div>
            </div>
            <div class="section" title="8.4.9.&nbsp;Overloading">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.4.9"></a>8.4.9.&nbsp;Overloading
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.4.9-100"></a>If two
                  methods of a class (whether both declared in the same class, or both
                  inherited by a class, or one declared and one inherited) have the same
                  name but signatures that are not override-equivalent, then the method
                  name is said to be <span class="emphasis"><em>overloaded</em></span>.
               </p>
               <p class="norm"><a name="jls-8.4.9-110"></a>This fact causes no
                  difficulty and never of itself results in a compile-time error. There
                  is no required relationship between the return types or between the
                  <code class="literal">throws</code> clauses of two methods with the same name, unless their
                  signatures are override-equivalent.
               </p>
               <p class="norm"><a name="jls-8.4.9-200"></a>When a method is invoked
                  (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), the number of actual arguments (and any
                  explicit type arguments) and the compile-time types of the arguments
                  are used, at compile time, to determine the signature of the method
                  that will be invoked (<a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>). If the method
                  that is to be invoked is an instance method, the actual method to be
                  invoked will be determined at run time, using dynamic method lookup
                  (<a class="xref" href="jls-15.html#jls-15.12.4" title="15.12.4.&nbsp;Run-Time Evaluation of Method Invocation">&sect;15.12.4</a>).
               </p>
               <div class="example"><a name="d5e14212"></a><p class="title"><b>Example&nbsp;8.4.9-1.&nbsp;Overloading</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    float x, y;
    void move(int dx, int dy) { x += dx; y += dy; }
    void move(float dx, float dy) { x += dx; y += dy; }
    public String toString() { return "("+x+","+y+")"; }
}
</pre><p class="note">Here, the class <code class="literal">Point</code> has two
                        members that are methods with the same
                        name, <code class="literal">move</code>. The overloaded <code class="literal">move</code>
                        method of class <code class="literal">Point</code> chosen for any particular
                        method invocation is determined at compile time by the overloading
                        resolution procedure given in <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>.
                     </p>
                     <p class="note">In total, the members of the
                        class <code class="literal">Point</code> are the <code class="literal">float</code>
                        instance variables <code class="literal">x</code> and <code class="literal">y</code>
                        declared in <code class="literal">Point</code>, the two
                        declared <code class="literal">move</code> methods, the declared <code class="literal">toString</code>
                        method, and the members that <code class="literal">Point</code> inherits from
                        its implicit direct superclass <code class="literal">Object</code> (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>),
                        such as the method <code class="literal">hashCode</code>. Note
                        that <code class="literal">Point</code> does not inherit the <code class="literal">toString</code> method
                        of class <code class="literal">Object</code> because that method is overridden by the declaration
                        of the <code class="literal">toString</code> method in class <code class="literal">Point</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e14238"></a><p class="title"><b>Example&nbsp;8.4.9-2.&nbsp;Overloading, Overriding, and Hiding</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    int x = 0, y = 0;
    void move(int dx, int dy) { x += dx; y += dy; }
    int color;
}
class RealPoint extends Point {
    float x = 0.0f, y = 0.0f;
    void move(int dx, int dy) { move((float)dx, (float)dy); }
    void move(float dx, float dy) { x += dx; y += dy; }
}
</pre><p class="note">Here, the class <code class="literal">RealPoint</code> hides
                        the declarations of the <code class="literal">int</code> instance variables <code class="literal">x</code>
                        and <code class="literal">y</code> of class <code class="literal">Point</code> with its
                        own <code class="literal">float</code> instance variables <code class="literal">x</code>
                        and <code class="literal">y</code>, and overrides the
                        method <code class="literal">move</code> of class <code class="literal">Point</code> with
                        its own <code class="literal">move</code> method. It also overloads the
                        name <code class="literal">move</code> with another method with a different
                        signature (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>).
                     </p>
                     <p class="note">In this example, the members of the
                        class <code class="literal">RealPoint</code> include the instance
                        variable <code class="literal">color</code> inherited from the
                        class <code class="literal">Point</code>, the <code class="literal">float</code> instance
                        variables <code class="literal">x</code> and <code class="literal">y</code> declared
                        in <code class="literal">RealPoint</code>, and the two <code class="literal">move</code>
                        methods declared in <code class="literal">RealPoint</code>.
                     </p>
                     <p class="note">Which of these overloaded <code class="literal">move</code>
                        methods of class <code class="literal">RealPoint</code> will be chosen for any
                        particular method invocation will be determined at compile time by the
                        overloading resolution procedure described in
                        <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>.
                     </p>
                     <p class="note">This following program is an extended variation of
                        the preceding program:
                     </p><pre class="programlisting">
class Point {
    int x = 0, y = 0, color;
    void move(int dx, int dy) { x += dx; y += dy; }
    int getX() { return x; }
    int getY() { return y; }
}
class RealPoint extends Point {
    float x = 0.0f, y = 0.0f;
    void move(int dx, int dy) { move((float)dx, (float)dy); }
    void move(float dx, float dy) { x += dx; y += dy; }
    float getX() { return x; }
    float getY() { return y; }
}
</pre><p class="note">Here, the class <code class="literal">Point</code> provides
                        methods <code class="literal">getX</code> and <code class="literal">getY</code> that
                        return the values of its fields <code class="literal">x</code>
                        and <code class="literal">y</code>; the class <code class="literal">RealPoint</code> then
                        overrides these methods by declaring methods with the same
                        signature. The result is two errors at compile time, one for each
                        method, because the return types do not match; the methods in
                        class <code class="literal">Point</code> return values of type <code class="literal">int</code>, but the
                        wanna-be overriding methods in class <code class="literal">RealPoint</code>
                        return values of type <code class="literal">float</code>.
                     </p>
                     <p class="note">This program corrects the errors of the preceding
                        program:
                     </p><pre class="programlisting">
class Point {
    int x = 0, y = 0;
    void move(int dx, int dy) { x += dx; y += dy; }
    int getX() { return x; }
    int getY() { return y; }
    int color;
}
class RealPoint extends Point {
    float x = 0.0f, y = 0.0f;
    void move(int dx, int dy) { move((float)dx, (float)dy); }
    void move(float dx, float dy) { x += dx; y += dy; }
    int getX() { return (int)Math.floor(x); }
    int getY() { return (int)Math.floor(y); }
}
</pre><p class="note">Here, the overriding methods <code class="literal">getX</code>
                        and <code class="literal">getY</code> in class <code class="literal">RealPoint</code> have
                        the same return types as the methods of class <code class="literal">Point</code>
                        that they override, so this code can be successfully compiled.
                     </p>
                     <p class="note">Consider, then, this test program:</p><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        RealPoint rp = new RealPoint();
        Point p = rp;
        rp.move(1.71828f, 4.14159f);
        p.move(1, -1);
        show(p.x, p.y);
        show(rp.x, rp.y);
        show(p.getX(), p.getY());
        show(rp.getX(), rp.getY());
    }
    static void show(int x, int y) {
        System.out.println("(" + x + ", " + y + ")");
    }
    static void show(float x, float y) {
        System.out.println("(" + x + ", " + y + ")");
    }
}
</pre><p class="note">The output from this program is:</p><pre class="screen">
(0, 0)
(2.7182798, 3.14159)
(2, 3)
(2, 3)
</pre><p class="note">The first line of output illustrates the fact that
                        an instance of <code class="literal">RealPoint</code> actually contains the two
                        integer fields declared in class <code class="literal">Point</code>; it is just
                        that their names are hidden from code that occurs within the
                        declaration of class <code class="literal">RealPoint</code> (and those of any
                        subclasses it might have). When a reference to an instance of
                        class <code class="literal">RealPoint</code> in a variable of
                        type <code class="literal">Point</code> is used to access the
                        field <code class="literal">x</code>, the integer field <code class="literal">x</code>
                        declared in class <code class="literal">Point</code> is accessed. The fact that
                        its value is zero indicates that the method
                        invocation <code class="literal">p.move(1, -1)</code> did not invoke the
                        method <code class="literal">move</code> of class <code class="literal">Point</code>;
                        instead, it invoked the overriding method <code class="literal">move</code> of
                        class <code class="literal">RealPoint</code>.
                     </p>
                     <p class="note">The second line of output shows that the field
                        access <code class="literal">rp.x</code> refers to the
                        field <code class="literal">x</code> declared in
                        class <code class="literal">RealPoint</code>. This field is of type <code class="literal">float</code>, and
                        this second line of output accordingly displays floating-point
                        values. Incidentally, this also illustrates the fact that the method
                        name <code class="literal">show</code> is overloaded; the types of the arguments
                        in the method invocation dictate which of the two definitions will be
                        invoked.
                     </p>
                     <p class="note">The last two lines of output show that the method
                        invocations <code class="literal">p.getX()</code>
                        and <code class="literal">rp.getX()</code> each invoke
                        the <code class="literal">getX</code> method declared in
                        class <code class="literal">RealPoint</code>. Indeed, there is no way to invoke
                        the <code class="literal">getX</code> method of class <code class="literal">Point</code>
                        for an instance of class <code class="literal">RealPoint</code> from outside the
                        body of <code class="literal">RealPoint</code>, no matter what the type of the
                        variable we may use to hold the reference to the object. Thus, we see
                        that fields and methods behave differently: hiding is different from
                        overriding.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="8.5.&nbsp;Member Type Declarations">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-8.5"></a>8.5.&nbsp;Member Type Declarations
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-8.5-100"></a>
               A <span class="emphasis"><em>member class</em></span> is a class whose declaration is
               directly enclosed in the body of another class or interface
               declaration (<a class="xref" href="jls-8.html#jls-8.1.6" title="8.1.6.&nbsp;Class Body and Member Declarations">&sect;8.1.6</a>, <a class="xref" href="jls-9.html#jls-9.1.4" title="9.1.4.&nbsp;Interface Body and Member Declarations">&sect;9.1.4</a>).
            </p>
            <p class="norm-static"><a name="jls-8.5-110"></a>
               A <span class="emphasis"><em>member interface</em></span> is an interface whose
               declaration is directly enclosed in the body of another class or
               interface declaration (<a class="xref" href="jls-8.html#jls-8.1.6" title="8.1.6.&nbsp;Class Body and Member Declarations">&sect;8.1.6</a>,
               <a class="xref" href="jls-9.html#jls-9.1.4" title="9.1.4.&nbsp;Interface Body and Member Declarations">&sect;9.1.4</a>).
            </p>
            <p class="norm-static"><a name="jls-8.5-200"></a>
               The accessibility of a member type declaration in a class is specified
               by its access modifier, or by <a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a> if lacking an
               access modifier.
            </p>
            <p class="norm-error"><a name="jls-8.5-210"></a>
               It is a compile-time error if the same keyword appears more than once
               as a modifier for a member type declaration in a class, or if a member
               type declaration has more than one of the access modifiers <code class="literal">public</code>,
               <code class="literal">protected</code>, and <code class="literal">private</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>.)
            </p>
            <p class="norm-static"><a name="jls-8.5-300"></a>
               The scope and shadowing of a member type is specified in
               <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
            </p>
            <p class="norm-static"><a name="jls-8.5-310"></a>
               If a class declares a member type with a certain name, then the
               declaration of that type is said to <span class="emphasis"><em>hide</em></span> any and
               all accessible declarations of member types with the same name in
               superclasses and superinterfaces of the class.
            </p>
            <p class="note">In this respect, hiding of member types is similar
               to hiding of fields (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>).
            </p>
            <p class="norm-static"><a name="jls-8.5-400"></a>
               A class inherits from its direct superclass and direct superinterfaces
               all the non-<code class="literal">private</code> member types of the superclass and
               superinterfaces that are both accessible to code in the class and not
               hidden by a declaration in the class.
            </p>
            <p class="norm-error"><a name="jls-8.5-410"></a>
               It is possible for a class to inherit more than one member type with
               the same name, either from its superclass and superinterfaces or from
               its superinterfaces alone. Such a situation does not in itself cause a
               compile-time error. However, any attempt within the body of the class
               to refer to any such member type by its simple name will result in a
               compile-time error, because the reference is ambiguous.
            </p>
            <p class="norm-static"><a name="jls-8.5-420"></a>
               There might be several paths by which the same member type declaration
               is inherited from an interface. In such a situation, the member type
               is considered to be inherited only once, and it may be referred to by
               its simple name without ambiguity.
            </p>
            <div class="section" title="8.5.1.&nbsp;Static Member Type Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.5.1"></a>8.5.1.&nbsp;Static Member Type Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.5.1-100"></a>The
                  <code class="literal">static</code> keyword may modify the declaration of a member type <span class="type">C</span>
                  within the body of a non-inner class or interface
                  <span class="type">T</span>. Its effect is to declare that <span class="type">C</span> is not an inner class. Just as
                  a <code class="literal">static</code> method of <span class="type">T</span> has no current instance of <span class="type">T</span> in its body,
                  <span class="type">C</span> also has no current instance of <span class="type">T</span>, nor does it have any
                  lexically enclosing instances.
               </p>
               <p class="norm-error"><a name="jls-8.5.1-200"></a>It is a
                  compile-time error if a <code class="literal">static</code> class contains a usage of a
                  non-<code class="literal">static</code> member of an enclosing class.
               </p>
               <p class="norm-static"><a name="jls-8.5.1-300"></a>A member
                  interface is implicitly <code class="literal">static</code> (<a class="xref" href="jls-9.html#jls-9.1.1" title="9.1.1.&nbsp;Interface Modifiers">&sect;9.1.1</a>). It is
                  permitted for the declaration of a member interface to redundantly
                  specify the <code class="literal">static</code> modifier.
               </p>
            </div>
         </div>
         <div class="section" title="8.6.&nbsp;Instance Initializers">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-8.6"></a>8.6.&nbsp;Instance Initializers
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-8.6-100"></a>
               An <span class="emphasis"><em>instance initializer</em></span> declared in a class is
               executed when an instance of the class is created
               (<a class="xref" href="jls-12.html#jls-12.5" title="12.5.&nbsp;Creation of New Class Instances">&sect;12.5</a>, <a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>,
               <a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>).
            </p>
            <div id="jls-8.6-110" class="productionset"><a name="jls-8.6-110"></a>
                 
               <div class="production"><a name="jls-InstanceInitializer"></a>
                      
                  <div class="lhs">InstanceInitializer:</div>
                      
                  <div class="rhs">
                           <a href="jls-14.html#jls-Block" title="Block">Block</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-error"><a name="jls-8.6-200"></a>
               It is a compile-time error if an instance initializer cannot complete
               normally (<a class="xref" href="jls-14.html#jls-14.21" title="14.21.&nbsp;Unreachable Statements">&sect;14.21</a>).
            </p>
            <p class="norm-error"><a name="jls-8.6-210"></a>
               It is a compile-time error if a <code class="literal">return</code> statement
               (<a class="xref" href="jls-14.html#jls-14.17" title="14.17.&nbsp;The return Statement">&sect;14.17</a>) appears anywhere within an instance
               initializer.
            </p>
            <p class="norm-static"><a name="jls-8.6-220"></a>
               An instance initializer is permitted to refer to the current object
               using the keyword <code class="literal">this</code> (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>) or the keyword
               <code class="literal">super</code> (<a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>, <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>),
               and to use any type variables in scope.
            </p>
            <p class="norm-static"><a name="jls-8.6-230"></a>
               Restrictions on how an instance initializer may refer to instance
               variables, even when the instance variables are in scope, are
               specified in <a class="xref" href="jls-8.html#jls-8.3.3" title="8.3.3.&nbsp;Restrictions on Field References in Initializers">&sect;8.3.3</a>).
            </p>
            <p class="norm-static"><a name="jls-8.6-300"></a>
               Exception checking for an instance initializer is specified in
               <a class="xref" href="jls-11.html#jls-11.2.3" title="11.2.3.&nbsp;Exception Checking">&sect;11.2.3</a>.
            </p>
         </div>
         <div class="section" title="8.7.&nbsp;Static Initializers">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-8.7"></a>8.7.&nbsp;Static Initializers
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-8.7-100"></a>
               A <span class="emphasis"><em>static initializer</em></span> declared in a class is
               executed when the class is initialized (<a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>).
               Together with any field initializers for class variables
               (<a class="xref" href="jls-8.html#jls-8.3.2" title="8.3.2.&nbsp;Field Initialization">&sect;8.3.2</a>), static initializers may be used to
               initialize the class variables of the class.
            </p>
            <div id="jls-8.7-110" class="productionset"><a name="jls-8.7-110"></a>
                 
               <div class="production"><a name="jls-StaticInitializer"></a>
                      
                  <div class="lhs">StaticInitializer:</div>
                      
                  <div class="rhs">
                           <code class="literal">static</code> <a href="jls-14.html#jls-Block" title="Block">Block</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-error"><a name="jls-8.7-200"></a>
               It is a compile-time error if a static initializer cannot complete
               normally (<a class="xref" href="jls-14.html#jls-14.21" title="14.21.&nbsp;Unreachable Statements">&sect;14.21</a>).
            </p>
            <p class="norm-error"><a name="jls-8.7-210"></a>
               It is a compile-time error if a <code class="literal">return</code> statement
               (<a class="xref" href="jls-14.html#jls-14.17" title="14.17.&nbsp;The return Statement">&sect;14.17</a>) appears anywhere within a static
               initializer.
            </p>
            <p class="norm-error"><a name="jls-8.7-220"></a>
               It is a compile-time error if the keyword <code class="literal">this</code>
               (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>) or the keyword <code class="literal">super</code>
               (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>, <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>) or any type
               variable declared outside the static initializer, appears anywhere
               within a static initializer.
            </p>
            <p class="norm-error"><a name="jls-8.7-230"></a>
               Restrictions on how a static initializer may refer to class variables,
               even when the class variables are in scope, are specified in
               <a class="xref" href="jls-8.html#jls-8.3.3" title="8.3.3.&nbsp;Restrictions on Field References in Initializers">&sect;8.3.3</a>.
            </p>
            <p class="norm-static"><a name="jls-8.7-300"></a>
               Exception checking for a static initializer is specified in
               <a class="xref" href="jls-11.html#jls-11.2.3" title="11.2.3.&nbsp;Exception Checking">&sect;11.2.3</a>.
            </p>
         </div>
         <div class="section" title="8.8.&nbsp;Constructor Declarations">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-8.8"></a>8.8.&nbsp;Constructor Declarations
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-8.8-100"></a>
               A <span class="emphasis"><em>constructor</em></span> is used in the creation of an object
               that is an instance of a class (<a class="xref" href="jls-12.html#jls-12.5" title="12.5.&nbsp;Creation of New Class Instances">&sect;12.5</a>,
               <a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>).
            </p>
            <div id="jls-8.8-110" class="productionset"><a name="jls-8.8-110"></a>
                 
               <div class="production"><a name="jls-ConstructorDeclaration"></a>
                      
                  <div class="lhs">ConstructorDeclaration:</div>
                      
                  <div class="rhs">
                           {<a href="jls-8.html#jls-ConstructorModifier" title="ConstructorModifier">ConstructorModifier</a>}
                           <a href="jls-8.html#jls-ConstructorDeclarator" title="ConstructorDeclarator">ConstructorDeclarator</a>
                           [<a href="jls-8.html#jls-Throws" title="Throws">Throws</a>]
                           <a href="jls-8.html#jls-ConstructorBody" title="ConstructorBody">ConstructorBody</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-ConstructorDeclarator"></a>
                      
                  <div class="lhs">ConstructorDeclarator:</div>
                      
                  <div class="rhs">
                           [<a href="jls-8.html#jls-TypeParameters" title="TypeParameters">TypeParameters</a>]
                           <a href="jls-8.html#jls-SimpleTypeName" title="SimpleTypeName">SimpleTypeName</a>
                           <code class="literal">(</code> [<a href="jls-8.html#jls-FormalParameterList" title="FormalParameterList">FormalParameterList</a>] <code class="literal">)</code>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-SimpleTypeName"></a>
                      
                  <div class="lhs">SimpleTypeName:</div>
                      
                  <div class="rhs">
                           <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm"><a name="jls-8.8-120"></a>
               The rules in this section apply to constructors in all class
               declarations, including enum declarations. However, special rules
               apply to enum declarations with regard to constructor modifiers,
               constructor bodies, and default constructors; these rules are stated
               in <a class="xref" href="jls-8.html#jls-8.9.2" title="8.9.2.&nbsp;Enum Body Declarations">&sect;8.9.2</a>.
            </p>
            <p class="norm-error"><a name="jls-8.8-200"></a>
               The <span class="emphasis"><em>SimpleTypeName</em></span> in the 
               <span class="emphasis"><em>ConstructorDeclarator</em></span> must be the simple name
               of the class that contains the constructor declaration, or a
               compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-8.8-210"></a>
               In all other respects, a constructor declaration looks just like a
               method declaration that has no result (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>).
            </p>
            <p class="norm-static"><a name="jls-8.8-300"></a>
               Constructor declarations are not members. They are never inherited and
               therefore are not subject to hiding or overriding.
            </p>
            <p class="norm"><a name="jls-8.8-400"></a>
               Constructors are invoked by class instance creation expressions
               (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>), by the conversions and concatenations
               caused by the string concatenation operator <code class="literal">+</code>
               (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>), and by explicit constructor
               invocations from other constructors
               (<a class="xref" href="jls-8.html#jls-8.8.7" title="8.8.7.&nbsp;Constructor Body">&sect;8.8.7</a>). Access to constructors is governed by
               access modifiers (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>), so it is possible to
               prevent class instantiation by declaring an inaccessible constructor
               (<a class="xref" href="jls-8.html#jls-8.8.10" title="8.8.10.&nbsp;Preventing Instantiation of a Class">&sect;8.8.10</a>).
            </p>
            <p class="norm"><a name="jls-8.8-410"></a>
               Constructors are never invoked by method invocation expressions
               (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>).
            </p>
            <div class="example"><a name="d5e14466"></a><p class="title"><b>Example&nbsp;8.8-1.&nbsp;Constructor Declarations</b></p>
               <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}
</pre></div>
            </div><br class="example-break"><div class="section" title="8.8.1.&nbsp;Formal Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.1"></a>8.8.1.&nbsp;Formal Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.8.1-100"></a>The formal
                  parameters of a constructor are identical in syntax and semantics to
                  those of a method (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>).
               </p>
               <p class="norm-static"><a name="jls-8.8.1-200"></a>The
                  constructor of a non-<code class="literal">private</code> inner member class implicitly declares,
                  as the first formal parameter, a variable representing the immediately
                  enclosing instance of the class (<a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>,
                  <a class="xref" href="jls-15.html#jls-15.9.3" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">&sect;15.9.3</a>).
               </p>
               <p class="note">The rationale for why only this kind of class has an
                  implicitly declared constructor parameter is subtle. The following
                  explanation may be helpful:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="note">In a class instance creation expression for a
                                 non-<code class="literal">private</code> inner member class, <a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>
                                 specifies the immediately enclosing instance of the member
                                 class. The member class may have been emitted by a compiler
                                 which is different than the compiler of the class instance
                                 creation expression. Therefore, there must be a standard way for
                                 the compiler of the creation expression to pass a reference
                                 (representing the immediately enclosing instance) to the member
                                 class's constructor. Consequently, the Java programming language deems in this
                                 section that a non-<code class="literal">private</code> inner member class's constructor
                                 implicitly declares an initial parameter for the immediately
                                 enclosing instance. <a class="xref" href="jls-15.html#jls-15.9.3" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">&sect;15.9.3</a> specifies that
                                 the instance is passed to the constructor.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">In a class instance creation expression for a
                                 local class (not in a static context) or anonymous class,
                                 <a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a> specifies the immediately enclosing
                                 instance of the local/anonymous class. The local/anonymous class
                                 is necessarily emitted by the same compiler as the class
                                 instance creation expression. That compiler can represent the
                                 immediately enclosing instance how ever it wishes. There is no
                                 need for the Java programming language to implicitly declare a parameter in the
                                 local/anonymous class's constructor.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">In a class instance creation expression for an
                                 anonymous class, and where the anonymous class's superclass is
                                 either inner or local (not in a static context),
                                 <a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a> specifies the anonymous class's
                                 immediately enclosing instance with respect to the
                                 superclass. This instance must be transmitted from the anonymous
                                 class to its superclass, where it will serve as the immediately
                                 enclosing instance. Since the superclass may have been emitted
                                 by a compiler which is different than the compiler of the class
                                 instance creation expression, it is necessary to transmit the
                                 instance in a standard way, by passing it as the first argument
                                 to the superclass's constructor. Note that the anonymous class
                                 itself is necessarily emitted by the same compiler as the class
                                 instance creation expression, so it would be possible for the
                                 compiler to transmit the immediately enclosing instance with
                                 respect to the superclass to the anonymous class how ever it
                                 wishes, before the anonymous class passes the instance to the
                                 superclass's constructor. However, for consistency, the
                                 Java programming language deems in <a class="xref" href="jls-15.html#jls-15.9.5.1" title="15.9.5.1.&nbsp;Anonymous Constructors">&sect;15.9.5.1</a> that, in some
                                 circumstances, an anonymous class's constructor implicitly
                                 declares an initial parameter for the immediately enclosing
                                 instance with respect to the superclass.
                        </p>
                     </li>
                  </ol>
               </div>
               <p class="note">The fact that a non-<code class="literal">private</code> inner member class may
                  be accessed by a different compiler than compiled it, whereas a local
                  or anonymous class is always accessed by the same compiler that
                  compiled it, explains why the binary name of a non-<code class="literal">private</code> inner
                  member class is defined to be predictable but the binary name of a
                  local or anonymous class is not (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>).
               </p>
            </div>
            <div class="section" title="8.8.2.&nbsp;Constructor Signature">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.2"></a>8.8.2.&nbsp;Constructor Signature
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-8.8.2-100"></a>It is a
                  compile-time error to declare two constructors with
                  override-equivalent signatures (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) in a
                  class.
               </p>
               <p class="norm-error"><a name="jls-8.8.2-110"></a>It is a
                  compile-time error to declare two constructors whose signatures have
                  the same erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) in a class.
               </p>
            </div>
            <div class="section" title="8.8.3.&nbsp;Constructor Modifiers">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.3"></a>8.8.3.&nbsp;Constructor Modifiers
                        </h3>
                     </div>
                  </div>
               </div>
               <div id="jls-8.8.3-100" class="productionset"><a name="jls-8.8.3-100"></a>
                    
                  <div class="production"><a name="jls-ConstructorModifier"></a>
                         
                     <div class="lhs">ConstructorModifier:</div>
                         
                     <div class="rhs">
                              (one of) <br>
                              <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <code class="literal">public</code> <code class="literal">protected</code> <code class="literal">private</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.8.3-110"></a>
                  The rules for annotation modifiers on a constructor declaration are
                  specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Type">&sect;9.7.5</a>.
               </p>
               <p class="norm-error"><a name="jls-8.8.3-200"></a>
                  It is a compile-time error if the same keyword appears more than once
                  as a modifier in a constructor declaration, or if a constructor
                  declaration has more than one of the access modifiers <code class="literal">public</code>,
                  <code class="literal">protected</code>, and <code class="literal">private</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>).
               </p>
               <p class="norm-static"><a name="jls-8.8.3-210"></a>
                  In a normal class declaration, a constructor declaration with no
                  access modifiers has package access.
               </p>
               <p class="note">If two or more (distinct) method modifiers appear in
                  a method declaration, it is customary, though not required, that they
                  appear in the order consistent with that shown above in the production
                  for <span class="emphasis"><em>MethodModifier</em></span>.
               </p>
               <p class="note">Unlike methods, a constructor cannot be <code class="literal">abstract</code>,
                  <code class="literal">static</code>, <code class="literal">final</code>, <code class="literal">native</code>, <code class="literal">strictfp</code>, or <code class="literal">synchronized</code>:
               </p>
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note">A constructor is not inherited, so there is no
                                 need to declare it <code class="literal">final</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">An <code class="literal">abstract</code> constructor could never be
                                 implemented.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">A constructor is always invoked with respect to
                                 an object, so it makes no sense for a constructor to be
                                 <code class="literal">static</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">There is no practical need for a constructor to
                                 be <code class="literal">synchronized</code>, because it would lock the object under
                                 construction, which is normally not made available to other
                                 threads until all constructors for the object have completed
                                 their work.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">The lack of <code class="literal">native</code> constructors is an
                                 arbitrary language design choice that makes it easy for an
                                 implementation of the Java Virtual Machine to verify that superclass
                                 constructors are always properly invoked during object
                                 creation.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">The inability to declare a constructor as
                                 <code class="literal">strictfp</code> (in contrast to a method
                                 (<a class="xref" href="jls-8.html#jls-8.4.3" title="8.4.3.&nbsp;Method Modifiers">&sect;8.4.3</a>)) is an intentional language design
                                 choice; it effectively ensures that a constructor is FP-strict
                                 if and only if its class is FP-strict
                                 (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>).
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="8.8.4.&nbsp;Generic Constructors">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.4"></a>8.8.4.&nbsp;Generic Constructors
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.8.4-100"></a>A
                  constructor is <span class="emphasis"><em>generic</em></span> if it declares one or more
                  type variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>).
               </p>
               <p class="norm-static"><a name="jls-8.8.4-110"></a>These type
                  variables are known as the <span class="emphasis"><em>type parameters</em></span> of the
                  constructor. The form of the type parameter section of a generic
                  constructor is identical to the type parameter section of a generic
                  class (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>).
               </p>
               <p class="norm"><a name="jls-8.8.4-120"></a>It is possible for a
                  constructor to be generic independently of whether the class the
                  constructor is declared in is itself generic.
               </p>
               <p class="norm-static"><a name="jls-8.8.4-130"></a>A generic
                  constructor declaration defines a set of constructors, one for each
                  possible invocation of the type parameter section by type
                  arguments. Type arguments may not need to be provided explicitly when
                  a generic constructor is invoked, as they can often by inferred
                  (<a class="xref" href="jls-18.html" title="Chapter&nbsp;18.&nbsp;Type Inference">&sect;18 (<i>Type Inference</i>)</a>).
               </p>
               <p class="norm-static"><a name="jls-8.8.4-200"></a>The scope
                  and shadowing of a constructor's type parameter is specified in
                  <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
               </p>
            </div>
            <div class="section" title="8.8.5.&nbsp;Constructor Throws">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.5"></a>8.8.5.&nbsp;Constructor Throws
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.8.5-100"></a>The
                  <code class="literal">throws</code> clause for a constructor is identical in structure and
                  behavior to the <code class="literal">throws</code> clause for a method
                  (<a class="xref" href="jls-8.html#jls-8.4.6" title="8.4.6.&nbsp;Method Throws">&sect;8.4.6</a>).
               </p>
            </div>
            <div class="section" title="8.8.6.&nbsp;The Type of a Constructor">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.6"></a>8.8.6.&nbsp;The Type of a Constructor
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.8.6-100"></a>The type
                  of a constructor consists of its signature and the exception types
                  given by its <code class="literal">throws</code> clause.
               </p>
            </div>
            <div class="section" title="8.8.7.&nbsp;Constructor Body">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.7"></a>8.8.7.&nbsp;Constructor Body
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.8.7-100"></a>The first
                  statement of a constructor body may be an explicit invocation of
                  another constructor of the same class or of the direct superclass
                  (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>).
               </p>
               <div id="jls-8.8.7-110" class="productionset"><a name="jls-8.8.7-110"></a>
                    
                  <div class="production"><a name="jls-ConstructorBody"></a>
                         
                     <div class="lhs">ConstructorBody:</div>
                         
                     <div class="rhs">
                              <code class="literal">{</code>
                              [<a href="jls-8.html#jls-ExplicitConstructorInvocation" title="ExplicitConstructorInvocation">ExplicitConstructorInvocation</a>]
                              [<a href="jls-14.html#jls-BlockStatements" title="BlockStatements">BlockStatements</a>]
                              <code class="literal">}</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.8.7-200"></a>It is a
                  compile-time error for a constructor to directly or indirectly invoke
                  itself through a series of one or more explicit constructor
                  invocations involving <code class="literal">this</code>.
               </p>
               <p class="norm-static"><a name="jls-8.8.7-220"></a>If a
                  constructor body does not begin with an explicit constructor
                  invocation and the constructor being declared is not part of the
                  primordial class <code class="literal">Object</code>, then the constructor body implicitly begins
                  with a superclass constructor invocation
                  "<code class="literal">super();</code>", an invocation of the constructor of its
                  direct superclass that takes no arguments.
               </p>
               <p class="norm-static"><a name="jls-8.8.7-230"></a>Except for
                  the possibility of explicit constructor invocations, and the
                  prohibition on explicitly returning a value
                  (<a class="xref" href="jls-14.html#jls-14.17" title="14.17.&nbsp;The return Statement">&sect;14.17</a>), the body of a constructor is like the
                  body of a method (<a class="xref" href="jls-8.html#jls-8.4.7" title="8.4.7.&nbsp;Method Body">&sect;8.4.7</a>).
               </p>
               <p class="norm-static"><a name="jls-8.8.7-240"></a>A <code class="literal">return</code>
                  statement (<a class="xref" href="jls-14.html#jls-14.17" title="14.17.&nbsp;The return Statement">&sect;14.17</a>) may be used in the body of a
                  constructor if it does not include an expression.
               </p>
               <div class="example"><a name="d5e14598"></a><p class="title"><b>Example&nbsp;8.8.7-1.&nbsp;Constructor Bodies</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
    static final int WHITE = 0, BLACK = 1;
    int color;
    ColoredPoint(int x, int y) {
        this(x, y, WHITE);
    }
    ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = color;
    }
}
</pre><p class="note">Here, the first constructor
                        of <code class="literal">ColoredPoint</code> invokes the second, providing an
                        additional argument; the second constructor
                        of <code class="literal">ColoredPoint</code> invokes the constructor of its
                        superclass <code class="literal">Point</code>, passing along the
                        coordinates.
                     </p>
                  </div>
               </div><br class="example-break"><div class="section" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-8.8.7.1"></a>8.8.7.1.&nbsp;Explicit Constructor Invocations
                           </h4>
                        </div>
                     </div>
                  </div>
                  <div id="jls-8.8.7.1-100" class="productionset"><a name="jls-8.8.7.1-100"></a>
                       
                     <div class="production"><a name="jls-ExplicitConstructorInvocation"></a>
                            
                        <div class="lhs">ExplicitConstructorInvocation:</div>
                            
                        <div class="rhs">
                                 
                                 [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <code class="literal">this</code> <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> <code class="literal">;</code> <br>
                           
                                 
                                 [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <code class="literal">super</code> <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> <code class="literal">;</code> <br>
                           
                                 
                                 <a href="jls-6.html#jls-ExpressionName" title="ExpressionName">ExpressionName</a> <code class="literal">.</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <code class="literal">super</code> <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> <code class="literal">;</code> <br>
                           
                                 
                                 <a href="jls-15.html#jls-Primary" title="Primary">Primary</a> <code class="literal">.</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <code class="literal">super</code> <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> <code class="literal">;</code>
                               
                        </div>
                          
                     </div>  
                     
                  </div>
                  <p class="note">The following productions from
                     <a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a> and <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a> are shown
                     here for convenience:
                  </p>
                  <div id="d5e14642" class="productionset"><a name="d5e14642"></a>
                       
                     <div class="productionrecap-note">
                        <div class="production">
                               
                           <div class="lhs">TypeArguments:</div>
                               
                           <div class="rhs">
                                    <code class="literal">&lt;</code> <a href="jls-4.html#jls-TypeArgumentList" title="TypeArgumentList">TypeArgumentList</a> <code class="literal">&gt;</code>
                                  
                           </div>
                             
                        </div>
                     </div>
                       
                     <div class="productionrecap-note">
                        <div class="production">
                               
                           <div class="lhs">ArgumentList:</div>
                               
                           <div class="rhs">
                                    <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> {<code class="literal">,</code> <a href="jls-15.html#jls-Expression" title="Expression">Expression</a>}
                                  
                           </div>
                             
                        </div>
                     </div>
                     
                  </div>
                  <p class="norm-static"><a name="jls-8.8.7.1-110"></a>
                     Explicit constructor invocation statements are divided into two
                     kinds:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.8.7.1-110-A"></a>
                                    <span class="emphasis"><em>Alternate constructor invocations</em></span> begin
                                    with the keyword <code class="literal">this</code> (possibly prefaced with explicit type
                                    arguments). They are used to invoke an alternate constructor of
                                    the same class.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.8.7.1-110-B"></a>
                                    <span class="emphasis"><em>Superclass constructor invocations</em></span> begin
                                    with either the keyword <code class="literal">super</code> (possibly prefaced with explicit
                                    type arguments) or a <span class="emphasis"><em>Primary</em></span> expression or an
                                    <span class="emphasis"><em>ExpressionName</em></span>. They are used to invoke a constructor of the
                                    direct superclass. They are further divided:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-8.8.7.1-110-B-A"></a>
                                       	  <span class="emphasis"><em>Unqualified superclass constructor
                                                       invocations</em></span> begin with the keyword <code class="literal">super</code>
                                                 (possibly prefaced with explicit type arguments).
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-8.8.7.1-110-B-B"></a>
                                       	  <span class="emphasis"><em>Qualified superclass constructor
                                                       invocations</em></span> begin with a <span class="emphasis"><em>Primary</em></span> expression or
                                                 an <span class="emphasis"><em>ExpressionName</em></span>. They allow a subclass constructor to
                                                 explicitly specify the newly created object's immediately
                                                 enclosing instance with respect to the direct superclass
                                                 (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>). This may be necessary when
                                                 the superclass is an inner class.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-error"><a name="jls-8.8.7.1-200"></a>
                     An explicit constructor invocation statement in a constructor body may
                     not refer to any instance variables or instance methods 
                     or inner classes  declared in this class or any
                     superclass, or use <code class="literal">this</code> or <code class="literal">super</code> in any expression; otherwise, a
                     compile-time error occurs.
                  </p>
                  <p class="note">This prohibition on using the current instance
                     explains why an explicit constructor invocation statement is deemed to
                     occur in a static context (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>).
                  </p>
                  <p class="norm-error"><a name="jls-8.8.7.1-210"></a>
                     If <span class="emphasis"><em>TypeArguments</em></span> is present to the left of <code class="literal">this</code> or <code class="literal">super</code>, then
                     it is a compile-time error if any of the type arguments are wildcards
                     (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>).
                  </p>
                  <p class="norm"><a name="jls-8.8.7.1-300"></a>
                     Let <span class="type">C</span> be the class being instantiated, and let <span class="type">S</span> be the direct
                     superclass of <span class="type">C</span>.
                  </p>
                  <p class="norm-error"><a name="jls-8.8.7.1-310"></a>
                     If a superclass constructor invocation statement is unqualified, then:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.8.7.1-310-A"></a>
                                    If <span class="type">S</span> is an inner member class, but <span class="type">S</span> is not a member of a
                                    
                                     class enclosing  <span class="type">C</span>,
                                    then a compile-time error occurs.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-8.8.7.1-320"></a>
                     If a superclass constructor invocation statement is qualified, then:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-8.8.7.1-320-A"></a>
                                    If <span class="type">S</span> is not an inner class, or if the declaration of <span class="type">S</span>
                                    occurs in a static context, then a compile-time error occurs.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-8.8.7.1-320-B"></a>
                                    Otherwise, let <code class="varname">p</code> be the <span class="emphasis"><em>Primary</em></span> expression or the
                                    <span class="emphasis"><em>ExpressionName</em></span> immediately preceding "<code class="literal">.</code><code class="literal">super</code>", and let
                                    <span class="type">O</span> be the immediately enclosing class of <span class="type">S</span>. It is a
                                    compile-time error if the type of <code class="varname">p</code> is not <span class="type">O</span> or a subclass
                                    of <span class="type">O</span>, or if the type of <code class="varname">p</code> is not accessible
                                    (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-8.8.7.1-400"></a>
                     The exception types that an explicit constructor invocation statement
                     can throw are specified in <a class="xref" href="jls-11.html#jls-11.2.2" title="11.2.2.&nbsp;Exception Analysis of Statements">&sect;11.2.2</a>.
                  </p>
                  <p class="norm-dynamic"><a name="jls-8.8.7.1-500"></a>
                     Evaluation of an alternate constructor invocation statement proceeds
                     by first evaluating the arguments to the constructor, left-to-right,
                     as in an ordinary method invocation; and then invoking the
                     constructor.
                  </p>
                  <p class="norm-dynamic"><a name="jls-8.8.7.1-510"></a>
                     Evaluation of a superclass constructor invocation statement proceeds
                     as follows:
                  </p>
                  <div class="orderedlist">
                     <ol class="orderedlist" type="1">
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A"></a>
                                    Let <code class="varname">i</code> be the instance being created. The immediately enclosing
                                    instance of <code class="varname">i</code> with respect to <span class="type">S</span> (if any) must be
                                    determined:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="disc">
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A-A"></a>
                                       	  If <span class="type">S</span> is not an inner class, or if the declaration of <span class="type">S</span>
                                       	  occurs in a static context, then no immediately enclosing
                                       	  instance of <code class="varname">i</code> with respect to <span class="type">S</span> exists.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A-B"></a>
                                       	  If the superclass constructor invocation is unqualified,
                                       	  then <span class="type">S</span> is necessarily a local class or an inner member
                                       	  class.
                                    </p>
                                    <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A-B.1"></a>
                                       	  If <span class="type">S</span> is a local class, then let <span class="type">O</span> be the immediately
                                       	  enclosing type declaration of <span class="type">S</span>.
                                    </p>
                                    <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A-B.2"></a>
                                       	  If <span class="type">S</span> is an inner member class, then let <span class="type">O</span> be the
                                       	  innermost enclosing class of <span class="type">C</span> of which <span class="type">S</span> is a member.
                                    </p>
                                    <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A-B.3"></a>
                                       	  Let <span class="emphasis"><em>n</em></span> be an integer (<span class="emphasis"><em>n</em></span> <span class="symbol">&#8805;</span> 1) such that <span class="type">O</span> is
                                                 the <span class="emphasis"><em>n</em></span>'th lexically enclosing type declaration of <span class="type">C</span>.
                                    </p>
                                    <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A-B.4"></a>
                                       	  The immediately enclosing instance of <code class="varname">i</code> with respect to
                                       	  <span class="type">S</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing instance of <code class="literal">this</code>.
                                    </p>
                                    <p class="note">
                                       	  While it may be the case that <span class="type">S</span> is a member of <span class="type">C</span> due to
                                       	  inheritance, the zeroth lexically enclosing instance of
                                       	  <code class="literal">this</code> (that is, <code class="literal">this</code> itself) is never used as the
                                       	  immediately enclosing instance of <span class="emphasis"><em>i</em></span> with respect to <span class="type">S</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A-C"></a>
                                       	  If the superclass constructor invocation is qualified, then
                                       	  the <span class="emphasis"><em>Primary</em></span> expression or the <span class="emphasis"><em>ExpressionName</em></span> immediately
                                       	  preceding "<code class="literal">.</code><code class="literal">super</code>", <code class="varname">p</code>, is evaluated.
                                    </p>
                                    <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A-C.1"></a>
                                       	  If <code class="varname">p</code> evaluates to <code class="literal">null</code>, a <code class="literal">NullPointerException</code> is raised, and the
                                                 superclass constructor invocation completes abruptly.
                                    </p>
                                    <p class="norm-dynamic"><a name="jls-8.8.7.1-510-A-C.2"></a>
                                       	  Otherwise, the result of this evaluation is the immediately
                                                 enclosing instance of <code class="varname">i</code> with respect to <span class="type">S</span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-8.8.7.1-510-B"></a>
                                    After determining the immediately enclosing instance of <code class="varname">i</code> with
                                    respect to <span class="type">S</span> (if any), evaluation of the superclass
                                    constructor invocation statement proceeds by evaluating the
                                    arguments to the constructor, left-to-right, as in an ordinary
                                    method invocation; and then invoking the constructor.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-8.8.7.1-510-C"></a>
                                    Finally, if the superclass constructor invocation statement
                                    completes normally, then all instance variable initializers of
                                    <span class="type">C</span> and all instance initializers of <span class="type">C</span> are executed. If an
                                    instance initializer or instance variable
                                    initializer <code class="varname">I</code> textually precedes another
                                    instance initializer or instance variable
                                    initializer <code class="varname">J</code>, then <code class="varname">I</code> is
                                    executed before <code class="varname">J</code>.
                           </p>
                           <p class="norm-dynamic"><a name="jls-8.8.7.1-510-C.1"></a>
                                    Execution of instance variable initializers and instance
                                    initializers is performed regardless of whether the superclass
                                    constructor invocation actually appears as an explicit
                                    constructor invocation statement or is provided implicitly. (An
                                    alternate constructor invocation does not perform this
                                    additional implicit execution.)
                           </p>
                        </li>
                     </ol>
                  </div>
                  <div class="example"><a name="d5e14784"></a><p class="title"><b>Example&nbsp;8.8.7.1-1.&nbsp;Restrictions on Explicit Constructor Invocation Statements</b></p>
                     <div class="example-contents">
                        <p class="note">If the first constructor
                           of <code class="literal">ColoredPoint</code> in the example from
                           <a class="xref" href="jls-8.html#jls-8.8.7" title="8.8.7.&nbsp;Constructor Body">&sect;8.8.7</a> were changed as follows:
                        </p><pre class="programlisting">
class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
    static final int WHITE = 0, BLACK = 1;
    int color;
    ColoredPoint(int x, int y) {
        this(x, y, color);  // Changed to color from WHITE
    }
    ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = color;
    }
}
</pre><p class="note">then a compile-time error would occur, because the
                           instance variable <code class="literal">color</code> cannot be used by a
                           explicit constructor invocation statement.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e14792"></a><p class="title"><b>Example&nbsp;8.8.7.1-2.&nbsp;Qualified Superclass Constructor Invocation</b></p>
                     <div class="example-contents">
                        <p class="note">In the code below, <code class="literal">ChildOfInner</code>
                           has no lexically enclosing type declaration, so an instance of
                           <code class="literal">ChildOfInner</code> has no enclosing instance. However,
                           the superclass of <code class="literal">ChildOfInner</code>
                           (<code class="literal">Inner</code>) has a lexically enclosing type declaration
                           (<code class="literal">Outer</code>), and an instance
                           of <code class="literal">Inner</code> must have an enclosing instance
                           of <code class="literal">Outer</code>. The enclosing instance
                           of <code class="literal">Outer</code> is set when an instance
                           of <code class="literal">Inner</code> is created. Therefore, when we create an
                           instance of <code class="literal">ChildOfInner</code>, which is implicitly an
                           instance of <code class="literal">Inner</code>, we must provide the enclosing
                           instance of <code class="literal">Outer</code> via a qualified superclass
                           invocation statement in <code class="literal">ChildOfInner</code>'s
                           constructor. The instance of <code class="literal">Outer</code> is called the
                           immediately enclosing instance of <code class="literal">ChildOfInner</code> with
                           respect to <code class="literal">Inner</code>.
                        </p><pre class="programlisting">
class Outer {
    class Inner {}
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner() { (new Outer()).super(); }
}
</pre><p class="note">Perhaps surprisingly, the same instance
                           of <code class="literal">Outer</code> may serve as the immediately enclosing
                           instance of <code class="literal">ChildOfInner</code> with respect
                           to <code class="literal">Inner</code> <span class="emphasis"><em>for multiple instances
                                 of <code class="literal">ChildOfInner</code></em></span>. These instances of
                           <code class="literal">ChildOfInner</code> are implicitly linked to the same
                           instance of <code class="literal">Outer</code>. The program below achieves this
                           by passing an instance of <code class="literal">Outer</code> to the constructor
                           of <code class="literal">ChildOfInner</code>, which uses the instance in a
                           qualified superclass constructor invocation statement. The rules for
                           an explicit constructor invocation statement do not prohibit using
                           formal parameters of the constructor that contains the
                           statement.
                        </p><pre class="programlisting">
class Outer {
    int secret = 5;
    class Inner {
        int  getSecret()      { return secret; }
        void setSecret(int s) { secret = s; }
    }
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner(Outer x) { x.super(); }
}

public class Test {
    public static void main(String[] args) {
        Outer x = new Outer();
        ChildOfInner a = new ChildOfInner(x);
        ChildOfInner b = new ChildOfInner(x);
        System.out.println(b.getSecret());
        a.setSecret(6);
        System.out.println(b.getSecret());
    }
}

</pre><p class="note">This program produces the output:</p><pre class="screen">
5
6
</pre><p class="note">The effect is that manipulation of instance
                           variables in the common instance of <code class="literal">Outer</code> is
                           visible through references to different instances
                           of <code class="literal">ChildOfInner</code>, even though such references are
                           not aliases in the conventional sense.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
            </div>
            <div class="section" title="8.8.8.&nbsp;Constructor Overloading">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.8"></a>8.8.8.&nbsp;Constructor Overloading
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.8.8-100"></a>
                  Overloading of constructors is identical in behavior to overloading of
                  methods (<a class="xref" href="jls-8.html#jls-8.4.9" title="8.4.9.&nbsp;Overloading">&sect;8.4.9</a>). The overloading is resolved at
                  compile time by each class instance creation expression
                  (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>).
               </p>
            </div>
            <div class="section" title="8.8.9.&nbsp;Default Constructor">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.9"></a>8.8.9.&nbsp;Default Constructor
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.8.9-100"></a>
                  If a class contains no constructor declarations, then a default
                  constructor is implicitly declared. The form of the default
                  constructor for a top level class, member class, or local class is as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.8.9-100-A"></a>
                                 The default constructor has the same 
                                 access modifier as the class, unless the class lacks an access modifier, 
                                 in which case the default constructor has package access
                                 (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.8.9-100-B"></a>
                                 The default constructor has no formal parameters, except in a
                                 non-<code class="literal">private</code> inner member class, where the default constructor
                                 implicitly declares one formal parameter representing the
                                 immediately enclosing instance of the class
                                 (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters">&sect;8.8.1</a>, <a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>,
                                 <a class="xref" href="jls-15.html#jls-15.9.3" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">&sect;15.9.3</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.8.9-100-C"></a>
                                 The default constructor has no <code class="literal">throws</code> clauses.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.8.9-100-D"></a>
                                 If the class being declared is the primordial class <code class="literal">Object</code>,
                                 then the default constructor has an empty body. Otherwise, the
                                 default constructor simply invokes the superclass constructor
                                 with no arguments.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-8.8.9-110"></a>
                  The form of the default constructor for an anonymous class is
                  specified in <a class="xref" href="jls-15.html#jls-15.9.5.1" title="15.9.5.1.&nbsp;Anonymous Constructors">&sect;15.9.5.1</a>.
               </p>
               <p class="norm-error"><a name="jls-8.8.9-200"></a>
                  It is a compile-time error if a default constructor is implicitly
                  declared but the superclass does not have an accessible constructor
                  that takes no arguments and has no <code class="literal">throws</code> clause.
               </p>
               <div class="example"><a name="d5e14856"></a><p class="title"><b>Example&nbsp;8.8.9-1.&nbsp;Default Constructors</b></p>
                  <div class="example-contents">
                     <p class="note">The declaration:</p><pre class="programlisting">

public class Point {
    int x, y;
}

</pre><p class="note">is equivalent to the declaration:</p><pre class="programlisting">

public class Point {
    int x, y;
    public Point() { super(); }
}

</pre><p class="note">where the default constructor is <code class="literal">public</code> because
                        the class <code class="literal">Point</code> is <code class="literal">public</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e14866"></a><p class="title"><b>Example&nbsp;8.8.9-2.&nbsp;Accessibility of Constructors v. Classes</b></p>
                  <div class="example-contents">
                     <p class="note">The rule that the default constructor of a class has
                        the same accessibility as the class itself is simple and
                        intuitive. Note, however, that this does not imply that the
                        constructor is accessible whenever the class is
                        accessible. Consider:
                     </p><pre class="programlisting">
package p1;
public class Outer {
    protected class Inner {}
}
package p2;
class SonOfOuter extends p1.Outer {
    void foo() {
        new Inner();  // compile-time access error
    }
}
</pre><p class="note">The default constructor for <code class="literal">Inner</code>
                        is <code class="literal">protected</code>. However, the constructor is <code class="literal">protected</code> relative
                        to <code class="literal">Inner</code>, while <code class="literal">Inner</code> is
                        <code class="literal">protected</code> relative
                        to <code class="literal">Outer</code>. So, <code class="literal">Inner</code> is
                        accessible in <code class="literal">SonOfOuter</code>, since it is a subclass
                        of <code class="literal">Outer</code>. <code class="literal">Inner</code>'s constructor is
                        not accessible in <code class="literal">SonOfOuter</code>, because the
                        class <code class="literal">SonOfOuter</code> is not a subclass
                        of <code class="literal">Inner</code>! Hence, even
                        though <code class="literal">Inner</code> is accessible, its default constructor
                        is not.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="8.8.10.&nbsp;Preventing Instantiation of a Class">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.8.10"></a>8.8.10.&nbsp;Preventing Instantiation of a Class
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.8.10-100"></a>
                  A class can be designed to prevent code outside the class declaration
                  from creating instances of the class by declaring at least one
                  constructor, to prevent the creation of a default constructor, and by
                  declaring all constructors to be <code class="literal">private</code> (<a class="xref" href="jls-6.html#jls-6.6.1" title="6.6.1.&nbsp;Determining Accessibility">&sect;6.6.1</a>).
               </p>
               <p class="norm-static"><a name="jls-8.8.10-110"></a>
                  A <code class="literal">public</code> class can likewise prevent the creation of instances
                  outside its package by declaring at least one constructor, 
                  to prevent creation of a default constructor with <code class="literal">public</code> access, 
                  and by declaring no constructor that is <code class="literal">public</code> 
                  or <code class="literal">protected</code> (<a class="xref" href="jls-6.html#jls-6.6.2" title="6.6.2.&nbsp;Details on protected Access">&sect;6.6.2</a>).
               </p>
               <div class="example"><a name="d5e14897"></a><p class="title"><b>Example&nbsp;8.8.10-1.&nbsp;Preventing Instantiation via Constructor Accessibility</b></p>
                  <div class="example-contents"><pre class="programlisting">

class ClassOnly {
    private ClassOnly() { }
    static String just = "only the lonely";
}

</pre><p class="note">Here, the class <code class="literal">ClassOnly</code> cannot
                        be instantiated, while in the following code:
                     </p><pre class="programlisting">

package just;
public class PackageOnly {
    PackageOnly() { }
    String[] justDesserts = { "cheesecake", "ice cream" };
}

</pre><p class="note">
                        the <code class="literal">public</code> class <code class="literal">PackageOnly</code> can be instantiated
                        only within the package <code class="literal">just</code>, in which it is
                        declared. This restriction would also apply if the constructor
                        of <code class="literal">PackageOnly</code> was <code class="literal">protected</code>, although in that
                        case, it would be possible for code in other packages to instantiate
                        subclasses of <code class="literal">PackageOnly</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="8.9.&nbsp;Enum Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-8.9"></a>8.9.&nbsp;Enum Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-8.9-100"></a>
               An <span class="emphasis"><em>enum declaration</em></span> specifies a
               new <span class="emphasis"><em>enum type</em></span>, a special kind of class type.
            </p>
            <div id="jls-8.9-110" class="productionset"><a name="jls-8.9-110"></a>
                 
               <div class="production"><a name="jls-EnumDeclaration"></a>
                      
                  <div class="lhs">EnumDeclaration:</div>
                      
                  <div class="rhs">
                           {<a href="jls-8.html#jls-ClassModifier" title="ClassModifier">ClassModifier</a>}
                           <code class="literal">enum</code> <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           [<a href="jls-8.html#jls-Superinterfaces" title="Superinterfaces">Superinterfaces</a>]
                           <a href="jls-8.html#jls-EnumBody" title="EnumBody">EnumBody</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-error"><a name="jls-8.9-200"></a>
               It is a compile-time error if an enum declaration has the modifier
               <code class="literal">abstract</code> or <code class="literal">final</code>.
            </p>
            <p class="norm-static"><a name="jls-8.9-210"></a>
               An enum declaration is implicitly <code class="literal">final</code> unless it contains at least
               one enum constant that has a class body (<a class="xref" href="jls-8.html#jls-8.9.1" title="8.9.1.&nbsp;Enum Constants">&sect;8.9.1</a>).
            </p>
            <p class="norm-static"><a name="jls-8.9-220"></a>
               A nested enum type is implicitly <code class="literal">static</code>. It is permitted for the
               declaration of a nested enum type to redundantly specify the <code class="literal">static</code>
               modifier.
            </p>
            <p class="note">This implies that it is impossible to declare an
               enum type in the body of an inner class (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>),
               because an inner class cannot have <code class="literal">static</code> members except for
               constant variables.
            </p>
            <p class="norm-error"><a name="jls-8.9-230"></a>
               It is a compile-time error if the same keyword appears more than once
               as a modifier for an enum declaration, or if an enum declaration has
               more than one of the access modifiers <code class="literal">public</code>, <code class="literal">protected</code>, and
               <code class="literal">private</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>).
            </p>
            <p class="norm"><a name="jls-8.9-300"></a>The direct superclass of an
               enum type <span class="type">E</span> is <code class="literal">Enum</code><code class="literal">&lt;</code><span class="type">E</span><code class="literal">&gt;</code>
               (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>).
            </p>
            <p class="norm-error"><a name="jls-8.9-400"></a>An enum type
               has no instances other than those defined by its enum constants. It is
               a compile-time error to attempt to explicitly instantiate an enum type
               (<a class="xref" href="jls-15.html#jls-15.9.1" title="15.9.1.&nbsp;Determining the Class being Instantiated">&sect;15.9.1</a>).
            </p>
            <p class="note">In addition to the compile-time error, three further
               mechanisms ensure that no instances of an enum type exist beyond those
               defined by its enum constants:
            </p>
            <div class="note">
               <ul class="note" type="disc">
                  <li class="listitem">
                     <p class="note">
                              The <code class="literal">final</code> <code class="literal">clone</code> method in <code class="literal">Enum</code> ensures
                              that enum constants can never be cloned.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">
                              Reflective instantiation of enum types is prohibited.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">
                              Special treatment by the serialization mechanism ensures that
                              duplicate instances are never created as a result of
                              deserialization.
                     </p>
                  </li>
               </ul>
            </div>
            <div class="section" title="8.9.1.&nbsp;Enum Constants">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.9.1"></a>8.9.1.&nbsp;Enum Constants
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.9.1-100"></a>
                  The body of an enum declaration may contain <span class="emphasis"><em>enum
                        constants</em></span>. An enum constant defines an instance of the enum
                  type.
               </p>
               <div id="jls-8.9.1-110" class="productionset"><a name="jls-8.9.1-110"></a>
                    
                  <div class="production"><a name="jls-EnumBody"></a>
                         
                     <div class="lhs">EnumBody:</div>
                         
                     <div class="rhs">
                              <code class="literal">{</code>
                              [<a href="jls-8.html#jls-EnumConstantList" title="EnumConstantList">EnumConstantList</a>] [<code class="literal">,</code>]
                              [<a href="jls-8.html#jls-EnumBodyDeclarations" title="EnumBodyDeclarations">EnumBodyDeclarations</a>]
                              <code class="literal">}</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-EnumConstantList"></a>
                         
                     <div class="lhs">EnumConstantList:</div>
                         
                     <div class="rhs">
                              <a href="jls-8.html#jls-EnumConstant" title="EnumConstant">EnumConstant</a> {<code class="literal">,</code> <a href="jls-8.html#jls-EnumConstant" title="EnumConstant">EnumConstant</a>}
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-EnumConstant"></a>
                         
                     <div class="lhs">EnumConstant:</div>
                         
                     <div class="rhs">
                              {<a href="jls-8.html#jls-EnumConstantModifier" title="EnumConstantModifier">EnumConstantModifier</a>}
                              <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                              [<code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code>]
                              [<a href="jls-8.html#jls-ClassBody" title="ClassBody">ClassBody</a>]
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-EnumConstantModifier"></a>
                         
                     <div class="lhs">EnumConstantModifier:</div>
                         
                     <div class="rhs">
                              <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">The following production from
                  <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a> is shown here for convenience:
               </p>
               <div id="d5e14995" class="productionset"><a name="d5e14995"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">ArgumentList:</div>
                            
                        <div class="rhs">
                                 <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> {<code class="literal">,</code> <a href="jls-15.html#jls-Expression" title="Expression">Expression</a>}
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-8.9.1-120"></a>
                  The rules for annotation modifiers on an enum constant declaration are
                  specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Type">&sect;9.7.5</a>.
               </p>
               <p class="norm-static"><a name="jls-8.9.1-130"></a>
                  The <span class="emphasis"><em>Identifier</em></span> in a <span class="emphasis"><em>EnumConstant</em></span> may be used in
                  a name to refer to the enum constant.
               </p>
               <p class="norm-static"><a name="jls-8.9.1-140"></a>
                  The scope and shadowing of an enum constant is specified in
                  <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
               </p>
               <p class="norm-static"><a name="jls-8.9.1-200"></a>
                  An enum constant may be followed by arguments, which are passed to the
                  constructor of the enum when the constant is created during class
                  initialization as described later in this section. The constructor to
                  be invoked is chosen using the normal rules of overload resolution
                  (<a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>). If the arguments are omitted, an
                  empty argument list is assumed.
               </p>
               <p class="norm-static"><a name="jls-8.9.1-300"></a>
                  The optional class body of an enum constant implicitly defines an
                  anonymous class declaration (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>) that
                  extends the immediately enclosing enum type. The class body is
                  governed by the usual rules of anonymous classes; in particular it
                  cannot contain any constructors. Instance methods declared in these
                  class bodies may be invoked outside the enclosing enum type only if
                  they override accessible methods in the enclosing enum type
                  (<a class="xref" href="jls-8.html#jls-8.4.8" title="8.4.8.&nbsp;Inheritance, Overriding, and Hiding">&sect;8.4.8</a>).
               </p>
               <p class="norm-error"><a name="jls-8.9.1-320"></a>
                  It is a compile-time error for the class body of an enum constant to
                  declare an <code class="literal">abstract</code> method.
               </p>
               <p class="norm-dynamic"><a name="jls-8.9.1-400"></a>
                  Because there is only one instance of each enum constant, it is
                  permitted to use the <code class="literal">==</code> operator in place of
                  the <code class="literal">equals</code> method when comparing two object
                  references if it is known that at least one of them refers to an enum
                  constant.
               </p>
               <p class="note">The <code class="literal">equals</code> method in <code class="literal">Enum</code> is a
                  <code class="literal">final</code> method that merely invokes <code class="literal">super.equals</code> on
                  its argument and returns the result, thus performing an identity
                  comparison.
               </p>
            </div>
            <div class="section" title="8.9.2.&nbsp;Enum Body Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.9.2"></a>8.9.2.&nbsp;Enum Body Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.9.2-100"></a>
                  In addition to enum constants, the body of an enum declaration may
                  contain constructor and member declarations as well as instance and
                  static initializers.
               </p>
               <div id="jls-8.9.2-110" class="productionset"><a name="jls-8.9.2-110"></a>
                    
                  <div class="production"><a name="jls-EnumBodyDeclarations"></a>
                         
                     <div class="lhs">EnumBodyDeclarations:</div>
                         
                     <div class="rhs">
                              <code class="literal">;</code> {<a href="jls-8.html#jls-ClassBodyDeclaration" title="ClassBodyDeclaration">ClassBodyDeclaration</a>}
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">The following productions from
                  <a class="xref" href="jls-8.html#jls-8.1.6" title="8.1.6.&nbsp;Class Body and Member Declarations">&sect;8.1.6</a> are shown here for convenience:
               </p>
               <div id="d5e15032" class="productionset"><a name="d5e15032"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">ClassBodyDeclaration:</div>
                            
                        <div class="rhs">
                                 <a href="jls-8.html#jls-ClassMemberDeclaration" title="ClassMemberDeclaration">ClassMemberDeclaration</a> <br>
                                 <a href="jls-8.html#jls-InstanceInitializer" title="InstanceInitializer">InstanceInitializer</a> <br>
                                 <a href="jls-8.html#jls-StaticInitializer" title="StaticInitializer">StaticInitializer</a> <br>
                                 <a href="jls-8.html#jls-ConstructorDeclaration" title="ConstructorDeclaration">ConstructorDeclaration</a>
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">ClassMemberDeclaration:</div>
                            
                        <div class="rhs">
                                 <a href="jls-8.html#jls-FieldDeclaration" title="FieldDeclaration">FieldDeclaration</a> <br>
                                 <a href="jls-8.html#jls-MethodDeclaration" title="MethodDeclaration">MethodDeclaration</a> <br>
                                 <a href="jls-8.html#jls-ClassDeclaration" title="ClassDeclaration">ClassDeclaration</a> <br>
                                 <a href="jls-9.html#jls-InterfaceDeclaration" title="InterfaceDeclaration">InterfaceDeclaration</a> <br>
                                 <code class="literal">;</code>
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-8.9.2-120"></a>
                  Any constructor or member declarations in the body of an enum
                  declaration apply to the enum type exactly as if they had been present
                  in the body of a normal class declaration, unless explicitly stated
                  otherwise.
               </p>
               <p class="norm-error"><a name="jls-8.9.2-200"></a>
                  It is a compile-time error if a constructor declaration in an enum
                  declaration is <code class="literal">public</code> or <code class="literal">protected</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>).
               </p>
               <p class="norm-error"><a name="jls-8.9.2-210"></a>
                  It is a compile-time error if a constructor declaration in an enum
                  declaration contains a superclass constructor invocation statement
                  (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>).
               </p>
               <p class="norm-error"><a name="jls-8.9.2-220"></a>
                  It is a compile-time error to refer to a <code class="literal">static</code> field of an enum
                  type from a constructor, instance initializer, or instance variable
                  initializer of the enum type, unless the field is a constant variable
                  (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>).
               </p>
               <p class="norm-static"><a name="jls-8.9.2-230"></a>
                  In an enum declaration, a constructor declaration with no access
                  modifiers is <code class="literal">private</code>.
               </p>
               <p class="norm-static"><a name="jls-8.9.2-240"></a>
                  In an enum declaration with no constructor declarations, a default
                  constructor is implicitly declared. The default constructor is
                  <code class="literal">private</code>, has no formal parameters, and has no <code class="literal">throws</code> clause.
               </p>
               <p class="note">In practice, a compiler is likely to mirror the
                  <code class="literal">Enum</code> type by declaring <code class="literal">String</code> and <code class="literal">int</code> parameters in the default
                  constructor of an enum type. However, these parameters are not
                  specified as "implicitly declared" because different compilers do not
                  need to agree on the form of the default constructor. Only the
                  compiler of an enum type knows how to instantiate the enum constants;
                  other compilers can simply rely on the implicitly declared <code class="literal">public</code>
                  <code class="literal">static</code> fields of the enum type (<a class="xref" href="jls-8.html#jls-8.9.3" title="8.9.3.&nbsp;Enum Members">&sect;8.9.3</a>) without
                  regard for how those fields were initialized.
               </p>
               <p class="norm-error"><a name="jls-8.9.2-300"></a>
                  It is a compile-time error if an enum declaration <span class="type">E</span> has an
                  <code class="literal">abstract</code> method <code class="varname">m</code> as a member, unless <span class="type">E</span> has at least one enum
                  constant and all of <span class="type">E</span>'s enum constants have class bodies that
                  provide concrete implementations of <code class="varname">m</code>.
               </p>
               <p class="norm-error"><a name="jls-8.9.2-310"></a>
                  It is a compile-time error for an enum declaration to declare a
                  finalizer (<a class="xref" href="jls-12.html#jls-12.6" title="12.6.&nbsp;Finalization of Class Instances">&sect;12.6</a>). An instance of an enum type
                  may never be finalized.
               </p>
               <div class="example"><a name="d5e15066"></a><p class="title"><b>Example&nbsp;8.9.2-1.&nbsp;Enum Body Declarations</b></p>
                  <div class="example-contents"><pre class="programlisting">
enum Coin {
    PENNY(1), NICKEL(5), DIME(10), QUARTER(25);
    Coin(int value) { this.value = value; }

    private final int value;
    public int value() { return value; }
}
</pre><p class="note">Each enum constant arranges for a different value in
                        the field <code class="literal">value</code>, passed in via a constructor. The
                        field represents the value, in cents, of an American coin. Note that
                        there are no restrictions on the parameters that may be declared by an
                        enum type's constructor.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e15071"></a><p class="title"><b>Example&nbsp;8.9.2-2.&nbsp;Restriction On Enum Constant Self-Reference</b></p>
                  <div class="example-contents">
                     <p class="note">Without the rule on <code class="literal">static</code> field access,
                        apparently reasonable code would fail at run time due to the
                        initialization circularity inherent in enum types. (A circularity
                        exists in any class with a "self-typed" <code class="literal">static</code> field.) Here is an
                        example of the sort of code that would fail:
                     </p><pre class="programlisting">
import java.util.Map;
import java.util.HashMap;

enum Color {
    RED, GREEN, BLUE;
    Color() { colorMap.put(toString(), this); }

    static final Map&lt;String,Color&gt; colorMap =
        new HashMap&lt;String,Color&gt;();
}
</pre><p class="note">Static initialization of this enum would throw a
                        <code class="literal">NullPointerException</code> because the <code class="literal">static</code> variable <code class="literal">colorMap</code> is
                        uninitialized when the constructors for the enum constants run. The
                        restriction above ensures that such code cannot be compiled. However,
                        the code can easily be refactored to work properly:
                     </p><pre class="programlisting">
import java.util.Map;
import java.util.HashMap;

enum Color {
    RED, GREEN, BLUE;

    static final Map&lt;String,Color&gt; colorMap =
        new HashMap&lt;String,Color&gt;();
    static {
        for (Color c : Color.values())
            colorMap.put(c.toString(), c);
    }
}
</pre><p class="note">The refactored version is clearly correct, as static
                        initialization occurs top to bottom.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="8.9.3.&nbsp;Enum Members">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-8.9.3"></a>8.9.3.&nbsp;Enum Members
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-8.9.3-100"></a>
                  The members of an enum type <span class="type">E</span> are all of the following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.9.3-100-A"></a>
                                 Members declared in the body of the declaration of <span class="type">E</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.9.3-100-B"></a>
                                 Members inherited from <code class="literal">Enum</code><code class="literal">&lt;</code><span class="type">E</span><code class="literal">&gt;</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.9.3-100-C"></a>
                                 For each enum constant <code class="varname">c</code> declared in the body of the
                                 declaration of <span class="type">E</span>, <span class="type">E</span> has an implicitly declared <code class="literal">public</code>
                                 <code class="literal">static</code> <code class="literal">final</code> field of type <span class="type">E</span> that has the same name as
                                 <code class="varname">c</code>. The field has a variable initializer  which instantiates <span class="type">E</span> and passes any arguments of <code class="varname">c</code> to
                                 the constructor chosen for <span class="type">E</span>. The field has the same
                                 annotations as <code class="varname">c</code> (if any).
                        </p>
                        <p class="norm-static"><a name="jls-8.9.3-100-C.1"></a>
                                 These fields are implicitly declared in the same order as the
                                 corresponding enum constants, before any <code class="literal">static</code> fields
                                 explicitly declared in the body of the declaration of <span class="type">E</span>.
                        </p>
                        <p class="norm-static"><a name="jls-8.9.3-100-C.2"></a>
                                 An enum constant is said to be <span class="emphasis"><em>created</em></span> when
                                 the corresponding implicitly declared field is initialized.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-8.9.3-100-D"></a>
                                 The following implicitly declared methods:
                        </p><a name="jls-8.9.3-110-D.1"></a><pre class="programlisting">

/**
* Returns an array containing the constants of this enum 
* type, in the order they're declared.  This method may be
* used to iterate over the constants as follows:
*
*    for(E c : E.values())
*        System.out.println(c);
*
* @return an array containing the constants of this enum 
* type, in the order they're declared
*/
public static E[] values();

/**
* Returns the enum constant of this type with the specified
* name.
* The string must match exactly an identifier used to declare
* an enum constant in this type.  (Extraneous whitespace 
* characters are not permitted.)
* 
* @return the enum constant with the specified name
* @throws IllegalArgumentException if this enum type has no
* constant with the specified name
*/
public static E valueOf(String name);

</pre></li>
                  </ul>
               </div>
               <p class="note">It follows that the declaration of enum type <span class="type">E</span>
                  cannot contain fields that conflict with the implicitly declared
                  fields corresponding to <span class="type">E</span>'s enum constants, nor contain methods that
                  conflict with implicitly declared methods or override <code class="literal">final</code> methods
                  of class <code class="literal">Enum</code><code class="literal">&lt;</code><span class="type">E</span><code class="literal">&gt;</code>.
               </p>
               <div class="example"><a name="d5e15127"></a><p class="title"><b>Example&nbsp;8.9.3-1.&nbsp;Iterating Over Enum Constants With An Enhanced <code class="literal">for</code> Loop</b></p>
                  <div class="example-contents"><pre class="programlisting">
public class Test {
    enum Season { WINTER, SPRING, SUMMER, FALL }

    public static void main(String[] args) {
        for (Season s : Season.values())
            System.out.println(s);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
WINTER
SPRING
SUMMER
FALL
</pre></div>
               </div><br class="example-break"><div class="example"><a name="d5e15133"></a><p class="title"><b>Example&nbsp;8.9.3-2.&nbsp;Switching Over Enum Constants</b></p>
                  <div class="example-contents">
                     <p class="note">A <code class="literal">switch</code> statement (<a class="xref" href="jls-14.html#jls-14.11" title="14.11.&nbsp;The switch Statement">&sect;14.11</a>)
                        is useful for simulating the addition of a method to an enum type from
                        outside the type. This example "adds" a <code class="literal">color</code>
                        method to the <code class="literal">Coin</code> type from
                        <a class="xref" href="jls-8.html#jls-8.9.2" title="8.9.2.&nbsp;Enum Body Declarations">&sect;8.9.2</a>, and prints a table of coins, their
                        values, and their colors.
                     </p><pre class="programlisting">
class Test {
    enum CoinColor { COPPER, NICKEL, SILVER }

    static CoinColor color(Coin c) {
        switch (c) {
            case PENNY:
                return CoinColor.COPPER;
            case NICKEL:
                return CoinColor.NICKEL;
            case DIME: case QUARTER:
                return CoinColor.SILVER;
            default:
                throw new AssertionError("Unknown coin: " + c);
        }
    }

    public static void main(String[] args) {
        for (Coin c : Coin.values())
            System.out.println(c + "\t\t" +
                               c.value() + "\t" + color(c));
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
PENNY           1       COPPER
NICKEL          5       NICKEL
DIME            10      SILVER
QUARTER         25      SILVER
</pre></div>
               </div><br class="example-break"><div class="example"><a name="d5e15144"></a><p class="title"><b>Example&nbsp;8.9.3-3.&nbsp;Enum Constants with Class Bodies</b></p>
                  <div class="example-contents"><pre class="programlisting">
enum Operation {
    PLUS {
        double eval(double x, double y) { return x + y; }
    },
    MINUS {
        double eval(double x, double y) { return x - y; }
    },
    TIMES {
        double eval(double x, double y) { return x * y; }
    },
    DIVIDED_BY {
        double eval(double x, double y) { return x / y; }
    };

    // Each constant supports an arithmetic operation
    abstract double eval(double x, double y);

    public static void main(String args[]) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);
        for (Operation op : Operation.values())
            System.out.println(x + " " + op + " " + y +
                               " = " + op.eval(x, y));
    }
}
</pre><p class="note">Class bodies attach behaviors to the enum
                        constants. The program produces the output:
                     </p><pre class="screen">
java Operation 2.0 4.0
2.0 PLUS 4.0 = 6.0
2.0 MINUS 4.0 = -2.0
2.0 TIMES 4.0 = 8.0
2.0 DIVIDED_BY 4.0 = 0.5
</pre><p class="note">This pattern is 
                        much safer than using a <code class="literal">switch</code> statement in the base type
                        (<code class="literal">Operation</code>), as the pattern precludes the
                        possibility of forgetting to add a behavior for a new constant (since
                        the enum declaration would cause a compile-time error).
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e15152"></a><p class="title"><b>Example&nbsp;8.9.3-4.&nbsp;Multiple Enum Types</b></p>
                  <div class="example-contents">
                     <p class="note">In the following program, a playing card class is
                        built atop two simple enums.
                     </p><pre class="programlisting">
import java.util.List;
import java.util.ArrayList;
class Card implements Comparable&lt;Card&gt;,
                      java.io.Serializable {
    public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX, SEVEN,
                       EIGHT, NINE, TEN,JACK, QUEEN, KING, ACE }

    public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES }

    private final Rank rank;
    private final Suit suit;
    public Rank rank() { return rank; }
    public Suit suit() { return suit; }

    private Card(Rank rank, Suit suit) {
        if (rank == null || suit == null)
            throw new NullPointerException(rank + ", " + suit);
        this.rank = rank;
        this.suit = suit;
    }

    public String toString() { return rank + " of " + suit; }

    // Primary sort on suit, secondary sort on rank
    public int compareTo(Card c) {
        int suitCompare = suit.compareTo(c.suit);
        return (suitCompare != 0 ?
                    suitCompare :
                    rank.compareTo(c.rank));
    }

    private static final List&lt;Card&gt; prototypeDeck =
        new ArrayList&lt;Card&gt;(52);

    static {
        for (Suit suit : Suit.values())
            for (Rank rank : Rank.values())
                prototypeDeck.add(new Card(rank, suit));
    }

    // Returns a new deck
    public static List&lt;Card&gt; newDeck() {
        return new ArrayList&lt;Card&gt;(prototypeDeck);
    }
}
</pre><p class="note">The following program exercises
                        the <code class="literal">Card</code> class. It takes two integer parameters on
                        the command line, representing the number of hands to deal and the
                        number of cards in each hand:
                     </p><pre class="programlisting">
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
class Deal {
    public static void main(String args[]) {
        int numHands     = Integer.parseInt(args[0]);
        int cardsPerHand = Integer.parseInt(args[1]);
        List&lt;Card&gt; deck  = Card.newDeck();
        Collections.shuffle(deck);
        for (int i=0; i &lt; numHands; i++)
            System.out.println(dealHand(deck, cardsPerHand));
    }

    /**
     * Returns a new ArrayList consisting of the last n
     * elements of deck, which are removed from deck.
     * The returned list is sorted using the elements'
     * natural ordering.
     */
    public static &lt;E extends Comparable&lt;E&gt;&gt;
    ArrayList&lt;E&gt; dealHand(List&lt;E&gt; deck, int n) {
        int deckSize = deck.size();
        List&lt;E&gt; handView = deck.subList(deckSize - n, deckSize);
        ArrayList&lt;E&gt; hand = new ArrayList&lt;E&gt;(handView);
        handView.clear();
        Collections.sort(hand);
        return hand;
    }
}
</pre><p class="note">The program produces the output:</p><pre class="screen">
java Deal 4 3
[DEUCE of CLUBS, SEVEN of CLUBS, QUEEN of DIAMONDS]
[NINE of HEARTS, FIVE of SPADES, ACE of SPADES]
[THREE of HEARTS, SIX of HEARTS, TEN of SPADES]
[TEN of CLUBS, NINE of DIAMONDS, THREE of SPADES]
</pre></div>
               </div><br class="example-break"></div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-7.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-9.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;7.&nbsp;Packages and Modules&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;9.&nbsp;Interfaces</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>