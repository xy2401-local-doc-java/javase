
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;15.&nbsp;Expressions</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-14.html" title="Chapter&nbsp;14.&nbsp;Blocks and Statements">
      <link rel="next" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo">
<img src="../../../../webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="../../../../7/docs/">Java SE</a> &gt; <a href="../../../index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;15.&nbsp;Expressions</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-14.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-16.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;15.&nbsp;Expressions">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-15"></a>Chapter&nbsp;15.&nbsp;Expressions
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-15.html#jls-15.1">15.1. Evaluation, Denotation, and Result</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.2">15.2. Variables as Values</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.3">15.3. Type of an Expression</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.4">15.4. FP-strict Expressions</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.5">15.5. Expressions and Run-Time Checks</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.6">15.6. Normal and Abrupt Completion of Evaluation</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.7">15.7. Evaluation Order</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.1">15.7.1. Evaluate Left-Hand Operand First</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.2">15.7.2. Evaluate Operands before Operation</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.3">15.7.3. Evaluation Respects Parentheses and Precedence</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.4">15.7.4. Argument Lists are Evaluated Left-to-Right</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.5">15.7.5. Evaluation Order for Other Expressions</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.8">15.8. Primary Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.1">15.8.1. Lexical Literals</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.2">15.8.2. Class Literals</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.3">15.8.3. <code class="literal">this</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.4">15.8.4. Qualified <code class="literal">this</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.5">15.8.5. Parenthesized Expressions</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.9">15.9. Class Instance Creation
                        Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.1">15.9.1. Determining the Class being Instantiated</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.2">15.9.2. Determining Enclosing Instances</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.3">15.9.3. Choosing the Constructor and its Arguments</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.4">15.9.4. Run-Time Evaluation of Class Instance Creation Expressions</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.5">15.9.5. Anonymous Class Declarations</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-15.html#jls-15.9.5.1">15.9.5.1. Anonymous Constructors</a></span></dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.10">15.10. Array Creation Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.10.1">15.10.1. Run-Time Evaluation of Array Creation Expressions</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.11">15.11. Field Access Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.11.1">15.11.1. Field Access Using a Primary</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.11.2">15.11.2. Accessing Superclass Members using <code class="literal">super</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.12">15.12. Method Invocation Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.12.1">15.12.1. Compile-Time Step 1: Determine Class or Interface to Search</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.12.2">15.12.2. Compile-Time Step 2: Determine Method Signature</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.1">15.12.2.1. Identify Potentially Applicable Methods</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.2">15.12.2.2. Phase 1: Identify Matching Arity Methods Applicable by Subtyping</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.3">15.12.2.3. Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.4">15.12.2.4. Phase 3: Identify Applicable Variable Arity Methods</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.5">15.12.2.5. Choosing the Most Specific Method</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.6">15.12.2.6. Method Result and Throws Types</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.7">15.12.2.7. Inferring Type Arguments Based on Actual Arguments</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.8">15.12.2.8. Inferring Unresolved Type Arguments</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-15.html#jls-15.12.3">15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.12.4">15.12.4. Run-Time Evaluation of Method Invocation</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.1">15.12.4.1. Compute Target Reference (If Necessary)</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.2">15.12.4.2. Evaluate Arguments</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.3">15.12.4.3. Check Accessibility of Type and Method</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.4">15.12.4.4. Locate Method to Invoke</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.5">15.12.4.5. Create Frame, Synchronize, Transfer Control</a></span></dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.13">15.13. Array Access Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.13.1">15.13.1. Run-Time Evaluation of Array Access</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.14">15.14. Postfix Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.14.1">15.14.1. Expression Names</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.14.2">15.14.2. Postfix Increment Operator <code class="literal">++</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.14.3">15.14.3. Postfix Decrement Operator <code class="literal">--</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.15">15.15. Unary Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.1">15.15.1. Prefix Increment Operator <code class="literal">++</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.2">15.15.2. Prefix Decrement Operator <code class="literal">--</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.3">15.15.3. Unary Plus Operator <code class="literal">+</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.4">15.15.4. Unary Minus Operator <code class="literal">-</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.5">15.15.5. Bitwise Complement Operator <code class="literal">~</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.6">15.15.6. Logical Complement Operator <code class="literal">!</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.16">15.16. Cast Expressions</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.17">15.17. Multiplicative Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.17.1">15.17.1. Multiplication Operator <code class="literal">*</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.17.2">15.17.2. Division Operator <code class="literal">/</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.17.3">15.17.3. Remainder Operator <code class="literal">%</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.18">15.18. Additive Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.18.1">15.18.1. String Concatenation Operator <code class="literal">+</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.18.2">15.18.2. Additive Operators (<code class="literal">+</code> and <code class="literal">-</code>) for Numeric Types</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.19">15.19. Shift Operators</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.20">15.20. Relational Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.20.1">15.20.1. Numerical Comparison Operators <code class="literal">&lt;</code>,
                              <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.20.2">15.20.2. Type Comparison Operator <code class="literal">instanceof</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.21">15.21. Equality Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.21.1">15.21.1. Numerical Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.21.2">15.21.2. Boolean Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.21.3">15.21.3. Reference Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.22">15.22. Bitwise and Logical Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.22.1">15.22.1. Integer Bitwise Operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.22.2">15.22.2. Boolean Logical Operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.23">15.23. Conditional-And Operator <code class="literal">&amp;&amp;</code></a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.24">15.24. Conditional-Or Operator <code class="literal">||</code></a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.25">15.25. Conditional Operator <code class="literal">? :</code></a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.26">15.26. Assignment Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.26.1">15.26.1. Simple Assignment Operator =</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.26.2">15.26.2. Compound Assignment Operators</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.27">15.27. Expression</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.28">15.28. Constant Expressions</a></span></dt>
            </dl>
         </div>
         <p class="norm"><a name="jls-15-100"></a>Much of the work in a program is
            done by evaluating <span class="emphasis"><em>expressions</em></span>, either for their
            side effects, such as assignments to variables, or for their values,
            which can be used as arguments or operands in larger expressions, or
            to affect the execution sequence in statements, or both.
         </p>
         <p class="norm"><a name="jls-15-110"></a>This chapter specifies the
            meanings of expressions and the rules for their evaluation.
         </p>
         <div class="section" title="15.1.&nbsp;Evaluation, Denotation, and Result">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.1"></a>15.1.&nbsp;Evaluation, Denotation, and Result
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.1-100"></a>When an expression in a
               program is <span class="emphasis"><em>evaluated</em></span>
               (<span class="emphasis"><em>executed</em></span>), the result denotes one of three
               things:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-100-A"></a>A variable
                            (<a class="xref" href="jls-4.html#jls-4.12" title="4.12.&nbsp;Variables">&sect;4.12</a>) (in C, this would be called
                            an <span class="emphasis"><em>lvalue</em></span>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-100-B"></a>A value
                            (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>, <a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-100-C"></a>Nothing (the expression
                            is said to be void)
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.1-110"></a>Evaluation of an expression
               can also produce side effects, because expressions may contain
               embedded assignments, increment operators, decrement operators, and
               method invocations.
            </p>
            <p class="norm"><a name="jls-15.1-120"></a>An expression denotes nothing
               if and only if it is a method invocation (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
               that invokes a method that does not return a value, that is, a method
               declared <code class="literal">void</code> (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>). Such an expression can be
               used only as an expression statement (<a class="xref" href="jls-14.html#jls-14.8" title="14.8.&nbsp;Expression Statements">&sect;14.8</a>),
               because every other context in which an expression can appear requires
               the expression to denote something. An expression statement that is a
               method invocation may also invoke a method that produces a result; in
               this case the value returned by the method is quietly
               discarded.
            </p>
            <p class="norm"><a name="jls-15.1-200"></a>Value set conversion
               (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) is applied to the result of every
               expression that produces a value.
            </p>
            <p class="norm"><a name="jls-15.1-300"></a>Each expression occurs in
               either:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-300-A"></a>The declaration of some
                            (class or interface) type that is being declared: in a field
                            initializer, in a static initializer, in an instance initializer,
                            in a constructor declaration, in an annotation, or in the code for
                            a method.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-300-B"></a>An annotation
                            (<a class="xref" href="jls-9.html#jls-9.7" title="9.7.&nbsp;Annotations">&sect;9.7</a>) of a package or of a top level type
                            declaration.
                     </p>
                  </li>
               </ul>
            </div>
         </div>
         <div class="section" title="15.2.&nbsp;Variables as Values">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.2"></a>15.2.&nbsp;Variables as Values
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.2-100"></a>If an expression denotes a
               variable, and a value is required for use in further evaluation, then
               the value of that variable is used. In this context, if the expression
               denotes a variable or a value, we may speak simply of
               the <span class="emphasis"><em>value</em></span> of the expression.
            </p>
            <p class="norm"><a name="jls-15.2-110"></a>If the value of a variable of
               type <code class="literal">float</code> or <code class="literal">double</code> is used in this manner, then value set
               conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) is applied to the value of
               the variable.
            </p>
         </div>
         <div class="section" title="15.3.&nbsp;Type of an Expression">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.3"></a>15.3.&nbsp;Type of an Expression
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.3-100"></a>If an expression denotes a
               variable or a value, then the expression has a type known at compile
               time. The rules for determining the type of an expression are
               explained separately below for each kind of expression.
            </p>
            <p class="norm"><a name="jls-15.3-110"></a>The value of an expression is
               assignment compatible (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Conversion">&sect;5.2</a>) with the type of the
               expression, unless heap pollution (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>)
               occurs.
            </p>
            <p class="norm"><a name="jls-15.3-120"></a>Likewise, the value stored in
               a variable is always compatible with the type of the variable, unless
               heap pollution occurs.
            </p>
            <p class="norm"><a name="jls-15.3-130"></a>In other words, the value of
               an expression whose type is <span class="type">T</span> is always suitable for assignment to a
               variable of type <span class="type">T</span>.
            </p>
            <p class="norm"><a name="jls-15.3-200"></a>Note that an expression whose
               type is a class type <span class="type">F</span> that is declared <code class="literal">final</code> is guaranteed to
               have a value that is either a null reference or an object whose class
               is <span class="type">F</span> itself, because <code class="literal">final</code> types have no subclasses.
            </p>
         </div>
         <div class="section" title="15.4.&nbsp;FP-strict Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.4"></a>15.4.&nbsp;FP-strict Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.4-100"></a>If the type of an expression
               is <code class="literal">float</code> or <code class="literal">double</code>, then there is a question as to what value set
               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>) the value of the expression is drawn
               from. This is governed by the rules of value set conversion
               (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>); these rules in turn depend on whether
               or not the expression is <span class="emphasis"><em>FP-strict</em></span>.
            </p>
            <p class="norm"><a name="jls-15.4-110"></a>Every compile-time constant
               expression (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>) is FP-strict.
            </p>
            <p class="norm"><a name="jls-15.4-120"></a>If an expression is not a
               compile-time constant expression, then consider all the class
               declarations, interface declarations, and method declarations that
               contain the expression. If <span class="emphasis"><em>any</em></span> such declaration
               bears the <code class="literal">strictfp</code> modifier (<a class="xref" href="jls-8.html#jls-8.1.1.3" title="8.1.1.3.&nbsp;strictfp Classes">&sect;8.1.1.3</a>,
               <a class="xref" href="jls-8.html#jls-8.4.3.5" title="8.4.3.5.&nbsp;strictfp Methods">&sect;8.4.3.5</a>, <a class="xref" href="jls-9.html#jls-9.1.1.2" title="9.1.1.2.&nbsp;strictfp Interfaces">&sect;9.1.1.2</a>), then
               the expression is FP-strict.
            </p>
            <p class="norm"><a name="jls-15.4-130"></a>If a class, interface, or
               method, <span class="type">X</span>, is declared <code class="literal">strictfp</code>, then <span class="type">X</span> and any class,
               interface, method, constructor, instance initializer, static
               initializer or variable initializer within <span class="type">X</span> is said to
               be <span class="emphasis"><em>FP-strict</em></span>.
            </p>
            <p class="note">Note that an annotation (<a class="xref" href="jls-9.html#jls-9.7" title="9.7.&nbsp;Annotations">&sect;9.7</a>)
               element value (<a class="xref" href="jls-9.html#jls-9.6" title="9.6.&nbsp;Annotation Types">&sect;9.6</a>) is always FP-strict, because
               it is always a compile-time constant expression.
            </p>
            <p class="norm"><a name="jls-15.4-200"></a>It follows that an expression
               is not FP-strict if and only if it is not a compile-time constant
               expression <span class="emphasis"><em>and</em></span> it does not appear within any
               declaration that has the <code class="literal">strictfp</code> modifier.
            </p>
            <p class="norm"><a name="jls-15.4-300"></a>Within an FP-strict
               expression, all intermediate values must be elements of the float
               value set or the double value set, implying that the results of all
               FP-strict expressions must be those predicted by IEEE 754 arithmetic
               on operands represented using single and double formats.
            </p>
            <p class="norm"><a name="jls-15.4-310"></a>Within an expression that is
               not FP-strict, some leeway is granted for an implementation to use an
               extended exponent range to represent intermediate results; the net
               effect, roughly speaking, is that a calculation might produce "the
               correct answer" in situations where exclusive use of the float value
               set or double value set might result in overflow or underflow.
            </p>
         </div>
         <div class="section" title="15.5.&nbsp;Expressions and Run-Time Checks">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.5"></a>15.5.&nbsp;Expressions and Run-Time Checks
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.5-100"></a>If the type of an expression
               is a primitive type, then the value of the expression is of that same
               primitive type.
            </p>
            <p class="norm"><a name="jls-15.5-110"></a>If the type of an expression
               is a reference type, then the class of the referenced object, or even
               whether the value is a reference to an object rather than <code class="literal">null</code>, is
               not necessarily known at compile time. There are a few places in the
               Java programming language where the actual class of a referenced object affects
               program execution in a manner that cannot be deduced from the type of
               the expression. They are as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-A"></a>Method invocation
                            (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>). The particular method used for an
                            invocation <code class="literal">o.m(...)</code> is chosen based on the
                            methods that are part of the class or interface that is the type
                            of <code class="literal">o</code>. For instance methods, the class of the
                            object referenced by the run-time value of <code class="literal">o</code>
                            participates because a subclass may override a specific method
                            already declared in a parent class so that this overriding method
                            is invoked. (The overriding method may or may not choose to
                            further invoke the original overridden <code class="literal">m</code>
                            method.)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-B"></a>The <code class="literal">instanceof</code>
                            operator (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>). An expression whose type
                            is a reference type may be tested using <code class="literal">instanceof</code> to find out
                            whether the class of the object referenced by the run-time value of
                            the expression is assignment compatible
                            (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Conversion">&sect;5.2</a>) with some other reference type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-C"></a>Casting
                            (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Conversion">&sect;5.5</a>, <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>). The
                            class of the object referenced by the run-time value of the operand
                            expression might not be compatible with the type specified by the
                            cast. For reference types, this may require a run-time check that
                            throws an exception if the class of the referenced object, as
                            determined at run time, is not assignment compatible
                            (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Conversion">&sect;5.2</a>) with the target type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-D"></a>Assignment to an array
                            component of reference type (<a class="xref" href="jls-10.html#jls-10.5" title="10.5.&nbsp;Array Store Exception">&sect;10.5</a>,
                            <a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Array Access Expressions">&sect;15.13</a>, <a class="xref" href="jls-15.html#jls-15.26.1" title="15.26.1.&nbsp;Simple Assignment Operator =">&sect;15.26.1</a>). The
                            type-checking rules allow the array type <span class="type">S</span><code class="literal">[]</code> to be
                            treated as a subtype of <span class="type">T</span><code class="literal">[]</code> if <span class="type">S</span> is a subtype of <span class="type">T</span>,
                            but this requires a run-time check for assignment to an array
                            component, similar to the check performed for a cast.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-E"></a>Exception handling
                            (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>). An exception is caught by a <code class="literal">catch</code>
                            clause only if the class of the thrown exception object is an
                            <code class="literal">instanceof</code> the type of the formal parameter of the <code class="literal">catch</code>
                            clause.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.5-120"></a>Situations where the class of
               an object is not statically known may lead to run-time type
               errors.
            </p>
            <p class="norm"><a name="jls-15.5-200"></a>In addition, there are
               situations where the statically known type may not be accurate at run
               time. Such situations can arise in a program that gives rise to
               compile-time unchecked warnings. Such warnings are given in response
               to operations that cannot be statically guaranteed to be safe, and
               cannot immediately be subjected to dynamic checking because they
               involve non-reifiable (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>) types. As a result,
               dynamic checks later in the course of program execution may detect
               inconsistencies and result in run-time type errors.
            </p>
            <p class="norm"><a name="jls-15.5-210"></a>A run-time type error can occur
               only in these situations:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-210-A"></a>In a cast, when the
                            actual class of the object referenced by the value of the operand
                            expression is not compatible with the target type specified by the
                            cast operator (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Conversion">&sect;5.5</a>,
                            <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>); in this case a <code class="literal">ClassCastException</code> is
                            thrown.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-210-B"></a>In an automatically generated cast introduced to
                            ensure the validity of an operation on a non-reifiable type
                            (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-210-C"></a>In an assignment to an
                            array component of reference type, when the actual class of the
                            object referenced by the value to be assigned is not compatible
                            with the actual run-time component type of the array
                            (<a class="xref" href="jls-10.html#jls-10.5" title="10.5.&nbsp;Array Store Exception">&sect;10.5</a>, <a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Array Access Expressions">&sect;15.13</a>,
                            <a class="xref" href="jls-15.html#jls-15.26.1" title="15.26.1.&nbsp;Simple Assignment Operator =">&sect;15.26.1</a>); in this case an <code class="literal">ArrayStoreException</code> is
                            thrown.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-210-D"></a>When an exception is not caught
                            by any <code class="literal">catch</code> clause of a <code class="literal">try</code> statement
                            (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>); in this case the thread of control
                            that encountered the exception first   attempts to invoke an uncaught exception handler
                            (<a class="xref" href="jls-11.html#jls-11.3" title="11.3.&nbsp;Run-Time Handling of an Exception">&sect;11.3</a>)  and then
                            terminates.
                     </p>
                  </li>
               </ul>
            </div>
         </div>
         <div class="section" title="15.6.&nbsp;Normal and Abrupt Completion of Evaluation">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.6"></a>15.6.&nbsp;Normal and Abrupt Completion of Evaluation
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.6-100"></a>Every expression has a normal
               mode of evaluation in which certain computational steps are carried
               out. The following sections describe the normal mode of evaluation for
               each kind of expression.
            </p>
            <p class="norm"><a name="jls-15.6-110"></a>If all the steps are carried
               out without an exception being thrown, the expression is said
               to <span class="emphasis"><em>complete normally</em></span>.
            </p>
            <p class="norm"><a name="jls-15.6-120"></a>If, however, evaluation of an
               expression throws an exception, then the expression is said
               to <span class="emphasis"><em>complete abruptly</em></span>. An abrupt completion always
               has an associated reason, which is always a <code class="literal">throw</code> with a given
               value.
            </p>
            <p class="norm"><a name="jls-15.6-200"></a>Run-time exceptions are thrown
               by the predefined operators as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-A"></a>A class instance
                            creation expression (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>), array creation
                            expression (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation Expressions">&sect;15.10</a>),  array
                            initializer expression (<a class="xref" href="jls-10.html#jls-10.6" title="10.6.&nbsp;Array Initializers">&sect;10.6</a>),
                            or string concatenation operator expression
                            (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>) throws an <code class="literal">OutOfMemoryError</code> if there is
                            insufficient memory available.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-B"></a>An array creation
                            expression (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation Expressions">&sect;15.10</a>) throws a
                            <code class="literal">NegativeArraySizeException</code> if the value of any dimension
                            expression is less than zero.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-C"></a>A field access
                            expression (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>) throws a <code class="literal">NullPointerException</code> if the
                            value of the object reference expression is <code class="literal">null</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-D"></a>A method invocation
                            expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>) that invokes an instance
                            method throws a <code class="literal">NullPointerException</code> if the target reference is <code class="literal">null</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-E"></a>An array access
                            expression (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Array Access Expressions">&sect;15.13</a>) throws a <code class="literal">NullPointerException</code> if the
                            value of the array reference expression is <code class="literal">null</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-F"></a>An array access
                            expression (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Array Access Expressions">&sect;15.13</a>) throws an <code class="literal">ArrayIndexOutOfBoundsException</code> if the
                            value of the array index expression is negative or greater than or
                            equal to the <code class="literal">length</code> of the array.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-G"></a>A cast expression
                            (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>) throws a <code class="literal">ClassCastException</code> if a cast is found to
                            be impermissible at run time.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-H"></a>An integer division
                            (<a class="xref" href="jls-15.html#jls-15.17.2" title="15.17.2.&nbsp;Division Operator /">&sect;15.17.2</a>) or integer remainder
                            (<a class="xref" href="jls-15.html#jls-15.17.3" title="15.17.3.&nbsp;Remainder Operator %">&sect;15.17.3</a>) operator throws an
                            <code class="literal">ArithmeticException</code> if the value of the right-hand operand
                            expression is zero.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-I"></a>An assignment to an
                            array component of reference type (<a class="xref" href="jls-15.html#jls-15.26.1" title="15.26.1.&nbsp;Simple Assignment Operator =">&sect;15.26.1</a>),
                            a method invocation expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), or a
                            prefix or postfix increment (<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>,
                            <a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>) or decrement operator
                            (<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>, <a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>) may
                            all throw an <code class="literal">OutOfMemoryError</code> as a result of boxing conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-J"></a>An assignment to an
                            array component of reference type (<a class="xref" href="jls-15.html#jls-15.26.1" title="15.26.1.&nbsp;Simple Assignment Operator =">&sect;15.26.1</a>)
                            throws an <code class="literal">ArrayStoreException</code> when the value to be assigned is not compatible
                            with the component type of the array
                            (<a class="xref" href="jls-10.html#jls-10.5" title="10.5.&nbsp;Array Store Exception">&sect;10.5</a>).
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.6-210"></a>A method invocation expression
               can also result in an exception being thrown if an exception occurs
               that causes execution of the method body to complete abruptly.
            </p>
            <p class="norm"><a name="jls-15.6-220"></a>A class instance creation
               expression can also result in an exception being thrown if an
               exception occurs that causes execution of the constructor to complete
               abruptly.
            </p>
            <p class="norm"><a name="jls-15.6-230"></a>Various linkage and virtual
               machine errors may also occur during the evaluation of an
               expression. By their nature, such errors are difficult to predict and
               difficult to handle.
            </p>
            <p class="norm"><a name="jls-15.6-300"></a>If an exception occurs, then
               evaluation of one or more expressions may be terminated before all
               steps of their normal mode of evaluation are complete; such
               expressions are said to complete abruptly.
            </p>
            <p class="norm"><a name="jls-15.6-310"></a>If evaluation of an expression
               requires evaluation of a subexpression, then abrupt completion of the
               subexpression always causes the immediate abrupt completion of the
               expression itself, with the same reason, and all succeeding steps in
               the normal mode of evaluation are not performed.
            </p>
            <p class="norm"><a name="jls-15.6-400"></a>The terms "complete normally"
               and "complete abruptly" are also applied to the execution of
               statements (<a class="xref" href="jls-14.html#jls-14.1" title="14.1.&nbsp;Normal and Abrupt Completion of Statements">&sect;14.1</a>). A statement may complete
               abruptly for a variety of reasons, not just because an exception is
               thrown.
            </p>
         </div>
         <div class="section" title="15.7.&nbsp;Evaluation Order">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.7"></a>15.7.&nbsp;Evaluation Order
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.7-100"></a>The
               Java programming language guarantees that the operands of operators appear to be
               evaluated in a specific <span class="emphasis"><em>evaluation order</em></span>, namely,
               from left to right.
            </p>
            <p class="note">It is recommended that code not rely crucially on
               this specification. Code is usually clearer when each expression
               contains at most one side effect, as its outermost operation, and when
               code does not depend on exactly which exception arises as a
               consequence of the left-to-right evaluation of expressions.
            </p>
            <div class="section" title="15.7.1.&nbsp;Evaluate Left-Hand Operand First">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.1"></a>15.7.1.&nbsp;Evaluate Left-Hand Operand First
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.7.1-100"></a>The left-hand operand of a
                  binary operator appears to be fully evaluated before any part of the
                  right-hand operand is evaluated.
               </p>
               <p class="norm"><a name="jls-15.7.1-110"></a>If the operator is a
                  compound-assignment operator (<a class="xref" href="jls-15.html#jls-15.26.2" title="15.26.2.&nbsp;Compound Assignment Operators">&sect;15.26.2</a>), then
                  evaluation of the left-hand operand includes both remembering the
                  variable that the left-hand operand denotes and fetching and saving
                  that variable's value for use in the implied binary
                  operation.
               </p>
               <p class="norm"><a name="jls-15.7.1-120"></a>If evaluation of the
                  left-hand operand of a binary operator completes abruptly, no part of
                  the right-hand operand appears to have been evaluated.
               </p>
               <div class="example"><a name="d5e18725"></a><p class="title"><b>Example&nbsp;15.7.1-1.&nbsp;Left-Hand Operand Is Evaluated First</b></p>
                  <div class="example-contents">
                     <p class="note">In the following program, the <code class="literal">*</code> operator
                        has a left-hand operand that contains an assignment to a variable and
                        a right-hand operand that contains a reference to the same
                        variable. The value produced by the reference will reflect the fact
                        that the assignment occurred first.
                     </p><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        int i = 2;
        int j = (i=3) * i;
        System.out.println(j);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
9
</pre><p class="note">It is not permitted for evaluation of the <code class="literal">*</code>
                        operator to produce <code class="literal">6</code> instead
                        of <code class="literal">9</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e18736"></a><p class="title"><b>Example&nbsp;15.7.1-2.&nbsp;Implicit Left-Hand Operand In Operator Of Compound Assigment</b></p>
                  <div class="example-contents">
                     <p class="note">In the following program, the two assignment
                        statements both fetch and remember the value of the left-hand operand,
                        which is <code class="literal">9</code>, before the right-hand operand of the
                        addition operator is evaluated, at which point the variable is set
                        to <code class="literal">3</code>.
                     </p><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        int a = 9;
        a += (a = 3);  // first example
        System.out.println(a);
        int b = 9;
        b = b + (b = 3);  // second example
        System.out.println(b);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
12
12
</pre><p class="note">It is not permitted for either assignment (compound
                        for <code class="literal">a</code>, simple for <code class="literal">b</code>) to produce
                        the result <code class="literal">6</code>. 
                     </p>
                     <p class="note">See also the example in
                        <a class="xref" href="jls-15.html#jls-15.26.2" title="15.26.2.&nbsp;Compound Assignment Operators">&sect;15.26.2</a>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e18750"></a><p class="title"><b>Example&nbsp;15.7.1-3.&nbsp;Abrupt Completion of Evaluation of the Left-Hand Operand</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test3 {
    public static void main(String[] args) {
        int j = 1;
        try {
            int i = forgetIt() / (j = 2);
        } catch (Exception e) {
            System.out.println(e);
            System.out.println("Now j = " + j);
        }
    }
    static int forgetIt() throws Exception {
        throw new Exception("I'm outta here!");
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
java.lang.Exception: I'm outta here!
Now j = 1
</pre><p class="note">That is, the left-hand
                        operand <code class="literal">forgetIt()</code> of the operator <code class="literal">/</code> throws
                        an exception before the right-hand operand is evaluated and its
                        embedded assignment of <code class="literal">2</code> to <code class="literal">j</code>
                        occurs.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.7.2.&nbsp;Evaluate Operands before Operation">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.2"></a>15.7.2.&nbsp;Evaluate Operands before Operation
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.7.2-100"></a>The
                  Java programming language guarantees that every operand of an operator (except the
                  conditional operators <code class="literal">&amp;&amp;</code>, <code class="literal">||</code>, and <code class="literal">? :</code>) appears to be
                  fully evaluated before any part of the operation itself is
                  performed.
               </p>
               <p class="norm-error"><a name="jls-15.7.2-110"></a>If the
                  binary operator is an integer division <code class="literal">/</code>
                  (<a class="xref" href="jls-15.html#jls-15.17.2" title="15.17.2.&nbsp;Division Operator /">&sect;15.17.2</a>) or integer remainder <code class="literal">%</code>
                  (<a class="xref" href="jls-15.html#jls-15.17.3" title="15.17.3.&nbsp;Remainder Operator %">&sect;15.17.3</a>), then its execution may raise an
                  <code class="literal">ArithmeticException</code>, but this exception is thrown only after both
                  operands of the binary operator have been evaluated and only if these
                  evaluations completed normally.
               </p>
               <div class="example"><a name="d5e18772"></a><p class="title"><b>Example&nbsp;15.7.2-1.&nbsp;Evaluation of Operands Before Operation</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        int divisor = 0;
        try {
            int i = 1 / (divisor * loseBig());
        } catch (Exception e) {
            System.out.println(e);
        }
    }
    static int loseBig() throws Exception {
        throw new Exception("Shuffle off to Buffalo!");
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
java.lang.Exception: Shuffle off to Buffalo!
</pre><p class="note">and not:</p><pre class="screen">
java.lang.ArithmeticException: / by zero
</pre><p class="note">since no part of the division operation, including
                        signaling of a divide-by-zero exception, may appear to occur before
                        the invocation of <code class="literal">loseBig</code> completes, even though
                        the implementation may be able to detect or infer that the division
                        operation would certainly result in a divide-by-zero exception.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.7.3.&nbsp;Evaluation Respects Parentheses and Precedence">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.3"></a>15.7.3.&nbsp;Evaluation Respects Parentheses and Precedence
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.7.3-100"></a>The
                  Java programming language respects the order of evaluation indicated explicitly by
                  parentheses and implicitly by operator precedence.
               </p>
               <p class="note">An implementation of the Java programming language may not take
                  advantage of algebraic identities such as the associative law to
                  rewrite expressions into a more convenient computational order unless
                  it can be proven that the replacement expression is equivalent in
                  value and in its observable side effects, even in the presence of
                  multiple threads of execution (using the thread execution model in
                  <a class="xref" href="jls-17.html" title="Chapter&nbsp;17.&nbsp;Threads and Locks">&sect;17</a>), for all possible computational values that
                  might be involved.
               </p>
               <p class="norm-dynamic"><a name="jls-15.7.3-110"></a>In the
                  case of floating-point calculations, this rule applies also for
                  infinity and not-a-number (NaN) values.
               </p>
               <p class="note">For example, <code class="literal">!(x&lt;y)</code> may not be
                  rewritten as <code class="literal">x&gt;=y</code>, because these expressions
                  have different values if either <code class="literal">x</code>
                  or <code class="literal">y</code> is NaN or both are NaN.
               </p>
               <p class="norm-dynamic"><a name="jls-15.7.3-120"></a>Specifically, floating-point calculations that
                  appear to be mathematically associative are unlikely to be
                  computationally associative. Such computations must not be naively
                  reordered.
               </p>
               <p class="note">For example, it is not correct for a Java compiler
                  to rewrite <code class="literal">4.0*x*0.5</code> as <code class="literal">2.0*x</code>;
                  while roundoff happens not to be an issue here, there are large values
                  of <code class="literal">x</code> for which the first expression produces
                  infinity (because of overflow) but the second expression produces a
                  finite result.
               </p>
               <div class="informalexample">
                  <p class="note">So, for example, the test program:</p><pre class="programlisting">
strictfp class Test {
    public static void main(String[] args) {
        double d = 8e+307;
        System.out.println(4.0 * d * 0.5);
        System.out.println(2.0 * d);
    }
}
</pre><p class="note">prints:</p><pre class="screen">
Infinity
1.6e+308
</pre><p class="note">because the first expression overflows and the
                     second does not.
                  </p>
               </div>
               <p class="norm"><a name="jls-15.7.3-130"></a>In contrast, integer
                  addition and multiplication <span class="emphasis"><em>are</em></span> provably
                  associative in the Java programming language.
               </p>
               <p class="note">For example <code class="literal">a+b+c</code>,
                  where <code class="literal">a</code>, <code class="literal">b</code>,
                  and <code class="literal">c</code> are local variables (this simplifying
                  assumption avoids issues involving multiple threads
                  and <code class="literal">volatile</code> variables), will always produce the
                  same answer whether evaluated as <code class="literal">(a+b)+c</code>
                  or <code class="literal">a+(b+c)</code>; if the
                  expression <code class="literal">b+c</code> occurs nearby in the code, a smart
                  Java compiler may be able to use this common subexpression.
               </p>
            </div>
            <div class="section" title="15.7.4.&nbsp;Argument Lists are Evaluated Left-to-Right">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.4"></a>15.7.4.&nbsp;Argument Lists are Evaluated Left-to-Right
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.7.4-100"></a>In a method or constructor
                  invocation or class instance creation expression, argument expressions
                  may appear within the parentheses, separated by commas. Each argument
                  expression appears to be fully evaluated before any part of any
                  argument expression to its right.
               </p>
               <p class="norm"><a name="jls-15.7.4-110"></a>If evaluation of an argument
                  expression completes abruptly, no part of any argument expression to
                  its right appears to have been evaluated.
               </p>
               <div class="example"><a name="d5e18818"></a><p class="title"><b>Example&nbsp;15.7.4-1.&nbsp;Evaluation Order At Method Invocation</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        String s = "going, ";
        print3(s, s, s = "gone");
    }
    static void print3(String a, String b, String c) {
        System.out.println(a + b + c);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
going, going, gone
</pre><p class="note">because the assignment of the string
                        "<code class="literal">gone</code>" to <code class="literal">s</code> occurs after the
                        first two arguments to <code class="literal">print3</code> have been
                        evaluated.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e18827"></a><p class="title"><b>Example&nbsp;15.7.4-2.&nbsp;Abrupt Completion of Argument Expression</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test2 {
    static int id;
    public static void main(String[] args) {
        try {
            test(id = 1, oops(), id = 3);
        } catch (Exception e) {
            System.out.println(e + ", id=" + id);
        }
    }
    static int test(int a, int b, int c) {
        return a + b + c;
    }
    static int oops() throws Exception {
        throw new Exception("oops");
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
java.lang.Exception: oops, id=1
</pre><p class="note">because the assignment of <code class="literal">3</code>
                        to <code class="literal">id</code> is not executed.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.7.5.&nbsp;Evaluation Order for Other Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.5"></a>15.7.5.&nbsp;Evaluation Order for Other Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.7.5-100"></a>The order of evaluation for
                  some expressions is not completely covered by these general rules,
                  because these expressions may raise exceptional conditions at times
                  that must be specified. See the detailed explanations of evaluation
                  order for the following kinds of expressions:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-A"></a>class instance
                               creation expressions (<a class="xref" href="jls-15.html#jls-15.9.4" title="15.9.4.&nbsp;Run-Time Evaluation of Class Instance Creation Expressions">&sect;15.9.4</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-B"></a>array creation
                               expressions (<a class="xref" href="jls-15.html#jls-15.10.1" title="15.10.1.&nbsp;Run-Time Evaluation of Array Creation Expressions">&sect;15.10.1</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-C"></a>method invocation
                               expressions (<a class="xref" href="jls-15.html#jls-15.12.4" title="15.12.4.&nbsp;Run-Time Evaluation of Method Invocation">&sect;15.12.4</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-D"></a>array access
                               expressions (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Run-Time Evaluation of Array Access">&sect;15.13.1</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-E"></a>assignments involving
                               array components (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>)
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="15.8.&nbsp;Primary Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.8"></a>15.8.&nbsp;Primary Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.8-100"></a>Primary expressions include
               most of the simplest kinds of expressions, from which all others are
               constructed: literals, class literals, field accesses, method
               invocations, and array accesses. A parenthesized expression is also
               treated syntactically as a primary expression.
            </p>
            <div class="literallayout">
               <p><br>
                  Primary:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;PrimaryNoNewArray<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ArrayCreationExpression<br>
                  <br>
                  PrimaryNoNewArray:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Literal<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;<code class="literal">.</code>&nbsp;<code class="literal">class</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">void</code>&nbsp;<code class="literal">.</code>&nbsp;<code class="literal">class</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">this</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ClassName&nbsp;<code class="literal">.</code>&nbsp;<code class="literal">this</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">(</code>&nbsp;Expression&nbsp;<code class="literal">)</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ClassInstanceCreationExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;FieldAccess<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;MethodInvocation<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ArrayAccess<br>
                  
               </p>
            </div>
            <p class="note">This part of the
               grammar of the Java programming language is unusual, in two ways. First, one might
               expect simple names, such as names of local variables and method
               parameters, to be primary expressions. For technical reasons, names
               are grouped together with primary expressions a little later when
               postfix expressions are introduced
               (<a class="xref" href="jls-15.html#jls-15.14" title="15.14.&nbsp;Postfix Expressions">&sect;15.14</a>).
            </p>
            <p class="note">The technical
               reasons have to do with allowing left-to-right parsing of Java
               programs with only one-token lookahead. Consider the
               expressions <code class="literal">(z[3])</code>
               and <code class="literal">(z[])</code>. The first is a parenthesized array
               access (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Array Access Expressions">&sect;15.13</a>) and the second is the start of a
               cast (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>). At the point that the look-ahead
               symbol is <code class="literal">[</code>, a left-to-right parse will have reduced
               the <code class="literal">z</code> to the
               nonterminal <span class="emphasis"><em>Name</em></span>. In the context of a cast we
               prefer not to have to reduce the name to
               a <span class="emphasis"><em>Primary</em></span>, but if <span class="emphasis"><em>Name</em></span> were
               one of the alternatives for <span class="emphasis"><em>Primary</em></span>, then we
               could not tell whether to do the reduction (that is, we could not
               determine whether the current situation would turn out to be a
               parenthesized array access or a cast) without looking ahead two
               tokens, to the token following the <code class="literal">[</code>. The Java grammar
               presented here avoids the problem by keeping <span class="emphasis"><em>Name</em></span>
               and <span class="emphasis"><em>Primary</em></span> separate and allowing either in
               certain other syntax rules (those for
               <span class="emphasis"><em>MethodInvocation</em></span>, <span class="emphasis"><em>ArrayAccess</em></span>, 
               <span class="emphasis"><em>PostfixExpression</em></span>, but not
               for <span class="emphasis"><em>FieldAccess</em></span>, because this  uses an identifier directly). This strategy effectively defers
               the question of whether a <span class="emphasis"><em>Name</em></span> should be treated
               as a <span class="emphasis"><em>Primary</em></span> until more context can be
               examined.
            </p>
            <p class="note">The second unusual
               feature avoids a potential grammatical ambiguity in the expression
               "<code class="literal">new int[3][3]</code>" which in Java always means a single
               creation of a multidimensional array, but which, without appropriate
               grammatical finesse, might also be interpreted as meaning the same as
               "<code class="literal">(new int[3])[3]</code>".
            </p>
            <p class="note">This ambiguity is
               eliminated by splitting the expected definition
               of <span class="emphasis"><em>Primary</em></span> into <span class="emphasis"><em>Primary</em></span>
               and <span class="emphasis"><em>PrimaryNoNewArray</em></span>. (This may be compared to
               the splitting of <span class="emphasis"><em>Statement</em></span>
               into <span class="emphasis"><em>Statement</em></span>
               and <span class="emphasis"><em>StatementNoShortIf</em></span>
               (<a class="xref" href="jls-14.html#jls-14.5" title="14.5.&nbsp;Statements">&sect;14.5</a>) to avoid the "dangling else"
               problem.)
            </p>
            <div class="section" title="15.8.1.&nbsp;Lexical Literals">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.1"></a>15.8.1.&nbsp;Lexical Literals
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.8.1-100"></a>A literal
                  (<a class="xref" href="jls-3.html#jls-3.10" title="3.10.&nbsp;Literals">&sect;3.10</a>) denotes a fixed, unchanging value.
               </p>
               <p class="note">The following production from
                  <a class="xref" href="jls-3.html#jls-3.10" title="3.10.&nbsp;Literals">&sect;3.10</a> is repeated here for convenience:
               </p>
               <div class="literallayout">
                  <p><br>
                     Literal:<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;IntegerLiteral<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;FloatingPointLiteral<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;BooleanLiteral<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;CharacterLiteral<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;StringLiteral<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;NullLiteral<br>
                     
                  </p>
               </div>
               <p class="norm"><a name="jls-15.8.1-200"></a>The type of a literal is
                  determined as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-A"></a>The type of an integer
                               literal (<a class="xref" href="jls-3.html#jls-3.10.1" title="3.10.1.&nbsp;Integer Literals">&sect;3.10.1</a>) that ends
                               with <code class="literal">L</code> or <code class="literal">l</code> is <code class="literal">long</code>
                               (<a class="xref" href="jls-4.html#jls-4.2.1" title="4.2.1.&nbsp;Integral Types and Values">&sect;4.2.1</a>).
                        </p>
                        <p class="norm"><a name="jls-15.8.1-200-A.1"></a>The type of any
                               other integer literal is <code class="literal">int</code>
                               (<a class="xref" href="jls-4.html#jls-4.2.1" title="4.2.1.&nbsp;Integral Types and Values">&sect;4.2.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-B"></a>The type of a
                               floating-point literal (<a class="xref" href="jls-3.html#jls-3.10.2" title="3.10.2.&nbsp;Floating-Point Literals">&sect;3.10.2</a>) that ends
                               with <code class="literal">F</code> or <code class="literal">f</code> is <code class="literal">float</code> and
                               its value must be an element of the float value set
                               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>).
                        </p>
                        <p class="norm"><a name="jls-15.8.1-200-B.1"></a>The type of any
                               other floating-point literal is <code class="literal">double</code> and its value must be an
                               element of the double value set
                               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-C"></a>The type of a boolean
                               literal (<a class="xref" href="jls-3.html#jls-3.10.3" title="3.10.3.&nbsp;Boolean Literals">&sect;3.10.3</a>) is <code class="literal">boolean</code>
                               (<a class="xref" href="jls-4.html#jls-4.2.5" title="4.2.5.&nbsp;The boolean Type and boolean Values">&sect;4.2.5</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-D"></a>The type of a
                               character literal (<a class="xref" href="jls-3.html#jls-3.10.4" title="3.10.4.&nbsp;Character Literals">&sect;3.10.4</a>) is <code class="literal">char</code>
                               (<a class="xref" href="jls-4.html#jls-4.2.1" title="4.2.1.&nbsp;Integral Types and Values">&sect;4.2.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-E"></a>The type of a string
                               literal (<a class="xref" href="jls-3.html#jls-3.10.5" title="3.10.5.&nbsp;String Literals">&sect;3.10.5</a>) is <code class="literal">String</code>
                               (<a class="xref" href="jls-4.html#jls-4.3.3" title="4.3.3.&nbsp;The Class String">&sect;4.3.3</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-F"></a>The type of the null
                               literal <code class="literal">null</code> (<a class="xref" href="jls-3.html#jls-3.10.7" title="3.10.7.&nbsp;The Null Literal">&sect;3.10.7</a>) is the null type
                               (<a class="xref" href="jls-4.html#jls-4.1" title="4.1.&nbsp;The Kinds of Types and Values">&sect;4.1</a>); its value is the null
                               reference.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-15.8.1-210"></a>Evaluation of a lexical
                  literal always completes normally.
               </p>
            </div>
            <div class="section" title="15.8.2.&nbsp;Class Literals">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.2"></a>15.8.2.&nbsp;Class Literals
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.8.2-100"></a>A <span class="emphasis"><em>class
                        literal</em></span> is an expression consisting of the name of a class,
                  interface, array, or primitive type, or the pseudo-type <code class="literal">void</code>,
                  followed by a '<code class="literal">.</code>' and the token <code class="literal">class</code>.
               </p>
               <p class="norm-static"><a name="jls-15.8.2-110"></a>The type
                  of <span class="type">C</span><code class="literal">.</code><code class="literal">class</code>, where <span class="type">C</span> is the name of a class, interface, or
                  array type (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>), is
                  <code class="literal">Class</code><code class="literal">&lt;</code><span class="type">C</span><code class="literal">&gt;</code>.
               </p>
               <p class="norm-static"><a name="jls-15.8.2-120"></a>The type
                  of <span class="type">p</span><code class="literal">.</code><code class="literal">class</code>, where <span class="type">p</span> is the name of a
                  primitive type (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>), is
                  <code class="literal">Class</code><code class="literal">&lt;</code><span class="type">B</span><code class="literal">&gt;</code>, where <span class="type">B</span> is the
                  type of an expression of type <span class="type">p</span> after boxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>).
               </p>
               <p class="norm"><a name="jls-15.8.2-130"></a>The type of
                  <code class="literal">void</code><code class="literal">.</code><code class="literal">class</code> (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Return Type">&sect;8.4.5</a>) is
                  <code class="literal">Class</code><code class="literal">&lt;</code><code class="literal">Void</code><code class="literal">&gt;</code>.
               </p>
               <p class="norm-error"><a name="jls-15.8.2-200"></a>It is a
                  compile-time error if the named type is a type variable
                  (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) or a parameterized type
                  (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) or an array whose element type is a type
                  variable or parameterized type.
               </p>
               <p class="norm-error"><a name="jls-15.8.2-210"></a>It is a
                  compile-time error if the named type does not denote a type that is
                  accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) and in scope
                  (<a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a>) at the point where the class literal
                  appears.
               </p>
               <p class="norm-dynamic"><a name="jls-15.8.2-300"></a>A class
                  literal evaluates to the <code class="literal">Class</code> object for the named type (or for
                  <code class="literal">void</code>) as defined by the defining class loader
                  (<a class="xref" href="jls-12.html#jls-12.2" title="12.2.&nbsp;Loading of Classes and Interfaces">&sect;12.2</a>) of the class of the current
                  instance.
               </p>
            </div>
            <div class="section" title="15.8.3.&nbsp;this">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.3"></a>15.8.3.&nbsp;<code class="literal">this</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.8.3-100"></a>The
                  keyword <code class="literal">this</code> may be used only in the body of an instance method,
                  instance initializer, or constructor, or in the initializer of an
                  instance variable of a class. If it appears anywhere else, a
                  compile-time error occurs.
               </p>
               <p class="norm-dynamic"><a name="jls-15.8.3-200"></a>When
                  used as a primary expression, the keyword <code class="literal">this</code> denotes a value that
                  is a reference to the object for which the instance method was invoked
                  (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), or to the object being
                  constructed.
               </p>
               <p class="norm-static"><a name="jls-15.8.3-210"></a>The type
                  of <code class="literal">this</code> is the class <span class="type">C</span> within which the keyword <code class="literal">this</code>
                  occurs.
               </p>
               <p class="norm-dynamic"><a name="jls-15.8.3-220"></a>At run
                  time, the class of the actual object referred to may be the class <span class="type">C</span>
                  or any subclass of <span class="type">C</span>.
               </p>
               <p class="norm"><a name="jls-15.8.3-300"></a>The keyword <code class="literal">this</code> is also
                  used in a special explicit constructor invocation statement, which can
                  appear at the beginning of a constructor body
                  (<a class="xref" href="jls-8.html#jls-8.8.7" title="8.8.7.&nbsp;Constructor Body">&sect;8.8.7</a>).
               </p>
               <div class="example"><a name="d5e19018"></a><p class="title"><b>Example&nbsp;15.8.3-1.&nbsp;The <code class="literal">this</code> Expression</b></p>
                  <div class="example-contents"><pre class="programlisting">
class IntVector {
    int[] v;
    boolean equals(IntVector other) {
        if (this == other)
            return true;
        if (v.length != other.v.length)
            return false;
        for (int i = 0; i &lt; v.length; i++) {
            if (v[i] != other.v[i]) return false;
        }
        return true;
    }
}
</pre><p class="note">Here, the class <code class="literal">IntVector</code>
                        implements a method <code class="literal">equals</code>, which compares two
                        vectors. If the other vector is the same vector object as the one for
                        which the <code class="literal">equals</code> method was invoked, then the check
                        can skip the length and value
                        comparisons. The <code class="literal">equals</code> method implements this
                        check by comparing the reference to the other object to <code class="literal">this</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.8.4.&nbsp;Qualified this">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.4"></a>15.8.4.&nbsp;Qualified <code class="literal">this</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.8.4-100"></a>Any
                  lexically enclosing instance (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>) can be
                  referred to by explicitly qualifying the keyword <code class="literal">this</code>.
               </p>
               <p class="norm-static"><a name="jls-15.8.4-110"></a>Let <span class="type">C</span>
                  be the class denoted by <span class="emphasis"><em>ClassName</em></span>. Let <span class="emphasis"><em>n</em></span> be
                  an integer such that <span class="type">C</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing class of
                  the class in which the qualified <code class="literal">this</code> expression appears.
               </p>
               <p class="norm-static"><a name="jls-15.8.4-120"></a>The value
                  of an expression of the form <span class="emphasis"><em>ClassName</em></span><code class="literal">.</code><code class="literal">this</code>
                  is the <span class="emphasis"><em>n</em></span>'th lexically enclosing instance of <code class="literal">this</code>.
               </p>
               <p class="norm-static"><a name="jls-15.8.4-200"></a>The type
                  of the expression is <span class="type">C</span>.
               </p>
               <p class="norm-error"><a name="jls-15.8.4-210"></a>It is a
                  compile-time error if the current class is not an inner class of class
                  <span class="type">C</span> or <span class="type">C</span> itself.
               </p>
            </div>
            <div class="section" title="15.8.5.&nbsp;Parenthesized Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.5"></a>15.8.5.&nbsp;Parenthesized Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.8.5-100"></a>A
                  parenthesized expression is a primary expression whose type is the
                  type of the contained expression and whose value at run time is the
                  value of the contained expression. If the contained expression denotes
                  a variable then the parenthesized expression also denotes that
                  variable.
               </p>
               <p class="norm-static"><a name="jls-15.8.5-110"></a>The use
                  of parentheses affects only the <span class="emphasis"><em>order</em></span> of
                  evaluation, except for a corner case
                  whereby <code class="literal">(-2147483648)</code>
                  and <code class="literal">(-9223372036854775808L)</code> are legal
                  but <code class="literal">-(2147483648)</code>
                  and <code class="literal">-(9223372036854775808L)</code> are illegal.
               </p>
               <p class="note">This is because the decimal literals
                  <code class="literal">2147483648</code>
                  and <code class="literal">9223372036854775808L</code> are allowed only as an
                  operand of the unary minus operator
                  (<a class="xref" href="jls-3.html#jls-3.10.1" title="3.10.1.&nbsp;Integer Literals">&sect;3.10.1</a>).
               </p>
               <p class="norm-static"><a name="jls-15.8.5-120"></a>In
                  particular, the presence or absence of parentheses around an
                  expression does not (except for the case noted above) affect in any
                  way:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.5-120-A"></a>the choice of value
                               set (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>) for the value of an expression
                               of type <code class="literal">float</code> or <code class="literal">double</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.5-120-B"></a>whether a variable is
                               definitely assigned, definitely assigned when <code class="literal">true</code>, definitely
                               assigned when <code class="literal">false</code>, definitely unassigned, definitely
                               unassigned when <code class="literal">true</code>, or definitely unassigned when <code class="literal">false</code>
                               (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16</a>).
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="15.9.&nbsp;Class Instance Creation Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.9"></a>15.9.&nbsp;Class Instance Creation
                        Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.9-100"></a>A class
               instance creation expression is used to create new objects that are
               instances of classes.
            </p>
            <div class="literallayout">
               <p><br>
                  ClassInstanceCreationExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">new</code>&nbsp;TypeArguments<sub>opt</sub>&nbsp;TypeDeclSpecifier&nbsp;TypeArgumentsOrDiamond<sub>opt</sub><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">(</code>&nbsp;ArgumentList<sub>opt</sub>&nbsp;<code class="literal">)</code>&nbsp;ClassBody<sub>opt</sub><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Primary&nbsp;<code class="literal">.</code>&nbsp;<code class="literal">new</code>&nbsp;TypeArguments<sub>opt</sub>&nbsp;Identifier&nbsp;TypeArgumentsOrDiamond<sub>opt</sub><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">(</code>&nbsp;ArgumentList<sub>opt</sub>&nbsp;<code class="literal">)</code>&nbsp;ClassBody<sub>opt</sub><br>
                  <br>
                  TypeArgumentsOrDiamond:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;TypeArguments<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">&lt;&gt;</code>&nbsp;<br>
                  <br>
                  ArgumentList:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Expression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ArgumentList&nbsp;<code class="literal">,</code>&nbsp;Expression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.9-200"></a>A class instance
               creation expression specifies a class to be instantiated, possibly
               followed by type arguments (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments and Wildcards">&sect;4.5.1</a>) or
               a <span class="emphasis"><em>diamond</em></span> ("<code class="literal">&lt;&gt;</code>") if the class being
               instantiated is generic (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>), followed by (a
               possibly empty) list of actual value arguments to the
               constructor.
            </p>
            <p class="norm-static"><a name="jls-15.9-210"></a>If the type
               argument list to the class is empty &#8212; the diamond form "<code class="literal">&lt;&gt;</code>" &#8212;
               the type arguments of the class are inferred. It is legal, though
               strongly discouraged as a matter of style, to have white space between
               the "<code class="literal">&lt;</code>" and "<code class="literal">&gt;</code>" of a diamond.
            </p>
            <p class="norm-static"><a name="jls-15.9-220"></a>If the
               constructor is generic (<a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>), the type
               arguments to the constructor may similarly either be inferred or
               passed explicitly. If passed explicitly, the type arguments to the
               constructor immediately follow the keyword <code class="literal">new</code>.
            </p>
            <p class="norm-error"><a name="jls-15.9-300"></a>It is a
               compile-time error if a class instance creation expression provides a
               constructor type argument list but uses "<code class="literal">&lt;&gt;</code>" in place of a
               class type argument list.
            </p>
            <p class="note">This rule is introduced because inference of a
               generic class's type arguments may influence the constraints on a
               generic constructor's type arguments.
            </p>
            <p class="norm-error"><a name="jls-15.9-310"></a>It is a
               compile-time error if any of the type arguments used in a class
               instance creation expression are wildcard type arguments
               (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments and Wildcards">&sect;4.5.1</a>).
            </p>
            <p class="norm-static"><a name="jls-15.9-320"></a>The
               exception types that a class instance creation expression can throw
               are specified in <a class="xref" href="jls-11.html#jls-11.2.1" title="11.2.1.&nbsp;Exception Analysis of Expressions">&sect;11.2.1</a>.
            </p>
            <p class="norm"><a name="jls-15.9-400"></a>Class instance creation
               expressions have two forms:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.9-400-A"></a><span class="emphasis"><em>Unqualified
                                    class instance creation expressions</em></span> begin with the
                              keyword <code class="literal">new</code>.
                     </p>
                     <p class="norm"><a name="jls-15.9-400-A.1"></a>An unqualified class
                              instance creation expression may be used to create an instance
                              of a class, regardless of whether the class is a top level
                              (<a class="xref" href="jls-7.html#jls-7.6" title="7.6.&nbsp;Top Level Type Declarations">&sect;7.6</a>), member (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>,
                              <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>), local (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class Declarations">&sect;14.3</a>)
                              or anonymous class (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.9-400-B"></a><span class="emphasis"><em>Qualified
                                    class instance creation expressions</em></span> begin with a
                              <span class="emphasis"><em>Primary</em></span>.
                     </p>
                     <p class="norm"><a name="jls-15.9-400-B.1"></a>A qualified class
                              instance creation expression enables the creation of instances
                              of inner member classes and their anonymous subclasses.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.9-410"></a>Both unqualified and qualified
               class instance creation expressions may optionally end with a class
               body. Such a class instance creation expression declares
               an <span class="emphasis"><em>anonymous class</em></span> (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>)
               and creates an instance of it.
            </p>
            <p class="norm-error"><a name="jls-15.9-420"></a>It is a
               compile-time error if a class instance creation expression declares an
               anonymous class using the "<code class="literal">&lt;&gt;</code>" form for the class's type
               arguments.
            </p>
            <p class="norm"><a name="jls-15.9-500"></a>We say that a class
               is <span class="emphasis"><em>instantiated</em></span> when an instance of the class is
               created by a class instance creation expression. Class instantiation
               involves determining what class is to be instantiated, what the
               enclosing instances (if any) of the newly created instance are, what
               constructor should be invoked to create the new instance, and what
               arguments should be passed to that constructor.
            </p>
            <div class="section" title="15.9.1.&nbsp;Determining the Class being Instantiated">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.1"></a>15.9.1.&nbsp;Determining the Class being Instantiated
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.9.1-100"></a>If the
                  class instance creation expression ends in a class body, then the
                  class being instantiated is an anonymous class. Then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.9.1-100-A"></a>If the class
                               instance creation expression is an unqualified class instance
                               creation expression, then  <span class="emphasis"><em>TypeDeclSpecifier
                                     TypeArgumentsOrDiamond<sub>opt</sub></em></span> must denote a type, <span class="type">T</span>
                               (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>, <a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>), or a
                               compile-time error occurs.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-A.1"></a>It
                               is a compile-time error if the class or interface named by <span class="type">T</span> is
                               not accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) or if <span class="type">T</span> is an enum
                               type (<a class="xref" href="jls-8.html#jls-8.9" title="8.9.&nbsp;Enums">&sect;8.9</a>).
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-A.2"></a>If
                               <span class="type">T</span> denotes a class, then an anonymous direct subclass of the
                               class named by <span class="type">T</span> is declared. It is a compile-time error if the
                               class denoted by <span class="type">T</span> is a <code class="literal">final</code> class.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-100-A.3"></a>If <span class="type">T</span> denotes an interface, then an
                               anonymous direct subclass of <code class="literal">Object</code> that implements the
                               interface named by <span class="type">T</span> is declared.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-100-A.4"></a>In either case, the body of the
                               subclass is the <span class="emphasis"><em>ClassBody</em></span> given in the class
                               instance creation expression.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-100-A.5"></a>The class being instantiated is the
                               anonymous subclass.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.1-100-B"></a>Otherwise,
                               the class instance creation expression is a qualified class
                               instance creation expression. 
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-B.1"></a>It is a
                               compile-time error if  the <span class="emphasis"><em>Identifier</em></span> after the <code class="literal">new</code>
                               token is not the simple name (<a class="xref" href="jls-6.html#jls-6.2" title="6.2.&nbsp;Names and Identifiers">&sect;6.2</a>) of an
                               accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) non-<code class="literal">final</code> inner class
                               (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>) that is a member of the compile-time
                               type of the <span class="emphasis"><em>Primary</em></span>.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-B.2"></a>It is a
                               compile-time error if the name is ambiguous
                               (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>) or denotes an enum type.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-B.3"></a>When
                               <span class="emphasis"><em>TypeArguments</em></span> are provided after the name, it
                               is a compile-time error if the type arguments, when applied to the
                               named class, do not denote a well-formed parameterized type
                               (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>).
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-100-B.4"></a>Let <span class="type">T</span> be the
                               type named by the <span class="emphasis"><em>Identifier</em></span> and any type arguments. An
                               anonymous direct subclass of the class named by <span class="type">T</span> is
                               declared. The body of the subclass is
                               the <span class="emphasis"><em>ClassBody</em></span> given in the class instance
                               creation expression.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-100-B.5"></a>The class being instantiated is the
                               anonymous subclass.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-15.9.1-200"></a>If a class instance creation
                  expression does not declare an anonymous class, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.9.1-200-A"></a>If the class
                               instance creation expression is an unqualified class instance
                               creation expression, then
                               the <span class="emphasis"><em>TypeDeclSpecifier</em></span> must denote a class
                               that is accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) and is not an enum
                               type and not <code class="literal">abstract</code>, or a compile-time error occurs.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-A.1"></a>When
                               <span class="emphasis"><em>TypeArguments</em></span> are provided after the class
                               name, it is a compile-time error if the type arguments, when
                               applied to the class, do not denote a well-formed parameterized
                               type (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>).
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-A.2"></a>When
                               "<code class="literal">&lt;&gt;</code>" is used to elide type arguments after the class name,
                               it is a compile-time error if the class is not generic.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-200-A.3"></a>The class
                               being instantiated is the class denoted by
                               the <span class="emphasis"><em>TypeDeclSpecifier</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.1-200-B"></a>Otherwise, the class instance creation
                               expression is a qualified class instance creation
                               expression.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-B.1"></a>It
                               is a compile-time error if the <span class="emphasis"><em>Identifier</em></span> after the <code class="literal">new</code> token
                               is not the simple name (<a class="xref" href="jls-6.html#jls-6.2" title="6.2.&nbsp;Names and Identifiers">&sect;6.2</a>) of an
                               accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) non-<code class="literal">abstract</code> inner class
                               (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>) <span class="type">C</span> that is a member of the
                               compile-time type of the <span class="emphasis"><em>Primary</em></span>.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-B.2"></a>It
                               is a compile-time error if the name is ambiguous
                               (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>) or denotes an enum type
                               (<a class="xref" href="jls-8.html#jls-8.9" title="8.9.&nbsp;Enums">&sect;8.9</a>).
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-B.3"></a>When
                               <span class="emphasis"><em>TypeArguments</em></span> are provided after the name, it
                               is a compile-time error if the type arguments, when applied to
                               <span class="type">C</span>, do not denote a well-formed parameterized type
                               (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>).
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-B.4"></a>When
                               "<code class="literal">&lt;&gt;</code>" is used to elide type arguments after the name, it is
                               a compile-time error if <span class="type">C</span> is not generic.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-200-B.5"></a>The class
                               being instantiated is <span class="type">C</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.9.1-300"></a>The type
                  of the class instance creation expression is the class type being
                  instantiated, as defined above.
               </p>
            </div>
            <div class="section" title="15.9.2.&nbsp;Determining Enclosing Instances">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.2"></a>15.9.2.&nbsp;Determining Enclosing Instances
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.9.2-100"></a>Let <span class="type">C</span>
                  be the class being instantiated, and let <code class="varname">i</code> be the
                  instance being created. If <span class="type">C</span> is an inner class
                  then <code class="varname">i</code> may have an immediately enclosing
                  instance. The immediately enclosing instance of <code class="varname">i</code>
                  (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>) is determined as follows.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.2-110"></a>If <span class="type">C</span>
                  is an anonymous class, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-110-A"></a>If
                               the class instance creation expression occurs in a static context
                               (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>), then <code class="varname">i</code> has no
                               immediately enclosing instance.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-110-B"></a>Otherwise, the immediately enclosing
                               instance of <code class="varname">i</code> is <code class="literal">this</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.9.2-120"></a>If <span class="type">C</span>
                  is a local class (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class Declarations">&sect;14.3</a>), then let <span class="type">O</span> be the
                  innermost lexically enclosing class of <span class="type">C</span>. Let <span class="emphasis"><em>n</em></span> be an integer
                  such that <span class="type">O</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing class of the class
                  in which the class instance creation expression appears. Then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-120-A"></a>If
                               <span class="type">C</span> occurs in a static context, then <code class="varname">i</code> has no
                               immediately enclosing instance.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.9.2-120-B"></a>Otherwise, if the class instance
                               creation expression occurs in a static context, then a
                               compile-time error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-120-C"></a>Otherwise, the immediately enclosing
                               instance of <code class="varname">i</code> is the <span class="emphasis"><em>n</em></span>'th lexically
                               enclosing instance of <code class="literal">this</code> (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.9.2-130"></a>Otherwise, <span class="type">C</span> is an inner member class
                  (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>), and then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-130-A"></a>If
                               the class instance creation expression is an unqualified class
                               instance creation expression, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.9.2-130-A-1"></a>If the class instance creation
                                    	expression occurs in a static context, then a compile-time
                                    	error occurs.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.9.2-130-A-2"></a>Otherwise, if <span class="type">C</span> is a member of
                                    	an enclosing class then let <span class="type">O</span> be the innermost lexically
                                    	enclosing class of which <span class="type">C</span> is a member, and let <span class="emphasis"><em>n</em></span> be an
                                    	integer such that <span class="type">O</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing
                                    	class of the class in which the class instance creation
                                    	expression appears.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.9.2-130-A-2.1"></a>The immediately enclosing
                                    	instance of <code class="varname">i</code> is
                                    	the <span class="emphasis"><em>n</em></span>'th lexically enclosing instance of
                                    	<code class="literal">this</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.9.2-130-A-3"></a>Otherwise, a compile-time error
                                    	occurs.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-130-B"></a>Otherwise, the class instance creation
                               expression is a qualified class instance creation
                               expression.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.9.2-130-B.1"></a>The immediately enclosing instance
                               of <code class="varname">i</code> is the object that is the value of the
                               <span class="emphasis"><em>Primary</em></span> expression.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.9.2-200"></a>In
                  addition, if <span class="type">C</span> is an anonymous class, and the direct superclass of
                  <span class="type">C</span>, <span class="type">S</span>, is an inner class, then <code class="varname">i</code> may have an
                  immediately enclosing instance with respect to <span class="type">S</span>. It is determined
                  as follows.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.2-210"></a>If <span class="type">S</span>
                  is a local class (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class Declarations">&sect;14.3</a>), then let <span class="type">O</span> be the
                  innermost lexically enclosing class of <span class="type">S</span>. Let <span class="emphasis"><em>n</em></span> be an integer
                  such that <span class="type">O</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing class of the class
                  in which the class instance creation expression appears. Then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-210-A"></a>If
                               <span class="type">S</span> occurs within a static context, then <code class="varname">i</code> has
                               no immediately enclosing instance with respect to <span class="type">S</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.9.2-210-B"></a>Otherwise, if the class instance
                               creation expression occurs in a static context, then a
                               compile-time error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-210-C"></a>Otherwise, the immediately enclosing
                               instance of <code class="varname">i</code> with respect to <span class="type">S</span> is the
                               <span class="emphasis"><em>n</em></span>'th lexically enclosing instance of <code class="literal">this</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.9.2-220"></a>Otherwise, <span class="type">S</span> is an inner member class
                  (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>), and then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-220-A"></a>If
                               the class instance creation expression is an unqualified class
                               instance creation expression, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.9.2-220-A-1"></a>If the class instance creation
                                    	expression occurs in a static context, then a compile-time
                                    	error occurs.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.9.2-220-A-2"></a>Otherwise, if <span class="type">S</span> is a member of
                                    	an enclosing class, then let <span class="type">O</span> be the innermost lexically
                                    	enclosing class of which <span class="type">S</span> is a member, and let <span class="emphasis"><em>n</em></span> be an
                                    	integer such that <span class="type">O</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing
                                    	class of the class in which the class instance creation
                                    	expression appears.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.9.2-220-A-2.1"></a>The immediately enclosing
                                    	instance of <code class="varname">i</code> with respect to <span class="type">S</span> is the
                                    	<span class="emphasis"><em>n</em></span>'th lexically enclosing instance of <code class="literal">this</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.9.2-220-A-3"></a>Otherwise, a compile-time error
                                    	occurs.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-220-B"></a>Otherwise, the class instance creation
                               expression is a qualified class instance creation
                               expression.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.9.2-220-B.1"></a>The immediately enclosing instance
                               of <code class="varname">i</code> with respect to <span class="type">S</span> is the object that is
                               the value of the <span class="emphasis"><em>Primary</em></span> expression.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.3"></a>15.9.3.&nbsp;Choosing the Constructor and its Arguments
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.9.3-100"></a>Let <span class="type">C</span>
                  be the class  being instantiated. To create an instance of
                  <span class="type">C</span>, <code class="varname">i</code>, a constructor of <span class="type">C</span> is chosen at
                  compile time by the following rules.
               </p>
               <p class="norm-static"><a name="jls-15.9.3-110"></a>First,
                  the actual arguments to the constructor invocation are
                  determined:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-110-A"></a>If
                               <span class="type">C</span> is an anonymous class, and the direct superclass of <span class="type">C</span>, <span class="type">S</span>,
                               is an inner class, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.9.3-110-A-1"></a>If <span class="type">S</span> is a local class and <span class="type">S</span>
                                    	occurs in a static context, then the arguments in the argument
                                    	list, if any, are the arguments to the constructor, in the
                                    	order they appear in the expression.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.9.3-110-A-2"></a>Otherwise, the immediately
                                    	enclosing instance of <code class="varname">i</code> with respect to <span class="type">S</span>
                                    	is the first argument to the constructor, followed by the
                                    	arguments in the argument list of the class instance creation
                                    	expression, if any, in the order they appear in the
                                    	expression.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-110-B"></a>Otherwise the arguments in the argument
                               list, if any, are the arguments to the constructor, in the order
                               they appear in the expression.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.9.3-120"></a>Second, a
                  constructor of <span class="type">C</span> and corresponding result type and <code class="literal">throws</code> clause
                  are determined:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-120-A"></a>If
                               the class instance creation expression uses "<code class="literal">&lt;&gt;</code>" to elide
                               class type arguments, a list of methods <code class="varname">m<sub>1</sub></code>...<code class="varname">m<sub>n</sub></code> is defined for
                               the purpose of overload resolution and type argument
                               inference.
                        </p>
                        <p class="norm"><a name="jls-15.9.3-120-A.1"></a>Let <code class="varname">c<sub>1</sub></code>...<code class="varname">c<sub>n</sub></code> be
                               the constructors of class <span class="type">C</span>. Let <code class="literal">#m</code> be an
                               automatically generated name that is distinct from all constructor
                               and method names in <span class="type">C</span>. For all <span class="emphasis"><em>j</em></span> (1 &#8804; <span class="emphasis"><em>j</em></span> &#8804;
                               <span class="emphasis"><em>n</em></span>), <code class="varname">m<sub>j</sub></code> is defined in terms of <code class="varname">c<sub>j</sub></code> as follows:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-1"></a>A substitution
                                            &#952;<code class="varname"><sub>j</sub></code> is first defined to instantiate the types in
                                            <code class="varname">c<sub>j</sub></code>.
                                 </p>
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-1.1"></a>Let
                                            <span class="type">F<sub>1</sub></span>...<span class="type">F<sub>p</sub></span> be the type parameters of <span class="type">C</span>, and let <span class="type">G<sub>1</sub></span>...<span class="type">G<sub>q</sub></span>
                                            be the type parameters (if any) of <code class="varname">c<sub>j</sub></code>. Let <span class="type">X<sub>1</sub></span>...<span class="type">X<sub>p</sub></span> and
                                            <span class="type">Y<sub>1</sub></span>...<span class="type">Y<sub>q</sub></span> be type variables with distinct names that are not
                                            in scope in the body of <span class="type">C</span>.
                                 </p>
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-1.2"></a>&#952;<code class="varname"><sub>j</sub></code>
                                            is <code class="literal">[<span class="type">F<sub>1</sub></span>:=<span class="type">X<sub>1</sub></span>, ..., <span class="type">F<sub>p</sub></span>:=<span class="type">X<sub>p</sub></span>, <span class="type">G<sub>1</sub></span>:=<span class="type">Y<sub>1</sub></span>, ...,
                                               <span class="type">G<sub>q</sub></span>:=<span class="type">Y<sub>q</sub></span>]</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-2"></a>The modifiers
                                    	of <code class="varname">m<sub>j</sub></code> are those of <code class="varname">c<sub>j</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-3"></a>The type
                                    	parameters of <code class="varname">m<sub>j</sub></code> are <span class="type">X<sub>1</sub></span>...<span class="type">X<sub>p</sub></span>,<span class="type">Y<sub>1</sub></span>...<span class="type">Y<sub>q</sub></span>. The bound of
                                    	each parameter, if any, is &#952;<code class="varname"><sub>j</sub></code> applied to the
                                    	corresponding parameter bound in <span class="type">C</span> or <code class="varname">c<sub>j</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-4"></a>The return
                                    	type of <code class="varname">m<sub>j</sub></code> is &#952;<code class="varname"><sub>j</sub></code> applied to
                                    	<span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>p</sub></span><code class="literal">&gt;</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-5"></a>The name of
                                            <code class="varname">m<sub>j</sub></code> is <code class="literal">#m</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-6"></a>The (possibly
                                            empty) list of argument types of <code class="varname">m<sub>j</sub></code> is &#952;<code class="varname"><sub>j</sub></code> applied to
                                            the argument types of <code class="varname">c<sub>j</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-7"></a>The (possibly
                                    	empty) list of thrown types of <code class="varname">m<sub>j</sub></code> is &#952;<code class="varname"><sub>j</sub></code> applied to the
                                    	thrown types of <code class="varname">c<sub>j</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-8"></a>The body of
                                    	<code class="varname">m<sub>j</sub></code> is irrelevant.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-static"><a name="jls-15.9.3-120-A.2"></a>To choose a constructor, we
                               temporarily consider <code class="varname">m<sub>1</sub></code>...<code class="varname">m<sub>n</sub></code> to be members of <span class="type">C</span>. Then one of
                               <code class="varname">m<sub>1</sub></code>...<code class="varname">m<sub>n</sub></code> is selected, as determined by the class instance
                               creation's argument expressions, using the process described in
                               <a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.3-120-A.3"></a>It
                               is a compile-time error if there is no unique most-specific method
                               that is both applicable and accessible.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.3-120-A.4"></a>Otherwise, where <code class="varname">m<sub>j</sub></code> is the selected
                               method, <code class="varname">c<sub>j</sub></code> is the chosen constructor. The result type and
                               <code class="literal">throws</code> clause of <code class="varname">c<sub>j</sub></code> are the same as the return type and
                               <code class="literal">throws</code> clause determined for <code class="varname">m<sub>j</sub></code>
                               (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Result and Throws Types">&sect;15.12.2.6</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-120-B"></a>Otherwise, the class instance creation
                               expression does not use "<code class="literal">&lt;&gt;</code>" to elide class type
                               arguments.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.3-120-B.1"></a>Let <span class="type">T</span> be the type denoted by <span class="type">C</span>
                               followed by any class type arguments in the expression. The
                               process described in <a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>, modified to
                               handle constructors, is used to select one of the constructors of
                               <span class="type">T</span> and determine its <code class="literal">throws</code> clause.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.3-120-B.2"></a>As
                               in method invocations, it is a compile-time error if there is no
                               unique most-specific constructor that is both applicable and
                               accessible.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.3-120-B.3"></a>Otherwise, the result type is
                               <span class="type">T</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.9.3-130"></a>Finally, the type
                  of the class instance creation expression is the result type of the
                  chosen constructor, as defined above.
               </p>
               <p class="norm-static"><a name="jls-15.9.3-140"></a>Note that
                  the type of the class instance creation expression may be an anonymous
                  class type, in which case the constructor being invoked is an
                  anonymous constructor (<a class="xref" href="jls-15.html#jls-15.9.5.1" title="15.9.5.1.&nbsp;Anonymous Constructors">&sect;15.9.5.1</a>).
               </p>
            </div>
            <div class="section" title="15.9.4.&nbsp;Run-Time Evaluation of Class Instance Creation Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.4"></a>15.9.4.&nbsp;Run-Time Evaluation of Class Instance Creation Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.9.4-100"></a>At run time, evaluation of a
                  class instance creation expression is as follows.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-110"></a>First,
                  if the class instance creation expression is a qualified class
                  instance creation expression, the qualifying primary expression is
                  evaluated. If the qualifying expression evaluates to <code class="literal">null</code>, a <code class="literal">NullPointerException</code>
                  is raised, and the class instance creation expression completes
                  abruptly. If the qualifying expression completes abruptly, the class
                  instance creation expression completes abruptly for the same
                  reason.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-120"></a>Next,
                  space is allocated for the new class instance. If there is
                  insufficient space to allocate the object, evaluation of the class
                  instance creation expression completes abruptly by throwing an
                  <code class="literal">OutOfMemoryError</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-130"></a>The new
                  object contains new instances of all the fields declared in the
                  specified class type and all its superclasses. As each new field
                  instance is created, it is initialized to its default value
                  (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-140"></a>Next,
                  the actual arguments to the constructor are evaluated,
                  left-to-right. If any of the argument evaluations completes abruptly,
                  any argument expressions to its right are not evaluated, and the class
                  instance creation expression completes abruptly for the same
                  reason.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-150"></a>Next,
                  the selected constructor of the specified class type is invoked. This
                  results in invoking at least one constructor for each superclass of
                  the class type. This process can be directed by explicit constructor
                  invocation statements (<a class="xref" href="jls-8.html#jls-8.8" title="8.8.&nbsp;Constructor Declarations">&sect;8.8</a>) and is described in
                  detail in <a class="xref" href="jls-12.html#jls-12.5" title="12.5.&nbsp;Creation of New Class Instances">&sect;12.5</a>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-160"></a>The
                  value of a class instance creation expression is a reference to the
                  newly created object of the specified class. Every time the expression
                  is evaluated, a fresh object is created.
               </p>
               <div class="example"><a name="d5e19571"></a><p class="title"><b>Example&nbsp;15.9.4-1.&nbsp;Evaluation Order and Out-Of-Memory Detection</b></p>
                  <div class="example-contents">
                     <p class="note">If evaluation of a class instance creation
                        expression finds there is insufficient memory to perform the creation
                        operation, then an <code class="literal">OutOfMemoryError</code> is thrown. This check occurs before any
                        argument expressions are evaluated.
                     </p>
                     <p class="note">So, for example, the test program:</p><pre class="programlisting">
class List {
    int value;
    List next;
    static List head = new List(0);
    List(int n) { value = n; next = head; head = this; }
}
class Test {
    public static void main(String[] args) {
        int id = 0, oldid = 0;
        try {
            for (;;) {
                ++id;
                new List(oldid = id);
            }
        } catch (Error e) {
            List.head = null;
            System.out.println(e.getClass() + ", " + (oldid==id));
        }
    }
}
</pre><p class="note">prints:</p><pre class="screen">
class java.lang.OutOfMemoryError, false
</pre><p class="note">because the out-of-memory condition is detected
                        before the argument expression <code class="literal">oldid = id</code> is
                        evaluated.
                     </p>
                     <p class="note">Compare this to the treatment of array creation
                        expressions (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation Expressions">&sect;15.10</a>), for which the out-of-memory
                        condition is detected after evaluation of the dimension expressions
                        (<a class="xref" href="jls-15.html#jls-15.10.1" title="15.10.1.&nbsp;Run-Time Evaluation of Array Creation Expressions">&sect;15.10.1</a>).
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.9.5.&nbsp;Anonymous Class Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.5"></a>15.9.5.&nbsp;Anonymous Class Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.9.5-100"></a>An
                  anonymous class declaration is automatically derived from a class
                  instance creation expression by the Java compiler.
               </p>
               <p class="norm-static"><a name="jls-15.9.5-110"></a>An
                  anonymous class is never <code class="literal">abstract</code>
                  (<a class="xref" href="jls-8.html#jls-8.1.1.1" title="8.1.1.1.&nbsp;abstract Classes">&sect;8.1.1.1</a>).
               </p>
               <p class="norm-static"><a name="jls-15.9.5-120"></a>An
                  anonymous class is always implicitly <code class="literal">final</code>
                  (<a class="xref" href="jls-8.html#jls-8.1.1.2" title="8.1.1.2.&nbsp;final Classes">&sect;8.1.1.2</a>).
               </p>
               <p class="norm-static"><a name="jls-15.9.5-130"></a>An
                  anonymous class is always an inner class
                  (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>); it is never <code class="literal">static</code>
                  (<a class="xref" href="jls-8.html#jls-8.1.1" title="8.1.1.&nbsp;Class Modifiers">&sect;8.1.1</a>, <a class="xref" href="jls-8.html#jls-8.5.1" title="8.5.1.&nbsp;Static Member Type Declarations">&sect;8.5.1</a>).
               </p>
               <div class="section" title="15.9.5.1.&nbsp;Anonymous Constructors">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.9.5.1"></a>15.9.5.1.&nbsp;Anonymous Constructors
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.9.5.1-100"></a>An
                     anonymous class cannot have an explicitly declared
                     constructor. Instead, a Java compiler must automatically provide an
                     anonymous constructor for the anonymous class. The form of the
                     anonymous constructor of an anonymous class <span class="type">C</span> with direct superclass
                     <span class="type">S</span> is as follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.9.5.1-100-A"></a>If <span class="type">S</span> is not an inner class, or if
                                    <span class="type">S</span> is a local class that occurs in a static context, then the
                                    anonymous constructor has one formal parameter for each actual
                                    argument to the class instance creation expression in which <span class="type">C</span>
                                    is declared.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-A.1"></a>The actual arguments to the class
                                    instance creation expression are used to determine a
                                    constructor <code class="varname">cs</code> of <span class="type">S</span>, using the same rules
                                    as for method invocations (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>).
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-A.2"></a>The type of each formal parameter
                                    of the anonymous constructor must be identical to the
                                    corresponding formal parameter of <code class="varname">cs</code>.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-A.3"></a>The body of the constructor
                                    consists of an explicit constructor invocation
                                    (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>) of the
                                    form <code class="literal">super(...)</code>, where the actual arguments
                                    are the formal parameters of the constructor, in the order they
                                    were declared.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.9.5.1-100-B"></a>Otherwise, the first formal parameter
                                  of the constructor of <span class="type">C</span> represents the value of the immediately
                                  enclosing instance of <code class="varname">i</code> with respect to
                                  <span class="type">S</span>. The type of this parameter is the class type that immediately
                                  encloses the declaration of <span class="type">S</span>.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-B.1"></a>The constructor has an additional
                                  formal parameter for each actual argument to the class instance
                                  creation expression that declared the anonymous
                                  class. The <span class="emphasis"><em>n</em></span>'th formal
                                  parameter <code class="varname">e</code> corresponds to
                                  the <span class="emphasis"><em>n-1</em></span>'th actual argument.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-B.2"></a>The actual arguments to the class
                                  instance creation expression are used to determine a
                                  constructor <code class="varname">cs</code> of <span class="type">S</span>, using the same rules as
                                  for method invocations (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>).
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-B.3"></a>The type of each formal parameter of
                                  the anonymous constructor must be identical to the corresponding
                                  formal parameter of <code class="varname">cs</code>.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-B.4"></a>The body of the constructor consists
                                  of an explicit constructor invocation
                                  (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>) of the
                                  form <code class="literal">o.super(...)</code>, where <code class="literal">o</code>
                                  is the first formal parameter of the constructor, and the actual
                                  arguments are the subsequent formal parameters of the constructor,
                                  in the order they were declared.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.9.5.1-110"></a>In all
                     cases, the <code class="literal">throws</code> clause of an anonymous constructor must list all
                     the checked exceptions thrown by the explicit superclass constructor
                     invocation statement contained within the anonymous constructor, and
                     all checked exceptions thrown by any instance initializers or instance
                     variable initializers of the anonymous class.
                  </p>
                  <p class="norm-static"><a name="jls-15.9.5.1-200"></a>Note
                     that it is possible for the signature of the anonymous constructor to
                     refer to an inaccessible type (for example, if such a type occurred in
                     the signature of the superclass constructor <code class="varname">cs</code>).
                     This does not, in itself, cause any errors at either compile-time or
                     run-time.
                  </p>
               </div>
            </div>
         </div>
         <div class="section" title="15.10.&nbsp;Array Creation Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.10"></a>15.10.&nbsp;Array Creation Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.10-100"></a>An array
               creation expression is used to create new arrays
               (<a class="xref" href="jls-10.html" title="Chapter&nbsp;10.&nbsp;Arrays">&sect;10</a>).
            </p>
            <div class="literallayout">
               <p><br>
                  ArrayCreationExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">new</code>&nbsp;PrimitiveType&nbsp;DimExprs&nbsp;Dims<sub>opt</sub><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">new</code>&nbsp;ClassOrInterfaceType&nbsp;DimExprs&nbsp;Dims<sub>opt</sub><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">new</code>&nbsp;PrimitiveType&nbsp;Dims&nbsp;ArrayInitializer&nbsp;<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">new</code>&nbsp;ClassOrInterfaceType&nbsp;Dims&nbsp;ArrayInitializer<br>
                  <br>
                  DimExprs:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;DimExpr<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;DimExprs&nbsp;DimExpr<br>
                  <br>
                  DimExpr:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">[</code>&nbsp;Expression&nbsp;<code class="literal">]</code><br>
                  <br>
                  Dims:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">[</code>&nbsp;<code class="literal">]</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Dims&nbsp;<code class="literal">[</code>&nbsp;<code class="literal">]</code><br>
                  
               </p>
            </div>
            <p class="norm-dynamic"><a name="jls-15.10-120"></a>An array
               creation expression creates an object that is a new array whose
               elements are of the type specified by
               the <span class="emphasis"><em>PrimitiveType</em></span>
               or <span class="emphasis"><em>ClassOrInterfaceType</em></span>.
            </p>
            <p class="norm-error"><a name="jls-15.10-200"></a>It is a
               compile-time error if the <span class="emphasis"><em>ClassOrInterfaceType</em></span>
               does not denote a reifiable type
               (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>). Otherwise,
               the <span class="emphasis"><em>ClassOrInterfaceType</em></span> may name any named
               reference type, even an <code class="literal">abstract</code> class type
               (<a class="xref" href="jls-8.html#jls-8.1.1.1" title="8.1.1.1.&nbsp;abstract Classes">&sect;8.1.1.1</a>) or an interface type
               (<a class="xref" href="jls-9.html" title="Chapter&nbsp;9.&nbsp;Interfaces">&sect;9</a>).
            </p>
            <p class="note">The rules above imply that the element type in an
               array creation expression cannot be a parameterized type, other than
               an unbounded wildcard.
            </p>
            <p class="norm-error"><a name="jls-15.10-210"></a>The type of
               each dimension expression within a <span class="emphasis"><em>DimExpr</em></span> must
               be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to an
               integral type, or a compile-time error occurs.
            </p>
            <p class="norm-error"><a name="jls-15.10-220"></a>Each
               dimension expression undergoes unary numeric promotion
               (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>). The promoted type must be <code class="literal">int</code>, or a
               compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.10-300"></a>The type
               of the array creation expression is an array type that can denoted by
               a copy of the array creation expression from which the <code class="literal">new</code> keyword
               and every <span class="emphasis"><em>DimExpr</em></span> expression and array
               initializer have been deleted.
            </p>
            <div class="informalexample">
               <p class="note">For example, the type of the creation
                  expression:
               </p><pre class="screen">
new double[3][3][]
</pre><p class="note">is:</p><pre class="screen">
double[][][]
</pre></div>
            <div class="section" title="15.10.1.&nbsp;Run-Time Evaluation of Array Creation Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.10.1"></a>15.10.1.&nbsp;Run-Time Evaluation of Array Creation Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.10.1-100"></a>At run
                  time, evaluation of an array creation expression behaves as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.10.1-100-A"></a>If there are no dimension
                                 expressions, then there must be an array initializer.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.10.1-100-A.1"></a>A newly allocated array will be
                                 initialized with the values provided by the array initializer as
                                 described in <a class="xref" href="jls-10.html#jls-10.6" title="10.6.&nbsp;Array Initializers">&sect;10.6</a>.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.10.1-100-A.2"></a>The value of the array initializer
                                 becomes the value of the array creation expression.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.10.1-100-B"></a>Otherwise, there is no array
                               initializer, and:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.1-100-B-1"></a>First, the dimension
                                    	  expressions are evaluated, left-to-right. If any of the
                                    	  expression evaluations completes abruptly, the expressions
                                    	  to the right of it are not evaluated.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.1-100-B-2"></a>Next, the values of the
                                    	  dimension expressions are checked. If the value of
                                    	  any <span class="emphasis"><em>DimExpr</em></span> expression is less than
                                    	  zero, then a <code class="literal">NegativeArraySizeException</code> is thrown.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.1-100-B-3"></a>Next, space is allocated for
                                    	  the new array. If there is insufficient space to allocate
                                    	  the array, evaluation of the array creation expression
                                    	  completes abruptly by throwing an <code class="literal">OutOfMemoryError</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.1-100-B-4"></a>Then, if a
                                    	  single <span class="emphasis"><em>DimExpr</em></span> appears, a
                                    	  one-dimensional array is created of the specified length,
                                    	  and each component of the array is initialized to its
                                    	  default value (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>).
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.1-100-B-5"></a>Otherwise, if
                                    	  <span class="emphasis"><em>n</em></span> <span class="emphasis"><em>DimExpr</em></span> expressions appear, then
                                    	  array creation effectively executes a set of nested loops of
                                    	  depth <span class="emphasis"><em>n</em></span><code class="literal">-1</code> to create the implied
                                    	  arrays of arrays.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.10.1-100-B-5.1"></a>A multidimensional array need
                                    	  not have arrays of the same length at each level.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e19716"></a><p class="title"><b>Example&nbsp;15.10.1-1.&nbsp;Array Creation Evaluation</b></p>
                  <div class="example-contents">
                     <p class="note">In an array creation expression with one or more
                        dimension expressions, each dimension expression is fully evaluated
                        before any part of any dimension expression to its right. Thus:
                     </p><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        int i = 4;
        int ia[][] = new int[i][i=3];
        System.out.println(
            "[" + ia.length + "," + ia[0].length + "]");
    }
}
</pre><p class="note">prints:</p><pre class="screen">
[4,3]
</pre><p class="note">because the first dimension is calculated
                        as <code class="literal">4</code> before the second dimension expression
                        sets <code class="literal">i</code> to <code class="literal">3</code>.
                     </p>
                     <p class="note">If evaluation of a dimension expression completes
                        abruptly, no part of any dimension expression to its right will appear
                        to have been evaluated. Thus:
                     </p><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        int[][] a = { { 00, 01 }, { 10, 11 } };
        int i = 99;
        try {
            a[val()][i = 1]++;
        } catch (Exception e) {
            System.out.println(e + ", i=" + i);
        }
    }
    static int val() throws Exception {
        throw new Exception("unimplemented");
    }
}
</pre><p class="note">prints:</p><pre class="screen">
java.lang.Exception: unimplemented, i=99
</pre><p class="note">because the embedded assignment that
                        sets <code class="literal">i</code> to <code class="literal">1</code> is never
                        executed.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e19733"></a><p class="title"><b>Example&nbsp;15.10.1-2.&nbsp;Multi-Dimensional Array Creation</b></p>
                  <div class="example-contents">
                     <p class="note">The declaration:</p><pre class="screen">
float[][] matrix = new float[3][3];
</pre><p class="note">is equivalent in behavior to:</p><pre class="screen">
float[][] matrix = new float[3][];
for (int <code class="varname">d</code> = 0; <code class="varname">d</code> &lt; matrix.length; <code class="varname">d</code>++)
    matrix[<code class="varname">d</code>] = new float[3];
</pre><p class="note">and:</p><pre class="screen">
Age[][][][][] Aquarius = new Age[6][10][8][12][];
</pre><p class="note">is equivalent to:</p><pre class="screen">
Age[][][][][] Aquarius = new Age[6][][][][];
for (int <code class="varname">d1</code> = 0; <code class="varname">d1</code> &lt; Aquarius.length; <code class="varname">d1</code>++) {
    Aquarius[<code class="varname">d1</code>] = new Age[10][][][];
    for (int <code class="varname">d2</code> = 0; <code class="varname">d2</code> &lt; Aquarius[<code class="varname">d1</code>].length; <code class="varname">d2</code>++) {
        Aquarius[<code class="varname">d1</code>][<code class="varname">d2</code>] = new Age[8][][];
        for (int <code class="varname">d3</code> = 0; <code class="varname">d3</code> &lt; Aquarius[<code class="varname">d1</code>][<code class="varname">d2</code>].length; <code class="varname">d3</code>++) {
            Aquarius[<code class="varname">d1</code>][<code class="varname">d2</code>][<code class="varname">d3</code>] = new Age[12][];
        }
    }
}
</pre><p class="note">with <code class="varname">d</code>, <code class="varname">d1</code>, 
                        <code class="varname">d2</code>, and <code class="varname">d3</code> replaced by names
                        that are not already locally declared. Thus, a single <code class="literal">new</code> expression
                        actually creates one array of length 6, 6 arrays of length 10, 6x10 =
                        60 arrays of length 8, and 6x10x8 = 480 arrays of length 12. This
                        example leaves the fifth dimension, which would be arrays containing
                        the actual array elements (references to <code class="literal">Age</code>
                        objects), initialized only to null references. These arrays can be
                        filled in later by other code, such as:
                     </p><pre class="screen">
Age[] Hair = { new Age("quartz"), new Age("topaz") };
Aquarius[1][9][6][9] = Hair;
</pre><p class="note">A triangular matrix may be created by:</p><pre class="screen">
float triang[][] = new float[100][];
for (int i = 0; i &lt; triang.length; i++)
    triang[i] = new float[i+1];
</pre></div>
               </div><br class="example-break"><p class="norm-dynamic"><a name="jls-15.10.1-200"></a>If
                  evaluation of an array creation expression finds there is insufficient
                  memory to perform the creation operation, then an <code class="literal">OutOfMemoryError</code> is
                  thrown.  If the array
                  creation expression does not have an array initializer, then this
                  check occurs only after evaluation of all dimension expressions has
                  completed normally. If the array creation expression does have an
                  array initializer, then an <code class="literal">OutOfMemoryError</code> can occur when an object of
                  reference type is allocated during evaluation of a variable
                  initializer expression, or when space is allocated for an array to
                  hold the values of a (possibly nested) array initializer.
               </p>
               <div class="example"><a name="d5e19778"></a><p class="title"><b>Example&nbsp;15.10.1-3.&nbsp;<code class="literal">OutOfMemoryError</code> and Dimension Expression Evaluation</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test3 {
    public static void main(String[] args) {
        int len = 0, oldlen = 0;
        Object[] a = new Object[0];
        try {
            for (;;) {
                ++len;
                Object[] temp = new Object[oldlen = len];
                temp[0] = a;
                a = temp;
            }
        } catch (Error e) {
            System.out.println(e + ", " + (oldlen==len));
        }
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
java.lang.OutOfMemoryError, true
</pre><p class="note">because the out-of-memory condition is detected
                        after the dimension expression <code class="literal">oldlen = len</code> is
                        evaluated.
                     </p>
                     <p class="note">Compare this to class instance creation expressions
                        (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>), which detect the out-of-memory condition
                        before evaluating argument expressions
                        (<a class="xref" href="jls-15.html#jls-15.9.4" title="15.9.4.&nbsp;Run-Time Evaluation of Class Instance Creation Expressions">&sect;15.9.4</a>).
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.11.&nbsp;Field Access Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.11"></a>15.11.&nbsp;Field Access Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.11-100"></a>A field
               access expression may access a field of an object or array, a
               reference to which is the value of either an expression or the special
               keyword <code class="literal">super</code>.
            </p>
            <div class="literallayout">
               <p><br>
                  FieldAccess:&nbsp;<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Primary&nbsp;<code class="literal">.</code>&nbsp;Identifier<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">super</code>&nbsp;<code class="literal">.</code>&nbsp;Identifier<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ClassName&nbsp;<code class="literal">.</code>&nbsp;<code class="literal">super</code>&nbsp;<code class="literal">.</code>&nbsp;Identifier<br>
                  
               </p>
            </div>
            <p class="norm"><a name="jls-15.11-120"></a>The meaning of a field access
               expression is determined using the same rules as for qualified names
               (<a class="xref" href="jls-6.html#jls-6.5.6.2" title="6.5.6.2.&nbsp;Qualified Expression Names">&sect;6.5.6.2</a>), but limited by the fact that an
               expression cannot denote a package, class type, or interface
               type.
            </p>
            <p class="norm-dynamic"><a name="jls-15.11-130"></a>It is
               also possible to refer to a field of the current instance or current
               class by using a simple name (<a class="xref" href="jls-6.html#jls-6.5.6.1" title="6.5.6.1.&nbsp;Simple Expression Names">&sect;6.5.6.1</a>).
            </p>
            <div class="section" title="15.11.1.&nbsp;Field Access Using a Primary">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.11.1"></a>15.11.1.&nbsp;Field Access Using a Primary
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.11.1-100"></a>The type
                  of the <span class="emphasis"><em>Primary</em></span> must be a reference type <span class="type">T</span>, or a compile-time error
                  occurs.
               </p>
               <p class="norm-static"><a name="jls-15.11.1-110"></a>The
                  meaning of the field access expression is determined as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.11.1-110-A"></a>If
                               the identifier names several accessible
                               (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) member fields in type <span class="type">T</span>, then the
                               field access is ambiguous and a compile-time error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.11.1-110-B"></a>If
                               the identifier does not name an accessible member field in type
                               <span class="type">T</span>, then the field access is undefined and a compile-time error
                               occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.11.1-110-C"></a>Otherwise, the identifier names a
                               single accessible member field in type <span class="type">T</span>, and the type of the
                               field access expression is the type of the member field after
                               capture conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.11.1-200"></a>At run time,
                  the result of the field access expression is computed as
                  follows: (assuming that the program is correct with respect
                  to definite assignment analysis, i.e. every blank <code class="literal">final</code> variable is
                  definitely assigned before access)
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.11.1-200-A"></a>If the field is <code class="literal">static</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-A-1"></a>The <span class="emphasis"><em>Primary</em></span> expression is
                                    	  evaluated, and the result is discarded. If evaluation of the
                                    	  <span class="emphasis"><em>Primary</em></span> expression completes abruptly, the field access
                                    	  expression completes abruptly for the same reason.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-A-2"></a>If the field
                                    	  is a non-blank <code class="literal">final</code> field, then the
                                    	  result is the value of the specified class variable in the
                                    	  class or interface that is the type of the <span class="emphasis"><em>Primary</em></span>
                                    	  expression.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-A-3"></a>If the field is not
                                    	  <code class="literal">final</code>, or is a blank <code class="literal">final</code> and the field
                                    	  access occurs in a constructor, then the result is
                                    	  a variable, namely, the specified class variable in the
                                    	  class that is the type of the <span class="emphasis"><em>Primary</em></span> expression.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.11.1-200-B"></a>If the field is not
                                 <code class="literal">static</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-B-1"></a>The <span class="emphasis"><em>Primary</em></span> expression is
                                    	  evaluated. If evaluation of the <span class="emphasis"><em>Primary</em></span> expression
                                    	  completes abruptly, the field access expression completes
                                    	  abruptly for the same reason.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-B-2"></a>If the value of the <span class="emphasis"><em>Primary</em></span>
                                    	  is <code class="literal">null</code>, then a <code class="literal">NullPointerException</code> is thrown.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-B-3"></a>If the field
                                    	  is a non-blank <code class="literal">final</code>, then the result
                                    	  is the value of the named member field in type <span class="type">T</span>
                                    	  found in the object referenced by the value of the
                                    	  <span class="emphasis"><em>Primary</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-B-4"></a>If the field is not
                                    	  <code class="literal">final</code>, or is a blank <code class="literal">final</code> and the field
                                    	  access occurs in a constructor, then the result is
                                    	  a variable, namely the named member field in type <span class="type">T</span>
                                    	  found in the object referenced by the value of the
                                    	  <span class="emphasis"><em>Primary</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.11.1-210"></a>Note
                  that only the type of the <span class="emphasis"><em>Primary</em></span> expression, not the class of the
                  actual object referred to at run time, is used in determining which
                  field to use.
               </p>
               <div class="example"><a name="d5e19868"></a><p class="title"><b>Example&nbsp;15.11.1-1.&nbsp;Static Binding for Field Access</b></p>
                  <div class="example-contents"><pre class="programlisting">
class S           { int x = 0; }
class T extends S { int x = 1; }
class Test1 {
    public static void main(String[] args) {
        T t = new T();
        System.out.println("t.x=" + t.x + when("t", t));
        S s = new S();
        System.out.println("s.x=" + s.x + when("s", s));
        s = t;
        System.out.println("s.x=" + s.x + when("s", s));
    }
    static String when(String name, Object t) {
        return " when " + name + " holds a "
                        + t.getClass() + " at run time.";
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
t.x=1 when t holds a class T at run time.
s.x=0 when s holds a class S at run time.
s.x=0 when s holds a class T at run time.
</pre><p class="note">The last line shows that, indeed, the field that is
                        accessed does not depend on the run-time class of the referenced
                        object; even if <code class="literal">s</code> holds a reference to an object of
                        class <code class="literal">T</code>, the expression <code class="literal">s.x</code>
                        refers to the <code class="literal">x</code> field of
                        class <code class="literal">S</code>, because the type of the
                        expression <code class="literal">s</code> is <code class="literal">S</code>. Objects of
                        class <code class="literal">T</code> contain two fields
                        named <code class="literal">x</code>, one for class <code class="literal">T</code> and one
                        for its superclass <code class="literal">S</code>.
                     </p>
                     <p class="note">This lack of dynamic lookup for field accesses
                        allows programs to be run efficiently with straightforward
                        implementations. The power of late binding and overriding is
                        available, but only when instance methods are used. Consider the same
                        example using instance methods to access the fields:
                     </p><pre class="programlisting">
class S           { int x = 0; int z() { return x; } }
class T extends S { int x = 1; int z() { return x; } }
class Test2 {
    public static void main(String[] args) {
        T t = new T();
        System.out.println("t.z()=" + t.z() + when("t", t));
        S s = new S();
        System.out.println("s.z()=" + s.z() + when("s", s));
        s = t;
        System.out.println("s.z()=" + s.z() + when("s", s));
    }
    static String when(String name, Object t) {
        return " when " + name + " holds a "
                        + t.getClass() + " at run time.";
    }
}
</pre><p class="note">Now the output is:</p><pre class="screen">
t.z()=1 when t holds a class T at run time.
s.z()=0 when s holds a class S at run time.
s.z()=1 when s holds a class T at run time.
</pre><p class="note">The last line shows that, indeed, the method that is
                        accessed <span class="emphasis"><em>does</em></span> depend on the run-time class of the
                        referenced object; when <code class="literal">s</code> holds a reference to an
                        object of class <code class="literal">T</code>, the
                        expression <code class="literal">s.z()</code> refers to the <code class="literal">z</code>
                        method of class <code class="literal">T</code>, despite the fact that the type
                        of the expression <code class="literal">s</code>
                        is <code class="literal">S</code>. Method <code class="literal">z</code> of
                        class <code class="literal">T</code> overrides method <code class="literal">z</code> of
                        class <code class="literal">S</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e19902"></a><p class="title"><b>Example&nbsp;15.11.1-2.&nbsp;Receiver Variable Is Irrelevant For <code class="literal">static</code> Field Access</b></p>
                  <div class="example-contents">
                     <p class="note">The following program demonstrates that a null
                        reference may be used to access a class (<code class="literal">static</code>) variable without
                        causing an exception:
                     </p><pre class="programlisting">
class Test3 {
    static String mountain = "Chocorua";
    static Test3 favorite(){
        System.out.print("Mount ");
        return null;
    }
    public static void main(String[] args) {
        System.out.println(favorite().mountain);
    }
}
</pre><p class="note">It compiles, executes, and prints:</p><pre class="screen">
Mount Chocorua
</pre><p class="note">Even though the result
                        of <code class="literal">favorite()</code> is <code class="literal">null</code>, a <code class="literal">NullPointerException</code> is not
                        thrown. That "<code class="literal">Mount </code>" is printed demonstrates that
                        the <span class="emphasis"><em>Primary</em></span> expression is indeed fully evaluated at run time,
                        despite the fact that only its type, not its value, is used to
                        determine which field to access (because the
                        field <code class="literal">mountain</code> is <code class="literal">static</code>).
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.11.2.&nbsp;Accessing Superclass Members using super">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.11.2"></a>15.11.2.&nbsp;Accessing Superclass Members using <code class="literal">super</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.11.2-100"></a>The form <code class="literal">super</code><code class="literal">.</code><span class="emphasis"><em>Identifier</em></span>
                  refers to the field named <span class="emphasis"><em>Identifier</em></span> of the current object, but with
                  the current object viewed as an instance of the superclass of the
                  current class.
               </p>
               <p class="norm-static"><a name="jls-15.11.2-110"></a>The form
                  <span class="type">T</span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><span class="emphasis"><em>Identifier</em></span> refers to the field named
                  <span class="emphasis"><em>Identifier</em></span> of the lexically enclosing instance corresponding to <span class="type">T</span>,
                  but with that instance viewed as an instance of the superclass of
                  <span class="type">T</span>.
               </p>
               <p class="norm-error"><a name="jls-15.11.2-200"></a>The forms
                  using the keyword <code class="literal">super</code> are valid only in an instance method,
                  instance initializer, or constructor, or in the initializer of an
                  instance variable of a class. If they appear anywhere else, a
                  compile-time error occurs.
               </p>
               <p class="note">These are exactly the same situations in which the
                  keyword <code class="literal">this</code> may be used (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>).
               </p>
               <p class="norm-error"><a name="jls-15.11.2-210"></a>It is a
                  compile-time error if the forms using the keyword <code class="literal">super</code> appear in
                  the declaration of class <code class="literal">Object</code>, since <code class="literal">Object</code> has no
                  superclass.
               </p>
               <p class="norm"><a name="jls-15.11.2-300"></a>If a field access expression
                  <code class="literal">super</code><code class="literal">.</code><code class="varname">name</code> appears within class <span class="type">C</span>, and the
                  immediate superclass of <span class="type">C</span> is class <span class="type">S</span>, then
                  <code class="literal">super</code><code class="literal">.</code><code class="varname">name</code> is treated exactly as if it had
                  been the expression <code class="literal">this</code><code class="literal">.</code><code class="varname">name</code> <span class="emphasis"><em>in
                        the body of class <span class="type">S</span></em></span>. Thus it can access the
                  field <code class="varname">name</code> that is visible in class <span class="type">S</span>, even if
                  that field is hidden by a declaration of a
                  field <code class="varname">name</code> in class <span class="type">C</span>.
               </p>
               <p class="norm-static"><a name="jls-15.11.2-400"></a>If a field access expression
                  <span class="type">T</span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><code class="varname">name</code> appears within class <span class="type">C</span>,
                  and the immediate superclass of the class denoted by <span class="type">T</span> is a class
                  whose fully qualified name is <span class="type">S</span>, then
                  <span class="type">T</span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><code class="varname">name</code> is treated exactly as if
                  it had been the expression
                  <code class="literal">this</code><code class="literal">.</code><code class="varname">name</code> <span class="emphasis"><em>in the body of class
                        <span class="type">S</span></em></span>. Thus it can access the field <code class="varname">name</code>
                  that is visible in class <span class="type">S</span>, even if that field is hidden by a
                  declaration of a field <code class="varname">name</code> in class <span class="type">T</span>.
               </p>
               <p class="norm-error"><a name="jls-15.11.2-410"></a>It is a
                  compile-time error if the current class is not an inner class of class
                  <span class="type">T</span> or <span class="type">T</span> itself.
               </p>
               <div class="example"><a name="d5e19989"></a><p class="title"><b>Example&nbsp;15.11.2-1.&nbsp;The <code class="literal">super</code> Expression</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface I           { int x = 0; }
class T1 implements I { int x = 1; }
class T2 extends T1   { int x = 2; }
class T3 extends T2 {
    int x = 3;
    void test() {
        System.out.println("x=\t\t"          + x);
        System.out.println("super.x=\t\t"    + super.x);
        System.out.println("((T2)this).x=\t" + ((T2)this).x);
        System.out.println("((T1)this).x=\t" + ((T1)this).x);
        System.out.println("((I)this).x=\t"  + ((I)this).x);
    }
}
class Test {
    public static void main(String[] args) {
        new T3().test();
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
x=              3
super.x=        2
((T2)this).x=   2
((T1)this).x=   1
((I)this).x=    0
</pre><p class="note">Within class <code class="literal">T3</code>, the
                        expression <code class="literal">super.x</code> is treated as if it were:
                     </p><pre class="screen">
((T2)this).x
</pre><p class="note">Note that <code class="literal">super.x</code> is not
                        specified in terms of a cast, due to difficulties around access to
                        <code class="literal">protected</code> members of the superclass.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.12.&nbsp;Method Invocation Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.12"></a>15.12.&nbsp;Method Invocation Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-15.12-100"></a>A method
               invocation expression is used to invoke a class or instance
               method.
            </p>
            <div class="literallayout">
               <p><br>
                  MethodInvocation:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;MethodName&nbsp;<code class="literal">(</code>&nbsp;ArgumentList<sub>opt</sub>&nbsp;<code class="literal">)</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Primary&nbsp;<code class="literal">.</code>&nbsp;NonWildTypeArguments<sub>opt</sub>&nbsp;Identifier&nbsp;<code class="literal">(</code>&nbsp;ArgumentList<sub>opt</sub>&nbsp;<code class="literal">)</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">super</code>&nbsp;<code class="literal">.</code>&nbsp;NonWildTypeArguments<sub>opt</sub>&nbsp;Identifier&nbsp;<code class="literal">(</code>&nbsp;ArgumentList<sub>opt</sub>&nbsp;<code class="literal">)</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ClassName&nbsp;<code class="literal">.</code>&nbsp;<code class="literal">super</code>&nbsp;<code class="literal">.</code>&nbsp;NonWildTypeArguments<sub>opt</sub>&nbsp;Identifier&nbsp;<code class="literal">(</code>&nbsp;ArgumentList<sub>opt</sub>&nbsp;<code class="literal">)</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;TypeName&nbsp;<code class="literal">.</code>&nbsp;NonWildTypeArguments&nbsp;Identifier&nbsp;<code class="literal">(</code>&nbsp;ArgumentList<sub>opt</sub>&nbsp;<code class="literal">)</code><br>
                  
               </p>
            </div>
            <p class="note">The definition of <span class="emphasis"><em>ArgumentList</em></span>
               from <a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a> is repeated here for
               convenience:
            </p>
            <div class="literallayout">
               <p><br>
                  ArgumentList:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Expression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ArgumentList&nbsp;<code class="literal">,</code>&nbsp;Expression<br>
                  
               </p>
            </div>
            <p class="norm"><a name="jls-15.12-120"></a>Resolving a method name at
               compile time is more complicated than resolving a field name because
               of the possibility of method overloading. Invoking a method at run time
               is also more complicated than accessing a field because of the
               possibility of instance method overriding.
            </p>
            <p class="norm"><a name="jls-15.12-130"></a>Determining the method that
               will be invoked by a method invocation expression involves several
               steps. The following three sections describe the compile-time
               processing of a method invocation; the determination of the type of
               the method invocation expression is described in
               <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>.
            </p>
            <div class="section" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.12.1"></a>15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.12.1-100"></a>The
                  first step in processing a method invocation at compile time is to
                  figure out the name of the method to be invoked and which class or
                  interface to check for definitions of methods of that name. There are
                  several cases to consider, depending on the form that precedes the
                  left parenthesis, as follows.
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-100-A"></a>If
                                 the form is <span class="emphasis"><em>MethodName</em></span>, then there are
                                 three subcases:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.1-100-A-1"></a>If it is a simple name, that
                                    	  is, just an <span class="emphasis"><em>Identifier</em></span>, then the name of the method is the
                                    	  <span class="emphasis"><em>Identifier</em></span>.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.12.1-100-A-1.1"></a>If the <span class="emphasis"><em>Identifier</em></span> appears
                                    	  within the scope of a visible method declaration with that
                                    	  name (<a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a>,
                                    	  <a class="xref" href="jls-6.html#jls-6.4.1" title="6.4.1.&nbsp;Shadowing">&sect;6.4.1</a>), then:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.12.1-100-A-1.1-1"></a>If there is an
                                             	      enclosing type declaration of which that method is a
                                             	      member, let <span class="type">T</span> be the innermost such type
                                             	      declaration. The class or interface to search is
                                             	      <span class="type">T</span>.
                                          </p>
                                          <p class="note">This search policy is called the "comb
                                             	      rule". It effectively looks for methods in a nested
                                             	      class's superclass hierarchy before looking for methods
                                             	      in an enclosing class and its superclass hierarchy. See
                                             	      <a class="xref" href="jls-6.html#jls-6.5.7.1" title="6.5.7.1.&nbsp;Simple Method Names">&sect;6.5.7.1</a> for an example.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.12.1-100-A-1.1-2"></a>Otherwise, the visible method declaration
                                             	      may be in scope due to one or more single-static-import
                                             	      or static-import-on-demand declarations
                                             	      (<a class="xref" href="jls-7.html#jls-7.5.3" title="7.5.3.&nbsp;Single-Static-Import Declarations">&sect;7.5.3</a>,
                                             	      <a class="xref" href="jls-7.html#jls-7.5.4" title="7.5.4.&nbsp;Static-Import-on-Demand Declarations">&sect;7.5.4</a>). There is no class or
                                             	      interface to search, as the method to be invoked is
                                             	      determined later (<a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>).
                                             	    
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.1-100-A-2"></a>If it is a qualified name of
                                    	  the form <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <span class="emphasis"><em>Identifier</em></span>,
                                    	  then the name of the method is the <span class="emphasis"><em>Identifier</em></span> and the
                                    	  class to search is the one named by
                                    	  the <span class="emphasis"><em>TypeName</em></span>.
                                 </p>
                                 <p class="norm-error"><a name="jls-15.12.1-100-A-2.1"></a>If <span class="emphasis"><em>TypeName</em></span>
                                    	  is the name of an interface rather than a class, then a
                                    	  compile-time error occurs, because this form can invoke only
                                    	  <code class="literal">static</code> methods and interfaces have no <code class="literal">static</code>
                                    	  methods.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.1-100-A-3"></a>In all other cases, the
                                    	  qualified name has the form <span class="emphasis"><em>FieldName</em></span>
                                    	  <code class="literal">.</code> <span class="emphasis"><em>Identifier</em></span>.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.12.1-100-A-3.1"></a>The name of the method is the
                                    	  <span class="emphasis"><em>Identifier</em></span> and the class or interface to search is the
                                    	  declared type <span class="type">T</span> of the field named by
                                    	  the <span class="emphasis"><em>FieldName</em></span>, if <span class="type">T</span> is a class or
                                    	  interface type, or the upper bound of <span class="type">T</span> if <span class="type">T</span> is a type
                                    	  variable.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-100-B"></a>If
                                 the form is <span class="emphasis"><em>Primary</em></span>
                                 <code class="literal">.</code> <span class="emphasis"><em>NonWildTypeArguments<sub>opt</sub></em></span>
                                 <span class="emphasis"><em>Identifier</em></span>, then the name of the method is the
                                 <span class="emphasis"><em>Identifier</em></span>.
                        </p>
                        <p class="norm-static"><a name="jls-15.12.1-100-B.1"></a>Let <span class="type">T</span> be the type of the
                                 <span class="emphasis"><em>Primary</em></span> expression. The class or interface to be searched is
                                 <span class="type">T</span> if <span class="type">T</span> is a class or interface type, or the upper bound of
                                 <span class="type">T</span> if <span class="type">T</span> is a type variable.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.1-100-B.2"></a>It is a
                                compile-time error if <span class="type">T</span> is not a reference type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-100-C"></a>If
                                 the form is <code class="literal">super</code> <code class="literal">.</code> 
                                 <span class="emphasis"><em>NonWildTypeArguments<sub>opt</sub></em></span> <span class="emphasis"><em>Identifier</em></span>,
                                 then the name of the method is the <span class="emphasis"><em>Identifier</em></span> and the class to
                                 be searched is the superclass of the class whose declaration
                                 contains the method invocation.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.1-100-C.1"></a>Let <span class="type">T</span> be the type declaration
                                 immediately enclosing the method invocation. It is a
                                 compile-time error if <span class="type">T</span> is the class <code class="literal">Object</code> or <span class="type">T</span> is an
                                 interface.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-100-D"></a>If
                                 the form is <span class="emphasis"><em>ClassName</em></span> <code class="literal">.</code> <code class="literal">super</code>
                                 <code class="literal">.</code> <span class="emphasis"><em>NonWildTypeArguments<sub>opt</sub></em></span>
                                 <span class="emphasis"><em>Identifier</em></span>, then the name of the method is the <span class="emphasis"><em>Identifier</em></span>
                                 and the class to be searched is the superclass of the class <span class="type">C</span>
                                 denoted by <span class="emphasis"><em>ClassName</em></span>.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.1-100-D.1"></a>It is a compile-time error if <span class="type">C</span>
                                 is not a lexically enclosing class of the current class.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.1-100-D.2"></a>It is a compile-time error if <span class="type">C</span>
                                 is the class <code class="literal">Object</code>.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.1-100-D.3"></a>Let <span class="type">T</span> be the type declaration
                                 immediately enclosing the method invocation. It is a
                                 compile-time error if <span class="type">T</span> is the class <code class="literal">Object</code> or <span class="type">T</span> is an
                                 interface.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-100-E"></a>If
                                 the form is <span class="emphasis"><em>TypeName</em></span>
                                 <code class="literal">.</code> <span class="emphasis"><em>NonWildTypeArguments</em></span> <span class="emphasis"><em>Identifier</em></span>,
                                 then the name of the method is the <span class="emphasis"><em>Identifier</em></span> and the class to
                                 be searched is the class <span class="type">C</span> denoted
                                 by <span class="emphasis"><em>TypeName</em></span>.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.1-100-E.1"></a>If <span class="emphasis"><em>TypeName</em></span> is
                                 the name of an interface rather than a class, then a
                                 compile-time error occurs, because this form can invoke only
                                 <code class="literal">static</code> methods and interfaces have no <code class="literal">static</code> methods.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.12.2"></a>15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.12.2-100"></a>The second step searches
                  the type determined in the previous step for member methods. This step
                  uses the name of the method and the types of the argument expressions
                  to locate methods that are both <span class="emphasis"><em>accessible</em></span>
                  and <span class="emphasis"><em>applicable</em></span>, that is, declarations that can be
                  correctly invoked on the given arguments.
               </p>
               <p class="norm"><a name="jls-15.12.2-110"></a>There may be more than one
                  such method, in which case the <span class="emphasis"><em>most specific</em></span> one
                  is chosen. The descriptor (signature plus return type) of the most
                  specific method is one used at run time to perform the method
                  dispatch.
               </p>
               <p class="norm"><a name="jls-15.12.2-120"></a>A method
                  is <span class="emphasis"><em>applicable</em></span> if it is either applicable by
                  subtyping (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Subtyping">&sect;15.12.2.2</a>), applicable by method
                  invocation conversion (<a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion">&sect;15.12.2.3</a>), or it is an
                  applicable variable arity method
                  (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Applicable Variable Arity Methods">&sect;15.12.2.4</a>).
               </p>
               <p class="norm"><a name="jls-15.12.2-130"></a>The process of determining
                  applicability begins by determining the potentially applicable methods
                  (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>).
               </p>
               <p class="norm"><a name="jls-15.12.2-140"></a>The remainder of the
                  process is split into three phases, to ensure compatibility with
                  versions of the Java programming language prior to Java SE 5.0. The phases
                  are:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.12.2-140-A"></a>The first phase
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Subtyping">&sect;15.12.2.2</a>) performs overload resolution
                                 without permitting boxing or unboxing conversion, or the use of
                                 variable arity method invocation. If no applicable method is
                                 found during this phase then processing continues to the second
                                 phase.
                        </p>
                        <p class="note">This
                                 guarantees that any calls that were valid in the Java programming language
                                 before Java SE 5.0 are not considered ambiguous as the result of
                                 the introduction of variable arity methods, implicit boxing
                                 and/or unboxing. However, the declaration of a variable arity
                                 method (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) can change the method
                                 chosen for a given method method invocation expression, because
                                 a variable arity method is treated as a fixed arity method in
                                 the first phase. For example,
                                 declaring <code class="literal">m(Object...)</code> in a class which
                                 already declares <code class="literal">m(Object)</code>
                                 causes <code class="literal">m(Object)</code> to no longer be chosen for
                                 some invocation expressions (such
                                 as <code class="literal">m(null)</code>),
                                 as <code class="literal">m(Object[])</code> is more specific.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.12.2-140-B"></a>The second phase
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion">&sect;15.12.2.3</a>) performs overload resolution
                                 while allowing boxing and unboxing, but still precludes the use
                                 of variable arity method invocation. If no applicable method is
                                 found during this phase then processing continues to the third
                                 phase.
                        </p>
                        <p class="note">This ensures
                                 that a method is never chosen through variable arity method
                                 invocation if it is applicable through fixed arity method
                                 invocation.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.12.2-140-C"></a>The third phase
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Applicable Variable Arity Methods">&sect;15.12.2.4</a>) allows overloading to be
                                 combined with variable arity methods, boxing, and
                                 unboxing.
                        </p>
                     </li>
                  </ol>
               </div>
               <p class="norm"><a name="jls-15.12.2-150"></a>Deciding whether a method is
                  applicable will, in the case of generic methods
                  (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>), require that type arguments be
                  determined. Type arguments may be passed explicitly or implicitly. If
                  they are passed implicitly, they must be inferred
                  (<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>) from the types of the argument
                  expressions.
               </p>
               <p class="norm"><a name="jls-15.12.2-160"></a>If several applicable
                  methods have been identified during one of the three phases of
                  applicability testing, then the most specific one is chosen, as
                  specified in section <a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>.
               </p>
               <div class="example"><a name="d5e20193"></a><p class="title"><b>Example&nbsp;15.12.2-1.&nbsp;Method Applicability</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Doubler {
            static int two()      { return two(1); }
    private static int two(int i) { return 2*i;    }
}
class Test extends Doubler {	
    static long two(long j) { return j+j; }

    public static void main(String[] args) {
        System.out.println(two(3));
        System.out.println(Doubler.two(3)); // compile-time error
    }
}
</pre><p class="note">For the method invocation <code class="literal">two(1)</code>
                        within class <code class="literal">Doubler</code>, there are two accessible
                        methods named <code class="literal">two</code>, but only the second one is
                        applicable, and so that is the one invoked at run time.
                     </p>
                     <p class="note">For the method invocation <code class="literal">two(3)</code>
                        within class <code class="literal">Test</code>, there are two applicable
                        methods, but only the one in class <code class="literal">Test</code> is
                        accessible, and so that is the one to be invoked at run time (the
                        argument <code class="literal">3</code> is converted to
                        type <code class="literal">long</code>).
                     </p>
                     <p class="note">For the method
                        invocation <code class="literal">Doubler.two(3)</code>, the
                        class <code class="literal">Doubler</code>, not class <code class="literal">Test</code>,
                        is searched for methods named <code class="literal">two</code>; the only
                        applicable method is not accessible, and so this method invocation
                        causes a compile-time error.
                     </p>
                     <p class="note">Another example is:</p><pre class="programlisting">
class ColoredPoint {
    int x, y;
    byte color;
    void setColor(byte color) { this.color = color; }
}
class Test {
    public static void main(String[] args) {
        ColoredPoint cp = new ColoredPoint();
        byte color = 37;
        cp.setColor(color);
        cp.setColor(37);  // compile-time error
    }
}
</pre><p class="note">Here, a compile-time error occurs for the second
                        invocation of <code class="literal">setColor</code>, because no applicable
                        method can be found at compile time. The type of the
                        literal <code class="literal">37</code> is <code class="literal">int</code>, and <code class="literal">int</code> cannot be converted
                        to <code class="literal">byte</code> by method invocation conversion. Assignment conversion,
                        which is used in the initialization of the
                        variable <code class="literal">color</code>, performs an implicit conversion of
                        the constant from type <code class="literal">int</code> to <code class="literal">byte</code>, which is permitted because the
                        value <code class="literal">37</code> is small enough to be represented in type
                        <code class="literal">byte</code>; but such a conversion is not allowed for method invocation
                        conversion.
                     </p>
                     <p class="note">If the method <code class="literal">setColor</code> had,
                        however, been declared to take an <code class="literal">int</code> instead of a <code class="literal">byte</code>, then both
                        method invocations would be correct; the first invocation would be
                        allowed because method invocation conversion does permit a widening
                        conversion from <code class="literal">byte</code> to <code class="literal">int</code>. However, a narrowing cast would then
                        be required in the body of <code class="literal">setColor</code>:
                     </p><pre class="screen">
void setColor(int color) { this.color = (byte)color; }
</pre><p class="note">Here is an example of overloading
                        ambiguity. Consider the program:
                     </p><pre class="programlisting">
class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
    static void test(ColoredPoint p, Point q) {
        System.out.println("(ColoredPoint, Point)");
    }
    static void test(Point p, ColoredPoint q) {
        System.out.println("(Point, ColoredPoint)");
    }
    public static void main(String[] args) {
        ColoredPoint cp = new ColoredPoint();
        test(cp, cp);  // compile-time error
    }
}
</pre><p class="note">This example produces an error at compile time. The
                        problem is that there are two declarations of <code class="literal">test</code>
                        that are applicable and accessible, and neither is more specific than
                        the other. Therefore, the method invocation is ambiguous.
                     </p>
                     <p class="note">If a third definition of <code class="literal">test</code>
                        were added:
                     </p><pre class="screen">
static void test(ColoredPoint p, ColoredPoint q) {
    System.out.println("(ColoredPoint, ColoredPoint)");
}
</pre><p class="note">then it would be more specific than the other two,
                        and the method invocation would no longer be ambiguous.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e20240"></a><p class="title"><b>Example&nbsp;15.12.2-2.&nbsp;Return Type Not Considered During Method Selection</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
    static int test(ColoredPoint p) {
        return p.color;
    }
    static String test(Point p) {
        return "Point";
    }
    public static void main(String[] args) {
        ColoredPoint cp = new ColoredPoint();
        String s = test(cp);  // compile-time error
    }
}
</pre><p class="note">Here, the most specific declaration of
                        method <code class="literal">test</code> is the one taking a parameter of
                        type <code class="literal">ColoredPoint</code>. Because the result type of the
                        method is <code class="literal">int</code>, a compile-time error occurs because an <code class="literal">int</code> cannot
                        be converted to a <code class="literal">String</code> by assignment conversion. This example
                        shows that the result types of methods do not participate in resolving
                        overloaded methods, so that the second <code class="literal">test</code> method,
                        which returns a <code class="literal">String</code>, is not chosen, even though it has a result
                        type that would allow the example program to compile without
                        error.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e20251"></a><p class="title"><b>Example&nbsp;15.12.2-3.&nbsp;Choosing The Most Specific Method</b></p>
                  <div class="example-contents">
                     <p class="note">The most  specific method is chosen
                        at compile time; its descriptor determines what method is actually
                        executed at run time. If a new method is added to a class, then source
                        code that was compiled with the old definition of the class might not
                        use the new method, even if a recompilation would cause this method to
                        be chosen.
                     </p>
                     <p class="note">So, for example, consider two compilation units, one
                        for class <code class="literal">Point</code>:
                     </p><pre class="programlisting">
package points;
public class Point {
    public int x, y;
    public Point(int x, int y) { this.x = x; this.y = y; }
    public String toString() { return toString(""); }
    public String toString(String s) {
        return "(" + x + "," + y + s + ")";
    }
}
</pre><p class="note">and one for
                        class <code class="literal">ColoredPoint</code>:
                     </p><pre class="programlisting">
package points;
public class ColoredPoint extends Point {
    public static final int
        RED = 0, GREEN = 1, BLUE = 2;
    public static String[] COLORS =
        { "red", "green", "blue" };

    public byte color;
    public ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = (byte)color;
    }

    /** Copy all relevant fields of the argument into
        this ColoredPoint object. */
    public void adopt(Point p) { x = p.x; y = p.y; }

    public String toString() {
        String s = "," + COLORS[color];
        return super.toString(s);
    }
}
</pre><p class="note">Now consider a third compilation unit that
                        uses <code class="literal">ColoredPoint</code>:
                     </p><pre class="programlisting">
import points.*;
class Test {
    public static void main(String[] args) {
        ColoredPoint cp =
            new ColoredPoint(6, 6, ColoredPoint.RED);
        ColoredPoint cp2 =
            new ColoredPoint(3, 3, ColoredPoint.GREEN);
        cp.adopt(cp2);
        System.out.println("cp: " + cp);
    }
}
</pre><p class="note">The output is:</p><pre class="screen">
cp: (3,3,red)
</pre><p class="note">The programmer who coded
                        class <code class="literal">Test</code> has expected to see the
                        word <code class="literal">green</code>, because the actual argument,
                        a <code class="literal">ColoredPoint</code>, has a <code class="literal">color</code>
                        field, and <code class="literal">color</code> would seem to be a "relevant
                        field". (Of course, the documentation for the
                        package <code class="literal">points</code> ought to have been much more
                        precise!)
                     </p>
                     <p class="note">Notice, by the way, that the most specific method
                        (indeed, the only applicable method) for the method invocation
                        of <code class="literal">adopt</code> has a signature that indicates a method of
                        one parameter, and the parameter is of
                        type <code class="literal">Point</code>. This signature becomes part of the
                        binary representation of class <code class="literal">Test</code> produced by the
                        Java compiler and is used by the method invocation at run time.
                     </p>
                     <p class="note">Suppose the programmer reported this software error
                        and the maintainer of the <code class="literal">points</code> package decided,
                        after due deliberation, to correct it by adding a method to
                        class <code class="literal">ColoredPoint</code>:
                     </p><pre class="programlisting">

public void adopt(ColoredPoint p) {
    adopt((Point)p);
    color = p.color;
}

</pre><p class="note">If the programmer then runs the old binary file
                        for <code class="literal">Test</code> with the new binary file
                        for <code class="literal">ColoredPoint</code>, the output is still:
                     </p><pre class="screen">
cp: (3,3,red)
</pre><p class="note">because the old binary file
                        for <code class="literal">Test</code> still has the descriptor "one parameter,
                        whose type is <code class="literal">Point</code>; <code class="literal">void</code>" associated with the
                        method call <code class="literal">cp.adopt(cp2)</code>. If the source code
                        for <code class="literal">Test</code> is recompiled, the Java compiler will then
                        discover that there are now two applicable <code class="literal">adopt</code>
                        methods, and that the signature for the more specific one is "one
                        parameter, whose type is <code class="literal">ColoredPoint</code>; <code class="literal">void</code>";
                        running the program will then produce the desired output:
                     </p><pre class="screen">
cp: (3,3,green)
</pre><p class="note">With forethought about such problems, the maintainer
                        of the <code class="literal">points</code> package could fix
                        the <code class="literal">ColoredPoint</code> class to work with both newly
                        compiled and old code, by adding defensive code to the
                        old <code class="literal">adopt</code> method for the sake of old code that
                        still invokes it on <code class="literal">ColoredPoint</code> arguments:
                     </p><pre class="programlisting">

public void adopt(Point p) {
    if (p instanceof ColoredPoint)
        color = ((ColoredPoint)p).color;
    x = p.x; y = p.y;
}

</pre><p class="note">Ideally, source code should be recompiled whenever
                        code that it depends on is changed. However, in an environment where
                        different classes are maintained by different organizations, this is
                        not always feasible. Defensive programming with careful attention to
                        the problems of class evolution can make upgraded code much more
                        robust. See <a class="xref" href="jls-13.html" title="Chapter&nbsp;13.&nbsp;Binary Compatibility">&sect;13</a> for a detailed discussion of
                        binary compatibility and type evolution.
                     </p>
                  </div>
               </div><br class="example-break"><div class="section" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.1"></a>15.12.2.1.&nbsp;Identify Potentially Applicable Methods
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.1-100"></a>The
                     class or interface determined by compile-time step 1
                     (<a class="xref" href="jls-15.html#jls-15.12.1" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">&sect;15.12.1</a>) is searched for all member methods
                     that are potentially applicable to this method invocation; members
                     inherited from superclasses and superinterfaces are included in this
                     search.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.1-110"></a>In
                     addition, if the method invocation has, before the left parenthesis,
                     a <span class="emphasis"><em>MethodName</em></span> of the form <span class="emphasis"><em>Identifier</em></span>, then the
                     search process also examines all member methods that are (a) imported
                     by single-static-import declarations (<a class="xref" href="jls-7.html#jls-7.5.3" title="7.5.3.&nbsp;Single-Static-Import Declarations">&sect;7.5.3</a>) and
                     static-import-on-demand declarations (<a class="xref" href="jls-7.html#jls-7.5.4" title="7.5.4.&nbsp;Static-Import-on-Demand Declarations">&sect;7.5.4</a>)
                     within the compilation unit (<a class="xref" href="jls-7.html#jls-7.3" title="7.3.&nbsp;Compilation Units">&sect;7.3</a>) within which
                     the method invocation occurs, and (b) not shadowed
                     (<a class="xref" href="jls-6.html#jls-6.4.1" title="6.4.1.&nbsp;Shadowing">&sect;6.4.1</a>) at the place where the method invocation
                     appears, to determine if they are potentially applicable.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.1-200"></a>A
                     member method is <span class="emphasis"><em>potentially applicable</em></span> to a
                     method invocation if and only if all of the following are true:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-A"></a>The name of the member is identical
                                  to the name of the method in the method invocation.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-B"></a>The member is accessible
                                  (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) to the class or interface in which the
                                  method invocation appears.
                           </p>
                           <p class="note">Whether a member method is accessible at a
                                  method invocation depends on the access modifier (<code class="literal">public</code>, none,
                                  <code class="literal">protected</code>, or <code class="literal">private</code>) in the member's declaration and on
                                  where the method invocation appears.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-C"></a>If the member is a variable arity
                                  method with arity <span class="emphasis"><em>n</em></span>, the arity of the method invocation is
                                  greater or equal to <span class="emphasis"><em>n</em></span><code class="literal">-1</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-D"></a>If the member is a fixed arity method
                                  with arity <span class="emphasis"><em>n</em></span>, the arity of the method invocation is equal to
                                  <span class="emphasis"><em>n</em></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-E"></a>If the method invocation includes
                                  explicit type arguments, and the member is a generic method, then
                                  the number of type arguments is equal to the number of type
                                  parameters of the method.
                           </p>
                           <p class="note">This clause implies that a non-generic method
                                  may be potentially applicable to an invocation that supplies
                                  explicit type arguments. Indeed, it may turn out to be
                                  applicable. In such a case, the type arguments will simply be
                                  ignored.
                           </p>
                           <p class="note">This rule stems from issues of compatibility and
                                  principles of substitutability. Since interfaces or superclasses
                                  may be generified independently of their subtypes, we may override
                                  a generic method with a non-generic one. However, the overriding
                                  (non-generic) method must be applicable to calls to the generic
                                  method, including calls that explicitly pass type
                                  arguments. Otherwise the subtype would not be substitutable for
                                  its generified supertype.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-error"><a name="jls-15.12.2.1-210"></a>If the
                     search does not yield at least one method that is potentially
                     applicable, then a compile-time error occurs.
                  </p>
               </div>
               <div class="section" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Subtyping">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.2"></a>15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Subtyping
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.2-100"></a>Let <code class="varname">m</code> be a potentially
                     applicable method (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>), let <code class="varname">e<sub>1</sub></code>, ...,
                     <code class="varname">e<sub>n</sub></code> be the actual argument expressions of the method invocation, and
                     let <span class="type">A<sub>i</sub></span> be the type of <code class="varname">e<sub>i</sub></code> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804;
                     <span class="emphasis"><em>n</em></span>). Then:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-100-A"></a>If <code class="varname">m</code> is a generic
                                   method, then let <span class="type">F<sub>1</sub></span> ... <span class="type">F<sub>n</sub></span> be the types of the formal
                                   parameters of <code class="varname">m</code>, and let <span class="type">R<sub>1</sub></span> ... <span class="type">R<sub>p</sub></span> (<span class="emphasis"><em>p</em></span>
                                   &#8805; 1) be the type parameters of <code class="varname">m</code>, and let
                                   <span class="type">B<sub>l</sub></span> be the declared bound of <span class="type">R<sub>l</sub></span> (1 &#8804; <span class="emphasis"><em>l</em></span> &#8804;
                                   <span class="emphasis"><em>p</em></span>). Then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.2-100-A-1"></a>If the method invocation does
                                       	not provide explicit type arguments, then let <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>p</sub></span> be
                                       	the type arguments inferred (<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>)
                                       	for this invocation of <code class="varname">m</code>, using a set of
                                       	initial constraints consisting of the constraints <span class="type">A<sub>i</sub></span>
                                       	&lt;&lt; <span class="type">F<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>) for each actual
                                       	argument expression <code class="varname">e<sub>i</sub></code> whose type is a reference
                                       	type.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.2-100-A-2"></a>Otherwise, let <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>p</sub></span> be
                                       	the explicit type arguments given in the method
                                       	invocation.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <p class="norm-static"><a name="jls-15.12.2.2-100-A.1"></a>Then let <span class="type">S<sub>i</sub></span> =
                                  <span class="type">F<sub>i</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">U<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">U<sub>p</sub></span><code class="literal">]</code> (1 &#8804;
                                  <span class="emphasis"><em>i</em></span>  &#8804; <span class="emphasis"><em>n</em></span>) be the types inferred for the
                                  formal parameters of <code class="varname">m</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-100-B"></a>Otherwise, let <span class="type">S<sub>1</sub></span> ... <span class="type">S<sub>n</sub></span> be the
                                  types of the formal parameters of <code class="varname">m</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.2-110"></a>The
                     method <code class="varname">m</code> is <span class="emphasis"><em>applicable by
                           subtyping</em></span> if and only if both of the following conditions
                     hold:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.2-110-A"></a>For 1 &#8804; <span class="emphasis"><em>i</em></span>
                                  &#8804; <span class="emphasis"><em>n</em></span>, either:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.2-110-A-1"></a><span class="type">A<sub>i</sub></span>
                                       	<code class="literal">&lt;:</code> <span class="type">S<sub>i</sub></span> (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>), or
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.2-110-A-2"></a><span class="type">A<sub>i</sub></span> is
                                       	convertible to some type <span class="type">C<sub>i</sub></span> by unchecked conversion
                                       	(<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>), and <span class="type">C<sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">S<sub>i</sub></span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.2-110-B"></a>If <code class="varname">m</code> is a generic
                                  method as described above, then <span class="type">U<sub>l</sub></span> <code class="literal">&lt;:</code>
                                  <span class="type">B<sub>l</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">U<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">U<sub>p</sub></span><code class="literal">]</code> (1 &#8804; <span class="emphasis"><em>l</em></span> &#8804;
                                  <span class="emphasis"><em>p</em></span>).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.2-120"></a>If no
                     method applicable by subtyping is found, the search for applicable
                     methods continues with phase 2
                     (<a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion">&sect;15.12.2.3</a>).
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.2-130"></a>Otherwise, the most specific method
                     (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>) is chosen among the methods that are
                     applicable by subtyping.
                  </p>
               </div>
               <div class="section" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.3"></a>15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.3-100"></a>Let <code class="varname">m</code> be a potentially
                     applicable method (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>), let <code class="varname">e<sub>1</sub></code>, ...,
                     <code class="varname">e<sub>n</sub></code> be the actual argument expressions of the method invocation, and
                     let <span class="type">A<sub>i</sub></span> be the type of <code class="varname">e<sub>i</sub></code> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804;
                     <span class="emphasis"><em>n</em></span>). Then:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.3-100-A"></a>If <code class="varname">m</code> is a generic
                                   method, then let <span class="type">F<sub>1</sub></span> ... <span class="type">F<sub>n</sub></span> be the types of the formal
                                   parameters of <code class="varname">m</code>, and let <span class="type">R<sub>1</sub></span> ... <span class="type">R<sub>p</sub></span> (<span class="emphasis"><em>p</em></span>
                                   &#8805; 1) be the type parameters of <code class="varname">m</code>, and let
                                   <span class="type">B<sub>l</sub></span> be the declared bound of <span class="type">R<sub>l</sub></span> (1 &#8804; <span class="emphasis"><em>l</em></span> &#8804;
                                   <span class="emphasis"><em>p</em></span>). Then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.3-100-A-1"></a>If the method invocation does
                                       	not provide explicit type arguments, then let <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>p</sub></span> be
                                       	the type arguments inferred (<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>)
                                       	for this invocation of <code class="varname">m</code>, using a set of
                                       	initial constraints consisting of the constraints <span class="type">A<sub>i</sub></span>
                                       	&lt;&lt; <span class="type">F<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>).
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.3-100-A-2"></a>Otherwise, let <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>p</sub></span> be
                                       	the explicit type arguments given in the method
                                       	invocation.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <p class="norm-static"><a name="jls-15.12.2.3-100-A.1"></a>Then let <span class="type">S<sub>i</sub></span> =
                                  <span class="type">F<sub>i</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">U<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">U<sub>p</sub></span><code class="literal">]</code> (1 &#8804;
                                  <span class="emphasis"><em>i</em></span>  &#8804; <span class="emphasis"><em>n</em></span>) be the types inferred for the
                                  formal parameters of <code class="varname">m</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.3-100-B"></a>Otherwise, let <span class="type">S<sub>1</sub></span> ... <span class="type">S<sub>n</sub></span> be the
                                  types of the formal parameters of <code class="varname">m</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.3-110"></a>The
                     method <code class="varname">m</code> is <span class="emphasis"><em>applicable by method
                           invocation conversion</em></span> if and only if both of the following
                     conditions hold:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.3-110-A"></a>For 1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>, the
                                  type of <code class="varname">e<sub>i</sub></code>, <span class="type">A<sub>i</sub></span>, can be converted by method invocation
                                  conversion (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Method Invocation Conversion">&sect;5.3</a>) to <span class="type">S<sub>i</sub></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.3-110-B"></a>If <code class="varname">m</code> is a generic
                                  method as described above, then <span class="type">U<sub>l</sub></span> <code class="literal">&lt;:</code>
                                  <span class="type">B<sub>l</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">U<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">U<sub>p</sub></span><code class="literal">]</code> (1 &#8804; <span class="emphasis"><em>l</em></span> &#8804;
                                  <span class="emphasis"><em>p</em></span>).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.3-120"></a>If no
                     method applicable by method invocation conversion is found, the search
                     for applicable methods continues with phase 3
                     (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Applicable Variable Arity Methods">&sect;15.12.2.4</a>).
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.3-130"></a>Otherwise, the most specific method
                     (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>) is chosen among the methods that are
                     applicable by method invocation conversion.
                  </p>
               </div>
               <div class="section" title="15.12.2.4.&nbsp;Phase 3: Identify Applicable Variable Arity Methods">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.4"></a>15.12.2.4.&nbsp;Phase 3: Identify Applicable Variable Arity Methods
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.4-100"></a>Let <code class="varname">m</code> be a potentially
                     applicable method (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>) with variable
                     arity, let <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>k</sub></code> be the actual argument expressions of the
                     method invocation, and let <span class="type">A<sub>i</sub></span> be the type of <code class="varname">e<sub>i</sub></code> (1 &#8804; <span class="emphasis"><em>i</em></span>
                     &#8804; <span class="emphasis"><em>k</em></span>). Then:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-100-A"></a>If <code class="varname">m</code> is a generic
                                   method, then let <span class="type">F<sub>1</sub></span> ... <span class="type">F<sub>n</sub></span> (1 &#8804; <span class="emphasis"><em>n</em></span> &#8804; <span class="emphasis"><em>k</em></span>+1) be
                                   the types of the formal parameters of <code class="varname">m</code>, where
                                   <span class="type">F<sub>n</sub></span>=<span class="type">T</span><code class="literal">[]</code> for some type <span class="type">T</span>, and let <span class="type">R<sub>1</sub></span> ... <span class="type">R<sub>p</sub></span>
                                   (<span class="emphasis"><em>p</em></span> &#8805; 1) be the type parameters of <code class="varname">m</code>,
                                   and let <span class="type">B<sub>l</sub></span> be the declared bound of <span class="type">R<sub>l</sub></span> (1 &#8804; <span class="emphasis"><em>l</em></span> &#8804;
                                   <span class="emphasis"><em>p</em></span>). Then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.4-100-A-1"></a>If the method invocation does
                                       	 not provide explicit type arguments then let <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>p</sub></span> be
                                       	 the type arguments inferred (<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>)
                                       	 for this invocation of <code class="varname">m</code>, using a set of
                                       	 initial constraints consisting of the constraints <span class="type">A<sub>i</sub></span>
                                       	 &lt;&lt; <span class="type">F<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &lt; <span class="emphasis"><em>n</em></span>) and the
                                       	 constraints <span class="type">A<sub>j</sub></span> &lt;&lt; <span class="type">T</span> (<span class="emphasis"><em>n</em></span> &#8804; <span class="emphasis"><em>j</em></span> &#8804;
                                       	 <span class="emphasis"><em>k</em></span>).
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.4-100-A-2"></a>Otherwise let <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>p</sub></span> be
                                       	 the explicit type arguments given in the method
                                       	 invocation.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <p class="norm-static"><a name="jls-15.12.2.4-100-A.1"></a>Then let <span class="type">S<sub>i</sub></span> =
                                  <span class="type">F<sub>i</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">U<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">U<sub>p</sub></span><code class="literal">]</code> (1 &#8804;
                                  <span class="emphasis"><em>i</em></span>  &#8804; <span class="emphasis"><em>n</em></span>) be the types inferred for the
                                  formal parameters of <code class="varname">m</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-100-B"></a>Otherwise, let <span class="type">S<sub>1</sub></span> ... <span class="type">S<sub>n</sub></span> (where
                                  <span class="emphasis"><em>n</em></span> &#8804; <span class="emphasis"><em>k</em></span>+1) be the types of the formal parameters
                                  of <code class="varname">m</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.4-110"></a>The
                     method <code class="varname">m</code> is an <span class="emphasis"><em>applicable variable-arity
                           method</em></span> if and only if all of the following conditions
                     hold:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-110-A"></a>For 1 &#8804; <span class="emphasis"><em>i</em></span> &lt; <span class="emphasis"><em>n</em></span>, the
                                  type of <code class="varname">e<sub>i</sub></code>, <span class="type">A<sub>i</sub></span>, can be converted by method invocation
                                  conversion to <span class="type">S<sub>i</sub></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-110-B"></a>If <span class="emphasis"><em>k</em></span> &#8805; <span class="emphasis"><em>n</em></span>, then for
                                   <span class="emphasis"><em>n</em></span> &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>k</em></span>, the type of <code class="varname">e<sub>i</sub></code>, <span class="type">A<sub>i</sub></span>, can be
                                   converted by method invocation conversion to the component type
                                   of <span class="type">S<sub>n</sub></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-110-C"></a>If <span class="emphasis"><em>k</em></span>
                                   != <span class="emphasis"><em>n</em></span>, or if <span class="emphasis"><em>k</em></span> = <span class="emphasis"><em>n</em></span> and <span class="type">A<sub>n</sub></span> cannot be converted by
                                   method invocation conversion to <span class="type">S<sub>n</sub></span><code class="literal">[]</code>, then the type
                                   which is the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of <span class="type">S<sub>n</sub></span> is
                                   accessible at the point of invocation.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-110-D"></a>If <code class="varname">m</code> is a generic
                                   method as described above, then <span class="type">U<sub>l</sub></span> <code class="literal">&lt;:</code>
                                   <span class="type">B<sub>l</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">U<sub>1</sub></span>...,<span class="type">R<sub>p</sub></span>=<span class="type">U<sub>p</sub></span><code class="literal">]</code> (1 &#8804; <span class="emphasis"><em>l</em></span> &#8804;
                                   <span class="emphasis"><em>p</em></span>).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-error"><a name="jls-15.12.2.4-120"></a>If no
                     applicable variable arity method is found, a compile-time error
                     occurs.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.4-130"></a>Otherwise, the most specific method
                     (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>) is chosen among the applicable
                     variable-arity methods.
                  </p>
               </div>
               <div class="section" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.5"></a>15.12.2.5.&nbsp;Choosing the Most Specific Method
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.5-100"></a>If more than one member
                     method is both accessible and applicable to a method invocation, it is
                     necessary to choose one to provide the descriptor for the run-time
                     method dispatch. The Java programming language uses the rule that the <span class="emphasis"><em>most
                           specific</em></span> method is chosen.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.5-110"></a>The informal intuition is
                     that one method is more specific than another if any invocation
                     handled by the first method could be passed on to the other one
                     without a compile-time type error.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.5-200"></a>One fixed-arity member
                     method named <code class="varname">m</code> is <span class="emphasis"><em>more
                           specific</em></span> than another member method of the same name and
                     arity if all of the following conditions hold:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.5-200-A"></a>The declared types
                                  of the parameters of the first member method are <span class="type">T<sub>1</sub></span>, ...,
                                  <span class="type">T<sub>n</sub></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.5-200-B"></a>The declared types
                                    of the parameters of the other method are <span class="type">U<sub>1</sub></span>, ...,
                                    <span class="type">U<sub>n</sub></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.5-200-C"></a>If the second
                                  method is generic, then let <span class="type">R<sub>1</sub></span> ... <span class="type">R<sub>p</sub></span> (<span class="emphasis"><em>p</em></span> &#8805; 1) be its
                                  type parameters, let <span class="type">B<sub>l</sub></span> be the declared bound of <span class="type">R<sub>l</sub></span> (1 &#8804;
                                  <span class="emphasis"><em>l</em></span>  &#8804; <span class="emphasis"><em>p</em></span>), let <span class="type">A<sub>1</sub></span> ... <span class="type">A<sub>p</sub></span> be the type
                                  arguments inferred (<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>) for this
                                  invocation under the initial constraints <span class="type">T<sub>i</sub></span> &lt;&lt; <span class="type">U<sub>i</sub></span> (1
                                  &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>), and let <span class="type">S<sub>i</sub></span> =
                                  <span class="type">U<sub>i</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">A<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">A<sub>p</sub></span><code class="literal">]</code> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804;
                                  <span class="emphasis"><em>n</em></span>).
                           </p>
                           <p class="norm"><a name="jls-15.12.2.5-200-C.1"></a>Otherwise, let
                                  <span class="type">S<sub>i</sub></span> = <span class="type">U<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>).
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.5-200-D"></a>For all <span class="emphasis"><em>j</em></span> from
                                  1 to <span class="emphasis"><em>n</em></span>, <span class="type">T<sub>j</sub></span> <code class="literal">&lt;:</code> <span class="type">S<sub>j</sub></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.5-200-E"></a>If the second
                                  method is a generic method as described above, then <span class="type">A<sub>l</sub></span> <code class="literal">&lt;:</code>
                                  <span class="type">B<sub>l</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">A<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">A<sub>p</sub></span><code class="literal">]</code> (1 &#8804; <span class="emphasis"><em>l</em></span> &#8804;
                                  <span class="emphasis"><em>p</em></span>).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.5-300"></a>One variable arity member
                     method named <code class="varname">m</code> is <span class="emphasis"><em>more
                           specific</em></span> than another variable arity member method of the
                     same name if either:
                  </p>
                  <div class="orderedlist">
                     <ol class="orderedlist" type="1">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.5-300-A"></a>One member method
                                  has <span class="emphasis"><em>n</em></span> parameters and the other has <span class="emphasis"><em>k</em></span> parameters, where
                                  <span class="emphasis"><em>n</em></span> &#8805; <span class="emphasis"><em>k</em></span>, and:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="disc">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-A-1"></a>The types of
                                                the parameters of the first member method are <span class="type">T<sub>1</sub></span>, ...,
                                                <span class="type">T<sub>n-1</sub></span>, <span class="type">T<sub>n</sub></span><code class="literal">[]</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-A-2"></a>The types of
                                               the parameters of the other method are <span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k-1</sub></span>,
                                               <span class="type">U<sub>k</sub></span><code class="literal">[]</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-A-3"></a>If the second
                                               method is generic then let <span class="type">R<sub>1</sub></span> ... <span class="type">R<sub>p</sub></span> (<span class="emphasis"><em>p</em></span> &#8805; 1) be
                                               its type parameters, let <span class="type">B<sub>l</sub></span> be the declared bound of <span class="type">R<sub>l</sub></span> (1
                                               &#8804; <span class="emphasis"><em>l</em></span> &#8804; <span class="emphasis"><em>p</em></span>), let <span class="type">A<sub>1</sub></span> ... <span class="type">A<sub>p</sub></span> be the type
                                               arguments inferred (<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>) for this
                                               invocation under the initial constraints <span class="type">T<sub>i</sub></span> &lt;&lt; <span class="type">U<sub>i</sub></span> (1
                                               &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>k</em></span>-1) and <span class="type">T<sub>i</sub></span> &lt;&lt; <span class="type">U<sub>k</sub></span> (<span class="emphasis"><em>k</em></span>
                                               &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>), and let <span class="type">S<sub>i</sub></span> =
                                               <span class="type">U<sub>i</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">A<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">A<sub>p</sub></span><code class="literal">]</code> (1 &#8804; <span class="emphasis"><em>i</em></span>
                                               &#8804; <span class="emphasis"><em>k</em></span>).
                                    </p>
                                    <p class="norm"><a name="jls-15.12.2.5-300-A-3.1"></a>Otherwise,
                                               let <span class="type">S<sub>i</sub></span> = <span class="type">U<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>k</em></span>).
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-A-4"></a>For all
                                       	  <span class="emphasis"><em>j</em></span> from 1 to <span class="emphasis"><em>k</em></span>-1, <span class="type">T<sub>j</sub></span> <code class="literal">&lt;:</code> <span class="type">S<sub>j</sub></span>, and,
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-A-5"></a>For all
                                       	<span class="emphasis"><em>j</em></span> from <span class="emphasis"><em>k</em></span> to <span class="emphasis"><em>n</em></span>, <span class="type">T<sub>j</sub></span> <code class="literal">&lt;:</code> <span class="type">S<sub>k</sub></span>, and,
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-A-6"></a>If the second
                                       	  method is a generic method as described above, then <span class="type">A<sub>l</sub></span>
                                       	  <code class="literal">&lt;:</code> <span class="type">B<sub>l</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">A<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">A<sub>p</sub></span><code class="literal">]</code> (1
                                       	  &#8804; <span class="emphasis"><em>l</em></span>  &#8804; <span class="emphasis"><em>p</em></span>).
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.5-300-B"></a>One member method
                                  has <span class="emphasis"><em>k</em></span> parameters and the other has <span class="emphasis"><em>n</em></span> parameters, where
                                  <span class="emphasis"><em>n</em></span> &#8805; <span class="emphasis"><em>k</em></span>, and:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="disc">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-B-1"></a>The types of
                                       	the parameters of the first method are <span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k-1</sub></span>,
                                       	<span class="type">U<sub>k</sub></span><code class="literal">[]</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-B-2"></a>The types of
                                       	the parameters of the other method are <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>n-1</sub></span>,
                                       	<span class="type">T<sub>n</sub></span><code class="literal">[]</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-B-3"></a>If the second
                                       	method is generic, then let <span class="type">R<sub>1</sub></span> ... <span class="type">R<sub>p</sub></span> (<span class="emphasis"><em>p</em></span> &#8805; 1) be
                                       	its type parameters, let <span class="type">B<sub>l</sub></span> be the declared bound of <span class="type">R<sub>l</sub></span> (1
                                       	&#8804; <span class="emphasis"><em>l</em></span> &#8804; <span class="emphasis"><em>p</em></span>), let <span class="type">A<sub>1</sub></span> ... <span class="type">A<sub>p</sub></span> be the type
                                       	arguments inferred (<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>) for this
                                       	invocation under the initial constraints <span class="type">U<sub>i</sub></span> &lt;&lt; <span class="type">T<sub>i</sub></span> (1
                                       	&#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>k</em></span>-1) and <span class="type">U<sub>k</sub></span> &lt;&lt; <span class="type">T<sub>i</sub></span> (<span class="emphasis"><em>k</em></span>
                                       	&#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>), and let <span class="type">S<sub>i</sub></span> =
                                       	<span class="type">T<sub>i</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">A<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">A<sub>p</sub></span>] (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804;
                                       	<span class="emphasis"><em>n</em></span>).
                                    </p>
                                    <p class="norm"><a name="jls-15.12.2.5-300-B-4"></a>Otherwise,
                                       	 let <span class="type">S<sub>i</sub></span> = <span class="type">T<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>).
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-B-5"></a>For all
                                       	<span class="emphasis"><em>j</em></span> from 1 to <span class="emphasis"><em>k</em></span>-1, <span class="type">U<sub>j</sub></span> <code class="literal">&lt;:</code> <span class="type">S<sub>j</sub></span>, and,
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-B-6"></a>For all
                                       	<span class="emphasis"><em>j</em></span> from <span class="emphasis"><em>k</em></span> to <span class="emphasis"><em>n</em></span>, <span class="type">U<sub>k</sub></span> <code class="literal">&lt;:</code> <span class="type">S<sub>j</sub></span>, and,
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-300-B-7"></a>If the second
                                       	method is a generic method as described above, then <span class="type">A<sub>l</sub></span>
                                       	<code class="literal">&lt;:</code> <span class="type">B<sub>l</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>=<span class="type">A<sub>1</sub></span>,...,<span class="type">R<sub>p</sub></span>=<span class="type">A<sub>p</sub></span><code class="literal">]</code> (1 &#8804;
                                       	<span class="emphasis"><em>l</em></span> &#8804; <span class="emphasis"><em>p</em></span>).
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ol>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.5-400"></a>The above conditions are
                     the only circumstances under which one method may be more specific
                     than another.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.5-500"></a>A method <code class="varname">m<sub>1</sub></code>
                     is <span class="emphasis"><em>strictly more specific</em></span> than another method
                     <code class="varname">m<sub>2</sub></code> if and only if <code class="varname">m<sub>1</sub></code> is more specific than <code class="varname">m<sub>2</sub></code> and <code class="varname">m<sub>2</sub></code> is not
                     more specific than <code class="varname">m<sub>1</sub></code>.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.5-510"></a>A method is said to
                     be <span class="emphasis"><em>maximally specific</em></span> for a method invocation if
                     it is accessible and applicable and there is no other method that is
                     applicable and accessible that is strictly more specific.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.5-520"></a>If there is exactly one
                     maximally specific method, then that method is in fact
                     the <span class="emphasis"><em>most specific method</em></span>; it is necessarily more
                     specific than any other accessible method that is applicable. It is
                     then subjected to some further compile-time checks as described in
                     <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.5-530"></a>It is possible that no
                     method is the most specific, because there are two or more methods
                     that are maximally specific. In this case:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.5-530-A"></a>If all the
                                  maximally specific methods have override-equivalent
                                  (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) signatures, then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-530-A-1"></a>If exactly
                                       	one of the maximally specific methods is not declared
                                       	<code class="literal">abstract</code>, it is the most specific method.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.5-530-A-2"></a>Otherwise, if
                                       	all the maximally specific methods are declared <code class="literal">abstract</code>,
                                       	and the signatures of all of the maximally specific methods
                                       	have the same erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>), then the
                                       	most specific method is chosen arbitrarily among the subset of
                                       	the maximally specific methods that have the most specific
                                       	return type.
                                    </p>
                                    <p class="norm"><a name="jls-15.12.2.5-530-A-2.1"></a>However,
                                       	the most specific method is considered to throw a checked
                                       	exception if and only if that exception or its erasure is
                                       	declared in the <code class="literal">throws</code> clauses of each of the maximally
                                       	specific methods.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-15.12.2.5-530-B"></a>Otherwise, we say that the method
                                  invocation is <span class="emphasis"><em>ambiguous</em></span>, and a compile-time
                                  error occurs.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="section" title="15.12.2.6.&nbsp;Method Result and Throws Types">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.6"></a>15.12.2.6.&nbsp;Method Result and Throws Types
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.6-100"></a>The result type of the
                     chosen method is determined as follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.6-100-A"></a>If the chosen
                                  method  is declared with a return type of
                                  <code class="literal">void</code>, then the result is <code class="literal">void</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.6-100-B"></a>Otherwise, if
                                  unchecked conversion was necessary for the method to be
                                  applicable, then the result type is the erasure
                                  (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the method's declared return
                                  type.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.6-100-C"></a>Otherwise, if the chosen
                                  method  is generic, then for 1 &#8804; <span class="emphasis"><em>i</em></span>
                                  &#8804; <span class="emphasis"><em>n</em></span>, let <span class="type">F<sub>i</sub></span> be the formal type parameters of the
                                  method, let <span class="type">A<sub>i</sub></span> be the actual type arguments inferred for the
                                  method invocation, and let <span class="type">R</span> be the
                                   return type of the chosen
                                  method.
                           </p>
                           <p class="norm"><a name="jls-15.12.2.6-100-C.1"></a>The result type
                                  is obtained by applying capture conversion
                                  (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to
                                  <span class="type">R</span><code class="literal">[</code><span class="type">F<sub>1</sub></span>=<span class="type">A<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>=<span class="type">A<sub>n</sub></span><code class="literal">]</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.6-100-D"></a>Otherwise, the result type is
                                  obtained by applying capture conversion
                                  (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to the return type of the
                                  chosen method
                                  .
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.6-200"></a>The exception types of
                     the <code class="literal">throws</code> clause of the chosen method are determined as
                     follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.6-200-A"></a>If unchecked
                                  conversion was necessary for the method to be applicable, then the
                                  <code class="literal">throws</code> clause is composed of the erasure
                                  (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the types in the method's declared
                                  <code class="literal">throws</code> clause.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.6-200-B"></a>Otherwise, if the
                                  method being invoked is generic, then for 1 &#8804; <span class="emphasis"><em>i</em></span> &#8804;
                                  <span class="emphasis"><em>n</em></span>, let <span class="type">F<sub>i</sub></span> be the type parameters of the method, let <span class="type">A<sub>i</sub></span> be
                                  the type arguments inferred for the method invocation, and let
                                  <span class="type">E<sub>j</sub></span> (1 &#8804; <span class="emphasis"><em>j</em></span> &#8804; <span class="emphasis"><em>m</em></span>) be the exception types declared
                                  in the <code class="literal">throws</code> clause of the method being invoked.
                           </p>
                           <p class="norm"><a name="jls-15.12.2.6-200-B.1"></a>The <code class="literal">throws</code>
                                  clause consists of the types
                                  <span class="type">E<sub>j</sub></span><code class="literal">[</code><span class="type">F<sub>1</sub></span>=<span class="type">A<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>=<span class="type">A<sub>n</sub></span><code class="literal">]</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.6-200-C"></a>Otherwise, the type
                                  of the <code class="literal">throws</code> clause is the type given in the method
                                  declaration.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.6-300"></a>The
                     exception types that a method invocation expression can throw are
                     specified in <a class="xref" href="jls-11.html#jls-11.2.1" title="11.2.1.&nbsp;Exception Analysis of Expressions">&sect;11.2.1</a>.
                  </p>
               </div>
               <div class="section" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.7"></a>15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.7-100"></a>In this section, we
                     describe the process of inferring type arguments for method and
                     constructor invocations. This process is invoked as a subroutine when
                     testing for method (or constructor) applicability
                     (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Subtyping">&sect;15.12.2.2</a>, <a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion">&sect;15.12.2.3</a>,
                     <a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Applicable Variable Arity Methods">&sect;15.12.2.4</a>).
                  </p>
                  <p class="note">The process of type inference is inherently
                     complex. Therefore, it is useful to give an informal overview of the
                     process before delving into the detailed specification.
                  </p>
                  <p class="note">Inference begins with an initial set of
                     constraints. Generally, the constraints require that the statically
                     known types of the actual arguments are acceptable given the declared
                     formal parameter types. We discuss the meaning of "acceptable"
                     below.
                  </p>
                  <p class="note">Given these initial constraints, one may derive a
                     set of supertype and/or equality constraints on the type parameters of
                     the method or constructor.
                  </p>
                  <p class="note">Next, one must try and find a solution that
                     satisfies the constraints on the type parameters. As a first
                     approximation, if a type parameter is constrained by an equality
                     constraint, then that constraint gives its solution. Bear in mind that
                     the constraint may equate one type parameter with another, and only
                     when the entire set of constraints on all type variables is resolved
                     will we have a solution.
                  </p>
                  <p class="note">A supertype constraint <span class="type">T</span> <code class="literal">:&gt;</code> <span class="type">X</span> implies
                     that the solution is one of supertypes of <span class="type">X</span>. Given several such
                     constraints on <span class="type">T</span>, we can intersect the sets of supertypes implied by
                     each of the constraints, since the type parameter must be a member of
                     all of them. We can then choose the most specific type that is in the
                     intersection.
                  </p>
                  <p class="note">Computing the intersection is more complicated than
                     one might first realize. Given that a type parameter is constrained to
                     be a supertype of two distinct invocations of a generic type,
                     say <code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>
                     and <code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>, the naive intersection
                     operation might yield <code class="literal">Object</code>. However, a more sophisticated analysis
                     yields a set containing <code class="literal">List<code class="literal">&lt;</code>?<code class="literal">&gt;</code></code>. Similarly,
                     if a type parameter <span class="type">T</span> is constrained to be a supertype of two
                     unrelated interfaces <span class="type">I</span> and <span class="type">J</span>, we might infer <span class="type">T</span> must be <code class="literal">Object</code>,
                     or we might obtain a tighter bound of <span class="type">I</span> &amp; <span class="type">J</span>. These issues are
                     discussed in more detail later in this section.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-110"></a>We use the following
                     notational conventions in this section:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-110-A"></a>Type expressions
                                    are represented using the letters <span class="type">A</span>, <span class="type">F</span>, <span class="type">U</span>, <span class="type">V</span>, and
                                    <span class="type">W</span>. The letter <span class="type">A</span> is only used to denote the type of an actual
                                    argument, and <span class="type">F</span> is only used to denote the type of a formal
                                    parameter.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-110-B"></a>Type parameters are
                                    represented using the letters <span class="type">S</span> and <span class="type">T</span></p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-110-C"></a>Arguments to
                                    parameterized types are represented using the letters <span class="type">X</span> and
                                    <span class="type">Y</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-110-D"></a>Generic type
                                    declarations are represented using the letters <span class="type">G</span> and
                                    <span class="type">H</span>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.7-200"></a>Inference begins with a
                     set of initial constraints of the form <span class="type">A</span> &lt;&lt; <span class="type">F</span>, <span class="type">A</span> = <span class="type">F</span>, or
                     <span class="type">A</span> &gt;&gt; <span class="type">F</span>, where <span class="type">U</span> &lt;&lt; <span class="type">V</span> indicates that type <span class="type">U</span> is
                     convertible to type <span class="type">V</span> by method invocation conversion
                     (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Method Invocation Conversion">&sect;5.3</a>), and <span class="type">U</span> &gt;&gt; <span class="type">V</span> indicates that type
                     <span class="type">V</span> is convertible to type <span class="type">U</span> by method invocation conversion.
                  </p>
                  <p class="note">In a simpler world, the constraints could be of the
                     form <span class="type">A</span> <code class="literal">&lt;:</code> <span class="type">F</span> - simply requiring that the actual argument
                     types be subtypes of the formal ones. However, reality is more
                     involved. As discussed earlier, method applicability testing consists
                     of up to three phases; this is required for compatibility
                     reasons. Each phase imposes slightly different constraints. If a
                     method is applicable by subtyping (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Subtyping">&sect;15.12.2.2</a>),
                     the constraints are indeed subtyping constraints. If a method is
                     applicable by method invocation conversion
                     (<a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion">&sect;15.12.2.3</a>), the constraints imply that the
                     actual type is convertible to the formal type by method invocation
                     conversion. The situation is similar for the third phase
                     (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Applicable Variable Arity Methods">&sect;15.12.2.4</a>), but the exact form of the
                     constraints differ due to the variable arity.
                  </p>
                  <p class="note">It is worth noting that a constraint of the form <span class="type">A</span>
                     = <span class="type">F</span> is never part of the initial constraints. However, it can arise
                     as the algorithm recurses. We see this occur in the running example
                     below, when the constraint <span class="type">A</span> &lt;&lt; <span class="type">F</span> relates two parameterized
                     types, as in <span class="type">G</span><code class="literal">&lt;</code><span class="type">V</span><code class="literal">&gt;</code> &lt;&lt; <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code>.
                  </p>
                  <p class="note">A constraint of the form <span class="type">A</span> &gt;&gt; <span class="type">F</span> also
                     arises when the algorithm recurses, due to the contravariant subtyping
                     rules associated with lower-bounded wildcards (those of the form
                     <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code> <span class="type">X</span><code class="literal">&gt;</code>).
                  </p>
                  <p class="note">It might be tempting to consider <span class="type">A</span> &gt;&gt; <span class="type">F</span> as
                     being the same as <span class="type">F</span> &lt;&lt; <span class="type">A</span>, but the problem of inference is
                     not symmetric. We need to remember which participant in the relation
                     includes a type to be inferred.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-210"></a>These constraints are
                     then reduced to a set of simpler constraints of the forms <span class="type">T</span>
                     <code class="literal">:&gt;</code> <span class="type">X</span>, <span class="type">T</span> = <span class="type">X</span>, or <span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">X</span>, where <span class="type">T</span> is a type
                     parameter of the method. This reduction is achieved by the procedure
                     given below.
                  </p>
                  <p class="note">It may be that the initial constraints are
                     unsatisfiable; we say that inference
                     is <span class="emphasis"><em>overconstrained</em></span>. In that case, we do not
                     necessarily derive unsatisfiable constraints on the type
                     parameters. Instead, we may infer type arguments for the invocation,
                     but once we substitute the type arguments for the type parameters, the
                     applicability test may fail because the actual argument types are not
                     acceptable given the substituted formal parameter types.
                  </p>
                  <p class="note">An alternative strategy would be to have type
                     inference itself fail in such cases. A Java compiler may choose to do
                     so, provided the effect is equivalent to that specified here.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-300"></a>Given a constraint of the
                     form <span class="type">A</span> &lt;&lt; <span class="type">F</span>, <span class="type">A</span> = <span class="type">F</span>, or <span class="type">A</span> &gt;&gt; <span class="type">F</span>:
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-310"></a>If <span class="type">F</span> does not involve a
                     type parameter <span class="type">T<sub>j</sub></span> then no constraint is implied on <span class="type">T<sub>j</sub></span>.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-320"></a>Otherwise, <span class="type">F</span> involves a
                     type parameter <span class="type">T<sub>j</sub></span>, and there are four cases to consider.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-330"></a>1. If <span class="type">A</span> is the type of
                     <code class="literal">null</code>, no constraint is implied on <span class="type">T<sub>j</sub></span>.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-340"></a>2. Otherwise, if the
                     constraint has the form <span class="type">A</span> &lt;&lt; <span class="type">F</span>:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-340-A"></a>If <span class="type">A</span> is a
                                  primitive type, then <span class="type">A</span> is converted to a reference type <span class="type">U</span> via
                                  boxing conversion and this algorithm is applied recursively to the
                                  constraint <span class="type">U</span> &lt;&lt; <span class="type">F</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-340-B"></a>Otherwise, if <span class="type">F</span> =
                                  <span class="type">T<sub>j</sub></span>, then the constraint <span class="type">T<sub>j</sub></span> <code class="literal">:&gt;</code> <span class="type">A</span> is implied.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-340-C"></a>If <span class="type">F</span> =
                                  <span class="type">U</span><code class="literal">[]</code>, where the type <span class="type">U</span> involves <span class="type">T<sub>j</sub></span>, then if <span class="type">A</span> is an
                                  array type <span class="type">V</span><code class="literal">[]</code>, or a type variable with an upper bound
                                  that is an array type <span class="type">V</span><code class="literal">[]</code>, where <span class="type">V</span> is a reference
                                  type, this algorithm is applied recursively to the constraint <span class="type">V</span>
                                  &lt;&lt; <span class="type">U</span>.
                           </p>
                           <p class="note">This follows from the covariant subtype relation
                                  among array types. The constraint <span class="type">A</span> &lt;&lt; <span class="type">F</span> in this case
                                  means that <span class="type">A</span> &lt;&lt; <span class="type">U</span><code class="literal">[]</code>. <span class="type">A</span> is therefore
                                  necessarily an array type <span class="type">V</span><code class="literal">[]</code>, or a type variable whose
                                  upper bound is an array type <span class="type">V</span><code class="literal">[]</code> - otherwise the
                                  relation <span class="type">A</span> &lt;&lt; <span class="type">U</span><code class="literal">[]</code> could never hold true. It
                                  follows that <span class="type">V</span><code class="literal">[]</code> &lt;&lt; <span class="type">U</span><code class="literal">[]</code>. Since array
                                  subtyping is covariant, it must be the case that <span class="type">V</span> &lt;&lt;
                                  <span class="type">U</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-340-D"></a>If <span class="type">F</span> has the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">Y<sub>k-1</sub></span>, <span class="type">U</span>, <span class="type">Y<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>, where <span class="type">U</span> is
                                  a type expression that involves <span class="type">T<sub>j</sub></span>, then if <span class="type">A</span> has a supertype
                                  of the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <span class="type">V</span>, <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>
                                  where <span class="type">V</span> is a type expression, this algorithm is applied
                                  recursively to the constraint <span class="type">V</span> = <span class="type">U</span>.
                           </p>
                           <p class="note">For simplicity, assume that <span class="type">G</span> takes a single
                                  type argument. If the method invocation being examined is to be
                                  applicable, it must be the case that <span class="type">A</span> is a subtype of some
                                  invocation of <span class="type">G</span>. Otherwise, <span class="type">A</span> &lt;&lt; <span class="type">F</span> would never be
                                  true.
                           </p>
                           <p class="note">In other words, <span class="type">A</span> &lt;&lt; <span class="type">F</span>, where <span class="type">F</span> =
                                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code>, implies that <span class="type">A</span> &lt;&lt;
                                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">V</span><code class="literal">&gt;</code> for some <span class="type">V</span>. Now, since <span class="type">U</span> is a type
                                  expression (and therefore, <span class="type">U</span> is not a wildcard type argument),
                                  it must be the case that <span class="type">U</span> = <span class="type">V</span>, by the non-variance of
                                  ordinary parameterized type invocations.
                           </p>
                           <p class="note">The formulation above merely generalizes this
                                  reasoning to generics with an arbitrary number of type
                                  arguments.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-340-E"></a>If <span class="type">F</span> has the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">Y<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span>, <span class="type">Y<sub>k+1</sub></span>,
                                  ...<code class="literal">&gt;</code>, where <span class="type">U</span> involves <span class="type">T<sub>j</sub></span>, then if <span class="type">A</span> has a supertype
                                  that is one of:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-340-E-1"></a><span class="type">G</span><code class="literal">&lt;</code>...,
                                       	<span class="type">X<sub>k-1</sub></span>, <span class="type">V</span>, <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>, where <span class="type">V</span> is a type
                                       	expression. Then this algorithm is applied recursively to the
                                       	constraint <span class="type">V</span> &lt;&lt; <span class="type">U</span>.
                                    </p>
                                    <p class="note">Again, let's keep things as simple as
                                       	possible, and consider only the case where <span class="type">G</span> has a single
                                       	type argument.
                                    </p>
                                    <p class="note"><span class="type">A</span> &lt;&lt; <span class="type">F</span> in this case means <span class="type">A</span>
                                       	&lt;&lt; <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span><code class="literal">&gt;</code>. As above, it
                                       	must be the case that <span class="type">A</span> is a subtype of some invocation of
                                       	<span class="type">G</span>. However, <span class="type">A</span> may now be a subtype of either
                                       	<span class="type">G</span><code class="literal">&lt;</code><span class="type">V</span><code class="literal">&gt;</code>, or <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code>
                                       	<span class="type">V</span><code class="literal">&gt;</code>, or <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code> <span class="type">V</span><code class="literal">&gt;</code>. We
                                       	examine these cases in turn. The first variation is described
                                       	(generalized to multiple arguments) by the sub-bullet directly
                                       	above. We therefore have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><span class="type">V</span><code class="literal">&gt;</code> &lt;&lt;
                                       	<span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span><code class="literal">&gt;</code>. The rules of
                                       	subtyping for wildcards imply that <span class="type">V</span> &lt;&lt; <span class="type">U</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-340-E-2"></a><span class="type">G</span><code class="literal">&lt;</code>...,
                                       	<span class="type">X<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">extends</code> <span class="type">V</span>, <span class="type">X<sub>k+1</sub></span>,
                                       	...<code class="literal">&gt;</code>. Then this algorithm is applied recursively to the
                                       	constraint <span class="type">V</span> &lt;&lt; <span class="type">U</span>.
                                    </p>
                                    <p class="note">Extending the analysis above, we have <span class="type">A</span> =
                                       	<span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">V</span><code class="literal">&gt;</code> &lt;&lt;
                                       	<span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span><code class="literal">&gt;</code>. The rules of
                                       	subtyping for wildcards again imply that <span class="type">V</span> &lt;&lt;
                                       	<span class="type">U</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-340-E-3"></a>Otherwise, no
                                       	constraint is implied on <span class="type">T<sub>j</sub></span>.
                                    </p>
                                    <p class="note">Here, we have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code>
                                       	<code class="literal">super</code> <span class="type">V</span><code class="literal">&gt;</code> &lt;&lt; <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code>
                                       	<span class="type">U</span><code class="literal">&gt;</code>. In general, we cannot conclude anything in this
                                       	case. However, it is not necessarily an error. It may be that
                                       	<span class="type">U</span> will eventually be inferred to be <code class="literal">Object</code>, in which case
                                       	the call may indeed be valid. Therefore, we simply refrain
                                       	from placing any constraint on <span class="type">U</span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-340-F"></a>If <span class="type">F</span> has the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">Y<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">U</span>, <span class="type">Y<sub>k+1</sub></span>,
                                  ...<code class="literal">&gt;</code>, where <span class="type">U</span> involves <span class="type">T<sub>j</sub></span>, then if <span class="type">A</span> has a supertype
                                  that is one of:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-340-F-1"></a><span class="type">G</span><code class="literal">&lt;</code>...,
                                       	<span class="type">X<sub>k-1</sub></span>, <span class="type">V</span>, <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>. Then this algorithm is
                                       	applied recursively to the constraint <span class="type">V</span> &gt;&gt; <span class="type">U</span>.
                                    </p>
                                    <p class="note">As usual, we consider only the case where
                                       	<span class="type">G</span> has a single type argument.
                                    </p>
                                    <p class="note"><span class="type">A</span> &lt;&lt; <span class="type">F</span> in this case means <span class="type">A</span>
                                       	&lt;&lt; <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code> <span class="type">U</span><code class="literal">&gt;</code>. As above, it
                                       	must be the case that <span class="type">A</span> is a subtype of some invocation of
                                       	<span class="type">G</span>. <span class="type">A</span> may now be a subtype of either
                                       	<span class="type">G</span><code class="literal">&lt;</code><span class="type">V</span><code class="literal">&gt;</code>, or <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code>
                                       	<span class="type">V</span><code class="literal">&gt;</code>, or <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code> <span class="type">V</span><code class="literal">&gt;</code>. We
                                       	examine these cases in turn. The first variation is described
                                       	(generalized to multiple arguments) by the sub-bullet directly
                                       	above. We therefore have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><span class="type">V</span><code class="literal">&gt;</code> &lt;&lt;
                                       	<span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code> <span class="type">U</span><code class="literal">&gt;</code>. The rules of subtyping
                                       	for wildcards imply that <span class="type">V</span> &gt;&gt; <span class="type">U</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-340-F-2"></a><span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <code class="literal">?</code>
                                       	<code class="literal">super</code> <span class="type">V</span>, <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>. Then this algorithm is
                                       	applied recursively to the constraint <span class="type">V</span> &gt;&gt; <span class="type">U</span>.
                                    </p>
                                    <p class="note">We have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code>
                                       	<span class="type">V</span><code class="literal">&gt;</code> &lt;&lt; <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code>
                                       	<span class="type">U</span><code class="literal">&gt;</code>. The rules of subtyping for lower-bounded
                                       	wildcards again imply that <span class="type">V</span> &gt;&gt; <span class="type">U</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-340-F-3"></a>Otherwise, no
                                       	constraint is implied on <span class="type">T<sub>j</sub></span>.
                                    </p>
                                    <p class="note">Here, we have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code>
                                       	<code class="literal">extends</code> <span class="type">V</span><code class="literal">&gt;</code> &lt;&lt; <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code>
                                       	<span class="type">U</span><code class="literal">&gt;</code>. In general, we cannot conclude anything in this
                                       	case. However, it is not necessarily an error. It may be that
                                       	<span class="type">U</span> will eventually be inferred to the null type, in which
                                       	case the call may indeed be valid. Therefore, we simply
                                       	refrain from placing any constraint on <span class="type">U</span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-340-G"></a>Otherwise, no
                                  constraint is implied on <span class="type">T<sub>j</sub></span>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.7-350"></a>3. Otherwise, if the
                     constraint has the form <span class="type">A</span> = <span class="type">F</span>:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-350-A"></a>If <span class="type">F</span> = <span class="type">T<sub>j</sub></span>, then
                                  the constraint <span class="type">T<sub>j</sub></span> = <span class="type">A</span> is implied.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-350-B"></a>If <span class="type">F</span> =
                                  <span class="type">U</span><code class="literal">[]</code> where the type <span class="type">U</span> involves <span class="type">T<sub>j</sub></span>, then if <span class="type">A</span> is an
                                  array type <span class="type">V</span><code class="literal">[]</code>, or a type variable with an upper bound
                                  that is an array type <span class="type">V</span><code class="literal">[]</code>, where <span class="type">V</span> is a reference
                                  type, this algorithm is applied recursively to the constraint <span class="type">V</span>
                                  = <span class="type">U</span>.
                           </p>
                           <p class="note">If the array types <span class="type">U</span><code class="literal">[]</code> and
                                  <span class="type">V</span><code class="literal">[]</code> are the same, their component types must be the
                                  same.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-350-C"></a>If <span class="type">F</span> has the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">Y<sub>k-1</sub></span>, <span class="type">U</span>, <span class="type">Y<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>, where <span class="type">U</span> is
                                  type expression that involves <span class="type">T<sub>j</sub></span>, then if <span class="type">A</span> is of the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <span class="type">V</span>, <span class="type">X<sub>k+1</sub></span>,...<code class="literal">&gt;</code> where <span class="type">V</span> is a
                                  type expression, this algorithm is applied recursively to the
                                  constraint <span class="type">V</span> = <span class="type">U</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-350-D"></a>If <span class="type">F</span> has the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">Y<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span>, <span class="type">Y<sub>k+1</sub></span>,
                                  ...<code class="literal">&gt;</code>, where <span class="type">U</span> involves <span class="type">T<sub>j</sub></span>, then if <span class="type">A</span> is one
                                  of:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-350-D-1"></a><span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <code class="literal">?</code>
                                       	<code class="literal">extends</code> <span class="type">V</span>, <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>. Then this algorithm is
                                       	applied recursively to the constraint <span class="type">V</span> = <span class="type">U</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-350-D-2"></a>Otherwise, no
                                       	constraint is implied on <span class="type">T<sub>j</sub></span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-350-E"></a>If <span class="type">F</span> has the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">Y<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">U</span>, <span class="type">Y<sub>k+1</sub></span>
                                  ,...<code class="literal">&gt;</code>, where <span class="type">U</span> involves <span class="type">T<sub>j</sub></span>, then if <span class="type">A</span> is one
                                  of:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-350-E-1"></a><span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <code class="literal">?</code>
                                       	<code class="literal">super</code> <span class="type">V</span>, <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>. Then this algorithm is
                                       	applied recursively to the constraint <span class="type">V</span> = <span class="type">U</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-350-E-2"></a>Otherwise, no
                                       	constraint is implied on <span class="type">T<sub>j</sub></span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-350-F"></a>Otherwise, no
                                  constraint is implied on <span class="type">T<sub>j</sub></span>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.7-360"></a>4. Otherwise, if the
                     constraint has the form <span class="type">A</span> &gt;&gt; <span class="type">F</span>:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-360-A"></a>If <span class="type">F</span> = <span class="type">T<sub>j</sub></span>, then
                                  the constraint <span class="type">T<sub>j</sub></span> <code class="literal">&lt;:</code> <span class="type">A</span> is implied.
                           </p>
                           <p class="note">We do not make use of such constraints in the
                                  main body of the inference algorithm. However, they are used in
                                  <a class="xref" href="jls-15.html#jls-15.12.2.8" title="15.12.2.8.&nbsp;Inferring Unresolved Type Arguments">&sect;15.12.2.8</a>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-360-B"></a>If <span class="type">F</span> =
                                  <span class="type">U</span><code class="literal">[]</code>, where the type <span class="type">U</span> involves <span class="type">T<sub>j</sub></span>, then if <span class="type">A</span> is an
                                  array type <span class="type">V</span><code class="literal">[]</code>, or a type variable with an upper bound
                                  that is an array type <span class="type">V</span><code class="literal">[]</code>, where <span class="type">V</span> is a reference
                                  type, this algorithm is applied recursively to the constraint <span class="type">V</span>
                                  &gt;&gt; <span class="type">U</span>. Otherwise, no constraint is implied on <span class="type">T<sub>j</sub></span>.
                           </p>
                           <p class="note">This follows from the covariant subtype relation
                                  among array types. The constraint <span class="type">A</span> &gt;&gt; <span class="type">F</span> in this case
                                  means that <span class="type">A</span> &gt;&gt; <span class="type">U</span><code class="literal">[]</code>. <span class="type">A</span> is therefore
                                  necessarily an array type <span class="type">V</span><code class="literal">[]</code>, or a type variable whose
                                  upper bound is an array type <span class="type">V</span><code class="literal">[]</code> - otherwise the
                                  relation <span class="type">A</span> &gt;&gt; <span class="type">U</span><code class="literal">[]</code> could never hold true. It
                                  follows that <span class="type">V</span><code class="literal">[]</code> &gt;&gt; <span class="type">U</span><code class="literal">[]</code>. Since array
                                  subtyping is covariant, it must be the case that <span class="type">V</span> &gt;&gt;
                                  <span class="type">U</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-360-C"></a>If <span class="type">F</span> has the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">Y<sub>k-1</sub></span>, <span class="type">U</span>, <span class="type">Y<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>, where <span class="type">U</span> is a type
                                  expression that involves <span class="type">T<sub>j</sub></span>, then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-360-C-1"></a>If <span class="type">A</span> is an
                                       	instance of a non-generic type, then no constraint is implied
                                       	on <span class="type">T<sub>j</sub></span>.
                                    </p>
                                    <p class="note">In this case (once again restricting the
                                       	analysis to the unary case), we have the constraint <span class="type">A</span>
                                       	&gt;&gt; <span class="type">F</span> = <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code>. <span class="type">A</span> must be a supertype of the
                                       	generic type <span class="type">G</span>. However, since <span class="type">A</span> is not a parameterized
                                       	type, it cannot depend upon the type argument <span class="type">U</span> in any
                                       	way. It is a supertype of <span class="type">G</span><code class="literal">&lt;</code><span class="type">X</span><code class="literal">&gt;</code> for every <span class="type">X</span> that is
                                       	a valid type argument to <span class="type">G</span>. No meaningful constraint on <span class="type">U</span>
                                       	can be derived from <span class="type">A</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-360-C-2"></a>If <span class="type">A</span> is an
                                       	invocation of a generic type declaration <span class="type">H</span>, where <span class="type">H</span> is
                                       	either <span class="type">G</span> or superclass or superinterface of <span class="type">G</span>,
                                       	then:
                                    </p>
                                    <div class="norm">
                                       <ul class="norm" type="square">
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-C-2-1"></a>If <span class="type">H</span>
                                                	    &#8800; <span class="type">G</span>, then let <span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>n</sub></span> be the type parameters
                                                	    of <span class="type">G</span>, and let <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>l</sub></span><code class="literal">&gt;</code> be the unique
                                                	    invocation of <span class="type">H</span> that is a supertype of <span class="type">G</span><code class="literal">&lt;</code><span class="type">S<sub>1</sub></span>, ...,
                                                	    <span class="type">S<sub>n</sub></span><code class="literal">&gt;</code>, and let <span class="type">V</span> = <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>, ...,
                                                	    <span class="type">U<sub>l</sub></span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S<sub>k</sub></span>=<span class="type">U</span><code class="literal">]</code>. Then, if <span class="type">V</span> <code class="literal">:&gt;</code>
                                                	    <span class="type">F</span> this algorithm is applied recursively to the
                                                	    constraint <span class="type">A</span> &gt;&gt; <span class="type">V</span>.
                                             </p>
                                             <p class="note">Our goal here is to simplify the
                                                	    relationship between <span class="type">A</span> and <span class="type">F</span>. We aim to recursively
                                                	    invoke the algorithm on a simpler case, where the type
                                                	    argument is known to be an invocation of the same generic
                                                	    type declaration as the formal.
                                             </p>
                                             <p class="note">Let's consider the case where both <span class="type">H</span>
                                                	    and <span class="type">G</span> have only a single type argument. Since we have
                                                	    the constraint <span class="type">A</span> = <span class="type">H</span><code class="literal">&lt;</code><span class="type">X</span><code class="literal">&gt;</code> &gt;&gt; <span class="type">F</span> =
                                                	    <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code>, where <span class="type">H</span> is distinct from <span class="type">G</span>, it must be
                                                	    the case that <span class="type">H</span> is some proper superclass or
                                                	    superinterface of <span class="type">G</span>. There must be a (non-wildcard)
                                                	    invocation of <span class="type">H</span> that is a supertype of <span class="type">F</span> =
                                                	    <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code>. Call this invocation <span class="type">V</span>.
                                             </p>
                                             <p class="note">If we replace <span class="type">F</span> by <span class="type">V</span> in the
                                                	    constraint, we will have accomplished the goal of relating
                                                	    two invocations of the same generic (as it happens,
                                                	    <span class="type">H</span>).
                                             </p>
                                             <p class="note">How do we compute <span class="type">V</span>? The declaration
                                                	    of <span class="type">G</span> must introduce a type parameter <span class="type">S</span>, and there must
                                                	    be some (non-wildcard) invocation of <span class="type">H</span>, <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span><code class="literal">&gt;</code>,
                                                	    that is a supertype of <span class="type">G</span><code class="literal">&lt;</code><span class="type">S</span><code class="literal">&gt;</code>. Substituting the
                                                	    type expression <span class="type">U</span> for <span class="type">S</span> will then yield a
                                                	    (non-wildcard) invocation of <span class="type">H</span>,
                                                	    <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S</span>=<span class="type">U</span><code class="literal">]</code>,
                                                	    that is a supertype of <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code>. For example, in the
                                                	    simplest instance, <span class="type">U<sub>1</sub></span> might be <span class="type">S</span>, in which case we
                                                	    have <span class="type">G</span><code class="literal">&lt;</code><span class="type">S</span><code class="literal">&gt;</code> <code class="literal">&lt;:</code> <span class="type">H</span><code class="literal">&lt;</code><span class="type">S</span><code class="literal">&gt;</code>, and
                                                	    <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code> <code class="literal">&lt;:</code> <span class="type">H</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code> =
                                                	    <span class="type">H</span><code class="literal">&lt;</code><span class="type">S</span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S</span>=<span class="type">U</span><code class="literal">]</code>
                                                	    = <span class="type">V</span>.
                                             </p>
                                             <p class="note">It may be the case that <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span><code class="literal">&gt;</code>
                                                	    is independent of <span class="type">S</span> - that is, <span class="type">S</span> does not occur in
                                                	    <span class="type">U<sub>1</sub></span> at all. However, the substitution described above is
                                                	    still valid - in this situation, <span class="type">V</span> =
                                                	    <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S</span>=<span class="type">U</span><code class="literal">]</code>
                                                	    = <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span><code class="literal">&gt;</code>. Furthermore, in this circumstance,
                                                	    <span class="type">G</span><code class="literal">&lt;</code><span class="type">T</span><code class="literal">&gt;</code> <code class="literal">&lt;:</code> <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span><code class="literal">&gt;</code> for any <span class="type">T</span>, and
                                                	    in particular <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code> <code class="literal">&lt;:</code> <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span><code class="literal">&gt;</code> =
                                                	    <span class="type">V</span>.
                                             </p>
                                             <p class="note">Regardless of whether <span class="type">U<sub>1</sub></span> depends on
                                                	    <span class="type">S</span>, we have determined the type <span class="type">V</span>, the invocation of
                                                	    <span class="type">H</span> that is a supertype of <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code>. We can now
                                                	    invoke the algorithm recursively on the constraint
                                                	    <span class="type">H</span><code class="literal">&lt;</code><span class="type">X</span><code class="literal">&gt;</code> = <span class="type">A</span> &gt;&gt; <span class="type">V</span> =
                                                	    <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S</span>=<span class="type">U</span><code class="literal">]</code>. We
                                                	    will then be able to relate the type arguments of both
                                                	    invocations of <span class="type">H</span> and extract the relevant constraints
                                                	    from them.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-C-2-2"></a>Otherwise, if <span class="type">A</span> is of
                                                	    the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <span class="type">W</span>, <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>,
                                                	    where <span class="type">W</span> is a type expression, this algorithm is applied
                                                	    recursively to the constraint <span class="type">W</span> = <span class="type">U</span>.
                                             </p>
                                             <p class="note">We have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><span class="type">W</span><code class="literal">&gt;</code> &gt;&gt;
                                                	    <span class="type">F</span> = <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code> for some type expression <span class="type">W</span>. Since
                                                	    <span class="type">W</span> is a type expression (and not a wildcard type
                                                	    argument), it must be the case that <span class="type">W</span> = <span class="type">U</span>, by the
                                                	    invariance of parameterized types.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-C-2-3"></a>Otherwise, if <span class="type">A</span> is of
                                                	    the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">extends</code>
                                                	    <span class="type">W</span>, <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>, this algorithm is applied
                                                	    recursively to the constraint <span class="type">W</span> &gt;&gt; <span class="type">U</span>. 
                                             </p>
                                             <p class="note">We have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code>
                                                	    <code class="literal">extends</code> <span class="type">W</span><code class="literal">&gt;</code> &gt;&gt; <span class="type">F</span> =
                                                	    <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code> for some type expression <span class="type">W</span>. It
                                                	    must be the case that <span class="type">W</span> &gt;&gt; <span class="type">U</span>, by the subtyping
                                                	    rules for wildcard types.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-C-2-4"></a>Otherwise, if <span class="type">A</span> is of
                                                	    the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">W</span>,
                                                	    <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>, this algorithm is applied
                                                	    recursively to the constraint <span class="type">W</span> &lt;&lt; <span class="type">U</span>.
                                             </p>
                                             <p class="note">We have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code>
                                                	    <span class="type">W</span><code class="literal">&gt;</code> &gt;&gt; <span class="type">F</span> = <span class="type">G</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code> for some
                                                	    type expression <span class="type">W</span>. It must be the case that <span class="type">W</span> &lt;&lt;
                                                	    <span class="type">U</span>, by the subtyping rules for wildcard types.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-C-2-5"></a>Otherwise, no constraint
                                                	    is implied on <span class="type">T<sub>j</sub></span>.
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-360-D"></a>If <span class="type">F</span> has the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">Y<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span>, <span class="type">Y<sub>k+1</sub></span>,
                                  ...<code class="literal">&gt;</code>, where <span class="type">U</span> is a type expression that involves <span class="type">T<sub>j</sub></span>,
                                  then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-360-D-1"></a>If <span class="type">A</span> is an
                                       	instance of a non-generic type, then no constraint is implied
                                       	on <span class="type">T<sub>j</sub></span>.
                                    </p>
                                    <p class="note">Once again restricting the analysis to the
                                       	unary case, we have the constraint <span class="type">A</span> &gt;&gt; <span class="type">F</span> =
                                       	<span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span><code class="literal">&gt;</code>. <span class="type">A</span> must be a
                                       	supertype of the generic type <span class="type">G</span>. However, since <span class="type">A</span> is not a
                                       	parameterized type, it cannot depend upon <span class="type">U</span> in any way. It
                                       	is a supertype of the type <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code>
                                       	<span class="type">X</span><code class="literal">&gt;</code> for every <span class="type">X</span> such that <code class="literal">?</code> <code class="literal">extends</code>
                                       	<span class="type">X</span> is a valid type argument to <span class="type">G</span>. No meaningful constraint
                                       	on <span class="type">U</span> can be derived from <span class="type">A</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-360-D-2"></a>If <span class="type">A</span> is an
                                       	invocation of a generic type declaration <span class="type">H</span>, where <span class="type">H</span> is
                                       	either <span class="type">G</span> or superclass or superinterface of <span class="type">G</span>,
                                       	then:
                                    </p>
                                    <div class="norm">
                                       <ul class="norm" type="square">
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-D-2-1"></a>If <span class="type">H</span>
                                                	    &#8800; <span class="type">G</span>, then let <span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>n</sub></span> be the type parameters
                                                	    of <span class="type">G</span>, and let <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>l</sub></span><code class="literal">&gt;</code> be the unique
                                                	    invocation of <span class="type">H</span> that is a supertype of <span class="type">G</span><code class="literal">&lt;</code><span class="type">S<sub>1</sub></span>, ...,
                                                	    <span class="type">S<sub>n</sub></span><code class="literal">&gt;</code>, and let <span class="type">V</span> = <span class="type">H</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">U<sub>1</sub></span>, ..., <code class="literal">?</code> <code class="literal">extends</code>
                                                	    <span class="type">U<sub>l</sub></span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S<sub>k</sub></span>=<span class="type">U</span><code class="literal">]</code>. Then this algorithm is
                                                	    applied recursively to the constraint <span class="type">A</span> &gt;&gt;
                                                	    <span class="type">V</span>.
                                             </p>
                                             <p class="note">Our goal here is once more to simplify
                                                	    the relationship between <span class="type">A</span> and <span class="type">F</span>, and recursively
                                                	    invoke the algorithm on a simpler case, where the type
                                                	    argument is known to be an invocation of the same generic
                                                	    type as the formal.
                                             </p>
                                             <p class="note">Assume both <span class="type">H</span> and <span class="type">G</span> have only a
                                                	    single type argument. Since we have the constraint <span class="type">A</span> =
                                                	    <span class="type">H</span><code class="literal">&lt;</code><span class="type">X</span><code class="literal">&gt;</code> &gt;&gt; <span class="type">F</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code>
                                                	    <code class="literal">extends</code> <span class="type">U</span><code class="literal">&gt;</code>, where <span class="type">H</span> is distinct from <span class="type">G</span>, it
                                                	    must be the case that <span class="type">H</span> is some proper superclass or
                                                	    superinterface of <span class="type">G</span>. There must be an invocation of
                                                	    <span class="type">H</span><code class="literal">&lt;</code><span class="type">Y</span><code class="literal">&gt;</code>, such that <span class="type">H</span><code class="literal">&lt;</code><span class="type">X</span><code class="literal">&gt;</code>
                                                	    &gt;&gt; <span class="type">H</span><code class="literal">&lt;</code><span class="type">Y</span><code class="literal">&gt;</code>, that we can use instead
                                                	    of <span class="type">F</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span><code class="literal">&gt;</code>.
                                             </p>
                                             <p class="note">How do we compute
                                                	    <span class="type">H</span><code class="literal">&lt;</code><span class="type">Y</span><code class="literal">&gt;</code>? As before, note that the
                                                	    declaration of <span class="type">G</span> must introduce a type parameter <span class="type">S</span>,
                                                	    and there must be some (non-wildcard) invocation of <span class="type">H</span>,
                                                	    <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span><code class="literal">&gt;</code>, that is a supertype of
                                                	    <span class="type">G</span><code class="literal">&lt;</code><span class="type">S</span><code class="literal">&gt;</code>. However, substituting <code class="literal">?</code>
                                                	    <code class="literal">extends</code> <span class="type">U</span> for <span class="type">S</span> is not generally valid. To see this,
                                                	    assume <span class="type">U<sub>1</sub></span> = <span class="type">T</span><code class="literal">[]</code>.
                                             </p>
                                             <p class="note">Instead, we produce an invocation of
                                                	    <span class="type">H</span>, <span class="type">H</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code>
                                                	    <span class="type">U<sub>1</sub></span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S</span>=<span class="type">U</span><code class="literal">]</code>. In the simplest
                                                	    instance, <span class="type">U<sub>1</sub></span> might be <span class="type">S</span>, in which case we have
                                                	    <span class="type">G</span><code class="literal">&lt;</code><span class="type">S</span><code class="literal">&gt;</code> <code class="literal">&lt;:</code> <span class="type">H</span><code class="literal">&lt;</code><span class="type">S</span><code class="literal">&gt;</code>,
                                                	    and <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span><code class="literal">&gt;</code> <code class="literal">&lt;:</code>
                                                	    <span class="type">H</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span><code class="literal">&gt;</code> =
                                                	    <span class="type">H</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code>
                                                	    <span class="type">S</span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S</span>=<span class="type">U</span><code class="literal">]</code> = <span class="type">V</span>.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-D-2-2"></a>Otherwise, if <span class="type">A</span> is of
                                                	    the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">extends</code>
                                                	    <span class="type">W</span>, <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>, this algorithm is applied
                                                	    recursively to the constraint <span class="type">W</span> &gt;&gt; <span class="type">U</span>.
                                             </p>
                                             <p class="note">We have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code>
                                                	    <code class="literal">extends</code> <span class="type">W</span><code class="literal">&gt;</code> &gt;&gt; <span class="type">F</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code>
                                                	    <code class="literal">extends</code> <span class="type">U</span><code class="literal">&gt;</code> for some type expression <span class="type">W</span>. By the
                                                	    subtyping rules for wildcards it must be the case that <span class="type">W</span>
                                                	    &gt;&gt; <span class="type">U</span>.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-D-2-3"></a>Otherwise, no constraint
                                                	    is implied on <span class="type">T<sub>j</sub></span>.
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-360-E"></a>If <span class="type">F</span> has the form
                                  <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">Y<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">U</span>, <span class="type">Y<sub>k+1</sub></span>,
                                  ...<code class="literal">&gt;</code>, where <span class="type">U</span> is a type expression that involves <span class="type">T<sub>j</sub></span>,
                                  then <span class="type">A</span> is either:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-360-E-1"></a>If <span class="type">A</span> is an
                                       	instance of a non-generic type, then no constraint is implied
                                       	on <span class="type">T<sub>j</sub></span>.
                                    </p>
                                    <p class="note">Restricting the analysis to the unary case,
                                       	we have the constraint <span class="type">A</span> &gt;&gt; <span class="type">F</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code>
                                       	<code class="literal">super</code> <span class="type">U</span><code class="literal">&gt;</code>. <span class="type">A</span> must be a supertype of the generic
                                       	type <span class="type">G</span>. However, since <span class="type">A</span> is not a parameterized type, it
                                       	cannot depend upon <span class="type">U</span> in any way. It is a supertype of the
                                       	type <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code> <span class="type">X</span><code class="literal">&gt;</code> for every <span class="type">X</span> such
                                       	that <code class="literal">?</code> <code class="literal">super</code> <span class="type">X</span> is a valid type argument to <span class="type">G</span>. No
                                       	meaningful constraint on <span class="type">U</span> can be derived from <span class="type">A</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.7-360-E-2"></a>If <span class="type">A</span> is an
                                       	invocation of a generic type declaration <span class="type">H</span>, where <span class="type">H</span> is
                                       	either <span class="type">G</span> or superclass or superinterface of <span class="type">G</span>,
                                       	then:
                                    </p>
                                    <div class="norm">
                                       <ul class="norm" type="square">
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-E-2-1"></a>If <span class="type">H</span>
                                                	    &#8800; <span class="type">G</span>, then let <span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>n</sub></span> be the type parameters
                                                	    of <span class="type">G</span>, and let <span class="type">H</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>l</sub></span><code class="literal">&gt;</code> be the
                                                	    unique invocation of <span class="type">H</span> that is a supertype of
                                                	    <span class="type">G</span><code class="literal">&lt;</code><span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>n</sub></span><code class="literal">&gt;</code>, and let <span class="type">V</span> =
                                                	    <span class="type">H</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code> <span class="type">U<sub>1</sub></span>, ..., <code class="literal">?</code> <code class="literal">super</code>
                                                	    <span class="type">U<sub>l</sub></span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S<sub>k</sub></span>=<span class="type">U</span><code class="literal">]</code>. Then this algorithm
                                                	    is applied recursively to the constraint <span class="type">A</span> &gt;&gt;
                                                	    <span class="type">V</span>.
                                             </p>
                                             <p class="note">The treatment here is analogous to the
                                                	    case where <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code>
                                                	    <span class="type">U</span><code class="literal">&gt;</code>. Here our example would produce an invocation
                                                	    <span class="type">H</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code>
                                                	    <span class="type">U<sub>1</sub></span><code class="literal">&gt;</code><code class="literal">[</code><span class="type">S</span>=<span class="type">U</span><code class="literal">]</code>.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-E-2-2"></a>Otherwise, if <span class="type">A</span> is of
                                                	    the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="type">X<sub>k-1</sub></span>, <code class="literal">?</code> <code class="literal">super</code>
                                                	    <span class="type">W</span>, ..., <span class="type">X<sub>k+1</sub></span>, ...<code class="literal">&gt;</code>, this algorithm is applied
                                                	    recursively to the constraint <span class="type">W</span> &lt;&lt; <span class="type">U</span>.
                                             </p>
                                             <p class="note">We have <span class="type">A</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code>
                                                	    <span class="type">W</span><code class="literal">&gt;</code> &gt;&gt; <span class="type">F</span> = <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">super</code>
                                                	    <span class="type">U</span><code class="literal">&gt;</code> for some type expression <span class="type">W</span>. It must be the
                                                	    case that <span class="type">W</span> &lt;&lt; <span class="type">U</span>, by the subtyping rules for
                                                	    wildcard types.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.2.7-360-E-2-3"></a>Otherwise, no constraint
                                                	    is implied on <span class="type">T<sub>j</sub></span>.
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <p class="note">This concludes the process of determining
                     constraints on the type parameters of a method.
                  </p>
                  <p class="note">Note that this process does not impose any
                     constraints on the type parameters based on their declared
                     bounds. Once type arguments are inferred, they will be tested against
                     the declared bounds of the type parameters as part of applicability
                     testing.
                  </p>
                  <p class="note">Note also that type inference does not affect
                     soundness in any way. If the types inferred are nonsensical, the
                     invocation will yield a type error. The type inference algorithm
                     should be viewed as a heuristic, designed to perform well in
                     practice. If it fails to infer the desired result, explicit type
                     paramneters may be used instead.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-400"></a>Next, for each type
                     variable <span class="type">T<sub>j</sub></span> (1 &#8804; <span class="emphasis"><em>j</em></span> &#8804; <span class="emphasis"><em>n</em></span>), the implied equality
                     constraints are resolved as follows.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-410"></a>For each implied equality
                     constraint <span class="type">T<sub>j</sub></span> = <span class="type">U</span> or <span class="type">U</span> = <span class="type">T<sub>j</sub></span>:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-410-A"></a>If <span class="type">U</span> is not one
                                  of the type parameters of the method, then <span class="type">U</span> is the type
                                  inferred for <span class="type">T<sub>j</sub></span>. Then all remaining constraints involving <span class="type">T<sub>j</sub></span>
                                  are rewritten such that <span class="type">T<sub>j</sub></span> is replaced with <span class="type">U</span>. There are
                                  necessarily no further equality constraints involving <span class="type">T<sub>j</sub></span>, and
                                  processing continues with the next type parameter, if any.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-410-B"></a>Otherwise, if <span class="type">U</span>
                                  is <span class="type">T<sub>j</sub></span>, then this constraint carries no information and may be
                                  discarded.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-410-C"></a>Otherwise, the
                                  constraint is of the form <span class="type">T<sub>j</sub></span> = <span class="type">T<sub>k</sub></span> for <span class="emphasis"><em>j</em></span> &#8800;
                                  <span class="emphasis"><em>k</em></span>. Then all constraints involving <span class="type">T<sub>j</sub></span> are rewritten such
                                  that <span class="type">T<sub>j</sub></span> is replaced with <span class="type">T<sub>k</sub></span>, and processing continues with the
                                  next type variable.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.7-420"></a>Then, for each remaining
                     type variable <span class="type">T<sub>j</sub></span>, the constraints <span class="type">T<sub>j</sub></span> <code class="literal">:&gt;</code> <span class="type">U</span> are
                     considered. Given that these constraints are <span class="type">T<sub>j</sub></span> <code class="literal">:&gt;</code> <span class="type">U<sub>1</sub></span>
                     ... <span class="type">T<sub>j</sub></span> <code class="literal">:&gt;</code> <span class="type">U<sub>k</sub></span>, the type of <span class="type">T<sub>j</sub></span> is inferred as lub(<span class="type">U<sub>1</sub></span>
                     ... <span class="type">U<sub>k</sub></span>), computed as follows:
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-430"></a>For a type <span class="type">U</span>, we write
                     ST(<span class="type">U</span>) for the set of supertypes of <span class="type">U</span>, and define the erased
                     supertype set of <span class="type">U</span>:
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-440"></a>EST(<span class="type">U</span>) = { <span class="type">V</span> | <span class="type">W</span> in
                     ST(<span class="type">U</span>) and <span class="type">V</span> = |<span class="type">W</span>| } where |<span class="type">W</span>| is the erasure
                     (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of <span class="type">W</span>.
                  </p>
                  <p class="note">The reason for computing the set of erased
                     supertypes is to deal with situations where a type variable is
                     constrained to be a supertype of several distinct invocations of a
                     generic type declaration.
                  </p>
                  <div class="informalexample">
                     <p class="note">For example, if <span class="type">T</span>
                        <code class="literal">:&gt;</code> <code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code> and <span class="type">T</span>
                        <code class="literal">:&gt;</code> <code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>, simply intersecting
                        the sets ST(<code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>) =
                        { <code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>, <code class="literal">Collection<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>,
                        <code class="literal">Object</code> } and ST(<code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>) =
                        { <code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>, <code class="literal">Collection<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>,
                        <code class="literal">Object</code> } would yield a set { <code class="literal">Object</code> }, and we would have lost
                        track of the fact that <span class="type">T</span> can safely be assumed to be
                        a <code class="literal">List</code>.
                     </p>
                     <p class="note">In contrast, intersecting
                        EST(<code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>) =
                        { <code class="literal">List</code>, <code class="literal">Collection</code>, <code class="literal">Object</code> }
                        and EST(<code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>) =
                        { <code class="literal">List</code>, <code class="literal">Collection</code>, <code class="literal">Object</code> }
                        yields { <code class="literal">List</code>, <code class="literal">Collection</code>,
                        <code class="literal">Object</code> }, which we will eventually enable us to infer <span class="type">T</span>
                        = <code class="literal">List<code class="literal">&lt;</code>?<code class="literal">&gt;</code></code> as described below.
                     </p>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.7-450"></a>The erased candidate set
                     for type parameter <span class="type">T<sub>j</sub></span>, EC, is the intersection of all the sets
                     EST(<span class="type">U</span>) for each <span class="type">U</span> in <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>k</sub></span>.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-460"></a>The minimal erased
                     candidate set for <span class="type">T<sub>j</sub></span> is:
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-470"></a>MEC = { <span class="type">V</span> | <span class="type">V</span> in EC, and for all <span class="type">W</span> &#8800; <span class="type">V</span> in EC, it is not the case that <span class="type">W</span> <code class="literal">&lt;:</code> <span class="type">V</span> }
                  </p>
                  <p class="note">Because we are seeking to infer more precise types,
                     we wish to filter out any candidates that are supertypes of other
                     candidates. This is what computing MEC accomplishes.
                  </p>
                  <p class="note">In our running example, we had EC =
                     { <code class="literal">List</code>, <code class="literal">Collection</code>, <code class="literal">Object</code> },
                     and now MEC = { <code class="literal">List</code> }.
                  </p>
                  <p class="note">The next step will be to recover type arguments for
                     the inferred types themselves.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-480"></a>For any element <span class="type">G</span> of
                     MEC that is a generic type declaration, define the relevant
                     invocations of <span class="type">G</span>, Inv(G), to be:
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-490"></a>Inv(<span class="type">G</span>) = { <span class="type">V</span> | 1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>k</em></span>: <span class="type">V</span> in ST(<span class="type">U<sub>i</sub></span>), <span class="type">V</span> = <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code> }
                  </p>
                  <p class="note">In our running example, the only generic element of
                     MEC is <code class="literal">List</code>, and Inv(<code class="literal">List</code>) =
                     { <code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>, <code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>
                     }. We now will seek to find a type argument
                     for <code class="literal">List</code> that contains
                     (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments and Wildcards">&sect;4.5.1</a>) both <code class="literal">String</code> and <code class="literal">Object</code>.
                  </p>
                  <p class="note">This is done by means of the least containing
                     invocation (lci) operation defined below. The first line defines lci()
                     on a set, such as Inv(<code class="literal">List</code>), as an operation on a
                     list of the elements of the set. The next line defines the operation
                     on such lists, as a pairwise reduction on the elements of the
                     list. The third line is the definition of lci() on pairs of
                     parameterized types, which in turn relies on the notion of least
                     containing type argument (lcta).
                  </p>
                  <p class="note">lcta() is defined for all six possible cases. Then
                     CandidateInvocation(<span class="type">G</span>) defines the most specific invocation of the
                     generic type <span class="type">G</span> that contains all the invocations of <span class="type">G</span> that are
                     known to be supertypes of <span class="type">T<sub>j</sub></span>. This will be our candidate invocation
                     of <span class="type">G</span> in the bound we infer for <span class="type">T<sub>j</sub></span>.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-500"></a>Define
                     CandidateInvocation(<span class="type">G</span>) = lci(Inv(<span class="type">G</span>)), where lci, the least
                     containing invocation, is defined:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-500-A"></a>lci(<span class="type">S</span>) = lci(<code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>n</sub></code>) where <code class="varname">e<sub>i</sub></code> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>) in <span class="type">S</span></p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-500-B"></a>lci(<code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>n</sub></code>) = lci(lci(<code class="varname">e<sub>1</sub></code>, <code class="varname">e<sub>2</sub></code>), <code class="varname">e<sub>3</sub></code>, ..., <code class="varname">e<sub>n</sub></code>)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-500-C"></a>lci(<span class="type">G</span><code class="literal">&lt;</code><span class="type">X<sub>1</sub></span>, ..., <span class="type">X<sub>n</sub></span><code class="literal">&gt;</code>, <span class="type">G</span><code class="literal">&lt;</code><span class="type">Y<sub>1</sub></span>, ..., <span class="type">Y<sub>n</sub></span><code class="literal">&gt;</code>) = <span class="type">G</span><code class="literal">&lt;</code>lcta(<span class="type">X<sub>1</sub></span>, <span class="type">Y<sub>1</sub></span>), ..., lcta(<span class="type">X<sub>n</sub></span>, <span class="type">Y<sub>n</sub></span>)<code class="literal">&gt;</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-500-D"></a>lci(<span class="type">G</span><code class="literal">&lt;</code><span class="type">X<sub>1</sub></span>, ..., <span class="type">X<sub>n</sub></span><code class="literal">&gt;</code>) = <span class="type">G</span><code class="literal">&lt;</code>lcta(<span class="type">X<sub>1</sub></span>), ..., lcta(<span class="type">X<sub>n</sub></span>)<code class="literal">&gt;</code></p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.7-510"></a>where lcta() is the least
                     containing type argument function defined (assuming <span class="type">U</span> and <span class="type">V</span> are
                     type expressions) as:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-510-A"></a>lcta(<span class="type">U</span>, <span class="type">V</span>) = <span class="type">U</span> if <span class="type">U</span> = <span class="type">V</span>, otherwise <code class="literal">?</code> <code class="literal">extends</code> lub(<span class="type">U</span>, <span class="type">V</span>)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-510-B"></a>lcta(<span class="type">U</span>, <code class="literal">?</code> <code class="literal">extends</code> <span class="type">V</span>) = <code class="literal">?</code> <code class="literal">extends</code> lub(<span class="type">U</span>, <span class="type">V</span>)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-510-C"></a>lcta(<span class="type">U</span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">V</span>) = <code class="literal">?</code> <code class="literal">super</code> glb(<span class="type">U</span>, <span class="type">V</span>)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-510-D"></a>lcta(<code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span>, <code class="literal">?</code> <code class="literal">extends</code> <span class="type">V</span>) = <code class="literal">?</code> <code class="literal">extends</code> lub(<span class="type">U</span>, <span class="type">V</span>)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-510-E"></a>lcta(<code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">V</span>) = <span class="type">U</span> if <span class="type">U</span> = <span class="type">V</span>, otherwise <code class="literal">?</code></p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-510-F"></a>lcta(<code class="literal">?</code> <code class="literal">super</code> <span class="type">U</span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">V</span>) = <code class="literal">?</code> <code class="literal">super</code> glb(<span class="type">U</span>, <span class="type">V</span>)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.7-510-G"></a>
                                    lcta(<span class="type">U</span>) = <code class="literal">?</code> if <span class="type">U</span>'s upper bound is <code class="literal">Object</code>, otherwise <code class="literal">?</code> <code class="literal">extends</code> lub(<span class="type">U</span>,<code class="literal">Object</code>)
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.7-520"></a>where glb() is as defined
                     in <a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>.
                  </p>
                  <p class="note">Finally, we define a bound for <span class="type">T<sub>j</sub></span> based on on all
                     the elements of the minimal erased candidate set of its supertypes. If
                     any of these elements are generic, we use the CandidateInvocation()
                     function to recover the type argument information.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-530"></a>Define Candidate(<span class="type">W</span>) =
                     CandidateInvocation(<span class="type">W</span>) if <span class="type">W</span> is generic, <span class="type">W</span> otherwise.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-540"></a>The inferred type for
                     <span class="type">T<sub>j</sub></span>, lub(<span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>k</sub></span>), is Candidate(<span class="type">W<sub>1</sub></span>) <code class="literal">&amp;
                        ... &amp;</code> Candidate(<span class="type">W<sub>r</sub></span>), where <span class="type">W<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804;
                     <span class="emphasis"><em>r</em></span>) are the elements of MEC.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.7-600"></a>It is possible that the
                     process above yields an infinite type. This is permissible, and a Java
                     compiler must recognize such situations and represent them
                     appropriately using cyclic data structures.
                  </p>
                  <p class="note">The possibility of an infinite type stems from the
                     recursive calls to lub(). Readers familiar with recursive types should
                     note that an infinite type is not the same as a recursive type.
                  </p>
               </div>
               <div class="section" title="15.12.2.8.&nbsp;Inferring Unresolved Type Arguments">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.8"></a>15.12.2.8.&nbsp;Inferring Unresolved Type Arguments
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.8-100"></a>If any of the method's
                     type arguments were not inferred from the types of the actual
                     arguments, they are now inferred as follows.
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.8-120-A"></a>If the method
                                  result occurs in a context where it will be subject to assignment
                                  conversion (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Conversion">&sect;5.2</a>) to a type <span class="type">S</span>, then let <span class="type">R</span>
                                  be the declared result type of the method, and let <span class="type">R</span>' =
                                  <span class="type">R</span><code class="literal">[</code><span class="type">T<sub>1</sub></span>=B(<span class="type">T<sub>1</sub></span>) ... <span class="type">T<sub>n</sub></span>=B(<span class="type">T<sub>n</sub></span>)<code class="literal">]</code>, where B(<span class="type">T<sub>i</sub></span>) is
                                  the type inferred for <span class="type">T<sub>i</sub></span> in the previous section or <span class="type">T<sub>i</sub></span> if no
                                  type was inferred.
                           </p>
                           <p class="norm"><a name="jls-15.12.2.8-120-A.1"></a>If <span class="type">S</span> is
                                  a reference type, then let <span class="type">S</span>' be <span class="type">S</span>. Otherwise, if <span class="type">S</span> is a
                                  primitive type, then let <span class="type">S</span>' be the result of applying boxing
                                  conversion (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to <span class="type">S</span>.
                           </p>
                           <p class="norm"><a name="jls-15.12.2.8-120-A.2"></a>Then, a set of
                                  initial constraints consisting of:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.8-120-A.2-1"></a>the
                                       	constraint <span class="type">S</span>' &gt;&gt; <span class="type">R</span>', provided <span class="type">R</span> is not <code class="literal">void</code>;
                                       	and
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.8-120-A.2-2"></a>additional
                                       	constraints <span class="type">B<sub>i</sub></span><code class="literal">[</code><span class="type">T<sub>1</sub></span>=B(<span class="type">T<sub>1</sub></span>) ... <span class="type">T<sub>n</sub></span>=B(<span class="type">T<sub>n</sub></span>)<code class="literal">]</code>
                                       	&gt;&gt; <span class="type">T<sub>i</sub></span>, where <span class="type">B<sub>i</sub></span> is the declared bound of
                                       	<span class="type">T<sub>i</sub></span>,
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.8-120-A.2-3"></a>additional constraints B(<span class="type">T<sub>i</sub></span>) &lt;&lt;
                                       	<span class="type">B<sub>i</sub></span>[<span class="type">T<sub>1</sub></span>=B(<span class="type">T<sub>1</sub></span>) ... <span class="type">T<sub>n</sub></span>=B(<span class="type">T<sub>n</sub></span>)], where <span class="type">B<sub>i</sub></span> is the
                                       	declared bound of <span class="type">T<sub>i</sub></span>,
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.8-120-A.2-4"></a>for
                                       	any constraint of the form <span class="type">V</span> &gt;&gt; <span class="type">T<sub>i</sub></span> generated in
                                       	<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>: a constraint <span class="type">V</span>[<span class="type">T<sub>1</sub></span>=B(<span class="type">T<sub>1</sub></span>)
                                       	... <span class="type">T<sub>n</sub></span>=B(<span class="type">T<sub>n</sub></span>)] &gt;&gt; <span class="type">T<sub>i</sub></span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.2.8-120-A.2-5"></a>for
                                       	any constraint of the form <span class="type">T<sub>i</sub></span> = <span class="type">V</span> generated in
                                       	<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>: a constraint <span class="type">T<sub>i</sub></span> =
                                       	<span class="type">V</span>[<span class="type">T<sub>1</sub></span>=B(<span class="type">T<sub>1</sub></span>) ... <span class="type">T<sub>n</sub></span>=B(<span class="type">T<sub>n</sub></span>)].
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <p class="norm"><a name="jls-15.12.2.8-120-A.3"></a>is created and
                                  used to infer constraints on the type arguments using the
                                  algorithm of <a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>.
                           </p>
                           <p class="norm"><a name="jls-15.12.2.8-120-A.4"></a>Any equality
                                  constraints are resolved, and then, for each remaining constraint
                                  of the form <span class="type">T<sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">U<sub>k</sub></span>, the argument <span class="type">T<sub>i</sub></span> is inferred to
                                  be glb(<span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span>) (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
                           </p>
                           <p class="norm"><a name="jls-15.12.2.8-120-A.5"></a>If <span class="type">T<sub>i</sub></span>
                                  appears as a type argument in any <span class="type">U<sub>k</sub></span>, then <span class="type">T<sub>i</sub></span> is inferred to
                                  be a type variable <span class="type">X</span> whose upper bound is the parameterized type
                                  given by glb(<span class="type">U<sub>1</sub></span>[<span class="type">T<sub>i</sub></span>=<span class="type">X</span>], ..., <span class="type">U<sub>k</sub></span>[<span class="type">T<sub>i</sub></span>=<span class="type">X</span>]) and whose lower
                                  bound is the null type.
                           </p>
                           <p class="norm"><a name="jls-15.12.2.8-120-A.6"></a>Any
                                  remaining type variable <span class="type">T</span> that has not yet
                                  been inferred is then inferred to have type <code class="literal">Object</code>. If
                                  a previously inferred type variable <span class="type">P</span> uses <span class="type">T</span>, then <span class="type">P</span> is
                                  inferred to be <span class="type">P</span>[<span class="type">T</span>=<code class="literal">Object</code>].
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.2.8-120-B"></a>Otherwise, the
                                   unresolved type arguments are inferred by invoking the procedure
                                   described in this section under the assumption that the method
                                   result was assigned to a variable of type <code class="literal">Object</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="section" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.12.3"></a>15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.12.3-100"></a>If there is a most specific
                  method declaration for a method invocation, it is called
                  the <span class="emphasis"><em>compile-time declaration</em></span> for the method
                  invocation.
               </p>
               <p class="norm-static"><a name="jls-15.12.3-110"></a>If the
                  method invocation has, before the left parenthesis,
                  a <span class="emphasis"><em>MethodName</em></span> of the form <span class="emphasis"><em>Identifier</em></span>, and the
                  compile-time declaration is an instance method, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.12.3-110-A"></a>If
                                the method invocation occurs in a static context
                                (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>), then a compile-time error
                                occurs.
                        </p>
                        <p class="note">The reason is that a method invocation of this
                                form cannot be used to invoke an instance method in places where
                                <code class="literal">this</code> (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>) is not defined.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-110-B"></a>Otherwise, let <span class="type">C</span> be the innermost
                                enclosing class of which the compile-time declaration is a
                                member.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.3-110-B.1"></a>If the invocation is not directly
                                enclosed by <span class="type">C</span> or an inner class of <span class="type">C</span>, then a compile-time
                                error occurs.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-error"><a name="jls-15.12.3-120"></a>If the
                  method invocation has, before the left parenthesis,
                  a <span class="emphasis"><em>MethodName</em></span> of the
                  form <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <span class="emphasis"><em>Identifier</em></span>, or if the
                  method invocation, before the left parenthesis, has the
                  form <span class="emphasis"><em>TypeName</em></span>
                  <code class="literal">.</code> <span class="emphasis"><em>NonWildTypeArguments</em></span> <span class="emphasis"><em>Identifier</em></span>, then the
                  compile-time declaration must be <code class="literal">static</code>, or a compile-time error
                  occurs.
               </p>
               <p class="note">The reason is that a method invocation of this form
                  does not specify a reference to an object that can serve as this
                  within the instance method.
               </p>
               <p class="norm-static"><a name="jls-15.12.3-130"></a>If the
                  method invocation has, before the left parenthesis, the form <code class="literal">super</code>
                  <code class="literal">.</code> <span class="emphasis"><em>NonWildTypeArguments<sub>opt</sub></em></span> <span class="emphasis"><em>Identifier</em></span>,
                  then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.12.3-130-A"></a>If
                                 the compile-time declaration is <code class="literal">abstract</code>, a compile-time error
                                 occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.12.3-130-B"></a>If
                                 the method invocation occurs in a static context, a compile-time
                                 error occurs.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.12.3-140"></a>If the
                  method invocation has, before the left parenthesis, the
                  form <span class="emphasis"><em>ClassName</em></span> <code class="literal">.</code> <code class="literal">super</code>
                  <code class="literal">.</code> <span class="emphasis"><em>NonWildTypeArguments<sub>opt</sub></em></span> <span class="emphasis"><em>Identifier</em></span>,
                  then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.12.3-140-A"></a>If
                                 the compile-time declaration is <code class="literal">abstract</code>, a compile-time error
                                 occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.12.3-140-B"></a>If
                                the method invocation occurs in a static context, a compile-time
                                error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-140-C"></a>Otherwise, let <span class="type">C</span> be the class
                                denoted by <span class="emphasis"><em>ClassName</em></span>.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.3-140-C.1"></a>If the invocation is not directly
                                enclosed by <span class="type">C</span> or an inner class of <span class="type">C</span>, then a compile-time
                                error occurs.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-error"><a name="jls-15.12.3-200"></a>If the
                  compile-time declaration is <code class="literal">void</code>, then the method invocation must be
                  a top level expression (that is, the <span class="emphasis"><em>Expression</em></span> in an expression
                  statement (<a class="xref" href="jls-14.html#jls-14.8" title="14.8.&nbsp;Expression Statements">&sect;14.8</a>) or in
                  the <span class="emphasis"><em>ForInit</em></span> or <span class="emphasis"><em>ForUpdate</em></span>
                  part of a <code class="literal">for</code> statement (<a class="xref" href="jls-14.html#jls-14.14" title="14.14.&nbsp;The for Statement">&sect;14.14</a>)), or a
                  compile-time error occurs.
               </p>
               <p class="note">The reason is that such a method invocation produces
                  no value and so must be used only in a situation where a value is not
                  needed.
               </p>
               <p class="norm-static"><a name="jls-15.12.3-300"></a>A method
                  is <span class="emphasis"><em>signature polymorphic</em></span> if and only if all of
                  the following conditions hold:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-300-A"></a>It
                               is declared in the <code class="literal">java.lang.invoke.MethodHandle</code> class.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-300-B"></a>It
                               takes a single variable arity parameter
                               (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) whose declared type is
                               <code class="literal">Object</code><code class="literal">[]</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-300-C"></a>It
                               has a return type of <code class="literal">Object</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-300-D"></a>It
                               is <code class="literal">native</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">In Java SE 7, the only signature polymorphic methods
                  are the <code class="literal">invoke</code> and <code class="literal">invokeExact</code> methods of the class
                  <code class="literal">java.lang.invoke.MethodHandle</code>.
               </p>
               <p class="norm-static"><a name="jls-15.12.3-310"></a>If the
                  compile-time declaration for the method invocation
                  is <span class="emphasis"><em>not</em></span> a signature polymorphic method, then the
                  types of its parameters are the types of its formal parameters, and
                  the result type is its chosen result type.
               </p>
               <p class="norm-static"><a name="jls-15.12.3-320"></a>Otherwise, if the
                  compile-time declaration for the method invocation is a signature
                  polymorphic method, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-320-A"></a>The types of its parameters are the
                                 static types of the actual argument expressions.
                        </p>
                        <p class="norm-static"><a name="jls-15.12.3-320-A.1"></a>An argument expression which is the
                                 null literal <code class="literal">null</code> (<a class="xref" href="jls-3.html#jls-3.10.7" title="3.10.7.&nbsp;The Null Literal">&sect;3.10.7</a>) is treated as
                                 having the static type <code class="literal">Void</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-320-B"></a>The result type is determined as
                               follows:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-320-B-1"></a>If the method invocation
                                    	  expression is an expression statement, the method is
                                    	  <code class="literal">void</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-320-B-2"></a>Otherwise, if the method
                                    	  invocation expression is the operand of a cast expression
                                    	  (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>), the return type is the
                                    	  erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the type of the cast
                                    	  expression.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-320-B-3"></a>Otherwise, the return type is
                                    	  the method's declared return type, <code class="literal">Object</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.12.3-400"></a>The
                  following compile-time information is then associated with the method
                  invocation for use at run time:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-400-A"></a>The name of the method.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-400-B"></a>The qualifying type of the method
                               invocation (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-400-C"></a>The number of parameters and the types
                               of the parameters, in order.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-400-D"></a>The result type, or <code class="literal">void</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-400-E"></a>The invocation mode, computed as
                               follows:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-400-E-1"></a>If the compile-time declaration
                                    	has the <code class="literal">static</code> modifier, then the invocation mode is
                                    	<code class="literal">static</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-400-E-2"></a>Otherwise, if the compile-time
                                    	declaration has the <code class="literal">private</code> modifier, then the invocation
                                    	mode is <code class="literal">nonvirtual</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-400-E-3"></a>Otherwise, if the part of the
                                    	method invocation before the left parenthesis is of the form
                                    	<code class="literal">super</code> <code class="literal">.</code> <span class="emphasis"><em>Identifier</em></span> or of the
                                    	form <span class="emphasis"><em>ClassName</em></span> <code class="literal">.</code> <code class="literal">super</code> <code class="literal">.</code>
                                    	<span class="emphasis"><em>Identifier</em></span>, then the invocation mode is <code class="literal">super</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-400-E-4"></a>Otherwise, if the compile-time
                                    	declaration is in an interface, then the invocation mode is
                                    	<code class="literal">interface</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-400-E-5"></a>Otherwise, the invocation mode is
                                    	<code class="literal">virtual</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.12.3-410"></a>If the
                  compile-time declaration for the method invocation is not <code class="literal">void</code>, then
                  the type of the method invocation expression is the result type
                  specified in the compile-time declaration.
               </p>
            </div>
            <div class="section" title="15.12.4.&nbsp;Run-Time Evaluation of Method Invocation">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.12.4"></a>15.12.4.&nbsp;Run-Time Evaluation of Method Invocation
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.12.4-100"></a>At run time, method
                  invocation requires five steps. First, a <span class="emphasis"><em>target
                        reference</em></span> may be computed. Second, the argument expressions
                  are evaluated. Third, the accessibility of the method to be invoked is
                  checked. Fourth, the actual code for the method to be executed is
                  located. Fifth, a new activation frame is created, synchronization is
                  performed if necessary, and control is transferred to the method
                  code.
               </p>
               <div class="section" title="15.12.4.1.&nbsp;Compute Target Reference (If Necessary)">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.1"></a>15.12.4.1.&nbsp;Compute Target Reference (If Necessary)
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.4.1-100"></a>There are several cases
                     to consider, depending on which of the five productions
                     for <span class="emphasis"><em>MethodInvocation</em></span>
                     (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>) is involved:
                  </p>
                  <div class="orderedlist">
                     <ol class="orderedlist" type="1">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.1-100-A"></a>If the first
                                  production for MethodInvocation, which includes
                                  a <span class="emphasis"><em>MethodName</em></span>, is involved, then there are
                                  three subcases:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="disc">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.1-100-A-1"></a>If
                                       	the <span class="emphasis"><em>MethodName</em></span> is a simple name, that is,
                                       	just an <span class="emphasis"><em>Identifier</em></span>, then there are two subcases:
                                    </p>
                                    <div class="norm">
                                       <ul class="norm" type="circle">
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.4.1-100-A-1-1"></a>If the
                                                	    invocation mode is <code class="literal">static</code>, then there is no target
                                                	    reference.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.4.1-100-A-1-2"></a>Otherwise, let <span class="type">T</span> be the
                                                	    enclosing type declaration of which the method is a
                                                	    member, and let <span class="emphasis"><em>n</em></span> be an integer such that <span class="type">T</span> is the
                                                	    <span class="emphasis"><em>n</em></span>'th lexically enclosing type declaration
                                                	    (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>) of the class whose
                                                	    declaration immediately contains the method
                                                	    invocation. Then the target reference is the <span class="emphasis"><em>n</em></span>'th
                                                	    lexically enclosing instance (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>)
                                                	    of <code class="literal">this</code>.
                                             </p>
                                             <p class="norm-error"><a name="jls-15.12.4.1-100-A-1-2.1"></a>It is a compile-time
                                                	    error if the <span class="emphasis"><em>n</em></span>'th lexically enclosing instance
                                                	    (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>) of <code class="literal">this</code> does not
                                                	    exist.
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.1-100-A-2"></a>If
                                       	the <span class="emphasis"><em>MethodName</em></span> is a qualified name of the
                                       	form <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <span class="emphasis"><em>Identifier</em></span>, then
                                       	there is no target reference.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.1-120-A-3"></a>If
                                       	the <span class="emphasis"><em>MethodName</em></span> is a qualified name of the
                                       	form <span class="emphasis"><em>FieldName</em></span> <code class="literal">.</code> <span class="emphasis"><em>Identifier</em></span>, then
                                       	there are two subcases:
                                    </p>
                                    <div class="norm">
                                       <ul class="norm" type="circle">
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.4.1-120-A-3-1"></a>If the
                                                	    invocation mode is <code class="literal">static</code>, then there is no target
                                                	    reference. The expression <span class="emphasis"><em>FieldName</em></span>
                                                	    is evaluated, but the result is then discarded.
                                             </p>
                                          </li>
                                          <li class="listitem">
                                             <p class="norm"><a name="jls-15.12.4.1-130-A-3-2"></a>Otherwise, the target
                                                	    reference is the value of the
                                                	    expression <span class="emphasis"><em>FieldName</em></span>.
                                             </p>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.1-120-B"></a>If the second
                                  production for <span class="emphasis"><em>MethodInvocation</em></span>, which
                                  includes a <span class="emphasis"><em>Primary</em></span>, is involved, then there are two
                                  subcases:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="disc">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.1-120-B-1"></a>If the
                                       	invocation mode is <code class="literal">static</code>, then there is no target
                                       	reference. The expression <span class="emphasis"><em>Primary</em></span> is evaluated, but the
                                       	result is then discarded.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.1-120-B-2"></a>Otherwise,
                                       	the expression <span class="emphasis"><em>Primary</em></span> is evaluated and the result is used
                                       	as the target reference.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <p class="norm"><a name="jls-15.12.4.1-120-B.1"></a>In either case,
                                  if the evaluation of the <span class="emphasis"><em>Primary</em></span> expression completes abruptly,
                                  then no part of any argument expression appears to have been
                                  evaluated, and the method invocation completes abruptly for the
                                  same reason.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.1-120-C"></a>If the third
                                  production for <span class="emphasis"><em>MethodInvocation</em></span>, which
                                  includes the keyword <code class="literal">super</code>, is involved, then the target
                                  reference is the value of <code class="literal">this</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.1-120-D"></a>If the fourth
                                  production
                                  for <span class="emphasis"><em>MethodInvocation</em></span>, <span class="emphasis"><em>ClassName</em></span>
                                  <code class="literal">.</code> <code class="literal">super</code>, is involved, then the target reference is the value
                                  of <span class="emphasis"><em>ClassName</em></span><code class="literal">.</code><code class="literal">this</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.1-120-E"></a>If the fifth
                                  production for <span class="emphasis"><em>MethodInvocation</em></span>, beginning
                                  with <span class="emphasis"><em>TypeName</em></span>
                                  <code class="literal">.</code> <span class="emphasis"><em>NonWildTypeArguments</em></span>, is involved, then
                                  there is no target reference.
                           </p>
                        </li>
                     </ol>
                  </div>
                  <div class="example"><a name="d5e23450"></a><p class="title"><b>Example&nbsp;15.12.4.1-1.&nbsp;Target References and <code class="literal">static</code> Methods</b></p>
                     <div class="example-contents">
                        <p class="note">When a target reference is computed and then
                           discarded because the invocation mode is <code class="literal">static</code>, the reference is
                           not examined to see whether it is <code class="literal">null</code>:
                        </p><pre class="programlisting">
class Test1 {
    static void mountain() {
        System.out.println("Monadnock");
    }
    static Test1 favorite(){
        System.out.print("Mount ");
        return null;
    }
    public static void main(String[] args) {
        favorite().mountain();
    }
}
</pre><p class="note">which prints:</p><pre class="screen">
Mount Monadnock
</pre><p class="note">Here <code class="literal">favorite()</code> returns <code class="literal">null</code>,
                           yet no <code class="literal">NullPointerException</code> is thrown.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e23463"></a><p class="title"><b>Example&nbsp;15.12.4.1-2.&nbsp;Evaluation Order During Method Invocation</b></p>
                     <div class="example-contents">
                        <p class="note">As part of an instance method invocation
                           (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), there is an expression that denotes the
                           object to be invoked. This expression appears to be fully evaluated
                           before any part of any argument expression to the method invocation is
                           evaluated.
                        </p>
                        <p class="note">So, for example, in:</p><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        String s = "one";
        if (s.startsWith(s = "two"))
            System.out.println("oops");
    }
}
</pre><p class="note">the occurrence of <code class="literal">s</code> before
                           "<code class="literal">.startsWith</code>" is evaluated first, before the
                           argument expression <code class="literal">s = "two"</code>. Therefore, a
                           reference to the string <code class="literal">"one"</code> is remembered as the
                           target reference before the local variable <code class="literal">s</code> is
                           changed to refer to the string <code class="literal">"two"</code>. As a result,
                           the <code class="literal">startsWith</code> method is invoked for target
                           object <code class="literal">"one"</code> with
                           argument <code class="literal">"two"</code>, so the result of the invocation is
                           <code class="literal">false</code>, as the string <code class="literal">"one"</code> does not start
                           with <code class="literal">"two"</code>. It follows that the test program does
                           not print "<code class="literal">oops</code>".
                        </p>
                     </div>
                  </div><br class="example-break"></div>
               <div class="section" title="15.12.4.2.&nbsp;Evaluate Arguments">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.2"></a>15.12.4.2.&nbsp;Evaluate Arguments
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-dynamic"><a name="jls-15.12.4.2-100"></a>The
                     process of evaluating the argument list differs, depending on whether
                     the method being invoked is a fixed arity method or a variable arity
                     method (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>).
                  </p>
                  <p class="norm"><a name="jls-15.12.4.2-110"></a>If the method being
                     invoked is a variable arity method <code class="varname">m</code>, it
                     necessarily has <span class="emphasis"><em>n</em></span> &gt; 0 formal parameters. The final formal
                     parameter of <code class="varname">m</code> necessarily has type <span class="type">T</span><code class="literal">[]</code>
                     for some <span class="type">T</span>, and <code class="varname">m</code> is necessarily being invoked
                     with <span class="emphasis"><em>k</em></span> &#8805; 0 actual argument expressions.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.2-200"></a>If <code class="varname">m</code> is being
                     invoked with <span class="emphasis"><em>k</em></span> &#8800; <span class="emphasis"><em>n</em></span> actual argument expressions, or, if
                     <code class="varname">m</code> is being invoked with <span class="emphasis"><em>k</em></span> = <span class="emphasis"><em>n</em></span> actual argument expressions
                     and the type of the <span class="emphasis"><em>k</em></span>'th argument expression is not assignment
                     compatible with <span class="type">T</span><code class="literal">[]</code>, then the argument list (<code class="varname">e<sub>1</sub></code>, ...,
                     <code class="varname">e<sub>n-1</sub></code>, <code class="varname">e<sub>n</sub></code>, ..., <code class="varname">e<sub>k</sub></code>) is evaluated as if it were written as (<code class="varname">e<sub>1</sub></code>,
                     ..., <code class="varname">e<sub>n-1</sub></code>, <code class="literal">new</code> |<span class="type">T</span><code class="literal">[]</code>| <code class="literal">{</code> <code class="varname">e<sub>n</sub></code>, ..., <code class="varname">e<sub>k</sub></code> <code class="literal">}</code>),
                     where |<span class="type">T</span><code class="literal">[]</code>| denotes the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>)
                     of <span class="type">T</span><code class="literal">[]</code>.
                  </p>
                  <p class="note">The preceding paragraphs are crafted to handle the
                     interaction of parameterized types and array types that occurs in a
                     Java Virtual Machine with erased generics. Namely, if the element type <span class="type">T</span> of the
                     variable array parameter is non-reifiable,
                     e.g. <code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>, then special care must be
                     taken with the array creation expression (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation Expressions">&sect;15.10</a>)
                     because the created array's element type must be reifiable. By erasing
                     the array type of the final expression in the argument list, we are
                     guaranteed to obtain a reifiable element type. Then, since the array
                     creation expression appears in a method invocation context, an
                     unchecked conversion (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>) is possible from
                     the array type with reifiable element type to an array type with
                     non-reifiable element type, specifically that of the variable arity
                     parameter. A Java compiler is required by <a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>
                     to give a compile-time unchecked warning at this conversion. Oracle's
                     reference implementation of a Java compiler identifies the unchecked
                     warning here as a more informative <span class="emphasis"><em>unchecked generic array
                           creation</em></span>.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.2-210"></a>The
                     argument expressions (possibly rewritten as described above) are now
                     evaluated to yield <span class="emphasis"><em>argument values</em></span>. Each argument
                     value corresponds to exactly one of the method's <span class="emphasis"><em>n</em></span> formal
                     parameters.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.2-220"></a>The
                     argument expressions, if any, are evaluated in order, from left to
                     right. If the evaluation of any argument expression completes
                     abruptly, then no part of any argument expression to its right appears
                     to have been evaluated, and the method invocation completes abruptly
                     for the same reason. The result of evaluating the <span class="emphasis"><em>j</em></span>'th argument
                     expression is the <span class="emphasis"><em>j</em></span>'th argument value, for 1 &#8804; <span class="emphasis"><em>j</em></span> &#8804;
                     <span class="emphasis"><em>n</em></span>. Evaluation then continues, using the argument values, as
                     described below.
                  </p>
               </div>
               <div class="section" title="15.12.4.3.&nbsp;Check Accessibility of Type and Method">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.3"></a>15.12.4.3.&nbsp;Check Accessibility of Type and Method
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.4.3-100"></a>Let <span class="type">C</span> be the class
                     containing the method invocation, and let <span class="type">T</span> be the qualifying type
                     of the method invocation (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>), and let <code class="varname">m</code> be
                     the name of the method as determined at compile time
                     (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>).
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.3-110"></a>An
                     implementation of the Java programming language must ensure, as part of linkage, that
                     the method <code class="varname">m</code> still exists in the type <span class="type">T</span>. If this
                     is not true, then a <code class="literal">NoSuchMethodError</code> (which is a subclass of <code class="literal">IncompatibleClassChangeError</code>)
                     occurs.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.3-120"></a>If
                     the invocation mode is <code class="literal">interface</code>, then the implementation must also
                     check that the target reference type still implements the specified
                     interface. If the target reference type does not still implement the
                     interface, then an <code class="literal">IncompatibleClassChangeError</code> occurs.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.3-130"></a>The
                     implementation must also ensure, during linkage, that the type <span class="type">T</span> and
                     the method <code class="varname">m</code> are accessible:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.3-130-A"></a>For the type
                                   <span class="type">T</span>:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-A-1"></a>If <span class="type">T</span> is in
                                       	  the same package as <span class="type">C</span>, then <span class="type">T</span> is accessible.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-A-2"></a>If <span class="type">T</span> is in
                                       	  a different package than <span class="type">C</span>, and <span class="type">T</span> is <code class="literal">public</code>, then <span class="type">T</span>
                                       	  is accessible.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-A-3"></a>If <span class="type">T</span> is in
                                       	  a different package than <span class="type">C</span>, and <span class="type">T</span> is <code class="literal">protected</code>, then
                                       	  <span class="type">T</span> is accessible if and only if <span class="type">C</span> is a subclass of
                                       	  <span class="type">T</span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.3-130-B"></a>For the
                                    method <code class="varname">m</code>:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-B-1"></a>If 
                                       	  <code class="varname">m</code> is <code class="literal">public</code>, then <code class="varname">m</code>
                                       	  is accessible. (All members of interfaces are <code class="literal">public</code>
                                       	  (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>).)
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-B-2"></a>If 
                                       	  <code class="varname">m</code> is <code class="literal">protected</code>,
                                       	  then <code class="varname">m</code> is accessible if and only if
                                       	  either <span class="type">T</span> is in the same package as <span class="type">C</span>, or <span class="type">C</span> is <span class="type">T</span> or a
                                       	  subclass of <span class="type">T</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-B-3"></a>If
                                       	  <code class="varname">m</code> has default (package) access,
                                       	  then <code class="varname">m</code> is accessible if and only if <span class="type">T</span>
                                       	  is in the same package as <span class="type">C</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-B-4"></a>If 
                                       	  <code class="varname">m</code> is <code class="literal">private</code>, then <code class="varname">m</code>
                                       	  is accessible if and only if <span class="type">C</span> is <span class="type">T</span>, or <span class="type">C</span> encloses
                                       	  <span class="type">T</span>, or <span class="type">T</span> encloses <span class="type">C</span>, or <span class="type">T</span> and <span class="type">C</span> are both enclosed
                                       	  by a third class.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.4.3-140"></a>If either <span class="type">T</span>
                     or <code class="varname">m</code> is not accessible, then an <code class="literal">IllegalAccessError</code> occurs
                     (<a class="xref" href="jls-12.html#jls-12.3" title="12.3.&nbsp;Linking of Classes and Interfaces">&sect;12.3</a>).
                  </p>
               </div>
               <div class="section" title="15.12.4.4.&nbsp;Locate Method to Invoke">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.4"></a>15.12.4.4.&nbsp;Locate Method to Invoke
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.4.4-100"></a>The strategy for method
                     lookup depends on the invocation mode.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-110"></a>If
                     the invocation mode is <code class="literal">static</code>, no target reference is needed and
                     overriding is not allowed. Method <code class="varname">m</code> of class <span class="type">T</span> is the one to be
                     invoked.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-120"></a>Otherwise, an instance method is to be
                     invoked and there is a target reference. If the target reference is
                     <code class="literal">null</code>, a <code class="literal">NullPointerException</code> is thrown at this point. Otherwise, the target
                     reference is said to refer to a <span class="emphasis"><em>target object</em></span> and
                     will be used as the value of the keyword <code class="literal">this</code> in the invoked
                     method. The other four possibilities for the invocation mode are then
                     considered.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-200"></a>If
                     the invocation mode is <code class="literal">nonvirtual</code>, overriding is not allowed. Method
                     <code class="varname">m</code> of class <span class="type">T</span> is the one to be invoked.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-210"></a>Otherwise, if the
                     invocation mode is <code class="literal">virtual</code>, and <span class="type">T</span> and <code class="varname">m</code> jointly indicate a
                     signature polymorphic method (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>), then the
                     target object is an instance of <code class="literal">java.lang.invoke.MethodHandle</code>. The method handle
                     encapsulates a <span class="emphasis"><em>type</em></span> which is matched against the
                     information associated with the method invocation at compile time
                     (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>). Details of this matching are given in
                     <em class="citetitle">The Java Virtual Machine Specification, Java SE 7 Edition</em> and the Java SE platform API. If matching succeeds,
                     the <span class="emphasis"><em>target method</em></span> encapsulated by the method
                     handle is directly and immediately invoked,
                     <span class="emphasis"><em>and the procedure in <a class="xref" href="jls-15.html#jls-15.12.4.5" title="15.12.4.5.&nbsp;Create Frame, Synchronize, Transfer Control">&sect;15.12.4.5</a> is not
                           executed</em></span>.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-220"></a>Otherwise, the invocation mode is
                     <code class="literal">interface</code>, <code class="literal">virtual</code>, or <code class="literal">super</code>, and overriding may
                     occur. A <span class="emphasis"><em>dynamic method lookup</em></span> is used. The
                     dynamic lookup process starts from a class <span class="type">S</span>, determined as
                     follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-220-A"></a>If the invocation mode is <code class="literal">interface</code>
                                  or <code class="literal">virtual</code>, then <span class="type">S</span> is initially the actual run-time class <span class="type">R</span>
                                  of the target object.
                           </p>
                           <p class="note">This is true even if the target object is an
                                  array instance. (Note that for invocation mode <code class="literal">interface</code>, <span class="type">R</span>
                                  necessarily implements <span class="type">T</span>; for invocation mode <code class="literal">virtual</code>, <span class="type">R</span> is
                                  necessarily either <span class="type">T</span> or a subclass of <span class="type">T</span>.)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-220-B"></a>If the invocation mode is <code class="literal">super</code>,
                                  then <span class="type">S</span> is initially the qualifying type
                                  (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>) of the method invocation.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-230"></a>The
                     dynamic method lookup uses the following procedure to search class
                     <span class="type">S</span>, and then the superclasses of class <span class="type">S</span>, as necessary, for
                     method <code class="varname">m</code>.
                  </p>
                  <p class="norm"><a name="jls-15.12.4.4-240"></a>Let <span class="type">X</span> be the
                     compile-time type of the target reference of the method
                     invocation. Then:
                  </p>
                  <div class="orderedlist">
                     <ol class="orderedlist" type="1">
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-240-A"></a>If class <span class="type">S</span> contains a declaration
                                  for a non-<code class="literal">abstract</code> method named <code class="varname">m</code> with the
                                  same descriptor (same number of parameters, the same parameter
                                  types, and the same return type) required by the method invocation
                                  as determined at compile time (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>),
                                  then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="disc">
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.4-240-A-1"></a>If the invocation mode is
                                       	<code class="literal">super</code> or <code class="literal">interface</code>, then this is the method to be invoked,
                                       	and the procedure terminates.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.4-240-A-2"></a>If the invocation mode is
                                       	<code class="literal">virtual</code>, and the declaration in <span class="type">S</span> overrides
                                       	(<a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a>) <span class="type">X</span><code class="literal">.</code><code class="varname">m</code>,
                                       	then the method declared in <span class="type">S</span> is the method to be invoked,
                                       	and the procedure terminates.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-error"><a name="jls-15.12.4.4-240-A-3"></a>If the invocation mode is
                                       	  <code class="literal">virtual</code>, and the declaration in <span class="type">S</span> does not override
                                       	  <span class="type">X</span><code class="literal">.</code><code class="varname">m</code>, and moreover <span class="type">X</span><code class="literal">.</code><code class="varname">m</code> is declared
                                       	  <code class="literal">abstract</code>, then an <code class="literal">AbstractMethodError</code> is thrown.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.4-240-B"></a>Otherwise, if <span class="type">S</span>
                                  has a superclass, this same lookup procedure is performed
                                  recursively using the direct superclass of <span class="type">S</span> in place of <span class="type">S</span>;
                                  the method to be invoked is the result of the recursive invocation
                                  of this lookup procedure.
                           </p>
                        </li>
                     </ol>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.4.4-250"></a>The above
                     procedure (if it terminates without error)
                     will  find a non-<code class="literal">abstract</code>, accessible method to invoke,
                     provided that all classes and interfaces in the program have been
                     consistently compiled. However, if this is not the case, then various
                     errors may occur. The specification of the behavior of a Java Virtual Machine under
                     these circumstances is given by <em class="citetitle">The Java Virtual Machine Specification, Java SE 7 Edition</em>.
                  </p>
                  <p class="note">We note that the dynamic lookup process, while
                     described here explicitly, will often be implemented implicitly, for
                     example as a side-effect of the construction and use of per-class
                     method dispatch tables, or the construction of other per-class
                     structures used for efficient dispatch.
                  </p>
                  <div class="example"><a name="d5e23741"></a><p class="title"><b>Example&nbsp;15.12.4.4-1.&nbsp;Overriding and Method Invocation</b></p>
                     <div class="example-contents"><pre class="programlisting">
class Point {
    final int EDGE = 20;
    int x, y;
    void move(int dx, int dy) {
        x += dx; y += dy;
        if (Math.abs(x) &gt;= EDGE || Math.abs(y) &gt;= EDGE)
            clear();
    }
    void clear() {
        System.out.println("\tPoint clear");
        x = 0; y = 0;
    }
}
class ColoredPoint extends Point {
    int color;
    void clear() {
        System.out.println("\tColoredPoint clear");
        super.clear();
        color = 0;
    }
}
</pre><p class="note">Here, the subclass <code class="literal">ColoredPoint</code>
                           extends the <code class="literal">clear</code> abstraction defined by its
                           superclass <code class="literal">Point</code>. It does so by overriding
                           the <code class="literal">clear</code> method with its own method, which invokes
                           the <code class="literal">clear</code> method of its superclass, using the
                           form <code class="literal">super.clear()</code>.
                        </p>
                        <p class="note">This method is then invoked whenever the target
                           object for an invocation of <code class="literal">clear</code> is
                           a <code class="literal">ColoredPoint</code>. Even the
                           method <code class="literal">move</code> in <code class="literal">Point</code> invokes
                           the <code class="literal">clear</code> method of
                           class <code class="literal">ColoredPoint</code> when the class of <code class="literal">this</code>
                           is <code class="literal">ColoredPoint</code>, as shown by the output of this
                           test program:
                        </p><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        Point p = new Point();
        System.out.println("p.move(20,20):");
        p.move(20, 20);

        ColoredPoint cp = new ColoredPoint();
        System.out.println("cp.move(20,20):");
        cp.move(20, 20);

        p = new ColoredPoint();
        System.out.println("p.move(20,20), p colored:");
        p.move(20, 20);
    }
}
</pre><p class="note">which is:</p><pre class="screen">
p.move(20,20):
        Point clear
cp.move(20,20):
        ColoredPoint clear
        Point clear
p.move(20,20), p colored:
        ColoredPoint clear
        Point clear
</pre><p class="note">Overriding is sometimes called "late-bound
                           self-reference"; in this example it means that the reference
                           to <code class="literal">clear</code> in the body
                           of <code class="literal">Point.move</code> (which is really syntactic shorthand
                           for <code class="literal">this.clear</code>) invokes a method chosen "late" (at
                           run time, based on the run-time class of the object referenced by
                           <code class="literal">this</code>) rather than a method chosen "early" (at compile time, based
                           only on the type of <code class="literal">this</code>). This provides the programmer a powerful
                           way of extending abstractions and is a key idea in object-oriented
                           programming.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e23769"></a><p class="title"><b>Example&nbsp;15.12.4.4-2.&nbsp;Method Invocation Using <code class="literal">super</code></b></p>
                     <div class="example-contents">
                        <p class="note">An overridden instance method of a superclass may be
                           accessed by using the keyword <code class="literal">super</code> to access the members of the
                           immediate superclass, bypassing any overriding declaration in the
                           class that contains the method invocation.
                        </p>
                        <p class="note">When accessing an instance variable, <code class="literal">super</code> means
                           the same as a cast of <code class="literal">this</code> (<a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>), but this
                           equivalence does not hold true for method invocation. This is
                           demonstrated by the example:
                        </p><pre class="programlisting">
class T1 {
    String s() { return "1"; }
}
class T2 extends T1 {
    String s() { return "2"; }
}
class T3 extends T2 {
    String s() { return "3"; }
    void test() {
        System.out.println("s()=\t\t"          + s());
        System.out.println("super.s()=\t"      + super.s());
        System.out.println("((T2)this).s()=\t" + ((T2)this).s());
        System.out.println("((T1)this).s()=\t" + ((T1)this).s());
    }
}
class Test2 {
    public static void main(String[] args) {
        T3 t3 = new T3();
        t3.test();
    }
}
</pre><p class="note">which produces the output:</p><pre class="screen">
s()=            3
super.s()=      2
((T2)this).s()= 3
((T1)this).s()= 3
</pre><p class="note">The casts to types <code class="literal">T1</code>
                           and <code class="literal">T2</code> do not change the method that is invoked,
                           because the instance method to be invoked is chosen according to the
                           run-time class of the object referred to by <code class="literal">this</code>. A cast does not
                           change the class of an object; it only checks that the class is
                           compatible with the specified type.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
               <div class="section" title="15.12.4.5.&nbsp;Create Frame, Synchronize, Transfer Control">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.5"></a>15.12.4.5.&nbsp;Create Frame, Synchronize, Transfer Control
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-dynamic"><a name="jls-15.12.4.5-100"></a>A
                     method <code class="varname">m</code> in some class <span class="type">S</span> has been identified as the one to be
                     invoked.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.5-110"></a>Now a
                     new <span class="emphasis"><em>activation frame</em></span> is created, containing the
                     target reference (if any) and the argument values (if any), as well as
                     enough space for the local variables and stack for the method to be
                     invoked and any other bookkeeping information that may be required by
                     the implementation (stack pointer, program counter, reference to
                     previous activation frame, and the like). If there is not sufficient
                     memory available to create such an activation frame, a <code class="literal">StackOverflowError</code> is
                     thrown.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.5-120"></a>The
                     newly created activation frame becomes the current activation
                     frame. The effect of this is to assign the argument values to
                     corresponding freshly created parameter variables of the method, and
                     to make the target reference available as <code class="literal">this</code>, if there is a target
                     reference. Before each argument value is assigned to its corresponding
                     parameter variable, it is subjected to method invocation conversion
                     (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Method Invocation Conversion">&sect;5.3</a>), which includes any required value set
                     conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>).
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.5-130"></a>If
                     the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the type of the method
                     being invoked differs in its signature from the erasure of the type of
                     the compile-time declaration for the method invocation
                     (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>), then if any of the argument values is
                     an object which is not an instance of a subclass or subinterface of
                     the erasure of the corresponding formal parameter type in the
                     compile-time declaration for the method invocation, then a <code class="literal">ClassCastException</code> is
                     thrown.
                  </p>
                  <p class="norm"><a name="jls-15.12.4.5-140"></a>If the method <code class="varname">m</code> is a
                     <code class="literal">native</code> method but the necessary native, implementation-dependent
                     binary code has not been loaded or otherwise cannot be dynamically
                     linked, then an <code class="literal">UnsatisfiedLinkError</code> is thrown.
                  </p>
                  <p class="norm"><a name="jls-15.12.4.5-200"></a>If the method <code class="varname">m</code> is not
                     <code class="literal">synchronized</code>, control is transferred to the body of the method <code class="varname">m</code>
                     to be invoked.
                  </p>
                  <p class="norm"><a name="jls-15.12.4.5-210"></a>If the method <code class="varname">m</code> is
                     <code class="literal">synchronized</code>, then an object must be locked before the transfer of
                     control. No further progress can be made until the current thread can
                     obtain the lock. If there is a target reference, then the target
                     object must be locked; otherwise the <code class="literal">Class</code> object for class <span class="type">S</span>, the
                     class of the method <code class="varname">m</code>, must be locked. Control is then transferred
                     to the body of the method <code class="varname">m</code> to be invoked. The object is
                     automatically unlocked when execution of the body of the method has
                     completed, whether normally or abruptly. The locking and unlocking
                     behavior is exactly as if the body of the method were embedded in a
                     <code class="literal">synchronized</code> statement (<a class="xref" href="jls-14.html#jls-14.19" title="14.19.&nbsp;The synchronized Statement">&sect;14.19</a>).
                  </p>
                  <div class="example"><a name="d5e23818"></a><p class="title"><b>Example&nbsp;15.12.4.5-1.&nbsp;Invoked Method Signature Has Different Erasure Than
                           Compile-Time Method Signature</b></p>
                     <div class="example-contents">
                        <p class="note">Consider the declarations:</p><pre class="programlisting">
abstract class C&lt;T&gt; {
    abstract T id(T x);
}
class D extends C&lt;String&gt; {
    String id(String x) { return x; }
}
</pre><p class="note">Now, given an invocation:</p><pre class="screen">
C c = new D();
c.id(new Object());  // fails with a ClassCastException
</pre><p class="note">The erasure of the actual method being
                           invoked, <code class="literal">D.id()</code>, differs in its signature from that
                           of the compile-time method declaration, <code class="literal">C.id()</code>. The
                           former takes an argument of type <code class="literal">String</code> while the latter takes an
                           argument of type <code class="literal">Object</code>. The invocation fails with a <code class="literal">ClassCastException</code> before
                           the body of the method is executed.
                        </p>
                        <p class="note">Such situations can only arise if the program gives
                           rise to a compile-time unchecked warning (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>,
                           <a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>, <a class="xref" href="jls-5.html#jls-5.5.2" title="5.5.2.&nbsp;Checked Casts and Unchecked Casts">&sect;5.5.2</a>,
                           <a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>, <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>,
                           <a class="xref" href="jls-8.html#jls-8.4.8.4" title="8.4.8.4.&nbsp;Inheriting Methods with Override-Equivalent Signatures">&sect;8.4.8.4</a>, <a class="xref" href="jls-9.html#jls-9.4.1.2" title="9.4.1.2.&nbsp;Requirements in Overriding">&sect;9.4.1.2</a>,
                           <a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>).
                        </p>
                        <p class="note">Implementations can enforce these semantics by
                           creating <span class="emphasis"><em>bridge methods</em></span>. In the above example,
                           the following bridge method would be created in
                           class <code class="literal">D</code>:
                        </p><pre class="screen">
Object id(Object x) { return id((String) x); }
</pre><p class="note">This is the method that would actually be invoked by
                           the Java Virtual Machine in response to the call <code class="literal">c.id(new
                              Object())</code> shown above, and it will execute the cast and
                           fail, as required.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
            </div>
         </div>
         <div class="section" title="15.13.&nbsp;Array Access Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.13"></a>15.13.&nbsp;Array Access Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.13-100"></a>An array
               access expression refers to a variable that is a component of an
               array.
            </p>
            <div class="literallayout">
               <p><br>
                  ArrayAccess:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ExpressionName&nbsp;<code class="literal">[</code>&nbsp;Expression&nbsp;<code class="literal">]</code><br>
                  &nbsp;&nbsp;&nbsp;&nbsp;PrimaryNoNewArray&nbsp;<code class="literal">[</code>&nbsp;Expression&nbsp;<code class="literal">]</code><br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.13-120"></a>An array
               access expression contains two subexpressions, the <span class="emphasis"><em>array
                     reference expression</em></span> (before the left bracket) and
               the <span class="emphasis"><em>index expression</em></span> (within the
               brackets).
            </p>
            <p class="note">Note that the array reference expression may be a
               name or any primary expression that is not an array creation
               expression (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation Expressions">&sect;15.10</a>).
            </p>
            <p class="norm-error"><a name="jls-15.13-200"></a>The type of
               the array reference expression must be an array type (call it
               <span class="type">T</span><code class="literal">[]</code>, an array whose components are of type <span class="type">T</span>), or a
               compile-time error occurs.
            </p>
            <p class="norm-error"><a name="jls-15.13-210"></a>The index
               expression undergoes unary numeric promotion
               (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>). The promoted type must be <code class="literal">int</code>, or a
               compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.13-220"></a>The type
               of the array access expression is the result of applying capture
               conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to <span class="type">T</span>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.13-300"></a>The
               result of an array access expression is a variable of type <span class="type">T</span>, namely
               the variable within the array selected by the value of the index
               expression.
            </p>
            <p class="norm-dynamic"><a name="jls-15.13-310"></a>This
               resulting variable, which is a component of the array, is never
               considered <code class="literal">final</code>, even if the array reference expression denoted a
               <code class="literal">final</code> variable.
            </p>
            <div class="section" title="15.13.1.&nbsp;Run-Time Evaluation of Array Access">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.13.1"></a>15.13.1.&nbsp;Run-Time Evaluation of Array Access
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.13.1-100"></a>An array access expression
                  is evaluated using the following procedure:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.1-100-A"></a>First, the array reference expression
                               is evaluated. If this evaluation completes abruptly, then the
                               array access completes abruptly for the same reason and the index
                               expression is not evaluated.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.1-100-B"></a>Otherwise, the index expression is
                               evaluated. If this evaluation completes abruptly, then the array
                               access completes abruptly for the same reason.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.1-100-C"></a>Otherwise, if the value of the array
                               reference expression is <code class="literal">null</code>, then a <code class="literal">NullPointerException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.1-100-D"></a>Otherwise, the value of the array
                               reference expression indeed refers to an array. If the value of
                               the index expression is less than zero, or greater than or equal
                               to the array's <code class="literal">length</code>, then an <code class="literal">ArrayIndexOutOfBoundsException</code> is
                               thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.1-100-"></a>Otherwise, the result of the array
                               access is the variable of type <span class="type">T</span>, within the array, selected by
                               the value of the index expression.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e23892"></a><p class="title"><b>Example&nbsp;15.13-1.&nbsp;Array Reference Is Evaluated First</b></p>
                  <div class="example-contents">
                     <p class="note">In an array access, the expression to the left of
                        the brackets appears to be fully evaluated before any part of the
                        expression within the brackets is evaluated. For example, in the
                        (admittedly monstrous) expression <code class="literal">a[(a=b)[3]]</code>, the
                        expression <code class="literal">a</code> is fully evaluated before the
                        expression <code class="literal">(a=b)[3]</code>; this means that the original
                        value of <code class="literal">a</code> is fetched and remembered while the
                        expression <code class="literal">(a=b)[3]</code> is evaluated. This array
                        referenced by the original value of <code class="literal">a</code> is then
                        subscripted by a value that is element <code class="literal">3</code> of another
                        array (possibly the same array) that was referenced
                        by <code class="literal">b</code> and is now also referenced
                        by <code class="literal">a</code>.
                     </p>
                     <p class="note">Thus, the program:</p><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        int[] a = { 11, 12, 13, 14 };
        int[] b = { 0, 1, 2, 3 };
        System.out.println(a[(a=b)[3]]);
    }
}
</pre><p class="note">prints:</p><pre class="screen">
14
</pre><p class="note">because the monstrous expression's value is
                        equivalent to <code class="literal">a[b[3]]</code> or <code class="literal">a[3]</code>
                        or <code class="literal">14</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e23912"></a><p class="title"><b>Example&nbsp;15.13-2.&nbsp;Abrupt Completion of Array Reference Evaluation</b></p>
                  <div class="example-contents">
                     <p class="note">If evaluation of the expression to the left of the
                        brackets completes abruptly, no part of the expression within the
                        brackets will appear to have been evaluated. Thus, the program:
                     </p><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        int index = 1;
        try {
            skedaddle()[index=2]++;
        } catch (Exception e) {
            System.out.println(e + ", index=" + index);
        }
    }
    static int[] skedaddle() throws Exception {
        throw new Exception("Ciao");
    }
}
</pre><p class="note">prints:</p><pre class="screen">
java.lang.Exception: Ciao, index=1
</pre><p class="note">because the embedded assignment
                        of <code class="literal">2</code> to <code class="literal">index</code> never
                        occurs.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e23921"></a><p class="title"><b>Example&nbsp;15.13-3.&nbsp;<code class="literal">null</code> Array Reference</b></p>
                  <div class="example-contents">
                     <p class="note">If the array reference expression produces <code class="literal">null</code>
                        instead of a reference to an array, then a <code class="literal">NullPointerException</code> is thrown at run
                        time, but only after all parts of the array access expression have
                        been evaluated and only if these evaluations completed normally. Thus,
                        the program:
                     </p><pre class="programlisting">
class Test3 {
    public static void main(String[] args) {
        int index = 1;
        try {
            nada()[index=2]++;
        } catch (Exception e) {
            System.out.println(e + ", index=" + index);
        }
    }
    static int[] nada() { return null; }
}
</pre><p class="note">prints:</p><pre class="screen">
java.lang.NullPointerException, index=2
</pre><p class="note">because the embedded assignment
                        of <code class="literal">2</code> to <code class="literal">index</code> occurs before the
                        check for a <code class="literal">null</code> array reference expression. As a related example,
                        the program:
                     </p><pre class="programlisting">
class Test4 {
    public static void main(String[] args) {
        int[] a = null;
        try {
            int i = a[vamoose()];
            System.out.println(i);
        } catch (Exception e) {
            System.out.println(e);
        }
    }
    static int vamoose() throws Exception {
        throw new Exception("Twenty-three skidoo!");
    }
}
</pre><p class="note">always prints:</p><pre class="screen">
java.lang.Exception: Twenty-three skidoo!
</pre><p class="note">A <code class="literal">NullPointerException</code> never occurs, because the index expression
                        must be completely evaluated before any part of the  array access occurs, and that includes the check as to
                        whether the value of the  array reference
                        expression is <code class="literal">null</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.14.&nbsp;Postfix Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.14"></a>15.14.&nbsp;Postfix Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.14-100"></a>Postfix expressions include
               uses of the postfix <code class="literal">++</code> and <code class="literal">--</code> operators. Names are
               not considered to be primary expressions (<a class="xref" href="jls-15.html#jls-15.8" title="15.8.&nbsp;Primary Expressions">&sect;15.8</a>),
               but are handled separately in the grammar to avoid certain
               ambiguities. They become interchangeable only here, at the level of
               precedence of postfix expressions.
            </p>
            <div class="literallayout">
               <p><br>
                  PostfixExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Primary<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ExpressionName<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;PostIncrementExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;PostDecrementExpression<br>
                  
               </p>
            </div>
            <div class="section" title="15.14.1.&nbsp;Expression Names">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.14.1"></a>15.14.1.&nbsp;Expression Names
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.14.1-100"></a>The rules for evaluating
                  expression names are given in <a class="xref" href="jls-6.html#jls-6.5.6" title="6.5.6.&nbsp;Meaning of Expression Names">&sect;6.5.6</a>.
               </p>
            </div>
            <div class="section" title="15.14.2.&nbsp;Postfix Increment Operator ++">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.14.2"></a>15.14.2.&nbsp;Postfix Increment Operator <code class="literal">++</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.14.2-100"></a>A postfix expression
                  followed by a <code class="literal">++</code> operator is a postfix increment
                  expression.
               </p>
               <div class="literallayout">
                  <p><br>
                     PostIncrementExpression:<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;PostfixExpression&nbsp;<code class="literal">++</code><br>
                     
                  </p>
               </div>
               <p class="norm-error"><a name="jls-15.14.2-120"></a>The
                  result of the postfix expression must be a variable of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a numeric type, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.14.2-130"></a>The type
                  of the postfix increment expression is the type of the variable. The
                  result of the postfix increment expression is not a variable, but a
                  value.
               </p>
               <p class="norm-dynamic"><a name="jls-15.14.2-200"></a>At run
                  time, if evaluation of the operand expression completes abruptly, then
                  the postfix increment expression completes abruptly for the same
                  reason and no incrementation occurs. Otherwise, the
                  value <code class="literal">1</code> is added to the value of the variable and
                  the sum is stored back into the variable. Before the addition, binary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is performed on the
                  value <code class="literal">1</code> and the value of the variable. If
                  necessary, the sum is narrowed by a narrowing primitive conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>) and/or subjected to boxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to the type of the variable before it is
                  stored. The value of the postfix increment expression is the value of
                  the variable <span class="emphasis"><em>before</em></span> the new value is
                  stored.
               </p>
               <p class="note">Note that the binary numeric promotion mentioned
                  above may include unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>)
                  and value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). If necessary,
                  value set conversion is applied to the sum prior to its being stored
                  in the variable.
               </p>
               <p class="norm-static"><a name="jls-15.14.2-210"></a>A variable
                  that is declared <code class="literal">final</code> cannot be incremented  because when an access of
                  such a <code class="literal">final</code> variable is used as an expression, the result is a
                  value, not a variable. Thus, it cannot be used as the operand of a
                  postfix increment operator.
               </p>
            </div>
            <div class="section" title="15.14.3.&nbsp;Postfix Decrement Operator --">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.14.3"></a>15.14.3.&nbsp;Postfix Decrement Operator <code class="literal">--</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.14.3-100"></a>A postfix expression
                  followed by a <code class="literal">--</code> operator is a postfix decrement
                  expression.
               </p>
               <div class="literallayout">
                  <p><br>
                     PostDecrementExpression:<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;PostfixExpression&nbsp;<code class="literal">--</code><br>
                     
                  </p>
               </div>
               <p class="norm-error"><a name="jls-15.14.3-120"></a>The
                  result of the postfix expression must be a variable of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a numeric type, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.14.3-130"></a>The type
                  of the postfix decrement expression is the type of the variable. The
                  result of the postfix decrement expression is not a variable, but a
                  value.
               </p>
               <p class="norm-dynamic"><a name="jls-15.14.3-200"></a>At run
                  time, if evaluation of the operand expression completes abruptly, then
                  the postfix decrement expression completes abruptly for the same
                  reason and no decrementation occurs. Otherwise, the
                  value <code class="literal">1</code> is subtracted from the value of the
                  variable and the difference is stored back into the variable. Before
                  the subtraction, binary numeric promotion
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is performed on the
                  value <code class="literal">1</code> and the value of the variable. If
                  necessary, the difference is narrowed by a narrowing primitive
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>) and/or subjected to boxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to the type of the variable
                  before it is stored. The value of the postfix decrement expression is
                  the value of the variable <span class="emphasis"><em>before</em></span> the new value is
                  stored.
               </p>
               <p class="note">Note that the binary numeric promotion mentioned
                  above may include unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>)
                  and value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). If necessary,
                  value set conversion is applied to the difference prior to its being
                  stored in the variable.
               </p>
               <p class="norm-static"><a name="jls-15.14.3-210"></a>A variable
                  that is declared <code class="literal">final</code> cannot be decremented  because when an access of
                  such a <code class="literal">final</code> variable is used as an expression, the result is a
                  value, not a variable. Thus, it cannot be used as the operand of a
                  postfix decrement operator.
               </p>
            </div>
         </div>
         <div class="section" title="15.15.&nbsp;Unary Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.15"></a>15.15.&nbsp;Unary Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.15-100"></a>The operators <code class="literal">+</code>,
               <code class="literal">-</code>, <code class="literal">++</code>, <code class="literal">--</code>, <code class="literal">~</code>, <code class="literal">!</code>, and the cast
               operator (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>) are called the <span class="emphasis"><em>unary
                     operators</em></span>.
            </p>
            <div class="literallayout">
               <p><br>
                  UnaryExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;PreIncrementExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;PreDecrementExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">+</code>&nbsp;UnaryExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">-</code>&nbsp;UnaryExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;UnaryExpressionNotPlusMinus<br>
                  <br>
                  PreIncrementExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">++</code>&nbsp;UnaryExpression<br>
                  <br>
                  PreDecrementExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">--</code>&nbsp;UnaryExpression<br>
                  <br>
                  UnaryExpressionNotPlusMinus:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;PostfixExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">~</code>&nbsp;UnaryExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">!</code>&nbsp;UnaryExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;CastExpression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.15-120"></a>
               Expressions with unary operators group right-to-left, so
               that <code class="literal">-~x</code> means the same
               as <code class="literal">-(~x)</code>.
            </p>
            <div class="section" title="15.15.1.&nbsp;Prefix Increment Operator ++">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.1"></a>15.15.1.&nbsp;Prefix Increment Operator <code class="literal">++</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.15.1-100"></a>A unary expression preceded
                  by a <code class="literal">++</code> operator is a prefix increment expression.
               </p>
               <p class="norm-error"><a name="jls-15.15.1-110"></a>The
                  result of the unary expression must be a variable of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a numeric type, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.1-120"></a>The type
                  of the prefix increment expression is the type of the variable. The
                  result of the prefix increment expression is not a variable, but a
                  value.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.1-200"></a>At run
                  time, if evaluation of the operand expression completes abruptly, then
                  the prefix increment expression completes abruptly for the same reason
                  and no incrementation occurs. Otherwise, the
                  value <code class="literal">1</code> is added to the value of the variable and
                  the sum is stored back into the variable. Before the addition, binary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is performed on the
                  value <code class="literal">1</code> and the value of the variable. If
                  necessary, the sum is narrowed by a narrowing primitive conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>) and/or subjected to boxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to the type of the variable before it is
                  stored. The value of the prefix increment expression is the value of
                  the variable <span class="emphasis"><em>after</em></span> the new value is
                  stored.
               </p>
               <p class="note">Note that the binary numeric promotion mentioned
                  above may include unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>)
                  and value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). If necessary,
                  value set conversion is applied to the sum prior to its being stored
                  in the variable.
               </p>
               <p class="norm-static"><a name="jls-15.15.1-210"></a>A variable
                  that is declared <code class="literal">final</code> cannot be incremented  because when an access of
                  such a <code class="literal">final</code> variable is used as an expression, the result is a
                  value, not a variable. Thus, it cannot be used as the operand of a
                  prefix increment operator.
               </p>
            </div>
            <div class="section" title="15.15.2.&nbsp;Prefix Decrement Operator --">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.2"></a>15.15.2.&nbsp;Prefix Decrement Operator <code class="literal">--</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.15.2-100"></a>A unary expression preceded
                  by a <code class="literal">--</code> operator is a prefix decrement expression.
               </p>
               <p class="norm-error"><a name="jls-15.15.2-110"></a>The
                  result of the unary expression must be a variable of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a numeric type, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.2-120"></a>The type
                  of the prefix decrement expression is the type of the variable. The
                  result of the prefix decrement expression is not a variable, but a
                  value.
               </p>
               <p class="norm"><a name="jls-15.15.2-200"></a>At run time, if evaluation
                  of the operand expression completes abruptly, then the prefix
                  decrement expression completes abruptly for the same reason and no
                  decrementation occurs. Otherwise, the value <code class="literal">1</code> is
                  subtracted from the value of the variable and the difference is stored
                  back into the variable. Before the subtraction, binary numeric
                  promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is performed on the
                  value <code class="literal">1</code> and the value of the variable. If
                  necessary, the difference is narrowed by a narrowing primitive
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>) and/or subjected to boxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to the type of the variable
                  before it is stored. The value of the prefix decrement expression is
                  the value of the variable <span class="emphasis"><em>after</em></span> the new value is
                  stored.
               </p>
               <p class="note">Note that the binary numeric promotion mentioned
                  above may include unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>)
                  and value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). If necessary,
                  format conversion is applied to the difference prior to its being
                  stored in the variable.
               </p>
               <p class="norm-static"><a name="jls-15.15.2-210"></a>A variable
                  that is declared <code class="literal">final</code> cannot be decremented  because when an access of
                  such a <code class="literal">final</code> variable is used as an expression, the result is a
                  value, not a variable. Thus, it cannot be used as the operand of a
                  prefix decrement operator.
               </p>
            </div>
            <div class="section" title="15.15.3.&nbsp;Unary Plus Operator +">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.3"></a>15.15.3.&nbsp;Unary Plus Operator <code class="literal">+</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.15.3-100"></a>The type
                  of the operand expression of the unary <code class="literal">+</code> operator
                  must be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a
                  primitive numeric type, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.3-110"></a>Unary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>) is performed on the
                  operand. The type of the unary plus expression is the promoted type of
                  the operand. The result of the unary plus expression is not a
                  variable, but a value, even if the result of the operand expression is
                  a variable.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.3-200"></a>At run
                  time, the value of the unary plus expression is the promoted value of
                  the operand.
               </p>
            </div>
            <div class="section" title="15.15.4.&nbsp;Unary Minus Operator -">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.4"></a>15.15.4.&nbsp;Unary Minus Operator <code class="literal">-</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.15.4-100"></a>The type
                  of the operand expression of the unary <code class="literal">-</code> operator
                  must be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a
                  primitive numeric type, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.4-110"></a>Unary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>) is performed on the
                  operand.
               </p>
               <p class="norm-static"><a name="jls-15.15.4-120"></a>The type
                  of the unary minus expression is the promoted type of the
                  operand.
               </p>
               <p class="norm-static"><a name="jls-15.15.4-130"></a>Note
                  that unary numeric promotion performs value set conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). Whatever value set the promoted
                  operand value is drawn from, the unary negation operation is carried
                  out and the result is drawn from that same value set. That result is
                  then subject to further value set conversion.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.4-200"></a>At run
                  time, the value of the unary minus expression is the arithmetic
                  negation of the promoted value of the operand.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.4-210"></a>For
                  integer values, negation is the same as subtraction from zero. The
                  Java programming language uses two's-complement representation for integers, and the
                  range of two's-complement values is not symmetric, so negation of the
                  maximum negative <code class="literal">int</code> or <code class="literal">long</code> results in that same maximum negative
                  number. Overflow occurs in this case, but no exception is thrown. For
                  all integer values <code class="literal">x</code>, <code class="literal">-x</code>
                  equals <code class="literal">(~x)+1</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.4-220"></a>For
                  floating-point values, negation is <span class="emphasis"><em>not</em></span> the same
                  as subtraction from zero, because if <code class="literal">x</code>
                  is <code class="literal">+0.0</code>, then <code class="literal">0.0-x</code>
                  is <code class="literal">+0.0</code>, but <code class="literal">-x</code>
                  is <code class="literal">-0.0</code>. Unary minus merely inverts the sign of a
                  floating-point number. Special cases of interest:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.15.4-220-A"></a>If the operand is NaN, the result is
                               NaN. (Recall that NaN has no sign
                               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>).)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.15.4-220-B"></a>If the operand is an infinity, the
                               result is the infinity of opposite sign.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.15.4-220-C"></a>If the operand is a zero, the result is
                               the zero of opposite sign.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.15.5.&nbsp;Bitwise Complement Operator ~">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.5"></a>15.15.5.&nbsp;Bitwise Complement Operator <code class="literal">~</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.15.5-100"></a>The type
                  of the operand expression of the unary <code class="literal">~</code> operator
                  must be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a
                  primitive integral type, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.5-110"></a>Unary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>) is performed on the
                  operand. The type of the unary bitwise complement expression is the
                  promoted type of the operand.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.5-200"></a>At run
                  time, the value of the unary bitwise complement expression is the
                  bitwise complement of the promoted value of the operand. In all
                  cases, <code class="literal">~x</code> equals <code class="literal">(-x)-1</code>.
               </p>
            </div>
            <div class="section" title="15.15.6.&nbsp;Logical Complement Operator !">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.6"></a>15.15.6.&nbsp;Logical Complement Operator <code class="literal">!</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.15.6-100"></a>The type
                  of the operand expression of the unary <code class="literal">!</code> operator
                  must be <code class="literal">boolean</code> or <code class="literal">Boolean</code>, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.6-110"></a>The type
                  of the unary logical complement expression is <code class="literal">boolean</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.6-200"></a>At run
                  time, the operand is subject to unboxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) if necessary. The value of the unary
                  logical complement expression is <code class="literal">true</code> if the (possibly converted)
                  operand value is <code class="literal">false</code>, and <code class="literal">false</code> if the (possibly converted)
                  operand value is <code class="literal">true</code>.
               </p>
            </div>
         </div>
         <div class="section" title="15.16.&nbsp;Cast Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.16"></a>15.16.&nbsp;Cast Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-15.16-100"></a>A cast
               expression converts, at run time, a value of one numeric type to a
               similar value of another numeric type; or confirms, at compile time,
               that the type of an expression is <code class="literal">boolean</code>; or checks, at run time,
               that a reference value refers to an object whose class is compatible
               with a specified reference type.
            </p>
            <p class="norm"><a name="jls-15.16-110"></a>The parentheses and the type
               they contain are sometimes called the <span class="emphasis"><em>cast
                     operator</em></span>.
            </p>
            <div class="literallayout">
               <p><br>
                  CastExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">(</code>&nbsp;PrimitiveType&nbsp;<code class="literal">)</code>&nbsp;UnaryExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">(</code>&nbsp;ReferenceType&nbsp;<code class="literal">)</code>&nbsp;UnaryExpressionNotPlusMinus<br>
                  
               </p>
            </div>
            <p class="note">See <a class="xref" href="jls-15.html#jls-15.15" title="15.15.&nbsp;Unary Operators">&sect;15.15</a> for a discussion of
               the distinction between <span class="emphasis"><em>UnaryExpression</em></span>
               and <span class="emphasis"><em>UnaryExpressionNotPlusMinus</em></span>.
            </p>
            <p class="norm-static"><a name="jls-15.16-200"></a>The type
               of a cast expression is the result of applying capture conversion
               (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to the type whose name appears within
               the parentheses.
            </p>
            <p class="norm-static"><a name="jls-15.16-210"></a>The result
               of a cast expression is not a variable, but a value, even if the
               result of the operand expression is a variable.
            </p>
            <p class="norm-dynamic"><a name="jls-15.16-220"></a>A cast
               operator has no effect on the choice of value set
               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>) for a value of type <code class="literal">float</code> or type
               <code class="literal">double</code>. Consequently, a cast to type <code class="literal">float</code> within an expression
               that is not FP-strict (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>) does not
               necessarily cause its value to be converted to an element of the float
               value set, and a cast to type <code class="literal">double</code> within an expression that is
               not FP-strict does not necessarily cause its value to be converted to
               an element of the double value set.
            </p>
            <p class="norm-error"><a name="jls-15.16-300"></a>It is a
               compile-time error if the compile-time type of the operand may never
               be cast to the type specified by the cast operator according to the
               rules of casting conversion (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Conversion">&sect;5.5</a>).
            </p>
            <p class="note">Some casts result in an error at compile time. Some
               casts can be proven, at compile time, always to be correct at run
               time. For example, it is always correct to convert a value of a class
               type to the type of its superclass; such a cast should require no
               special action at run time. Finally, some casts cannot be proven to be
               either always correct or always incorrect at compile time. Such casts
               require a test at run time. See <a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Conversion">&sect;5.5</a> for
               details.
            </p>
            <p class="norm-dynamic"><a name="jls-15.16-310"></a>Otherwise, at run time, the operand value is
               converted (if necessary) by casting conversion to the type specified
               by the cast operator.
            </p>
            <p class="norm-dynamic"><a name="jls-15.16-400"></a>A <code class="literal">ClassCastException</code>
               is thrown if a cast is found at run time to be impermissible.
            </p>
         </div>
         <div class="section" title="15.17.&nbsp;Multiplicative Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.17"></a>15.17.&nbsp;Multiplicative Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.17-100"></a>The operators <code class="literal">*</code>,
               <code class="literal">/</code>, and <code class="literal">%</code> are called the <span class="emphasis"><em>multiplicative
                     operators</em></span>.
            </p>
            <div class="literallayout">
               <p><br>
                  MultiplicativeExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;UnaryExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;MultiplicativeExpression&nbsp;<code class="literal">*</code>&nbsp;UnaryExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;MultiplicativeExpression&nbsp;<code class="literal">/</code>&nbsp;UnaryExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;MultiplicativeExpression&nbsp;<code class="literal">%</code>&nbsp;UnaryExpression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.17-120"></a>The
               multiplicative operators have the same precedence and are
               syntactically left-associative (they group left-to-right).
            </p>
            <p class="norm-error"><a name="jls-15.17-200"></a>The type of
               each of the operands of a multiplicative operator must be a type that
               is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a primitive numeric
               type, or a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.17-300"></a>Binary
               numeric promotion is performed on the operands
               (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
            </p>
            <p class="note">Note that binary numeric promotion performs value
               set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may perform unboxing
               conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
            </p>
            <p class="norm-static"><a name="jls-15.17-310"></a>The type
               of a multiplicative expression is the promoted type of its
               operands.
            </p>
            <p class="norm-dynamic"><a name="jls-15.17-320"></a>If the
               promoted type is <code class="literal">int</code> or <code class="literal">long</code>, then integer arithmetic is
               performed.
            </p>
            <p class="norm-dynamic"><a name="jls-15.17-330"></a>If the
               promoted type is <code class="literal">float</code> or <code class="literal">double</code>, then floating-point arithmetic
               is performed.
            </p>
            <div class="section" title="15.17.1.&nbsp;Multiplication Operator *">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.17.1"></a>15.17.1.&nbsp;Multiplication Operator <code class="literal">*</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.1-100"></a>The
                  binary <code class="literal">*</code> operator performs multiplication,
                  producing the product of its operands.
               </p>
               <p class="norm-static"><a name="jls-15.17.1-110"></a>Multiplication is a commutative operation if
                  the operand expressions have no side effects.
               </p>
               <p class="norm-static"><a name="jls-15.17.1-120"></a>Integer
                  multiplication is associative when the operands are all of the same
                  type.
               </p>
               <p class="norm-static"><a name="jls-15.17.1-130"></a>Floating-point multiplication is not
                  associative.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.1-200"></a>If an
                  integer multiplication overflows, then the result is the low-order
                  bits of the mathematical product as represented in some sufficiently
                  large two's-complement format. As a result, if overflow occurs, then
                  the sign of the result may not be the same as the sign of the
                  mathematical product of the two operand values.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.1-300"></a>The
                  result of a floating-point multiplication is determined by the rules
                  of IEEE 754 arithmetic:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-A"></a>If either operand is NaN, the result is
                               NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-B"></a>If the result is not NaN, the sign of
                               the result is positive if both operands have the same sign, and
                               negative if the operands have different signs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-C"></a>Multiplication of an infinity by a zero
                               results in NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-D"></a>Multiplication of an infinity by a
                               finite value results in a signed infinity. The sign is determined
                               by the rule stated above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-E"></a>In the remaining cases, where neither
                               an infinity nor NaN is involved, the exact mathematical product is
                               computed. A floating-point value set is then chosen:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.17.1-300-E-1"></a>If the
                                    	multiplication expression is FP-strict
                                    	(<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>):
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.1-300-E-1-1"></a>If the type of the
                                             	    multiplication expression is <code class="literal">float</code>, then the float value
                                             	    set must be chosen.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.1-300-E-1-2"></a>If the type of the
                                             	    multiplication expression is <code class="literal">double</code>, then the double
                                             	    value set must be chosen.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.17.1-300-E-2"></a>If the
                                    	multiplication expression is not FP-strict:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.1-300-E-2-1"></a>If the type of the
                                             	    multiplication expression is <code class="literal">float</code>, then either the
                                             	    float value set or the float-extended-exponent value set
                                             	    may be chosen, at the whim of the implementation.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.1-300-E-2-2"></a>If the type of the
                                             	    multiplication expression is <code class="literal">double</code>, then either the
                                             	    double value set or the double-extended-exponent value set
                                             	    may be chosen, at the whim of the implementation.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-E.1"></a>Next, a value must be chosen from the
                               chosen value set to represent the product.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-E.2"></a>If the magnitude of the product is
                               too large to represent, we say the operation overflows; the result
                               is then an infinity of appropriate sign.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-E.3"></a>Otherwise, the product is rounded to
                               the nearest value in the chosen value set using IEEE 754
                               round-to-nearest mode. The Java programming language requires support of gradual
                               underflow as defined by IEEE 754
                               (<a class="xref" href="jls-4.html#jls-4.2.4" title="4.2.4.&nbsp;Floating-Point Operations">&sect;4.2.4</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.1-400"></a>Despite
                  the fact that overflow, underflow, or loss of information may occur,
                  evaluation of a multiplication operator <code class="literal">*</code> never throws a
                  run-time exception.
               </p>
            </div>
            <div class="section" title="15.17.2.&nbsp;Division Operator /">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.17.2"></a>15.17.2.&nbsp;Division Operator <code class="literal">/</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.2-100"></a>The
                  binary <code class="literal">/</code> operator performs division, producing the
                  quotient of its operands. The left-hand operand is
                  the <span class="emphasis"><em>dividend</em></span> and the right-hand operand is
                  the <span class="emphasis"><em>divisor</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.2-200"></a>Integer
                  division rounds toward <code class="literal">0</code>. That is, the quotient
                  produced for operands <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>d</em></span> that are integers after binary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is an integer value
                  <span class="emphasis"><em>q</em></span> whose magnitude is as large as possible while satisfying
                  |<span class="emphasis"><em>d</em></span> &middot; <span class="emphasis"><em>q</em></span>| &#8804; |<span class="emphasis"><em>n</em></span>|. Moreover, <span class="emphasis"><em>q</em></span> is positive
                  when |<span class="emphasis"><em>n</em></span>| &#8805; |<span class="emphasis"><em>d</em></span>| and <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>d</em></span> have the same sign,
                  but <span class="emphasis"><em>q</em></span> is negative when |<span class="emphasis"><em>n</em></span>| &#8805; |<span class="emphasis"><em>d</em></span>| and <span class="emphasis"><em>n</em></span> and
                  <span class="emphasis"><em>d</em></span> have opposite signs.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.2-210"></a>There
                  is one special case that does not satisfy this rule: if the dividend
                  is the negative integer of largest possible magnitude for its type,
                  and the divisor is <code class="literal">-1</code>, then integer overflow occurs
                  and the result is equal to the dividend. Despite the overflow, no
                  exception is thrown in this case. On the other hand, if the value of
                  the divisor in an integer division is <code class="literal">0</code>, then an
                  <code class="literal">ArithmeticException</code> is thrown.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.2-300"></a>The
                  result of a floating-point division is determined by the rules of IEEE
                  754 arithmetic:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-A"></a>If either operand is NaN, the result is
                               NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-B"></a>If the result is not NaN, the sign of
                               the result is positive if both operands have the same sign, and
                               negative if the operands have different signs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-C"></a>Division of an infinity by an infinity
                               results in NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-D"></a>Division of an infinity by a finite
                               value results in a signed infinity. The sign is determined by the
                               rule stated above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-E"></a>Division of a finite value by an
                               infinity results in a signed zero. The sign is determined by the
                               rule stated above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-F"></a>Division of a zero by a zero results in
                               NaN; division of zero by any other finite value results in a
                               signed zero. The sign is determined by the rule stated
                               above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-G"></a>Division of a nonzero finite value by a
                               zero results in a signed infinity. The sign is determined by the
                               rule stated above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-H"></a>In
                               the remaining cases, where neither an infinity nor NaN is
                               involved, the exact mathematical quotient is computed. A
                               floating-point value set is then chosen:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.17.2-300-H-1"></a>If the division
                                    	expression is FP-strict (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>):
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.2-300-H-1-1"></a>If the type of the division
                                             	    expression is <code class="literal">float</code>, then the float value set must be
                                             	    chosen.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.2-300-H-1-2"></a>If the type of the division
                                             	    expression is <code class="literal">double</code>, then the double value set must be
                                             	    chosen.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.17.2-300-H-2"></a>If the division
                                    	expression is not FP-strict:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.2-300-H-2-1"></a>If the type of the division
                                             	    expression is <code class="literal">float</code>, then either the float value set or
                                             	    the float-extended-exponent value set may be chosen, at
                                             	    the whim of the implementation.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.2-300-H-2-2"></a>If the type of the division
                                             	    expression is <code class="literal">double</code>, then either the double value set
                                             	    or the double-extended-exponent value set may be chosen,
                                             	    at the whim of the implementation.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-H.1"></a>Next, a value must be chosen from the
                               chosen value set to represent the quotient.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-H.2"></a>If the magnitude of the quotient is
                               too large to represent, we say the operation overflows; the result
                               is then an infinity of appropriate sign.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-H.3"></a>Otherwise, the quotient is rounded to
                               the nearest value in the chosen value set using IEEE 754
                               round-to-nearest mode. The Java programming language requires support of gradual
                               underflow as defined by IEEE 754
                               (<a class="xref" href="jls-4.html#jls-4.2.4" title="4.2.4.&nbsp;Floating-Point Operations">&sect;4.2.4</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.2-400"></a>Despite
                  the fact that overflow, underflow, division by zero, or loss of
                  information may occur, evaluation of a floating-point division
                  operator <code class="literal">/</code> never throws a run-time exception.
               </p>
            </div>
            <div class="section" title="15.17.3.&nbsp;Remainder Operator %">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.17.3"></a>15.17.3.&nbsp;Remainder Operator <code class="literal">%</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.17.3-100"></a>The
                  binary <code class="literal">%</code> operator is said to yield the remainder of
                  its operands from an implied division; the left-hand operand is
                  the <span class="emphasis"><em>dividend</em></span> and the right-hand operand is
                  the <span class="emphasis"><em>divisor</em></span>.
               </p>
               <p class="norm"><a name="jls-15.17.3-110"></a>In C and C++, the remainder
                  operator accepts only integral operands, but in the Java programming language, it
                  also accepts floating-point operands.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.3-200"></a>The
                  remainder operation for operands that are integers after binary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) produces a result
                  value such that <code class="literal">(a/b)*b+(a%b)</code> is equal
                  to <code class="literal">a</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.3-210"></a>This
                  identity holds even in the special case that the dividend is the
                  negative integer of largest possible magnitude for its type and the
                  divisor is <code class="literal">-1</code> (the remainder
                  is <code class="literal">0</code>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.3-220"></a>It
                  follows from this rule that the result of the remainder operation can
                  be negative only if the dividend is negative, and can be positive only
                  if the dividend is positive. Moreover, the magnitude of the result is
                  always less than the magnitude of the divisor.
               </p>
               <p class="norm-error"><a name="jls-15.17.3-230"></a>If the
                  value of the divisor for an integer remainder operator
                  is <code class="literal">0</code>, then an <code class="literal">ArithmeticException</code> is
                  thrown.
               </p>
               <div class="example"><a name="d5e24327"></a><p class="title"><b>Example&nbsp;15.17.3-1.&nbsp;Integer Remainder Operator</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        int a = 5%3;  // 2
        int b = 5/3;  // 1
        System.out.println("5%3 produces " + a +
                           " (note that 5/3 produces " + b + ")");

        int c = 5%(-3);  // 2
        int d = 5/(-3);  // -1
        System.out.println("5%(-3) produces " + c +
                           " (note that 5/(-3) produces " + d + ")");

        int e = (-5)%3;  // -2
        int f = (-5)/3;  // -1
        System.out.println("(-5)%3 produces " + e +
                           " (note that (-5)/3 produces " + f + ")");

        int g = (-5)%(-3);  // -2
        int h = (-5)/(-3);  // 1
        System.out.println("(-5)%(-3) produces " + g +
                           " (note that (-5)/(-3) produces " + h + ")");
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
5%3 produces 2 (note that 5/3 produces 1)
5%(-3) produces 2 (note that 5/(-3) produces -1)
(-5)%3 produces -2 (note that (-5)/3 produces -1)
(-5)%(-3) produces -2 (note that (-5)/(-3) produces 1)
</pre></div>
               </div><br class="example-break"><p class="norm"><a name="jls-15.17.3-300"></a>The result of a
                  floating-point remainder operation as computed by
                  the <code class="literal">%</code> operator is <span class="emphasis"><em>not</em></span> the same
                  as that produced by the remainder operation defined by IEEE 754. The
                  IEEE 754 remainder operation computes the remainder from a rounding
                  division, not a truncating division, and so its behavior
                  is <span class="emphasis"><em>not</em></span> analogous to that of the usual integer
                  remainder operator. Instead, the Java programming language
                  defines <code class="literal">%</code> on floating-point operations to behave in
                  a manner analogous to that of the integer remainder operator; this may
                  be compared with the C library function <code class="literal">fmod</code>. The
                  IEEE 754 remainder operation may be computed by the library
                  routine <code class="literal">Math.IEEEremainder</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.3-310"></a>The
                  result of a floating-point remainder operation is determined by the
                  rules of IEEE 754 arithmetic:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-A"></a>If either operand is NaN, the result is
                               NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-B"></a>If the result is not NaN, the sign of
                               the result equals the sign of the dividend.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-C"></a>If the dividend is an infinity, or the
                               divisor is a zero, or both, the result is NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-D"></a>If the dividend is finite and the
                               divisor is an infinity, the result equals the dividend.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-E"></a>If the dividend is a zero and the
                               divisor is finite, the result equals the dividend.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-F"></a>In the remaining cases, where neither
                               an infinity, nor a zero, nor NaN is involved, the floating-point
                               remainder <span class="emphasis"><em>r</em></span> from the division of a dividend <span class="emphasis"><em>n</em></span> by a
                               divisor <span class="emphasis"><em>d</em></span> is defined by the mathematical relation <span class="emphasis"><em>r</em></span> =
                               <span class="emphasis"><em>n</em></span> - (<span class="emphasis"><em>d</em></span> &middot; <span class="emphasis"><em>q</em></span>) where <span class="emphasis"><em>q</em></span> is an integer that
                               is negative only if <span class="emphasis"><em>n</em></span>/<span class="emphasis"><em>d</em></span> is negative and positive only if
                               <span class="emphasis"><em>n</em></span>/<span class="emphasis"><em>d</em></span> is positive, and whose magnitude is as large as
                               possible without exceeding the magnitude of the true mathematical
                               quotient of <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>d</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.3-400"></a>Evaluation of a floating-point remainder
                  operator <code class="literal">%</code> never throws a run-time exception, even
                  if the right-hand operand is zero. Overflow, underflow, or loss of
                  precision cannot occur.
               </p>
               <div class="example"><a name="d5e24369"></a><p class="title"><b>Example&nbsp;15.17.3-2.&nbsp;Floating-Point Remainder Operator</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        double a = 5.0%3.0;  // 2.0
        System.out.println("5.0%3.0 produces " + a);

        double b = 5.0%(-3.0);  // 2.0
        System.out.println("5.0%(-3.0) produces " + b);

        double c = (-5.0)%3.0;  // -2.0
        System.out.println("(-5.0)%3.0 produces " + c);

        double d = (-5.0)%(-3.0);  // -2.0
        System.out.println("(-5.0)%(-3.0) produces " + d);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
5.0%3.0 produces 2.0
5.0%(-3.0) produces 2.0
(-5.0)%3.0 produces -2.0
(-5.0)%(-3.0) produces -2.0
</pre></div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.18.&nbsp;Additive Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.18"></a>15.18.&nbsp;Additive Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.18-100"></a>The operators <code class="literal">+</code> and
               <code class="literal">-</code> are called the
               <span class="emphasis"><em>additive operators</em></span>.
            </p>
            <div class="literallayout">
               <p><br>
                  AdditiveExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;MultiplicativeExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;AdditiveExpression&nbsp;<code class="literal">+</code>&nbsp;MultiplicativeExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;AdditiveExpression&nbsp;<code class="literal">-</code>&nbsp;MultiplicativeExpression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.18-120"></a>The
               additive operators have the same precedence and are syntactically
               left-associative (they group left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.18-200"></a>If the
               type of either operand of a <code class="literal">+</code> operator is <code class="literal">String</code>,
               then the operation is string concatenation.
            </p>
            <p class="norm-error"><a name="jls-15.18-210"></a>Otherwise,
               the type of each of the operands of the <code class="literal">+</code> operator
               must be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a
               primitive numeric type, or a compile-time error occurs.
            </p>
            <p class="norm-error"><a name="jls-15.18-300"></a>In every
               case, the type of each of the operands of the
               binary <code class="literal">-</code> operator must be a type that is
               convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a primitive numeric type,
               or a compile-time error occurs.
            </p>
            <div class="section" title="15.18.1.&nbsp;String Concatenation Operator +">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.18.1"></a>15.18.1.&nbsp;String Concatenation Operator <code class="literal">+</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.18.1-100"></a>If only
                  one operand expression is of type <code class="literal">String</code>, then string conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.11" title="5.1.11.&nbsp;String Conversion">&sect;5.1.11</a>) is performed on the other operand to
                  produce a string at run time.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.1-110"></a>The
                  result of string concatenation is a reference to a
                  <code class="literal">String</code> object that is the concatenation of the two operand
                  strings. The characters of the left-hand operand precede the
                  characters of the right-hand operand in the newly created
                  string.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.1-120"></a>The
                  <code class="literal">String</code> object is newly created (<a class="xref" href="jls-12.html#jls-12.5" title="12.5.&nbsp;Creation of New Class Instances">&sect;12.5</a>) unless
                  the expression is a compile-time constant expression
                  (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>).
               </p>
               <p class="note">An implementation may choose to perform conversion
                  and concatenation in one step to avoid creating and then discarding an
                  intermediate <code class="literal">String</code> object. To increase the performance of repeated
                  string concatenation, a Java compiler may use
                  the <code class="literal">StringBuffer</code> class or a similar technique to
                  reduce the number of intermediate <code class="literal">String</code> objects that are created by
                  evaluation of an expression.
               </p>
               <p class="note">For primitive types, an implementation may also
                  optimize away the creation of a wrapper object by converting directly
                  from a primitive type to a string.
               </p>
               <div class="example"><a name="d5e24410"></a><p class="title"><b>Example&nbsp;15.18.1-1.&nbsp;String Concatenation</b></p>
                  <div class="example-contents">
                     <p class="note">The example expression:</p><pre class="screen">
"The square root of 2 is " + Math.sqrt(2)
</pre><p class="note">produces the result:</p><pre class="screen">
"The square root of 2 is 1.4142135623730952"
</pre><p class="note">The <code class="literal">+</code> operator is syntactically
                        left-associative, no matter whether it is determined by type analysis
                        to represent string concatenation or numeric addition. In some cases
                        care is required to get the desired result. For example, the
                        expression:
                     </p><pre class="screen">
a + b + c
</pre><p class="note">is always regarded as meaning:</p><pre class="screen">
(a + b) + c
</pre><p class="note">Therefore the result of the expression:</p><pre class="screen">
1 + 2 + " fiddlers"
</pre><p class="note">is:</p><pre class="screen">
"3 fiddlers"
</pre><p class="note">but the result of:</p><pre class="screen">
"fiddlers " + 1 + 2
</pre><p class="note">is:</p><pre class="screen">
"fiddlers 12"
</pre></div>
               </div><br class="example-break"><div class="example"><a name="d5e24429"></a><p class="title"><b>Example&nbsp;15.18.1-2.&nbsp;String Concatenation and Conditionals</b></p>
                  <div class="example-contents">
                     <p class="note">In this jocular little example:</p><pre class="programlisting">
class Bottles {
    static void printSong(Object stuff, int n) {
        String plural = (n == 1) ? "" : "s";
  loop: while (true) {
            System.out.println(n + " bottle" + plural
                    + " of " + stuff + " on the wall,");
            System.out.println(n + " bottle" + plural
                    + " of " + stuff + ";");
            System.out.println("You take one down "
                    + "and pass it around:");
            --n;
            plural = (n == 1) ? "" : "s";
            if (n == 0)
                break loop;
            System.out.println(n + " bottle" + plural
                    + " of " + stuff + " on the wall!");
            System.out.println();
        }
        System.out.println("No bottles of " +
                    stuff + " on the wall!");
    }

    public static void main(String[] args) {
        printSong("slime", 3);
    }
}
</pre><p class="note">the method <code class="literal">printSong</code> will print a
                        version of a children's song. Popular values
                        for <code class="literal">stuff</code> include "<code class="literal">pop</code>" and
                        "<code class="literal">beer</code>"; the most popular value
                        for <code class="literal">n</code> is <code class="literal">100</code>. Here is the output
                        that results from running the program:
                     </p><pre class="screen">
3 bottles of slime on the wall,
3 bottles of slime;
You take one down and pass it around:
2 bottles of slime on the wall!

2 bottles of slime on the wall,
2 bottles of slime;
You take one down and pass it around:
1 bottle of slime on the wall!

1 bottle of slime on the wall,
1 bottle of slime;
You take one down and pass it around:
No bottles of slime on the wall!
</pre><p class="note">In the code, note the careful conditional generation
                        of the singular "<code class="literal">bottle</code>" when appropriate rather
                        than the plural "<code class="literal">bottles</code>"; note also how the string
                        concatenation operator was used to break the long constant
                        string:
                     </p><pre class="screen">
"You take one down and pass it around:"
</pre><p class="note">into two pieces to avoid an inconveniently long line
                        in the source code.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.18.2.&nbsp;Additive Operators (+ and -) for Numeric Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.18.2"></a>15.18.2.&nbsp;Additive Operators (<code class="literal">+</code> and <code class="literal">-</code>) for Numeric Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.18.2-100"></a>The
                  binary <code class="literal">+</code> operator performs addition when applied to
                  two operands of numeric type, producing the sum of the
                  operands.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-110"></a>The
                  binary <code class="literal">-</code> operator performs subtraction, producing
                  the difference of two numeric operands.
               </p>
               <p class="norm-static"><a name="jls-15.18.2-200"></a>Binary
                  numeric promotion is performed on the operands
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
               </p>
               <p class="note">Note that binary numeric promotion performs value
                  set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may perform unboxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
               </p>
               <p class="norm-static"><a name="jls-15.18.2-210"></a>The type
                  of an additive expression on numeric operands is the promoted type of
                  its operands.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-220"></a>If this
                  promoted type is <code class="literal">int</code> or <code class="literal">long</code>, then integer arithmetic is
                  performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-230"></a>If this
                  promoted type is <code class="literal">float</code> or <code class="literal">double</code>, then floating-point arithmetic
                  is performed.
               </p>
               <p class="norm-static"><a name="jls-15.18.2-300"></a>Addition
                  is a commutative operation if the operand expressions have no side
                  effects.
               </p>
               <p class="norm-static"><a name="jls-15.18.2-310"></a>Integer
                  addition is associative when the operands are all of the same
                  type.
               </p>
               <p class="norm-static"><a name="jls-15.18.2-320"></a>Floating-point addition is not
                  associative.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-400"></a>If an
                  integer addition overflows, then the result is the low-order bits of
                  the mathematical sum as represented in some sufficiently large
                  two's-complement format. If overflow occurs, then the sign of the
                  result is not the same as the sign of the mathematical sum of the two
                  operand values.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-500"></a>The
                  result of a floating-point addition is determined using the following
                  rules of IEEE 754 arithmetic:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-A"></a>If either operand is NaN, the result is
                               NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-B"></a>The sum of two infinities of opposite
                               sign is NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-C"></a>The sum of two infinities of the same
                               sign is the infinity of that sign.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-D"></a>The sum of an infinity and a finite
                               value is equal to the infinite operand.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-E"></a>The sum of two zeros of opposite sign
                               is positive zero.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-F"></a>The sum of two zeros of the same sign
                               is the zero of that sign.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-G"></a>The sum of a zero and a nonzero finite
                               value is equal to the nonzero operand.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-H"></a>The sum of two nonzero finite values of
                               the same magnitude and opposite sign is positive zero.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-I"></a>In the remaining cases, where neither
                               an infinity, nor a zero, nor NaN is involved, and the operands
                               have the same sign or have different magnitudes, the exact
                               mathematical sum is computed. A floating-point value set is then
                               chosen:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.18.2-500-I-1"></a>If the addition
                                    	expression is FP-strict (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>):
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.18.2-500-I-1-1"></a>If the type of the addition
                                             	    expression is <code class="literal">float</code>, then the float value set must be
                                             	    chosen.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.18.2-500-I-1-2"></a>If the type of the addition
                                             	    expression is <code class="literal">double</code>, then the double value set must be
                                             	    chosen.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.18.2-500-I-2"></a>If the addition
                                    	expression is not FP-strict:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.18.2-500-I-2-1"></a>If the type of the addition
                                             	    expression is <code class="literal">float</code>, then either the float value set or
                                             	    the float-extended-exponent value set may be chosen, at
                                             	    the whim of the implementation.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.18.2-500-I-2-2"></a>If the type of the addition
                                             	    expression is <code class="literal">double</code>, then either the double value set
                                             	    or the double-extended-exponent value set may be chosen,
                                             	    at the whim of the implementation.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-I.1"></a>Next, a value must be chosen from the
                               chosen value set to represent the sum.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-I.2"></a>If the magnitude of the sum is too
                               large to represent, we say the operation overflows; the result is
                               then an infinity of appropriate sign.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-I.3"></a>Otherwise, the sum is rounded to the
                               nearest value in the chosen value set using IEEE 754
                               round-to-nearest mode. The Java programming language requires support of gradual
                               underflow as defined by IEEE 754
                               (<a class="xref" href="jls-4.html#jls-4.2.4" title="4.2.4.&nbsp;Floating-Point Operations">&sect;4.2.4</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.18.2-600"></a>The
                  binary <code class="literal">-</code> operator performs subtraction when applied
                  to two operands of numeric type, producing the difference of its
                  operands; the left-hand operand is the <span class="emphasis"><em>minuend</em></span>
                  and the right-hand operand is
                  the <span class="emphasis"><em>subtrahend</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-610"></a>For
                  both integer and floating-point subtraction, it is always the case
                  that <code class="literal">a-b</code> produces the same result
                  as <code class="literal">a+(-b)</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-620"></a>Note
                  that, for integer values, subtraction from zero is the same as
                  negation. However, for floating-point operands, subtraction from zero
                  is <span class="emphasis"><em>not</em></span> the same as negation, because if x
                  is <code class="literal">+0.0</code>, then <code class="literal">0.0-x</code>
                  is <code class="literal">+0.0</code>, but <code class="literal">-x</code>
                  is <code class="literal">-0.0</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-700"></a>Despite
                  the fact that overflow, underflow, or loss of information may occur,
                  evaluation of a numeric additive operator never throws a run-time
                  exception.
               </p>
            </div>
         </div>
         <div class="section" title="15.19.&nbsp;Shift Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.19"></a>15.19.&nbsp;Shift Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.19-100"></a>The operators <code class="literal">&lt;&lt;</code> (left
               shift), <code class="literal">&gt;&gt;</code> (signed right shift), and <code class="literal">&gt;&gt;&gt;</code> (unsigned right
               shift) are called the <span class="emphasis"><em>shift operators</em></span>. The
               left-hand operand of a shift operator is the value to be shifted; the
               right-hand operand specifies the shift distance.
            </p>
            <div class="literallayout">
               <p><br>
                  ShiftExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;AdditiveExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ShiftExpression&nbsp;<code class="literal">&lt;&lt;</code>&nbsp;AdditiveExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ShiftExpression&nbsp;<code class="literal">&gt;&gt;</code>&nbsp;AdditiveExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ShiftExpression&nbsp;<code class="literal">&gt;&gt;&gt;</code>&nbsp;AdditiveExpression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.19-120"></a>The shift
               operators are syntactically left-associative (they group
               left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.19-200"></a>Unary
               numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>) is performed on each
               operand separately. (Binary numeric promotion
               (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is <span class="emphasis"><em>not</em></span> performed on
               the operands.)
            </p>
            <p class="norm-error"><a name="jls-15.19-210"></a>It is a
               compile-time error if the type of each of the operands of a shift
               operator, after unary numeric promotion, is not a primitive integral
               type.
            </p>
            <p class="norm-static"><a name="jls-15.19-220"></a>The type
               of the shift expression is the promoted type of the left-hand
               operand.
            </p>
            <p class="norm-static"><a name="jls-15.19-300"></a>If the
               promoted type of the left-hand operand is <code class="literal">int</code>, only the five
               lowest-order bits of the right-hand operand are used as the shift
               distance. It is as if the right-hand operand were subjected to a
               bitwise logical AND operator <code class="literal">&amp;</code>
               (<a class="xref" href="jls-15.html#jls-15.22.1" title="15.22.1.&nbsp;Integer Bitwise Operators &amp;, ^, and |">&sect;15.22.1</a>) with the mask
               value <code class="literal">0x1f</code> (<code class="literal">0b11111</code>). The shift
               distance actually used is therefore always in the
               range <code class="literal">0</code> to <code class="literal">31</code>, inclusive.
            </p>
            <p class="norm-static"><a name="jls-15.19-310"></a>If the
               promoted type of the left-hand operand is <code class="literal">long</code>, then only the six
               lowest-order bits of the right-hand operand are used as the shift
               distance. It is as if the right-hand operand were subjected to a
               bitwise logical AND operator <code class="literal">&amp;</code>
               (<a class="xref" href="jls-15.html#jls-15.22.1" title="15.22.1.&nbsp;Integer Bitwise Operators &amp;, ^, and |">&sect;15.22.1</a>) with the mask
               value <code class="literal">0x3f</code> (<code class="literal">0b111111</code>). The shift
               distance actually used is therefore always in the
               range <code class="literal">0</code> to <code class="literal">63</code>, inclusive.
            </p>
            <p class="norm-dynamic"><a name="jls-15.19-400"></a>At run
               time, shift operations are performed on the two's-complement integer
               representation of the value of the left operand.
            </p>
            <p class="norm-dynamic"><a name="jls-15.19-410"></a>The value
               of <span class="emphasis"><em>n</em></span> <code class="literal">&lt;&lt;</code> <span class="emphasis"><em>s</em></span> is <span class="emphasis"><em>n</em></span> left-shifted <span class="emphasis"><em>s</em></span> bit positions;
               this is equivalent (even if overflow occurs) to multiplication by two
               to the power <span class="emphasis"><em>s</em></span>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.19-420"></a>The value
               of <span class="emphasis"><em>n</em></span> <code class="literal">&gt;&gt;</code> <span class="emphasis"><em>s</em></span> is <span class="emphasis"><em>n</em></span> right-shifted <span class="emphasis"><em>s</em></span> bit positions
               with sign-extension. The resulting value is &#8970; <span class="emphasis"><em>n</em></span> <code class="literal">/
                  2</code><sup><span class="emphasis"><em>s</em></span></sup> &#8971;. For
               non-negative values of <span class="emphasis"><em>n</em></span>, this is equivalent to truncating
               integer division, as computed by the integer division
               operator <code class="literal">/</code>, by two to the power <span class="emphasis"><em>s</em></span>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.19-430"></a>The value
               of <span class="emphasis"><em>n</em></span> <code class="literal">&gt;&gt;&gt;</code> <span class="emphasis"><em>s</em></span> is <span class="emphasis"><em>n</em></span> right-shifted <span class="emphasis"><em>s</em></span> bit
               positions with zero-extension, where:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.19-430-A"></a>If
                            <span class="emphasis"><em>n</em></span> is positive, then the result is the same as that of <span class="emphasis"><em>n</em></span>
                            <code class="literal">&gt;&gt;</code> <span class="emphasis"><em>s</em></span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.19-430-B"></a>If
                            <span class="emphasis"><em>n</em></span> is negative and the type of the left-hand operand is <code class="literal">int</code>,
                            then the result is equal to that of the expression
                              <code class="literal">(</code><span class="emphasis"><em>n</em></span> <code class="literal">&gt;&gt;</code> <span class="emphasis"><em>s</em></span><code class="literal">)</code> <code class="literal">+</code>
                              <code class="literal">(</code><code class="literal">2</code> <code class="literal">&lt;&lt;</code> <code class="literal">~</code><span class="emphasis"><em>s</em></span><code class="literal">)</code>.
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.19-430-C"></a>If
                            <span class="emphasis"><em>n</em></span> is negative and the type of the left-hand operand is
                            <code class="literal">long</code>, then the result is equal to that of the
                            expression 
                              <code class="literal">(</code><span class="emphasis"><em>n</em></span> <code class="literal">&gt;&gt;</code> <span class="emphasis"><em>s</em></span><code class="literal">)</code> <code class="literal">+</code>
                              <code class="literal">(</code><code class="literal">2L</code> <code class="literal">&lt;&lt;</code> <code class="literal">~</code><span class="emphasis"><em>s</em></span><code class="literal">)</code>.
                            
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">The added term <code class="literal">(</code><code class="literal">2</code>
               <code class="literal">&lt;&lt;</code> <code class="literal">~</code><span class="emphasis"><em>s</em></span><code class="literal">)</code> or
               <code class="literal">(</code><code class="literal">2L</code>
               <code class="literal">&lt;&lt;</code> <code class="literal">~</code><span class="emphasis"><em>s</em></span><code class="literal">)</code> cancels out the propagated
               sign bit.
            </p>
            <p class="note">Note that, because of the implicit masking of the
               right-hand operand of a shift operator, <code class="literal">~</code><span class="emphasis"><em>s</em></span> as
               a shift distance is equivalent to <code class="literal">31-</code><span class="emphasis"><em>s</em></span> when
               shifting an <code class="literal">int</code> value and to <code class="literal">63-</code><span class="emphasis"><em>s</em></span> when
               shifting a <code class="literal">long</code> value.
            </p>
         </div>
         <div class="section" title="15.20.&nbsp;Relational Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.20"></a>15.20.&nbsp;Relational Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.20-100"></a>The numerical comparison
               operators <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&lt;=</code>, and
               <code class="literal">&gt;=</code>, and the <code class="literal">instanceof</code> operator, are called
               the <span class="emphasis"><em>relational operators</em></span>.
            </p>
            <div class="literallayout">
               <p><br>
                  RelationalExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ShiftExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;RelationalExpression&nbsp;<code class="literal">&lt;</code>&nbsp;ShiftExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;RelationalExpression&nbsp;<code class="literal">&gt;</code>&nbsp;ShiftExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;RelationalExpression&nbsp;<code class="literal">&lt;=</code>&nbsp;ShiftExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;RelationalExpression&nbsp;<code class="literal">&gt;=</code>&nbsp;ShiftExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;RelationalExpression&nbsp;<code class="literal">instanceof</code>&nbsp;ReferenceType<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.20-120"></a>The
               relational operators are syntactically left-associative (they group
               left-to-right).
            </p>
            <p class="note">However, this fact is not useful. For
               example, <code class="literal">a&lt;b&lt;c</code> parses
               as <code class="literal">(a&lt;b)&lt;c</code>, which is always a compile-time
               error, because the type of <code class="literal">a&lt;b</code> is always
               <code class="literal">boolean</code> and &lt; is not an operator on <code class="literal">boolean</code> values.
            </p>
            <p class="norm-static"><a name="jls-15.20-200"></a>The type
               of a relational expression is always <code class="literal">boolean</code>.
            </p>
            <div class="section" title="15.20.1.&nbsp;Numerical Comparison Operators <, <=, &gt;, and &gt;=">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.20.1"></a>15.20.1.&nbsp;Numerical Comparison Operators <code class="literal">&lt;</code>,
                           <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.20.1-100"></a>The type
                  of each of the operands of a numerical comparison operator must be a
                  type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a primitive
                  numeric type, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.20.1-110"></a>Binary
                  numeric promotion is performed on the operands
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
               </p>
               <p class="note">Note that binary numeric promotion performs value
                  set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may perform unboxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.1-120"></a>If the
                  promoted type of the operands is <code class="literal">int</code> or <code class="literal">long</code>, then signed integer
                  comparison is performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.1-130"></a>If the
                  promoted type is <code class="literal">float</code> or <code class="literal">double</code>, then floating-point comparison
                  is performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.1-200"></a>Comparison is carried out accurately on
                  floating-point values, no matter what value sets their representing
                  values were drawn from.
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.1-210"></a>The
                  result of a floating-point comparison, as determined by the
                  specification of the IEEE 754 standard, is:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-210-A"></a>If either operand is NaN, then the
                               result is false.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-210-B"></a>All values other than NaN are ordered,
                               with negative infinity less than all finite values, and positive
                               infinity greater than all finite values.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-210-C"></a>Positive zero and negative zero are
                               considered equal.
                        </p>
                        <p class="note">For example, <code class="literal">-0.0&lt;0.0</code> is
                               <code class="literal">false</code>, but <code class="literal">-0.0&lt;=0.0</code> is <code class="literal">true</code>.
                        </p>
                        <p class="note">Note, however, that the
                               methods <code class="literal">Math.min</code>
                               and <code class="literal">Math.max</code> treat negative zero as being
                               strictly smaller than positive zero.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-15.20.1-220"></a>Subject to these
                  considerations for floating-point numbers, the following rules then
                  hold for integer operands or for floating-point operands other than
                  NaN:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-220-A"></a>The value produced by the <code class="literal">&lt;</code>
                               operator is <code class="literal">true</code> if the value of the left-hand operand is less
                               than the value of the right-hand operand, and otherwise is
                               <code class="literal">false</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-220-B"></a>The value produced by the
                               <code class="literal">&lt;=</code> operator is <code class="literal">true</code> if the value of the
                               left-hand operand is less than or equal to the value of the
                               right-hand operand, and otherwise is <code class="literal">false</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-220-C"></a>The value produced by the
                               <code class="literal">&gt;</code> operator is <code class="literal">true</code> if the value of the left-hand
                               operand is greater than the value of the right-hand operand, and
                               otherwise is <code class="literal">false</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-220-D"></a>The value produced by the
                               <code class="literal">&gt;=</code> operator is <code class="literal">true</code> if the value of the
                               left-hand operand is greater than or equal to the value of the
                               right-hand operand, and otherwise is <code class="literal">false</code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.20.2.&nbsp;Type Comparison Operator instanceof">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.20.2"></a>15.20.2.&nbsp;Type Comparison Operator <code class="literal">instanceof</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.20.2-100"></a>The type
                  of the <span class="emphasis"><em>RelationalExpression</em></span> operand of the
                  <code class="literal">instanceof</code> operator must be a reference type or the null type;
                  otherwise, a compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-15.20.2-110"></a>It is a
                  compile-time error if the <span class="emphasis"><em>ReferenceType</em></span> mentioned
                  after the <code class="literal">instanceof</code> operator does not denote a reference type that
                  is reifiable (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>).
               </p>
               <p class="norm-error"><a name="jls-15.20.2-120"></a>If a cast
                  of the <span class="emphasis"><em>RelationalExpression</em></span> to
                  the <span class="emphasis"><em>ReferenceType</em></span> would be rejected as a
                  compile-time error, then the <code class="literal">instanceof</code> relational expression
                  likewise produces a compile-time error. In such a situation, the
                  result of the <code class="literal">instanceof</code> expression could never be true.
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.2-200"></a>At run
                  time, the result of the <code class="literal">instanceof</code> operator is <code class="literal">true</code> if the value
                  of the <span class="emphasis"><em>RelationalExpression</em></span> is not <code class="literal">null</code> and the
                  reference could be cast (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>) to
                  the <span class="emphasis"><em>ReferenceType</em></span> without raising a
                  <code class="literal">ClassCastException</code>. Otherwise the result is <code class="literal">false</code>.
               </p>
               <div class="example"><a name="d5e24757"></a><p class="title"><b>Example&nbsp;15.20.2-1.&nbsp;The <code class="literal">instanceof</code> Operator</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point   { int x, y; }
class Element { int atomicNumber; }
class Test {
    public static void main(String[] args) {
        Point   p = new Point();
        Element e = new Element();
        if (e instanceof Point) {  // compile-time error
            System.out.println("I get your point!");
            p = (Point)e;  // compile-time error
        }
    }
}
</pre><p class="note">This program results in two compile-time errors. The
                        cast <code class="literal">(Point)e</code> is incorrect because no instance
                        of <code class="literal">Element</code> or any of its possible subclasses (none
                        are shown here) could possibly be an instance of any subclass
                        of <code class="literal">Point</code>. The <code class="literal">instanceof</code> expression is incorrect
                        for exactly the same reason. If, on the other hand, the
                        class <code class="literal">Point</code> were a subclass
                        of <code class="literal">Element</code> (an admittedly strange notion in this
                        example):
                     </p><pre class="programlisting">

class Point extends Element { int x, y; }

</pre><p class="note">then the cast would be possible, though it would
                        require a run-time check, and the <code class="literal">instanceof</code> expression would then
                        be sensible and valid. The cast <code class="literal">(Point)e</code> would
                        never raise an exception because it would not be executed if the value
                        of <code class="literal">e</code> could not correctly be cast to
                        type <code class="literal">Point</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.21.&nbsp;Equality Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.21"></a>15.21.&nbsp;Equality Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-15.21-100"></a>The
               operators <code class="literal">==</code> (equal to) and <code class="literal">!=</code>
               (not equal to) are called the <span class="emphasis"><em>equality
                     operators</em></span>.
            </p>
            <div class="literallayout">
               <p><br>
                  EqualityExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;RelationalExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;EqualityExpression&nbsp;<code class="literal">==</code>&nbsp;RelationalExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;EqualityExpression&nbsp;<code class="literal">!=</code>&nbsp;RelationalExpression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.21-120"></a>The
               equality operators are syntactically left-associative (they group
               left-to-right).
            </p>
            <p class="note">However, this fact is essentially never useful. For
               example, <code class="literal">a==b==c</code> parses
               as <code class="literal">(a==b)==c</code>. The result type
               of <code class="literal">a==b</code> is always <code class="literal">boolean</code>,
               and <code class="literal">c</code> must therefore be of type <code class="literal">boolean</code> or a
               compile-time error occurs. Thus, <code class="literal">a==b==c</code> does not
               test to see whether <code class="literal">a</code>, <code class="literal">b</code>,
               and <code class="literal">c</code> are all equal.
            </p>
            <p class="norm-static"><a name="jls-15.21-130"></a>The
               equality operators are commutative if the operand expressions have no
               side effects.
            </p>
            <p class="norm-static"><a name="jls-15.21-140"></a>The
               equality operators are analogous to the relational operators except
               for their lower precedence. Thus, <code class="literal">a&lt;b==c&lt;d</code> is
               <code class="literal">true</code> whenever <code class="literal">a&lt;b</code> and 
               <code class="literal">c&lt;d</code> have the same truth value.
            </p>
            <p class="norm-error"><a name="jls-15.21-200"></a>The
               equality operators may be used to compare two operands that are
               convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to numeric type, or two
               operands of type <code class="literal">boolean</code> or <code class="literal">Boolean</code>, or two operands that are each
               of either reference type or the null type. All other cases result in a
               compile-time error.
            </p>
            <p class="norm-static"><a name="jls-15.21-210"></a>The type
               of an equality expression is always <code class="literal">boolean</code>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.21-300"></a>In all
               cases, <code class="literal">a!=b</code> produces the same result
               as <code class="literal">!(a==b)</code>.
            </p>
            <div class="section" title="15.21.1.&nbsp;Numerical Equality Operators == and !=">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.21.1"></a>15.21.1.&nbsp;Numerical Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.21.1-100"></a>If the
                  operands of an equality operator are both of numeric type, or one is
                  of numeric type and the other is convertible
                  (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to numeric type, binary numeric
                  promotion is performed on the operands
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
               </p>
               <p class="note">Note that binary numeric promotion performs value
                  set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may perform unboxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.1-110"></a>If the
                  promoted type of the operands is <code class="literal">int</code> or <code class="literal">long</code>, then an integer
                  equality test is performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.1-120"></a>If the
                  promoted type is <code class="literal">float</code> or <code class="literal">double</code>, then a floating-point equality
                  test is performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.1-200"></a>Comparison is carried out accurately on
                  floating-point values, no matter what value sets their representing
                  values were drawn from.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.1-210"></a>Floating-point equality testing is performed
                  in accordance with the rules of the IEEE 754 standard:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-A"></a>If either operand is NaN, then the
                               result of <code class="literal">==</code> is <code class="literal">false</code> but the result
                               of <code class="literal">!=</code> is <code class="literal">true</code>.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-A.1"></a>Indeed, the
                               test <code class="literal">x!=x</code> is <code class="literal">true</code> if and only if the value
                               of <code class="literal">x</code> is NaN.
                        </p>
                        <p class="note">The methods <code class="literal">Float.isNaN</code>
                               and <code class="literal">Double.isNaN</code> may also be used to test
                               whether a value is NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-B"></a>Positive zero and negative zero are
                               considered equal.
                        </p>
                        <p class="note">For example, <code class="literal">-0.0==0.0</code> is
                               <code class="literal">true</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-C"></a>Otherwise, two distinct floating-point
                               values are considered unequal by the equality operators.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-C.1"></a>In particular, there is one value
                               representing positive infinity and one value representing negative
                               infinity; each compares equal only to itself, and each compares
                               unequal to all other values.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.21.1-220"></a>Subject
                  to these considerations for floating-point numbers, the following
                  rules then hold for integer operands or for floating-point operands
                  other than NaN:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-220-A"></a>The value produced by
                               the <code class="literal">==</code> operator is <code class="literal">true</code> if the value of the
                               left-hand operand is equal to the value of the right-hand operand;
                               otherwise, the result is <code class="literal">false</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-220-B"></a>The value produced by
                               the <code class="literal">!=</code> operator is <code class="literal">true</code> if the value of the
                               left-hand operand is not equal to the value of the right-hand
                               operand; otherwise, the result is <code class="literal">false</code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.21.2.&nbsp;Boolean Equality Operators == and !=">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.21.2"></a>15.21.2.&nbsp;Boolean Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.21.2-100"></a>If the
                  operands of an equality operator are both of type <code class="literal">boolean</code>, or if one
                  operand is of type <code class="literal">boolean</code> and the other is of type <code class="literal">Boolean</code>, then
                  the operation is boolean equality.
               </p>
               <p class="norm-static"><a name="jls-15.21.2-110"></a>The
                  boolean equality operators are associative.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.2-200"></a>If one
                  of the operands is of type <code class="literal">Boolean</code>, it is subjected to unboxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.2-300"></a>The
                  result of <code class="literal">==</code> is <code class="literal">true</code> if the operands (after any
                  required unboxing conversion) are both <code class="literal">true</code> or both <code class="literal">false</code>;
                  otherwise, the result is <code class="literal">false</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.2-400"></a>The
                  result of <code class="literal">!=</code> is <code class="literal">false</code> if the operands are both
                  <code class="literal">true</code> or both <code class="literal">false</code>; otherwise, the result is <code class="literal">true</code>.
               </p>
               <p class="note">Thus <code class="literal">!=</code> behaves the same
                  as <code class="literal">^</code> (<a class="xref" href="jls-15.html#jls-15.22.2" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">&sect;15.22.2</a>) when applied
                  to <code class="literal">boolean</code> operands.
               </p>
            </div>
            <div class="section" title="15.21.3.&nbsp;Reference Equality Operators == and !=">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.21.3"></a>15.21.3.&nbsp;Reference Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.21.3-100"></a>If the
                  operands of an equality operator are both of either reference type or
                  the null type, then the operation is object equality.
               </p>
               <p class="norm-error"><a name="jls-15.21.3-110"></a>It is a
                  compile-time error if it is impossible to convert the type of either
                  operand to the type of the other by a casting conversion
                  (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Conversion">&sect;5.5</a>). The run-time values of the two operands
                  would necessarily be unequal.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.3-200"></a>At
                  run time, the result of <code class="literal">==</code> is <code class="literal">true</code> if the operand
                  values are both <code class="literal">null</code> or both refer to the same object or array;
                  otherwise, the result is <code class="literal">false</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.3-300"></a>The
                  result of <code class="literal">!=</code> is <code class="literal">false</code> if the operand values are both
                  <code class="literal">null</code> or both refer to the same object or array; otherwise, the
                  result is <code class="literal">true</code>.
               </p>
               <p class="norm"><a name="jls-15.21.3-400"></a>While <code class="literal">==</code>
                  may be used to compare references of type <code class="literal">String</code>, such an equality
                  test determines whether or not the two operands refer to the same
                  <code class="literal">String</code> object. The result is <code class="literal">false</code> if the operands are distinct
                  <code class="literal">String</code> objects, even if they contain the same sequence of characters
                  (<a class="xref" href="jls-3.html#jls-3.10.5" title="3.10.5.&nbsp;String Literals">&sect;3.10.5</a>). The contents of two
                  strings <code class="literal">s</code> and <code class="literal">t</code> can be tested
                  for equality by the method
                  invocation <code class="literal">s.equals(t)</code>.
               </p>
            </div>
         </div>
         <div class="section" title="15.22.&nbsp;Bitwise and Logical Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.22"></a>15.22.&nbsp;Bitwise and Logical Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.22-100"></a>The <span class="emphasis"><em>bitwise
                     operators</em></span> and <span class="emphasis"><em>logical operators</em></span>
               include the AND operator <code class="literal">&amp;</code>, exclusive OR
               operator <code class="literal">^</code>, and inclusive OR
               operator <code class="literal">|</code>.
            </p>
            <div class="literallayout">
               <p><br>
                  AndExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;EqualityExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;AndExpression&nbsp;<code class="literal">&amp;</code>&nbsp;EqualityExpression<br>
                  <br>
                  ExclusiveOrExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;AndExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ExclusiveOrExpression&nbsp;<code class="literal">^</code>&nbsp;AndExpression<br>
                  <br>
                  InclusiveOrExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ExclusiveOrExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;InclusiveOrExpression&nbsp;<code class="literal">|</code>&nbsp;ExclusiveOrExpression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.22-120"></a>These
               operators have different precedence, with <code class="literal">&amp;</code>
               having the highest precedence and <code class="literal">|</code> the lowest
               precedence.
            </p>
            <p class="norm-static"><a name="jls-15.22-130"></a>Each of
               these operators is syntactically left-associative (each groups
               left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.22-140"></a>Each
               operator is commutative if the operand expressions have no side
               effects.
            </p>
            <p class="norm-static"><a name="jls-15.22-150"></a>Each
               operator is associative.
            </p>
            <p class="norm-error"><a name="jls-15.22-200"></a>The bitwise
               and logical operators may be used to compare two operands of numeric
               type or two operands of type <code class="literal">boolean</code>. All other cases result in a
               compile-time error.
            </p>
            <div class="section" title="15.22.1.&nbsp;Integer Bitwise Operators &amp;, ^, and |">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.22.1"></a>15.22.1.&nbsp;Integer Bitwise Operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.22.1-100"></a>When
                  both operands of an operator <code class="literal">&amp;</code>, 
                  <code class="literal">^</code>, or <code class="literal">|</code> are of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a primitive integral
                  type, binary numeric promotion is first performed on the operands
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
               </p>
               <p class="norm-static"><a name="jls-15.22.1-110"></a>The type
                  of the bitwise operator expression is the promoted type of the
                  operands.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.1-200"></a>For <code class="literal">&amp;</code>, the result
                  value is the bitwise AND of the operand values.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.1-210"></a>For <code class="literal">^</code>, the result value is
                  the bitwise exclusive OR of the operand values.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.1-220"></a>For <code class="literal">|</code>, the result value is
                  the bitwise inclusive OR of the operand values.
               </p>
               <div class="informalexample">
                  <p class="note">For example, the result of the expression:</p><pre class="screen">0xff00 &amp; 0xf0f0</pre><p class="note">is:</p><pre class="screen">0xf000</pre><p class="note">The result of the expression:</p><pre class="screen">0xff00 ^ 0xf0f0</pre><p class="note">is:</p><pre class="screen">0x0ff0</pre><p class="note">The result of the expression:</p><pre class="screen">0xff00 | 0xf0f0</pre><p class="note">is:</p><pre class="screen">0xfff0</pre></div>
            </div>
            <div class="section" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.22.2"></a>15.22.2.&nbsp;Boolean Logical Operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.22.2-100"></a>When
                  both operands of a <code class="literal">&amp;</code>, <code class="literal">^</code>,
                  or <code class="literal">|</code> operator are of type <code class="literal">boolean</code> or <code class="literal">Boolean</code>,
                  then the type of the bitwise operator expression is <code class="literal">boolean</code>. In all
                  cases, the operands are subject to unboxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) as necessary.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.2-200"></a>For <code class="literal">&amp;</code>, the result
                  value is <code class="literal">true</code> if both operand values are <code class="literal">true</code>; otherwise, the
                  result is <code class="literal">false</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.2-210"></a>For <code class="literal">^</code>, the result value is
                  <code class="literal">true</code> if the operand values are different; otherwise, the result is
                  <code class="literal">false</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.2-220"></a>For <code class="literal">|</code>, the result value is
                  <code class="literal">false</code> if both operand values are <code class="literal">false</code>; otherwise, the result is
                  <code class="literal">true</code>.
               </p>
            </div>
         </div>
         <div class="section" title="15.23.&nbsp;Conditional-And Operator &amp;&amp;">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.23"></a>15.23.&nbsp;Conditional-And Operator <code class="literal">&amp;&amp;</code></h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.23-100"></a>The
               conditional-and operator <code class="literal">&amp;&amp;</code> is like <code class="literal">&amp;</code>
               (<a class="xref" href="jls-15.html#jls-15.22.2" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">&sect;15.22.2</a>), but evaluates its right-hand operand
               only if the value of its left-hand operand is <code class="literal">true</code>.
            </p>
            <div class="literallayout">
               <p><br>
                  ConditionalAndExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;InclusiveOrExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ConditionalAndExpression&nbsp;<code class="literal">&amp;&amp;</code>&nbsp;InclusiveOrExpression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.23-120"></a>The
               conditional-and operator is syntactically left-associative (it groups
               left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.23-130"></a>The
               conditional-and operator is fully associative with respect to both
               side effects and result value. That is, for any
               expressions <code class="varname">a</code>, <code class="varname">b</code>,
               and <code class="varname">c</code>, evaluation of the
               expression <code class="literal">((<code class="varname">a</code>) <code class="literal">&amp;&amp;</code>
                  (<code class="varname">b</code>)) <code class="literal">&amp;&amp;</code> (<code class="varname">c</code>)</code>
               produces the same result, with the same side effects occurring in the
               same order, as evaluation of the
               expression <code class="literal">(<code class="varname">a</code>) <code class="literal">&amp;&amp;</code>
                  ((<code class="varname">b</code>) <code class="literal">&amp;&amp;</code>
                  (<code class="varname">c</code>))</code>.
            </p>
            <p class="norm-error"><a name="jls-15.23-200"></a>Each
               operand of the conditional-and operator must be of type <code class="literal">boolean</code> or
               <code class="literal">Boolean</code>, or a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.23-300"></a>The type
               of a conditional-and expression is always <code class="literal">boolean</code>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.23-400"></a>At run
               time, the left-hand operand expression is evaluated first; if the
               result has type <code class="literal">Boolean</code>, it is subjected to unboxing conversion
               (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.23-410"></a>If the
               resulting value is <code class="literal">false</code>, the value of the conditional-and
               expression is <code class="literal">false</code> and the right-hand operand expression is not
               evaluated.
            </p>
            <p class="norm-dynamic"><a name="jls-15.23-420"></a>If the
               value of the left-hand operand is <code class="literal">true</code>, then the right-hand
               expression is evaluated; if the result has type <code class="literal">Boolean</code>, it is
               subjected to unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>). The
               resulting value becomes the value of the conditional-and
               expression.
            </p>
            <p class="norm-dynamic"><a name="jls-15.23-430"></a>Thus,
               <code class="literal">&amp;&amp;</code> computes the same result as <code class="literal">&amp;</code> on
               <code class="literal">boolean</code> operands. It differs only in that the right-hand operand
               expression is evaluated conditionally rather than always.
            </p>
         </div>
         <div class="section" title="15.24.&nbsp;Conditional-Or Operator ||">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.24"></a>15.24.&nbsp;Conditional-Or Operator <code class="literal">||</code></h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.24-100"></a>The
               conditional-or operator <code class="literal">||</code> operator is like <code class="literal">|</code>
               (<a class="xref" href="jls-15.html#jls-15.22.2" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">&sect;15.22.2</a>), but evaluates its right-hand operand
               only if the value of its left-hand operand is <code class="literal">false</code>.
            </p>
            <div class="literallayout">
               <p><br>
                  ConditionalOrExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ConditionalAndExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ConditionalOrExpression&nbsp;<code class="literal">||</code>&nbsp;ConditionalAndExpression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.24-120"></a>The
               conditional-or operator is syntactically left-associative (it groups
               left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.24-130"></a>The
               conditional-or operator is fully associative with respect to both side
               effects and result value. That is, for any
               expressions <code class="varname">a</code>, <code class="varname">b</code>,
               and <code class="varname">c</code>, evaluation of the
               expression <code class="literal">((<code class="varname">a</code>) <code class="literal">||</code>
                  (<code class="varname">b</code>)) <code class="literal">||</code> (<code class="varname">c</code>)</code>
               produces the same result, with the same side effects occurring in the
               same order, as evaluation of the
               expression <code class="literal">(<code class="varname">a</code>) <code class="literal">||</code>
                  ((<code class="varname">b</code>) <code class="literal">||</code>
                  (<code class="varname">c</code>))</code>.
            </p>
            <p class="norm-error"><a name="jls-15.24-200"></a>Each
               operand of the conditional-or operator must be of type <code class="literal">boolean</code> or
               <code class="literal">Boolean</code>, or a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.24-300"></a>The type
               of a conditional-or expression is always <code class="literal">boolean</code>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.24-400"></a>At run
               time, the left-hand operand expression is evaluated first; if the
               result has type <code class="literal">Boolean</code>, it is subjected to unboxing conversion
               (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.24-410"></a>If the
               resulting value is <code class="literal">true</code>, the value of the conditional-or expression
               is <code class="literal">true</code> and the right-hand operand expression is not
               evaluated.
            </p>
            <p class="norm-dynamic"><a name="jls-15.24-420"></a>If the
               value of the left-hand operand is <code class="literal">false</code>, then the right-hand
               expression is evaluated; if the result has type <code class="literal">Boolean</code>, it is
               subjected to unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>). The
               resulting value becomes the value of the conditional-or
               expression.
            </p>
            <p class="norm-dynamic"><a name="jls-15.24-430"></a>Thus,
               <code class="literal">||</code> compures the same result as <code class="literal">|</code> on <code class="literal">boolean</code>
               or <code class="literal">Boolean</code> operands. It differs only in that the right-hand operand
               expression is evaluated conditionally rather than always.
            </p>
         </div>
         <div class="section" title="15.25.&nbsp;Conditional Operator ? :">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.25"></a>15.25.&nbsp;Conditional Operator <code class="literal">? :</code></h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.25-100"></a>The conditional operator
               <code class="literal">? :</code> uses the boolean value of one expression to decide which of
               two other expressions should be evaluated.
            </p>
            <div class="literallayout">
               <p><br>
                  ConditionalExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ConditionalOrExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ConditionalOrExpression&nbsp;<code class="literal">?</code>&nbsp;Expression&nbsp;<code class="literal">:</code>&nbsp;ConditionalExpression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.25-120"></a>The
               conditional operator is syntactically right-associative (it groups
               right-to-left). Thus, <code class="literal">a?b:c?d:e?f:g</code> means the same
               as <code class="literal">a?b:(c?d:(e?f:g))</code>.
            </p>
            <p class="norm"><a name="jls-15.25-200"></a>The conditional operator has
               three operand expressions. <code class="literal">?</code> appears between the first and second
               expressions, and <code class="literal">:</code> appears between the second and
               third expressions.
            </p>
            <p class="norm-error"><a name="jls-15.25-210"></a>The first
               expression must be of type <code class="literal">boolean</code> or <code class="literal">Boolean</code>, or a compile-time
               error occurs.
            </p>
            <p class="norm-error"><a name="jls-15.25-220"></a>It is a
               compile-time error for either the second or the third operand
               expression to be an invocation of a <code class="literal">void</code> method.
            </p>
            <p class="note">In fact, by the grammar of expression statements
               (<a class="xref" href="jls-14.html#jls-14.8" title="14.8.&nbsp;Expression Statements">&sect;14.8</a>), it is not permitted for a conditional
               expression to appear in any context where an invocation of a <code class="literal">void</code>
               method could appear.
            </p>
            <p class="norm-static"><a name="jls-15.25-300"></a>The type
               of a conditional expression is determined as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.25-300-A"></a>If
                            the second and third operands have the same type (which may be the
                            null type), then that is the type of the conditional
                            expression.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.25-300-B"></a>If one
                            of the second and third operands is of primitive type <span class="type">T</span>, and the
                            type of the other is the result of applying boxing conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to <span class="type">T</span>, then the type of the
                            conditional expression is <span class="type">T</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.25-300-C"></a>If
                            one of the second and third operands is of the null type and the
                            type of the other is a reference type, then the type of the
                            conditional expression is that reference type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.25-300-D"></a>Otherwise, if the second and third
                            operands have types that are convertible
                            (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to numeric types, then there are
                            several cases:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-D-1"></a>If one of the operands is of type
                                 	<code class="literal">byte</code> or <code class="literal">Byte</code> and the other is of type <code class="literal">short</code> or <code class="literal">Short</code>,
                                 	then the type of the conditional expression is <code class="literal">short</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-D-2"></a>If one of the operands is of type
                                 	<span class="type">T</span> where <span class="type">T</span> is <code class="literal">byte</code>, <code class="literal">short</code>, or <code class="literal">char</code>, and the other
                                 	operand is a constant expression (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>)
                                 	of type <code class="literal">int</code> whose value is representable in type <span class="type">T</span>, then
                                 	the type of the conditional expression is <span class="type">T</span>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-D-3"></a>If one of the operands is of type <span class="type">T</span>, where <span class="type">T</span>
                                 	is <code class="literal">Byte</code>, <code class="literal">Short</code>, or <code class="literal">Character</code>, and the other operand is a
                                 	constant expression (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>) of type
                                 	<code class="literal">int</code> whose value is representable in the type <span class="type">U</span> which is
                                 	the result of applying unboxing conversion to <span class="type">T</span>, then the
                                 	type of the conditional expression is <span class="type">U</span>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-D-4"></a>Otherwise, binary numeric promotion
                                 	(<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is applied to the operand types,
                                 	and the type of the conditional expression is the promoted
                                 	type of the second and third operands.
                              </p>
                              <p class="note">Note that binary numeric promotion performs
                                 	 value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may
                                 	 perform unboxing conversion
                                 	 (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.25-300-E"></a>Otherwise, the second and third operands
                            are of types <span class="type">S<sub>1</sub></span> and <span class="type">S<sub>2</sub></span> respectively. Let <span class="type">T<sub>1</sub></span> be the type that
                            results from applying boxing conversion to <span class="type">S<sub>1</sub></span>, and let <span class="type">T<sub>2</sub></span> be
                            the type that results from applying boxing conversion to
                            <span class="type">S<sub>2</sub></span>.
                     </p>
                     <p class="norm-static"><a name="jls-15.25-300-E.1"></a>The type of the conditional expression
                            is the result of applying capture conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to lub(<span class="type">T<sub>1</sub></span>, <span class="type">T<sub>2</sub></span>)
                            (<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>).
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-dynamic"><a name="jls-15.25-400"></a>At run
               time, the first operand expression of the conditional expression is
               evaluated first. If necessary, unboxing conversion is performed on the
               result.
            </p>
            <p class="norm-dynamic"><a name="jls-15.25-410"></a>The
               resulting <code class="literal">boolean</code> value is then used to choose either the second or
               the third operand expression:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.25-410-A"></a>If
                            the value of the first operand is <code class="literal">true</code>, then the second operand
                            expression is chosen.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.25-410-B"></a>If
                            the value of the first operand is <code class="literal">false</code>, then the third operand
                            expression is chosen.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-dynamic"><a name="jls-15.25-420"></a>The
               chosen operand expression is then evaluated and the resulting value is
               converted to the type of the conditional expression as determined by
               the rules stated above.
            </p>
            <p class="norm-dynamic"><a name="jls-15.25-430"></a>This
               conversion may include boxing (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) or
               unboxing (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) conversion.
            </p>
            <p class="norm-dynamic"><a name="jls-15.25-440"></a>The
               operand expression not chosen is not evaluated for that particular
               evaluation of the conditional expression.
            </p>
         </div>
         <div class="section" title="15.26.&nbsp;Assignment Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.26"></a>15.26.&nbsp;Assignment Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-15.26-100"></a>There are
               12 <span class="emphasis"><em>assignment operators</em></span>; all are syntactically
               right-associative (they group
               right-to-left). Thus, <code class="literal">a=b=c</code>
               means <code class="literal">a=(b=c)</code>, which assigns the value
               of <code class="literal">c</code> to <code class="literal">b</code> and then assigns the
               value of <code class="literal">b</code> to <code class="literal">a</code>.
            </p>
            <div class="literallayout">
               <p><br>
                  AssignmentExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ConditionalExpression<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Assignment<br>
                  <br>
                  Assignment:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;LeftHandSide&nbsp;AssignmentOperator&nbsp;AssignmentExpression<br>
                  <br>
                  LeftHandSide:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ExpressionName<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;FieldAccess<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ArrayAccess<br>
                  <br>
                  AssignmentOperator:&nbsp;one&nbsp;of<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">=&nbsp;*=&nbsp;/=&nbsp;%=&nbsp;+=&nbsp;-=&nbsp;&lt;&lt;=&nbsp;&gt;&gt;=&nbsp;&gt;&gt;&gt;=&nbsp;&amp;=&nbsp;^=&nbsp;|=</code><br>
                  
               </p>
            </div>
            <p class="norm-error"><a name="jls-15.26-200"></a>The result
               of the first operand of an assignment operator must be a variable, or
               a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.26-210"></a>This
               operand may be a named variable, such as a local variable or a field
               of the current object or class, or it may be a computed variable, as
               can result from a field access (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>) or an
               array access (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Array Access Expressions">&sect;15.13</a>).
            </p>
            <p class="norm-static"><a name="jls-15.26-300"></a>The type
               of the assignment expression is the type of the variable after capture
               conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.26-400"></a>At run
               time, the result of the assignment expression is the value of the
               variable after the assignment has occurred. The result of an
               assignment expression is not itself a variable.
            </p>
            <p class="norm-static"><a name="jls-15.26-410"></a>A variable
               that is declared <code class="literal">final</code> cannot be assigned to (unless it is
               definitely unassigned (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16</a>)), because when an
               access of such a <code class="literal">final</code> variable is used as an expression, the result
               is a value, not a variable, and so it cannot be used as the first
               operand of an assignment operator. 
            </p>
            <div class="section" title="15.26.1.&nbsp;Simple Assignment Operator =">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.26.1"></a>15.26.1.&nbsp;Simple Assignment Operator =
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.26.1-100"></a>A
                  compile-time error occurs if the type of the right-hand operand cannot
                  be converted to the type of the variable by assignment conversion
                  (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Conversion">&sect;5.2</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.26.1-200"></a>At run
                  time, the expression is evaluated in one of three ways.
               </p>
               <p class="norm-dynamic"><a name="jls-15.26.1-300"></a>If the
                  left-hand operand expression is a field access expression
                  (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>) <code class="varname">e.f</code>, possibly
                  enclosed in one or more pairs of parentheses, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-300-A"></a>First, the
                                 expression <code class="varname">e</code> is evaluated. If evaluation
                                 of <code class="varname">e</code> completes abruptly, the assignment
                                 expression completes abruptly for the same reason.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-300-B"></a>Next, the right hand operand is
                                 evaluated. If evaluation of the right hand expression completes
                                 abruptly, the assignment expression completes abruptly for the
                                 same reason.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-300-C"></a>Then, if the field denoted
                                 by <code class="varname">e.f</code> is not <code class="literal">static</code> and the result of the
                                 evaluation of <code class="varname">e</code> above is <code class="literal">null</code>, then a <code class="literal">NullPointerException</code>
                                 is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-300-D"></a>Otherwise, the variable denoted
                                 by <code class="varname">e.f</code> is assigned the value of the right
                                 hand operand as computed above.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.26.1-400"></a>If the
                  left-hand operand is an array access expression
                  (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Array Access Expressions">&sect;15.13</a>), possibly enclosed in one or more pairs
                  of parentheses, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-A"></a>First, the array reference
                                 subexpression of the left-hand operand array access expression
                                 is evaluated. If this evaluation completes abruptly, then the
                                 assignment expression completes abruptly for the same reason;
                                 the index subexpression (of the left-hand operand array access
                                 expression) and the right-hand operand are not evaluated and no
                                 assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-B"></a>Otherwise, the index subexpression of
                                 the left-hand operand array access expression is evaluated. If
                                 this evaluation completes abruptly, then the assignment
                                 expression completes abruptly for the same reason and the
                                 right-hand operand is not evaluated and no assignment
                                 occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-C"></a>Otherwise, the right-hand operand is
                                 evaluated. If this evaluation completes abruptly, then the
                                 assignment expression completes abruptly for the same reason and
                                 no assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-D"></a>Otherwise, if the value of the array
                                 reference subexpression is <code class="literal">null</code>, then no assignment occurs and
                                 a <code class="literal">NullPointerException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-E"></a>Otherwise, the value of the array
                                 reference subexpression indeed refers to an array. If the value
                                 of the index subexpression is less than zero, or greater than or
                                 equal to the <code class="literal">length</code> of the array, then no
                                 assignment occurs and an <code class="literal">ArrayIndexOutOfBoundsException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-F"></a>Otherwise, the value of the index
                                 subexpression is used to select a component of the array
                                 referred to by the value of the array reference
                                 subexpression.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1"></a>This component is a variable; call
                                 its type <span class="type">SC</span>. Also, let <span class="type">TC</span> be the type of the left-hand
                                 operand of the assignment operator as determined at compile
                                 time. Then there are two possibilities:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.26.1-400-F.1-1"></a>If <span class="type">TC</span> is a
                                    	  primitive type, then <span class="type">SC</span> is necessarily the same as
                                    	  <span class="type">TC</span>.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1-1.1"></a>The value of the right-hand
                                    	  operand is converted to the type of the selected array
                                    	  component, is subjected to value set conversion
                                    	  (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) to the appropriate standard
                                    	  value set (not an extended-exponent value set), and the
                                    	  result of the conversion is stored into the array
                                    	  component.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.26.1-400-F.1-2"></a>If <span class="type">TC</span> is a
                                              reference type, then <span class="type">SC</span> may not be the same as <span class="type">TC</span>, but
                                              rather a type that extends or implements <span class="type">TC</span>.
                                 </p>
                                 <p class="norm"><a name="jls-15.26.1-400-F.1-2.1"></a>Let <span class="type">RC</span> be
                                     	  the class of the object referred to by the value of the
                                     	  right-hand operand at run time.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1-2.2"></a>A Java compiler may be able
                                    	  to prove at compile time that the array component will be of
                                    	  type <span class="type">TC</span> exactly (for example, <span class="type">TC</span> might be <code class="literal">final</code>). But
                                    	  if a Java compiler cannot prove at compile time that the
                                    	  array component will be of type <span class="type">TC</span> exactly, then a check
                                    	  must be performed at run time to ensure that the class <span class="type">RC</span>
                                    	  is assignment compatible (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Conversion">&sect;5.2</a>) with
                                    	  the actual type <span class="type">SC</span> of the array component.
                                 </p>
                                 <p class="note">This check is similar to a narrowing cast
                                    	  (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Conversion">&sect;5.5</a>, <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>),
                                    	  except that if the check fails, an <code class="literal">ArrayStoreException</code> is thrown rather
                                    	  than a <code class="literal">ClassCastException</code>.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1-2.3"></a>If class <span class="type">RC</span> is not
                                    	  assignable to type <span class="type">SC</span>, then no assignment occurs and an
                                    	  <code class="literal">ArrayStoreException</code> is thrown.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1-2.4"></a>Otherwise, the reference
                                    	  value of the right-hand operand is stored into the selected
                                    	  array component.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.26.1-500"></a>Otherwise, three steps are required:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-500-A"></a>First, the left-hand operand is
                                 evaluated to produce a variable. If this evaluation completes
                                 abruptly, then the assignment expression completes abruptly for
                                 the same reason; the right-hand operand is not evaluated and no
                                 assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-500-B"></a>Otherwise, the right-hand operand is
                                 evaluated. If this evaluation completes abruptly, then the
                                 assignment expression completes abruptly for the same reason and
                                 no assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-500-C"></a>Otherwise, the value of the
                                 right-hand operand is converted to the type of the left-hand
                                 variable, is subjected to value set conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) to the appropriate standard value
                                 set (not an extended-exponent value set), and the result of the
                                 conversion is stored into the variable.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e25312"></a><p class="title"><b>Example&nbsp;15.26.1-1.&nbsp;Simple Assignment To An Array Component</b></p>
                  <div class="example-contents"><pre class="programlisting">
class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow          extends RuntimeException { }
class RightHandSideThrow  extends RuntimeException { }

class IllustrateSimpleArrayAssignment {
    static Object[] objects = { new Object(), new Object() };
    static Thread[] threads = { new Thread(), new Thread() };

    static Object[] arrayThrow() {
        throw new ArrayReferenceThrow();
    }
    static int indexThrow() {
        throw new IndexThrow();
    }
    static Thread rightThrow() {
        throw new RightHandSideThrow();
    }
    static String name(Object q) {
        String sq = q.getClass().getName();
        int k = sq.lastIndexOf('.');
        return (k &lt; 0) ? sq : sq.substring(k+1);
    }

    static void testFour(Object[] x, int j, Object y) {
        String sx = x == null ? "null" : name(x[0]) + "s";
        String sy = name(y);
        System.out.println();
        try {
            System.out.print(sx + "[throw]=throw =&gt; ");
            x[indexThrow()] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[throw]=" + sy + " =&gt; ");
            x[indexThrow()] = y;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[" + j + "]=throw =&gt; ");
            x[j] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[" + j + "]=" + sy + " =&gt; ");
            x[j] = y;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
    }

    public static void main(String[] args) {
        try {
            System.out.print("throw[throw]=throw =&gt; ");
            arrayThrow()[indexThrow()] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[throw]=Thread =&gt; ");
            arrayThrow()[indexThrow()] = new Thread();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]=throw =&gt; ");
            arrayThrow()[1] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]=Thread =&gt; ");
            arrayThrow()[1] = new Thread();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }

        testFour(null, 1, new StringBuffer());
        testFour(null, 9, new Thread());
        testFour(objects, 1, new StringBuffer());
        testFour(objects, 1, new Thread());
        testFour(objects, 9, new StringBuffer());
        testFour(objects, 9, new Thread());
        testFour(threads, 1, new StringBuffer());
        testFour(threads, 1, new Thread());
        testFour(threads, 9, new StringBuffer());
        testFour(threads, 9, new Thread());
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
throw[throw]=throw =&gt; ArrayReferenceThrow
throw[throw]=Thread =&gt; ArrayReferenceThrow
throw[1]=throw =&gt; ArrayReferenceThrow
throw[1]=Thread =&gt; ArrayReferenceThrow

null[throw]=throw =&gt; IndexThrow
null[throw]=StringBuffer =&gt; IndexThrow
null[1]=throw =&gt; RightHandSideThrow
null[1]=StringBuffer =&gt; NullPointerException

null[throw]=throw =&gt; IndexThrow
null[throw]=Thread =&gt; IndexThrow
null[9]=throw =&gt; RightHandSideThrow
null[9]=Thread =&gt; NullPointerException

Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=StringBuffer =&gt; IndexThrow
Objects[1]=throw =&gt; RightHandSideThrow
Objects[1]=StringBuffer =&gt; Okay!

Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=Thread =&gt; IndexThrow
Objects[1]=throw =&gt; RightHandSideThrow
Objects[1]=Thread =&gt; Okay!

Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=StringBuffer =&gt; IndexThrow
Objects[9]=throw =&gt; RightHandSideThrow
Objects[9]=StringBuffer =&gt; ArrayIndexOutOfBoundsException

Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=Thread =&gt; IndexThrow
Objects[9]=throw =&gt; RightHandSideThrow
Objects[9]=Thread =&gt; ArrayIndexOutOfBoundsException

Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=StringBuffer =&gt; IndexThrow
Threads[1]=throw =&gt; RightHandSideThrow
Threads[1]=StringBuffer =&gt; ArrayStoreException

Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=Thread =&gt; IndexThrow
Threads[1]=throw =&gt; RightHandSideThrow
Threads[1]=Thread =&gt; Okay!

Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=StringBuffer =&gt; IndexThrow
Threads[9]=throw =&gt; RightHandSideThrow
Threads[9]=StringBuffer =&gt; ArrayIndexOutOfBoundsException

Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=Thread =&gt; IndexThrow
Threads[9]=throw =&gt; RightHandSideThrow
Threads[9]=Thread =&gt; ArrayIndexOutOfBoundsException
</pre><p class="note">The most interesting case of the lot is thirteenth
                        from the end:
                     </p><pre class="screen">
Threads[1]=StringBuffer =&gt; ArrayStoreException
</pre><p class="note">which indicates that the attempt to store a
                        reference to a <code class="literal">StringBuffer</code> into an array whose
                        components are of type <code class="literal">Thread</code> throws an <code class="literal">ArrayStoreException</code>. The code is
                        type-correct at compile time: the assignment has a left-hand side of
                        type <code class="literal">Object[]</code> and a right-hand side of type
                        <code class="literal">Object</code>. At run time, the first actual argument to
                        method <code class="literal">testFour</code> is a reference to an instance of
                        "array of <code class="literal">Thread</code>" and the third actual argument is a reference to an
                        instance of class <code class="literal">StringBuffer</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.26.2.&nbsp;Compound Assignment Operators">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.26.2"></a>15.26.2.&nbsp;Compound Assignment Operators
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.26.2-100"></a>A
                  compound assignment expression of the form <code class="varname">E1 op=
                     E2</code> is equivalent to <code class="varname">E1 = (T) ((E1) op
                     (E2))</code>, where <span class="type">T</span> is the type of <code class="varname">E1</code>,
                  except that <code class="varname">E1</code> is evaluated only once.
               </p>
               <div class="informalexample">
                  <p class="note">For example, the following code is correct:</p><pre class="screen">
short x = 3;
x += 4.6;
</pre><p class="note">and results in <code class="literal">x</code> having the
                     value <code class="literal">7</code> because it is equivalent to:
                  </p><pre class="screen">
short x = 3;
x = (short)(x + 4.6);
</pre></div>
               <p class="norm-dynamic"><a name="jls-15.26.2-200"></a>At run
                  time, the expression is evaluated in one of two ways.
               </p>
               <p class="norm-dynamic"><a name="jls-15.26.2-300"></a>If the
                  left-hand operand expression is not an array access expression,
                  then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-300-A"></a>First, the left-hand operand is
                               evaluated to produce a variable. If this evaluation completes
                               abruptly, then the assignment expression completes abruptly for
                               the same reason; the right-hand operand is not evaluated and no
                               assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-300-B"></a>Otherwise, the value of the left-hand
                               operand is saved and then the right-hand operand is evaluated. If
                               this evaluation completes abruptly, then the assignment expression
                               completes abruptly for the same reason and no assignment
                               occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-300-C"></a>Otherwise, the saved value of the
                               left-hand variable and the value of the right-hand operand are
                               used to perform the binary operation indicated by the compound
                               assignment operator. If this operation completes abruptly, then
                               the assignment expression completes abruptly for the same reason
                               and no assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-300-D"></a>Otherwise, the result of the binary
                               operation is converted to the type of the left-hand variable,
                               subjected to value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>)
                               to the appropriate standard value set (not an extended-exponent
                               value set), and the result of the conversion is stored into the
                               variable.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.26.2-400"></a>If the
                  left-hand operand expression is an array access expression
                  (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Array Access Expressions">&sect;15.13</a>), then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-A"></a>First, the array reference
                               subexpression of the left-hand operand array access expression is
                               evaluated. If this evaluation completes abruptly, then the
                               assignment expression completes abruptly for the same reason; the
                               index subexpression (of the left-hand operand array access
                               expression) and the right-hand operand are not evaluated and no
                               assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-B"></a>Otherwise, the index subexpression of
                               the left-hand operand array access expression is evaluated. If
                               this evaluation completes abruptly, then the assignment expression
                               completes abruptly for the same reason and the right-hand operand
                               is not evaluated and no assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-C"></a>Otherwise, if the value of the array
                               reference subexpression is <code class="literal">null</code>, then no assignment occurs and a
                               <code class="literal">NullPointerException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-D"></a>Otherwise, the value of the array
                               reference subexpression indeed refers to an array. If the value of
                               the index subexpression is less than zero, or greater than or
                               equal to the <code class="literal">length</code> of the array, then no assignment occurs and
                               an <code class="literal">ArrayIndexOutOfBoundsException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-E"></a>Otherwise, the value of the index
                               subexpression is used to select a component of the array referred
                               to by the value of the array reference subexpression. The value of
                               this component is saved and then the right-hand operand is
                               evaluated. If this evaluation completes abruptly, then the
                               assignment expression completes abruptly for the same reason and
                               no assignment occurs.
                        </p>
                        <p class="note">For a simple assignment operator, the
                               evaluation of the right-hand operand occurs before the checks of
                               the array reference subexpression and the index subexpression, but
                               for a compound assignment operator, the evaluation of the
                               right-hand operand occurs after these checks.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-F"></a>Otherwise, consider the array component
                               selected in the previous step, whose value was saved. This
                               component is a variable; call its type <span class="type">S</span>. Also, let <span class="type">T</span> be the
                               type of the left-hand operand of the assignment operator as
                               determined at compile time.
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.26.2-400-F-1"></a>If <span class="type">T</span> is a
                                    	primitive type, then <span class="type">S</span> is necessarily the same as
                                    	<span class="type">T</span>.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-1.1"></a>The saved value of the array
                                    	component and the value of the right-hand operand are used to
                                    	perform the binary operation indicated by the compound
                                    	assignment operator.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-1.2"></a>If this operation completes
                                    	abruptly (the only possibility is an integer division by zero
                                    	- see <a class="xref" href="jls-15.html#jls-15.17.2" title="15.17.2.&nbsp;Division Operator /">&sect;15.17.2</a>), then the assignment
                                    	expression completes abruptly for the same reason and no
                                    	assignment occurs.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-1.3"></a>Otherwise, the result of the
                                    	binary operation is converted to the type of the selected
                                    	array component, subjected to value set conversion
                                    	(<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) to the appropriate standard
                                    	value set (not an extended-exponent value set), and the result
                                    	of the conversion is stored into the array component.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.26.2-400-F-2"></a>If <span class="type">T</span> is a
                                    	reference type, then it must be <code class="literal">String</code>. Because class
                                    	<code class="literal">String</code> is a <code class="literal">final</code> class, <span class="type">S</span> must also be <code class="literal">String</code>.
                                 </p>
                                 <p class="note">Therefore the run-time check that is
                                    	sometimes required for the simple assignment operator is never
                                    	required for a compound assignment operator.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-2.1"></a>The saved value of the array
                                    	component and the value of the right-hand operand are used to
                                    	perform the binary operation (string concatenation) indicated
                                    	by the compound assignment operator (which is
                                    	necessarily <code class="literal">+=</code>). If this operation
                                    	completes abruptly, then the assignment expression completes
                                    	abruptly for the same reason and no assignment occurs.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-2.2"></a>Otherwise, the <code class="literal">String</code> result
                                    	of the binary operation is stored into the array
                                    	component.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e25401"></a><p class="title"><b>Example&nbsp;15.26.2-1.&nbsp;Compound Assignment To An Array Component</b></p>
                  <div class="example-contents"><pre class="programlisting">
class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow          extends RuntimeException { }
class RightHandSideThrow  extends RuntimeException { }

class IllustrateCompoundArrayAssignment {
    static String[] strings = { "Simon", "Garfunkel" };
    static double[] doubles = { Math.E, Math.PI };

    static String[] stringsThrow() {
        throw new ArrayReferenceThrow();
    }
    static double[] doublesThrow() {
        throw new ArrayReferenceThrow();
    }
    static int indexThrow() {
        throw new IndexThrow();
    }
    static String stringThrow() {
        throw new RightHandSideThrow();
    }
    static double doubleThrow() {
        throw new RightHandSideThrow();
    }
    static String name(Object q) {
        String sq = q.getClass().getName();
        int k = sq.lastIndexOf('.');
        return (k &lt; 0) ? sq : sq.substring(k+1);
    }

    static void testEight(String[] x, double[] z, int j) {
        String sx = (x == null) ? "null" : "Strings";
        String sz = (z == null) ? "null" : "doubles";
        System.out.println();
        try {
            System.out.print(sx + "[throw]+=throw =&gt; ");
            x[indexThrow()] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "[throw]+=throw =&gt; ");
            z[indexThrow()] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[throw]+=\"heh\" =&gt; ");
            x[indexThrow()] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "[throw]+=12345 =&gt; ");
            z[indexThrow()] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[" + j + "]+=throw =&gt; ");
            x[j] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "[" + j + "]+=throw =&gt; ");
            z[j] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[" + j + "]+=\"heh\" =&gt; ");
            x[j] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "[" + j + "]+=12345 =&gt; ");
            z[j] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
    }

    public static void main(String[] args) {
        try {
            System.out.print("throw[throw]+=throw =&gt; ");
            stringsThrow()[indexThrow()] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[throw]+=throw =&gt; ");
            doublesThrow()[indexThrow()] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[throw]+=\"heh\" =&gt; ");
            stringsThrow()[indexThrow()] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[throw]+=12345 =&gt; ");
            doublesThrow()[indexThrow()] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]+=throw =&gt; ");
            stringsThrow()[1] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]+=throw =&gt; ");
            doublesThrow()[1] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]+=\"heh\" =&gt; ");
            stringsThrow()[1] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]+=12345 =&gt; ");
            doublesThrow()[1] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        testEight(null, null, 1);
        testEight(null, null, 9);
        testEight(strings, doubles, 1);
        testEight(strings, doubles, 9);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
throw[throw]+=throw =&gt; ArrayReferenceThrow
throw[throw]+=throw =&gt; ArrayReferenceThrow
throw[throw]+="heh" =&gt; ArrayReferenceThrow
throw[throw]+=12345 =&gt; ArrayReferenceThrow
throw[1]+=throw =&gt; ArrayReferenceThrow
throw[1]+=throw =&gt; ArrayReferenceThrow
throw[1]+="heh" =&gt; ArrayReferenceThrow
throw[1]+=12345 =&gt; ArrayReferenceThrow

null[throw]+=throw =&gt; IndexThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+="heh" =&gt; IndexThrow
null[throw]+=12345 =&gt; IndexThrow
null[1]+=throw =&gt; NullPointerException
null[1]+=throw =&gt; NullPointerException
null[1]+="heh" =&gt; NullPointerException
null[1]+=12345 =&gt; NullPointerException

null[throw]+=throw =&gt; IndexThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+="heh" =&gt; IndexThrow
null[throw]+=12345 =&gt; IndexThrow
null[9]+=throw =&gt; NullPointerException
null[9]+=throw =&gt; NullPointerException
null[9]+="heh" =&gt; NullPointerException
null[9]+=12345 =&gt; NullPointerException

Strings[throw]+=throw =&gt; IndexThrow
doubles[throw]+=throw =&gt; IndexThrow
Strings[throw]+="heh" =&gt; IndexThrow
doubles[throw]+=12345 =&gt; IndexThrow
Strings[1]+=throw =&gt; RightHandSideThrow
doubles[1]+=throw =&gt; RightHandSideThrow
Strings[1]+="heh" =&gt; Okay!
doubles[1]+=12345 =&gt; Okay!

Strings[throw]+=throw =&gt; IndexThrow
doubles[throw]+=throw =&gt; IndexThrow
Strings[throw]+="heh" =&gt; IndexThrow
doubles[throw]+=12345 =&gt; IndexThrow
Strings[9]+=throw =&gt; ArrayIndexOutOfBoundsException
doubles[9]+=throw =&gt; ArrayIndexOutOfBoundsException
Strings[9]+="heh" =&gt; ArrayIndexOutOfBoundsException
doubles[9]+=12345 =&gt; ArrayIndexOutOfBoundsException
</pre><p class="note">The most interesting cases of the lot are eleventh
                        and twelfth from the end:
                     </p><pre class="screen">
Strings[1]+=throw =&gt; RightHandSideThrow
doubles[1]+=throw =&gt; RightHandSideThrow
</pre><p class="note">They are the cases where a right-hand side that
                        throws an exception actually gets to throw the exception; moreover,
                        they are the only such cases in the lot. This demonstrates that the
                        evaluation of the right-hand operand indeed occurs after the checks
                        for a null array reference value and an out-of-bounds index
                        value.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e25409"></a><p class="title"><b>Example&nbsp;15.26.2-2.&nbsp;Value Of Left-Hand Side Of Compound Assignment Is Saved Before Evaluation Of Right-Hand Side</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        int k = 1;
        int[] a = { 1 };
        k += (k = 4) * (k + 2);
        a[0] += (a[0] = 4) * (a[0] + 2);
        System.out.println("k==" + k + " and a[0]==" + a[0]);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
k==25 and a[0]==25
</pre><p class="note">The value <code class="literal">1</code>
                        of <code class="literal">k</code> is saved by the compound assignment
                        operator <code class="literal">+=</code> before its right-hand
                        operand <code class="literal">(k = 4) * (k + 2)</code> is evaluated. Evaluation
                        of this right-hand operand then assigns <code class="literal">4</code>
                        to <code class="literal">k</code>, calculates the value <code class="literal">6</code>
                        for <code class="literal">k + 2</code>, and then multiplies <code class="literal">4</code>
                        by <code class="literal">6</code> to get <code class="literal">24</code>. This is added to
                        the saved value <code class="literal">1</code> to get <code class="literal">25</code>,
                        which is then stored into <code class="literal">k</code> by
                        the <code class="literal">+=</code> operator. An identical analysis applies to
                        the case that uses <code class="literal">a[0]</code>.
                     </p>
                     <p class="note">In short, the statements:</p><pre class="screen">
k += (k = 4) * (k + 2);
a[0] += (a[0] = 4) * (a[0] + 2);
</pre><p class="note">behave in exactly the same manner as the
                        statements:
                     </p><pre class="screen">
k = k + (k = 4) * (k + 2);
a[0] = a[0] + (a[0] = 4) * (a[0] + 2);
</pre></div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.27.&nbsp;Expression">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.27"></a>15.27.&nbsp;Expression
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-15.27-100"></a>An <span class="emphasis"><em>Expression</em></span> is any
               assignment expression:
            </p>
            <div class="literallayout">
               <p><br>
                  Expression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;AssignmentExpression<br>
                  
               </p>
            </div>
            <p class="norm"><a name="jls-15.27-120"></a>Unlike C and C++, the
               Java programming language has no comma operator.
            </p>
         </div>
         <div class="section" title="15.28.&nbsp;Constant Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.28"></a>15.28.&nbsp;Constant Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <div class="literallayout">
               <p><br>
                  ConstantExpression:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Expression<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-15.28-110"></a>A
               compile-time <span class="emphasis"><em>constant expression</em></span> is an expression
               denoting a value of primitive type or a <code class="literal">String</code> that does not
               complete abruptly and is composed using only the following:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-A"></a>Literals of primitive type and literals
                            of type <code class="literal">String</code> (<a class="xref" href="jls-3.html#jls-3.10.1" title="3.10.1.&nbsp;Integer Literals">&sect;3.10.1</a>,
                            <a class="xref" href="jls-3.html#jls-3.10.2" title="3.10.2.&nbsp;Floating-Point Literals">&sect;3.10.2</a>, <a class="xref" href="jls-3.html#jls-3.10.3" title="3.10.3.&nbsp;Boolean Literals">&sect;3.10.3</a>,
                            <a class="xref" href="jls-3.html#jls-3.10.4" title="3.10.4.&nbsp;Character Literals">&sect;3.10.4</a>, <a class="xref" href="jls-3.html#jls-3.10.5" title="3.10.5.&nbsp;String Literals">&sect;3.10.5</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-B"></a>Casts to primitive types and casts to
                            type <code class="literal">String</code> (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-C"></a>The
                            unary operators <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">~</code>, and <code class="literal">!</code> (but not
                            <code class="literal">++</code> or <code class="literal">--</code>) (<a class="xref" href="jls-15.html#jls-15.15.3" title="15.15.3.&nbsp;Unary Plus Operator +">&sect;15.15.3</a>,
                            <a class="xref" href="jls-15.html#jls-15.15.4" title="15.15.4.&nbsp;Unary Minus Operator -">&sect;15.15.4</a>, <a class="xref" href="jls-15.html#jls-15.15.5" title="15.15.5.&nbsp;Bitwise Complement Operator ~">&sect;15.15.5</a>,
                            <a class="xref" href="jls-15.html#jls-15.15.6" title="15.15.6.&nbsp;Logical Complement Operator !">&sect;15.15.6</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-D"></a>The
                            multiplicative operators <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">%</code>
                            (<a class="xref" href="jls-15.html#jls-15.17" title="15.17.&nbsp;Multiplicative Operators">&sect;15.17</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-E"></a>The
                            additive operators <code class="literal">+</code> and <code class="literal">-</code>
                            (<a class="xref" href="jls-15.html#jls-15.18" title="15.18.&nbsp;Additive Operators">&sect;15.18</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-F"></a>The
                            shift operators <code class="literal">&lt;&lt;</code>, <code class="literal">&gt;&gt;</code>, and <code class="literal">&gt;&gt;&gt;</code>
                            (<a class="xref" href="jls-15.html#jls-15.19" title="15.19.&nbsp;Shift Operators">&sect;15.19</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-G"></a>The
                            relational operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>,
                            <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code> (but not <code class="literal">instanceof</code>)
                            (<a class="xref" href="jls-15.html#jls-15.20" title="15.20.&nbsp;Relational Operators">&sect;15.20</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-H"></a>The
                            equality operators <code class="literal">==</code> and <code class="literal">!=</code>
                            (<a class="xref" href="jls-15.html#jls-15.21" title="15.21.&nbsp;Equality Operators">&sect;15.21</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-I"></a>The
                            bitwise and logical operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code>
                            (<a class="xref" href="jls-15.html#jls-15.22" title="15.22.&nbsp;Bitwise and Logical Operators">&sect;15.22</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-J"></a>The
                            conditional-and operator <code class="literal">&amp;&amp;</code> and the conditional-or operator
                            <code class="literal">||</code> (<a class="xref" href="jls-15.html#jls-15.23" title="15.23.&nbsp;Conditional-And Operator &amp;&amp;">&sect;15.23</a>,
                            <a class="xref" href="jls-15.html#jls-15.24" title="15.24.&nbsp;Conditional-Or Operator ||">&sect;15.24</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-K"></a>The
                            ternary conditional operator <code class="literal">? :</code>
                            (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-L"></a>Parenthesized expressions
                            (<a class="xref" href="jls-15.html#jls-15.8.5" title="15.8.5.&nbsp;Parenthesized Expressions">&sect;15.8.5</a>) whose contained expression is a
                            constant expression.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-M"></a>Simple names
                            (<a class="xref" href="jls-6.html#jls-6.5.6.1" title="6.5.6.1.&nbsp;Simple Expression Names">&sect;6.5.6.1</a>) that refer to constant variables
                            (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-N"></a>Qualified names
                            (<a class="xref" href="jls-6.html#jls-6.5.6.2" title="6.5.6.2.&nbsp;Qualified Expression Names">&sect;6.5.6.2</a>) of the
                            form <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <span class="emphasis"><em>Identifier</em></span> that refer
                            to constant variables (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>).
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-dynamic"><a name="jls-15.28-200"></a>Compile-time constant expressions of type
               <code class="literal">String</code> are always "interned" so as to share unique instances, using
               the method <code class="literal">String.intern</code>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.28-210"></a>A
               compile-time constant expression is always treated as FP-strict
               (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>), even if it occurs in a context where a
               non-constant expression would not be considered to be
               FP-strict.
            </p>
            <p class="note">Compile-time constant expressions are used in <code class="literal">case</code>
               labels in <code class="literal">switch</code> statements (<a class="xref" href="jls-14.html#jls-14.11" title="14.11.&nbsp;The switch Statement">&sect;14.11</a>) and have a
               special significance for assignment conversion
               (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Conversion">&sect;5.2</a>) and initialization of a class or interface
               (<a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>). They may also govern the ability of a
               <code class="literal">while</code>, <code class="literal">do</code>, or <code class="literal">for</code> statement to complete normally
               (<a class="xref" href="jls-14.html#jls-14.21" title="14.21.&nbsp;Unreachable Statements">&sect;14.21</a>), and the type of a conditional operator
               <code class="literal">? :</code> with numeric operands.
            </p>
            <div class="example"><a name="d5e25548"></a><p class="title"><b>Example&nbsp;15.28-1.&nbsp;Constant Expressions</b></p>
               <div class="example-contents"><pre class="screen">
true
(short)(1*2*3*4*5*6)
Integer.MAX_VALUE / 2
2.0 * Math.PI
"The integer " + Long.MAX_VALUE + " is mighty big."
</pre></div>
            </div><br class="example-break"></div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-14.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-16.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;14.&nbsp;Blocks and Statements&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;16.&nbsp;Definite Assignment</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>
