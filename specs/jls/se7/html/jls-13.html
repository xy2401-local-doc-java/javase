
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;13.&nbsp;Binary Compatibility</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-12.html" title="Chapter&nbsp;12.&nbsp;Execution">
      <link rel="next" href="jls-14.html" title="Chapter&nbsp;14.&nbsp;Blocks and Statements">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo">
<img src="../../../../webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="../../../../7/docs/">Java SE</a> &gt; <a href="../../../index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;13.&nbsp;Binary Compatibility</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-12.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-14.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;13.&nbsp;Binary Compatibility">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-13"></a>Chapter&nbsp;13.&nbsp;Binary Compatibility
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-13.html#jls-13.1">13.1. The Form of a Binary</a></span></dt>
               <dt><span class="section"><a href="jls-13.html#jls-13.2">13.2. What Binary Compatibility Is and Is Not</a></span></dt>
               <dt><span class="section"><a href="jls-13.html#jls-13.3">13.3. Evolution of Packages</a></span></dt>
               <dt><span class="section"><a href="jls-13.html#jls-13.4">13.4. Evolution of Classes</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.1">13.4.1. <code class="literal">abstract</code> Classes</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.2">13.4.2. <code class="literal">final</code> Classes</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.3">13.4.3. <code class="literal">public</code> Classes</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.4">13.4.4. Superclasses and Superinterfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.5">13.4.5. Class Type Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.6">13.4.6. Class Body and Member Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.7">13.4.7. Access to Members and Constructors</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.8">13.4.8. Field Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.9">13.4.9. <code class="literal">final</code> Fields and Constants</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.10">13.4.10. <code class="literal">static</code> Fields</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.11">13.4.11. <code class="literal">transient</code> Fields</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.12">13.4.12. Method and Constructor Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.13">13.4.13. Method and Constructor Type Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.14">13.4.14. Method and Constructor Formal Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.15">13.4.15. Method Result Type</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.16">13.4.16. <code class="literal">abstract</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.17">13.4.17. <code class="literal">final</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.18">13.4.18. <code class="literal">native</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.19">13.4.19. <code class="literal">static</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.20">13.4.20. <code class="literal">synchronized</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.21">13.4.21. Method and Constructor Throws</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.22">13.4.22. Method and Constructor Body</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.23">13.4.23. Method and Constructor Overloading</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.24">13.4.24. Method Overriding</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.25">13.4.25. Static Initializers</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.26">13.4.26. Evolution of Enums</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-13.html#jls-13.5">13.5. Evolution of Interfaces</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.1">13.5.1. <code class="literal">public</code> Interfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.2">13.5.2. Superinterfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.3">13.5.3. Interface Members</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.4">13.5.4. Interface Type Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.5">13.5.5. Field Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.6">13.5.6. <code class="literal">abstract</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.7">13.5.7. Evolution of Annotation Types</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <p class="norm"><a name="jls-13-100"></a>Development tools for the
            Java programming language should support automatic recompilation as necessary
            whenever source code is available. Particular implementations may also
            store the source and binary of types in a versioning database and
            implement a <code class="literal">ClassLoader</code> that uses integrity mechanisms of the
            database to prevent linkage errors by providing binary-compatible
            versions of types to clients.
         </p>
         <p class="norm"><a name="jls-13-110"></a>Developers of packages and
            classes that are to be widely distributed face a different set of
            problems. In the Internet, which is our favorite example of a widely
            distributed system, it is often impractical or impossible to
            automatically recompile the pre-existing binaries that directly or
            indirectly depend on a type that is to be changed. Instead, this
            specification defines a set of changes that developers are permitted
            to make to a package or to a class or interface type while preserving
            (not breaking) compatibility with pre-existing binaries.
         </p>
         <p class="norm"><a name="jls-13-120"></a>Within the framework
            of <em class="citetitle">Release-to-Release Binary Compatibility in
               SOM</em> (Forman, Conner, Danforth, and
            Raper, <em class="citetitle">Proceedings of OOPSLA '95</em>), Java programming language
            binaries are binary compatible under all relevant transformations that
            the authors identify (with some caveats with respect to the addition
            of instance variables). Using their scheme, here is a list of some
            important binary compatible changes that the Java programming language
            supports:
         </p>
         <div class="norm">
            <ul class="norm" type="disc">
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-A"></a>Reimplementing existing
                         methods, constructors, and initializers to improve
                         performance.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-B"></a>Changing methods or
                         constructors to return values on inputs for which they previously
                         either threw exceptions that normally should not occur or failed
                         by going into an infinite loop or causing a deadlock.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-C"></a>Adding new fields,
                         methods, or constructors to an existing class or interface.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-D"></a>Deleting <code class="literal">private</code> fields,
                         methods, or constructors of a class.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-E"></a>When an entire package is
                         updated, deleting default (package-only) access fields, methods,
                         or constructors of classes and interfaces in the package.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-F"></a>Reordering the fields,
                         methods, or constructors in an existing type declaration.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-G"></a>Moving a method upward in
                         the class hierarchy.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-H"></a>Reordering the list of
                         direct superinterfaces of a class or interface.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-I"></a>Inserting new class or
                         interface types in the type hierarchy.
                  </p>
               </li>
            </ul>
         </div>
         <p class="norm"><a name="jls-13-200"></a>This chapter specifies minimum
            standards for binary compatibility guaranteed by all
            implementations. The Java programming language guarantees compatibility when binaries
            of classes and interfaces are mixed that are not known to be from
            compatible sources, but whose sources have been modified in the
            compatible ways described here. Note that we are discussing
            compatibility between releases of an application. A discussion of
            compatibility among releases of the Java SE platform is beyond the scope of
            this chapter.
         </p>
         <p class="norm"><a name="jls-13-210"></a>We encourage development systems
            to provide facilities that alert developers to the impact of changes
            on pre-existing binaries that cannot be recompiled.
         </p>
         <p class="norm"><a name="jls-13-220"></a>This chapter first specifies
            some properties that any binary format for the Java programming language must have
            (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>). It next defines binary compatibility,
            explaining what it is and what it is not
            (<a class="xref" href="jls-13.html#jls-13.2" title="13.2.&nbsp;What Binary Compatibility Is and Is Not">&sect;13.2</a>). It finally enumerates a large set of
            possible changes to packages (<a class="xref" href="jls-13.html#jls-13.3" title="13.3.&nbsp;Evolution of Packages">&sect;13.3</a>), classes
            (<a class="xref" href="jls-13.html#jls-13.4" title="13.4.&nbsp;Evolution of Classes">&sect;13.4</a>), and interfaces
            (<a class="xref" href="jls-13.html#jls-13.5" title="13.5.&nbsp;Evolution of Interfaces">&sect;13.5</a>), specifying which of these changes are
            guaranteed to preserve binary compatibility and which are not.
         </p>
         <div class="section" title="13.1.&nbsp;The Form of a Binary">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.1"></a>13.1.&nbsp;The Form of a Binary
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-13.1-100"></a>Programs
               must be compiled either into the <code class="literal">class</code> file format specified by
               <em class="citetitle">The Java Virtual Machine Specification, Java SE 7 Edition</em>, or into a representation that can be mapped into that format
               by a class loader written in the Java programming language.
            </p>
            <p class="norm-static"><a name="jls-13.1-110"></a>Furthermore, the resulting <code class="literal">class</code> file must
               have certain properties. A number of these properties are specifically
               chosen to support source code transformations that preserve binary
               compatibility. The required properties are:
            </p>
            <div class="orderedlist">
               <ol class="orderedlist" type="1">
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-A"></a>The class or interface
                            must be named by its <span class="emphasis"><em>binary name</em></span>, which must
                            meet the following constraints:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-1"></a>The binary name of
                                 	a top level type (<a class="xref" href="jls-7.html#jls-7.6" title="7.6.&nbsp;Top Level Type Declarations">&sect;7.6</a>) is its canonical
                                 	name (<a class="xref" href="jls-6.html#jls-6.7" title="6.7.&nbsp;Fully Qualified Names and Canonical Names">&sect;6.7</a>).
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-2"></a>The binary name of
                                 	a member type (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>,
                                 	<a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>) consists of the binary name of its
                                 	immediately enclosing type, followed by $, followed by the
                                 	simple name of the member.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-3"></a>The binary name of
                                 	a local class (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class Declarations">&sect;14.3</a>) consists of the
                                 	binary name of its immediately enclosing type, followed by $,
                                 	followed by a non-empty sequence of digits, followed by the
                                 	simple name of the local class.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-4"></a>The binary name of
                                 	an anonymous class (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>) consists of
                                 	the binary name of its immediately enclosing type, followed by
                                 	$, followed by a non-empty sequence of digits.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-5"></a>The binary name of
                                 	a type variable declared by a generic class or interface
                                 	(<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>, <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>) is
                                 	the binary name of its immediately enclosing type, followed by
                                 	$, followed by the simple name of the type variable.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-6"></a>The binary name of
                                 	a type variable declared by a generic method
                                 	(<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>) is the binary name of the type
                                 	declaring the method, followed by $, followed by the
                                 	descriptor of the method as defined in <em class="citetitle">The Java Virtual Machine Specification, Java SE 7 Edition</em>, followed by $,
                                 	followed by the simple name of the type variable.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-7"></a>The binary name of
                                 	a type variable declared by a generic constructor
                                 	(<a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>) is the binary name of the type
                                 	declaring the constructor, followed by $, followed by the
                                 	descriptor of the constructor as defined in <em class="citetitle">The Java Virtual Machine Specification, Java SE 7 Edition</em>, followed
                                 	by $, followed by the simple name of the type variable.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-B"></a>A reference to another
                            class or interface type must be symbolic, using the binary name of
                            the type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-C"></a>References to fields
                            that are constant variables (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>) are
                            resolved at compile time to the constant value that is denoted. No
                            reference to such a  field should be present in the
                            code in a binary file (except in the class or interface containing
                            the  field, which will have code to initialize
                            it). Such a  field must always appear to have been
                            initialized (<a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>); the default initial
                            value for the type of such a field must never be observed. See
                            <a class="xref" href="jls-13.html#jls-13.4.9" title="13.4.9.&nbsp;final Fields and Constants">&sect;13.4.9</a> for a discussion.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-D"></a>Given a legal expression
                            denoting a field access in a class <span class="type">C</span>, referencing a non-constant
                            (<a class="xref" href="jls-13.html#jls-13.4.9" title="13.4.9.&nbsp;final Fields and Constants">&sect;13.4.9</a>) field named <code class="varname">f</code>
                            declared in a (possibly distinct) class or interface <span class="type">D</span>, we
                            define the <span class="emphasis"><em>qualifying type of the field
                                  reference</em></span> as follows:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-1"></a>If the expression
                                 	is of the form <span class="emphasis"><em>Primary</em></span><code class="literal">.</code><code class="varname">f</code> then:
                              </p>
                              <div class="norm">
                                 <ul class="norm" type="circle">
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-D-1-1"></a>If the
                                          	      compile-time type of <span class="emphasis"><em>Primary</em></span> is an intersection type
                                          	      (<a class="xref" href="jls-4.html#jls-4.9" title="4.9.&nbsp;Intersection Types">&sect;4.9</a>) <span class="type">V<sub>1</sub></span> &amp; ... &amp; <span class="type">V<sub>n</sub></span>,
                                          	      then the qualifying type of the reference is
                                          	      <span class="type">V<sub>1</sub></span>.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-D-1-2"></a>Otherwise,
                                          	      the compile-time type of <span class="emphasis"><em>Primary</em></span> is the qualifying
                                          	      type of the reference.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-2"></a>If the expression
                                 	is of the form <code class="literal">super</code><code class="literal">.</code><code class="varname">f</code> then the
                                 	superclass of <span class="type">C</span> is the qualifying type of the
                                 	reference.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-3"></a>If the expression
                                 	is of the form <span class="type">X</span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><code class="varname">f</code> then
                                 	the superclass of <span class="type">X</span> is the qualifying type of the
                                 	reference.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-4"></a>If the reference
                                 	is of the form <span class="type">X</span><code class="literal">.</code><code class="varname">f</code>, where <span class="type">X</span> denotes
                                 	a class or interface, then the class or interface denoted by
                                 	<span class="type">X</span> is the qualifying type of the reference.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-5"></a>If the expression
                                 	is referenced by a simple name, then if <code class="varname">f</code>
                                 	is a member of the current class or interface, <span class="type">C</span>, then let
                                 	<span class="type">T</span> be <span class="type">C</span>. Otherwise, let <span class="type">T</span> be the innermost lexically
                                 	enclosing class of which <code class="varname">f</code> is a member. In
                                 	either case, <span class="type">T</span> is the qualifying type of the
                                 	reference.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm"><a name="jls-13.1-110-D.1"></a>The reference to <code class="varname">f</code>
                            must be compiled into a symbolic reference to the erasure
                            (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the qualifying type of the
                            reference, plus the simple name of the field, <code class="varname">f</code>. The reference
                            must also include a symbolic reference to the erasure of the
                            declared type of the field so that the verifier can check that the
                            type is as expected.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-E"></a>Given a method invocation
                             expression in a class or interface <span class="type">C</span> referencing a method
                             named <code class="varname">m</code> declared (or implicitly
                             declared (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>)) in a (possibly
                             distinct) class or interface <span class="type">D</span>, we define
                             the <span class="emphasis"><em>qualifying type of the method invocation</em></span>
                             as follows:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E-1"></a>If <span class="type">D</span> is <code class="literal">Object</code>
                                 	  then the qualifying type of the expression is
                                 	  <code class="literal">Object</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E-2"></a>Otherwise:
                              </p>
                              <div class="norm">
                                 <ul class="norm" type="circle">
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-2-1"></a>If the
                                          	      expression is of the form
                                          	      <span class="emphasis"><em>Primary</em></span><code class="literal">.</code><code class="varname">m</code> then:
                                       </p>
                                       <div class="norm">
                                          <ul class="norm" type="square">
                                             <li class="listitem">
                                                <p class="norm"><a name="jls-13.1-110-E-2-1-1"></a>If the
                                                   		  compile-time type of <span class="emphasis"><em>Primary</em></span> is an intersection
                                                   		  type (<a class="xref" href="jls-4.html#jls-4.9" title="4.9.&nbsp;Intersection Types">&sect;4.9</a>) <span class="type">V<sub>1</sub></span> &amp;
                                                   		  ... &amp; <span class="type">V<sub>n</sub></span>, then the qualifying type of the
                                                   		  method invocation is <span class="type">V<sub>1</sub></span>.
                                                </p>
                                             </li>
                                             <li class="listitem">
                                                <p class="norm"><a name="jls-13.1-110-E-2-1-2"></a>Otherwise, the
                                                   		  compile-time type of <span class="emphasis"><em>Primary</em></span> is the qualifying
                                                   		  type of the method invocation.
                                                </p>
                                             </li>
                                          </ul>
                                       </div>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-2-2"></a>If the
                                          	      expression is of the form <code class="literal">super</code><code class="literal">.</code><code class="varname">m</code> then the
                                          	      superclass of <span class="type">C</span> is the qualifying type of the method
                                          	      invocation.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-2-3"></a>If the
                                          	      expression is of the form <span class="type">X</span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><code class="varname">m</code> then
                                          	      the superclass of <span class="type">X</span> is the qualifying type of the
                                          	      method invocation.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-2-4"></a>If the
                                          	      reference is of the form <span class="type">X</span><code class="literal">.</code><code class="varname">m</code>, where <span class="type">X</span> denotes
                                          	      a class or interface, then the class or interface
                                          	      denoted by <span class="type">X</span> is the qualifying type of the method
                                          	      invocation.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-2-5"></a>If the
                                          	      method is referenced by a simple name, then if <code class="varname">m</code> is a
                                          	      member of the current class or interface, <span class="type">C</span>, then let
                                          	      <span class="type">T</span> be <span class="type">C</span>. Otherwise, let <span class="type">T</span> be the innermost
                                          	      lexically enclosing class of which <code class="varname">m</code> is a member. In
                                          	      either case, <span class="type">T</span> is the qualifying type of the method
                                          	      invocation.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <p class="norm-static"><a name="jls-13.1-110-E.1"></a>A reference
                            to a method must be resolved at compile time to a symbolic
                            reference to the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the
                            qualifying type of the invocation, plus the erasure of the
                            signature (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of the method. The
                            signature of a method must include all of the
                            following as determined by
                            <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E.1-1"></a>The simple name
                                 	of the method
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E.1-2"></a>The number of
                                 	 parameters to the method
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E.1-3"></a>A symbolic
                                 	reference to the type of each parameter
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm"><a name="jls-13.1-110-E.2"></a>A reference to a
                            method must also include either a symbolic reference to the
                            erasure of the return type of the denoted method or an indication
                            that the denoted method is declared <code class="literal">void</code> and does not return a
                            value.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-F"></a>Given a class instance
                            creation expression (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) or a constructor
                            invocation statement (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>) in a class or
                            interface <span class="type">C</span> referencing a constructor <code class="varname">m</code>
                            declared in a (possibly distinct) class or interface <span class="type">D</span>, we
                            define the qualifying type of the constructor invocation as
                            follows:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F-1"></a>If the expression
                                 	is of the form <code class="literal">new</code> <span class="type">D</span><code class="literal">(...)</code> or
                                 	<span class="type">X</span><code class="literal">.</code><code class="literal">new</code> <span class="type">D</span><code class="literal">(...)</code>, then the qualifying
                                 	type of the invocation is <span class="type">D</span>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F-2"></a>If the expression
                                 	is of the form <code class="literal">new</code> <span class="type">D</span><code class="literal">(...){...}</code> or
                                 	<span class="type">X</span><code class="literal">.</code><code class="literal">new</code> <span class="type">D</span><code class="literal">(...){...}</code>, then the
                                 	qualifying type of the expression is the compile-time type of
                                 	the expression.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F-3"></a>If the expression
                                 	is of the form <code class="literal">super</code><code class="literal">(...)</code> or
                                 	<span class="emphasis"><em>Primary</em></span><code class="literal">.</code><code class="literal">super</code><code class="literal">(...)</code> then the
                                 	qualifying type of the expression is the direct superclass of
                                 	<span class="type">C</span>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F-4"></a>If the expression
                                 	is of the form <code class="literal">this</code><code class="literal">(...)</code>, then the
                                 	qualifying type of the expression is <span class="type">C</span>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm"><a name="jls-13.1-110-F.1"></a>A reference to a
                            constructor must be resolved at compile time to a symbolic
                            reference to the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the
                            qualifying type of the invocation, plus the signature of the
                            constructor (<a class="xref" href="jls-8.html#jls-8.8.2" title="8.8.2.&nbsp;Constructor Signature">&sect;8.8.2</a>). The signature of a
                            constructor must include both:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F.1-1"></a>The number of
                                 	parameters of the constructor
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F.1-2"></a>A symbolic
                                 	reference to the type of each formal parameter
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm"><a name="jls-13.1-110-F.2"></a>In addition, the
                            constructor of a non-<code class="literal">private</code> inner member class must be compiled
                            such that it has as its first parameter, an additional implicit
                            parameter representing the immediately enclosing instance
                            (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-13.1-110-G"></a>Any
                            constructs introduced by a Java compiler that do not have a
                            corresponding construct in the source code must be marked as
                            synthetic, except for default constructors, the class
                            initialization method, and the <code class="literal">values</code>
                            and <code class="literal">valueOf</code> methods of the <code class="literal">Enum</code>
                            class.
                     </p>
                  </li>
               </ol>
            </div>
            <p class="norm"><a name="jls-13.1-120"></a>A binary representation for a
               class or interface must also contain all of the following:
            </p>
            <div class="orderedlist">
               <ol class="orderedlist" type="1">
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-A"></a>If it is a class and is
                              not class <code class="literal">Object</code>, then a symbolic reference to the erasure
                              (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the direct superclass of this
                              class.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-B"></a>A symbolic reference to
                              the erasure of each direct superinterface, if any.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-C"></a>A specification of each
                              field declared in the class or interface, given as the simple
                              name of the field and a symbolic reference to the erasure of the
                              type of the field.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-D"></a>If it is a class, then
                              the erased signature of each constructor, as described
                              above.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-E"></a>For each method declared in
                              the class or interface (excluding, for an interface,
                              its implicitly declared methods
                              (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>)), its erased signature
                              and return type, as described above.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-F"></a>The code needed to
                            implement the class or interface:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-120-F-1"></a>For an interface,
                                 	code for the field initializers
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-120-F-2"></a>For a class, code
                                 	for the field initializers, the instance and static
                                 	initializers, and the implementation of each method or
                                 	constructor
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-G"></a>Every type must contain
                            sufficient information to recover its canonical name
                            (<a class="xref" href="jls-6.html#jls-6.7" title="6.7.&nbsp;Fully Qualified Names and Canonical Names">&sect;6.7</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-H"></a>Every member type must
                            have sufficient information to recover its source level access
                            modifier.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-I"></a>Every nested class must
                            have a symbolic reference to its immediately enclosing
                            class.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-J"></a>Every class that
                            contains a nested class must contain symbolic references to all of
                            its member classes, and to all local and anonymous classes that
                            appear in its methods, constructors, and static or instance
                            initializers.
                     </p>
                  </li>
               </ol>
            </div>
            <p class="norm"><a name="jls-13.1-200"></a>The following sections discuss
               changes that may be made to class and interface type declarations
               without breaking compatibility with pre-existing binaries. Under the
               translation requirements given above, the Java Virtual Machine and its <code class="literal">class</code> file
               format support these changes. Any other valid binary format, such as a
               compressed or encrypted representation that is mapped back into
               <code class="literal">class</code> files by a class loader under the above requirements, will
               necessarily support these changes as well.
            </p>
         </div>
         <div class="section" title="13.2.&nbsp;What Binary Compatibility Is and Is Not">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.2"></a>13.2.&nbsp;What Binary Compatibility Is and Is Not
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-13.2-100"></a>A change to a type
               is <span class="emphasis"><em>binary compatible with</em></span> (equivalently, does
               not <span class="emphasis"><em>break binary compatibility</em></span> with) pre-existing
               binaries if pre-existing binaries that previously linked without error
               will continue to link without error.
            </p>
            <p class="norm"><a name="jls-13.2-110"></a>Binaries are compiled to rely
               on the accessible members and constructors of other classes and
               interfaces. To preserve binary compatibility, a class or interface
               should treat its accessible members and constructors, their existence
               and behavior, as a <span class="emphasis"><em>contract</em></span> with its
               users.
            </p>
            <p class="norm"><a name="jls-13.2-120"></a>The Java programming language is designed to
               prevent additions to contracts and accidental name collisions from
               breaking binary compatibility. Specifically, addition of more methods
               overloading a particular method name does not break compatibility with
               pre-existing binaries. The method signature that the pre-existing
               binary will use for method lookup is chosen by the method overload
               resolution algorithm at compile time
               (<a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>).
            </p>
            <p class="note">If the Java programming language had been designed so that the
               particular method to be executed was chosen at run time, then such an
               ambiguity might be detected at run time. Such a rule would imply that
               adding an additional overloaded method so as to make ambiguity
               possible at a call site could break compatibility with an unknown
               number of pre-existing binaries. See <a class="xref" href="jls-13.html#jls-13.4.23" title="13.4.23.&nbsp;Method and Constructor Overloading">&sect;13.4.23</a> for
               more discussion.
            </p>
            <p class="norm"><a name="jls-13.2-200"></a>Binary compatibility is not
               the same as source compatibility. In particular, the example in
               <a class="xref" href="jls-13.html#jls-13.4.6" title="13.4.6.&nbsp;Class Body and Member Declarations">&sect;13.4.6</a> shows that a set of compatible binaries
               can be produced from sources that will not compile all together. This
               example is typical: a new declaration is added, changing the meaning
               of a name in an unchanged part of the source code, while the
               pre-existing binary for that unchanged part of the source code retains
               the fully-qualified, previous meaning of the name. Producing a
               consistent set of source code requires providing a qualified name or
               field access expression corresponding to the previous meaning.
            </p>
         </div>
         <div class="section" title="13.3.&nbsp;Evolution of Packages">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.3"></a>13.3.&nbsp;Evolution of Packages
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-13.3-100"></a>A new top level class or
               interface type may be added to a package without breaking
               compatibility with pre-existing binaries, provided the new type does
               not reuse a name previously given to an unrelated type.
            </p>
            <p class="norm"><a name="jls-13.3-110"></a>If a new type reuses a name
               previously given to an unrelated type, then a conflict may result,
               since binaries for both types could not be loaded by the same class
               loader.
            </p>
            <p class="norm"><a name="jls-13.3-200"></a>Changes in top level class and
               interface types that are not <code class="literal">public</code> and that are not a superclass or
               superinterface, respectively, of a <code class="literal">public</code> type, affect only types
               within the package in which they are declared. Such types may be
               deleted or otherwise changed, even if incompatibilities are otherwise
               described here, provided that the affected binaries of that package
               are updated together.
            </p>
         </div>
         <div class="section" title="13.4.&nbsp;Evolution of Classes">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.4"></a>13.4.&nbsp;Evolution of Classes
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-13.4-100"></a>This section describes the
               effects of changes to the declaration of a class and its members and
               constructors on pre-existing binaries.
            </p>
            <div class="section" title="13.4.1.&nbsp;abstract Classes">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.1"></a>13.4.1.&nbsp;<code class="literal">abstract</code> Classes
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.1-100"></a>If a class that was not
                  declared <code class="literal">abstract</code> is changed to be declared <code class="literal">abstract</code>, then
                  pre-existing binaries that attempt to create new instances of that
                  class will throw either an <code class="literal">InstantiationError</code> at link time, or (if a
                  reflective method is used) an <code class="literal">InstantiationException</code> at run time;
                  such a change is therefore not recommended for widely distributed
                  classes.
               </p>
               <p class="norm"><a name="jls-13.4.1-110"></a>Changing a class that is
                  declared <code class="literal">abstract</code> to no longer be declared <code class="literal">abstract</code> does not break
                  compatibility with pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.2.&nbsp;final Classes">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.2"></a>13.4.2.&nbsp;<code class="literal">final</code> Classes
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.2-100"></a>If a class that was not
                  declared <code class="literal">final</code> is changed to be declared <code class="literal">final</code>, then a <code class="literal">VerifyError</code> is
                  thrown if a binary of a pre-existing subclass of this class is loaded,
                  because <code class="literal">final</code> classes can have no subclasses; such a change is not
                  recommended for widely distributed classes.
               </p>
               <p class="norm"><a name="jls-13.4.2-110"></a>Changing a class that is
                  declared <code class="literal">final</code> to no longer be declared <code class="literal">final</code> does not break
                  compatibility with pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.3.&nbsp;public Classes">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.3"></a>13.4.3.&nbsp;<code class="literal">public</code> Classes
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.3-100"></a>Changing a class that is not
                  declared <code class="literal">public</code> to be declared <code class="literal">public</code> does not break compatibility
                  with pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.3-110"></a>If a class that was declared
                  <code class="literal">public</code> is changed to not be declared <code class="literal">public</code>, then an <code class="literal">IllegalAccessError</code> is
                  thrown if a pre-existing binary is linked that needs but no longer has
                  access to the class type; such a change is not recommended for widely
                  distributed classes.
               </p>
            </div>
            <div class="section" title="13.4.4.&nbsp;Superclasses and Superinterfaces">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.4"></a>13.4.4.&nbsp;Superclasses and Superinterfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.4-100"></a>A <code class="literal">ClassCircularityError</code> is
                  thrown at load time if a class would be a superclass of
                  itself. Changes to the class hierarchy that could result in such a
                  circularity when newly compiled binaries are loaded with pre-existing
                  binaries are not recommended for widely distributed classes.
               </p>
               <p class="norm"><a name="jls-13.4.4-110"></a>Changing the direct
                  superclass or the set of direct superinterfaces of a class type will
                  not break compatibility with pre-existing binaries, provided that the
                  total set of superclasses or superinterfaces, respectively, of the
                  class type loses no members.
               </p>
               <p class="norm"><a name="jls-13.4.4-120"></a>If a change to the direct
                  superclass or the set of direct superinterfaces results in any class
                  or interface no longer being a superclass or superinterface,
                  respectively, then linkage errors may result if pre-existing binaries
                  are loaded with the binary of the modified class. Such changes are not
                  recommended for widely distributed classes.
               </p>
               <div class="example"><a name="d5e15418"></a><p class="title"><b>Example&nbsp;13.4.4-1.&nbsp;Changing A Superclass</b></p>
                  <div class="example-contents">
                     <p class="note">Suppose that the following test program:</p><pre class="programlisting">
class Hyper { char h = 'h'; } 
class Super extends Hyper { char s = 's'; }
class Test extends Super {
    public static void printH(Hyper h) {
        System.out.println(h.h);
    }
    public static void main(String[] args) {
        printH(new Super());
    }
}
</pre><p class="note">is compiled and executed, producing the
                        output:
                     </p><pre class="screen">
h
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is then compiled:
                     </p><pre class="programlisting">
class Super { char s = 's'; }
</pre><p class="note">This version of class <code class="literal">Super</code> is
                        not a subclass of <code class="literal">Hyper</code>. If we then run the
                        existing binaries of <code class="literal">Hyper</code>
                        and <code class="literal">Test</code> with the new version
                        of <code class="literal">Super</code>, then a <code class="literal">VerifyError</code> is
                        thrown at link time. The verifier objects because the result
                        of <code class="literal">new Super()</code> cannot be passed as an argument in
                        place of a formal parameter of type <code class="literal">Hyper</code>,
                        because <code class="literal">Super</code> is not a subclass
                        of <code class="literal">Hyper</code>.
                     </p>
                     <p class="note">It is instructive to consider what might happen
                        without the verification step: the program might run and print:
                     </p><pre class="screen">
s
</pre><p class="note">This demonstrates that without the verifier, the
                        Java type system could be defeated by linking inconsistent binary
                        files, even though each was produced by a correct Java
                        compiler.
                     </p>
                     <p class="note">The lesson is that an implementation that lacks a
                        verifier or fails to use it will not maintain type safety and is,
                        therefore, not a valid implementation.
                     </p>
                  </div>
               </div><br class="example-break"><div class="informalexample">
                  <p class="note">The requirement that alternatives in a multi-<code class="literal">catch</code>
                     clause (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>) not be subclasses or superclasses
                     of each other is only a source restriction. Assuming the following
                     client code is legal:
                  </p><pre class="screen">
try {
    throwAorB();
} catch(ExceptionA | ExceptionB e) {
    ...
}
</pre><p class="note">where <code class="literal">ExceptionA</code>
                     and <code class="literal">ExceptionB</code> do not have a subclass/superclass
                     relationship when the client is compiled, it is binary compatible with
                     respect to the client for <code class="literal">ExceptionA</code>
                     and <code class="literal">ExceptionB</code> to have such a relationship when the
                     client is executed.
                  </p>
                  <p class="note">This is analogous to other situations where a class
                     transformation that is binary compatible for a client might not be
                     source compatible for the same client.
                  </p>
               </div>
            </div>
            <div class="section" title="13.4.5.&nbsp;Class Type Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.5"></a>13.4.5.&nbsp;Class Type Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.5-100"></a>Adding or removing a type
                  parameter of a class does not, in itself, have any implications for
                  binary compatibility.
               </p>
               <p class="norm"><a name="jls-13.4.5-110"></a>If such a type parameter is
                  used in the type of a field or method, that may have the normal
                  implications of changing the aforementioned type.
               </p>
               <p class="norm"><a name="jls-13.4.5-120"></a>Renaming a type parameter of
                  a class has no effect with respect to pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.5-130"></a>Changing the first bound of
                  a type parameter of a class may change the erasure
                  (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of any member that uses that type
                  parameter in its own type, and this may affect binary
                  compatibility. The change of such a bound is analogous to the change
                  of the first bound of a type parameter of a method or constructor
                  (<a class="xref" href="jls-13.html#jls-13.4.13" title="13.4.13.&nbsp;Method and Constructor Type Parameters">&sect;13.4.13</a>).
               </p>
               <p class="norm"><a name="jls-13.4.5-140"></a>Changing any other bound has
                  no effect on binary compatibility.
               </p>
            </div>
            <div class="section" title="13.4.6.&nbsp;Class Body and Member Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.6"></a>13.4.6.&nbsp;Class Body and Member Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.6-100"></a>No incompatibility with
                  pre-existing binaries is caused by adding an instance (respectively
                  <code class="literal">static</code>) member that has the same name and accessibility (for
                  fields), or same name and accessibility and signature and return type
                  (for methods), as an instance (respectively <code class="literal">static</code>) member of a
                  superclass or subclass. No error occurs even if the set of classes
                  being linked would encounter a compile-time error.
               </p>
               <p class="norm"><a name="jls-13.4.6-200"></a>Deleting a class member or
                  constructor that is not declared <code class="literal">private</code> may cause a linkage error
                  if the member or constructor is used by a pre-existing binary.
               </p>
               <div class="example"><a name="d5e15469"></a><p class="title"><b>Example&nbsp;13.4.6-1.&nbsp;Changing A Class Body</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Hyper {
    void hello() { System.out.println("hello from Hyper"); }
}
class Super extends Hyper {
    void hello() { System.out.println("hello from Super"); }
}
class Test {
    public static void main(String[] args) {
        new Super().hello();
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
hello from Super
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super extends Hyper {}
</pre><p class="note">Then, recompiling <code class="literal">Super</code> and
                        executing this new binary with the original binaries
                        for <code class="literal">Test</code> and <code class="literal">Hyper</code> produces the
                        output:
                     </p><pre class="screen">
hello from Hyper
</pre><p class="note">as expected.</p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.6-300"></a>The <code class="literal">super</code> keyword can be
                  used to access a method declared in a superclass, bypassing any
                  methods declared in the current class. The expression
                  <code class="literal">super</code><code class="literal">.</code><span class="emphasis"><em>Identifier</em></span> is resolved, at compile time, to a method <code class="varname">m</code>
                  in the superclass <span class="type">S</span>. If the method <code class="varname">m</code> is an instance method, then
                  the method which is invoked at run time is the method with the same
                  signature as <code class="varname">m</code> that is a member of the direct superclass of the
                  class containing the expression involving <code class="literal">super</code>.
               </p>
               <div class="example"><a name="d5e15493"></a><p class="title"><b>Example&nbsp;13.4.6-2.&nbsp;Changing A Superclass</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Hyper {
    void hello() { System.out.println("hello from Hyper"); }
}
class Super extends Hyper { }
class Test extends Super {
    public static void main(String[] args) {
        new Test().hello();
    }
    void hello() {
        super.hello();
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
hello from Hyper
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super extends Hyper {
    void hello() { System.out.println("hello from Super"); }
}
</pre><p class="note">Then, if <code class="literal">Super</code>
                        and <code class="literal">Hyper</code> are recompiled but
                        not <code class="literal">Test</code>, then running the new binaries with the
                        existing binary of <code class="literal">Test</code> produces the output:
                     </p><pre class="screen">
hello from Super
</pre><p class="note">as you might expect.</p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="13.4.7.&nbsp;Access to Members and Constructors">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.7"></a>13.4.7.&nbsp;Access to Members and Constructors
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.7-100"></a>Changing the declared access
                  of a member or constructor to permit less access may break
                  compatibility with pre-existing binaries, causing a linkage error to
                  be thrown when these binaries are resolved. Less access is permitted
                  if the access modifier is changed from default access to <code class="literal">private</code>
                  access; from <code class="literal">protected</code> access to default or <code class="literal">private</code> access; or
                  from <code class="literal">public</code> access to <code class="literal">protected</code>, default, or <code class="literal">private</code>
                  access. Changing a member or constructor to permit less access is
                  therefore not recommended for widely distributed classes.
               </p>
               <p class="norm"><a name="jls-13.4.7-110"></a>Perhaps surprisingly, the
                  binary format is defined so that changing a member or constructor to
                  be more accessible does not cause a linkage error when a subclass
                  (already) defines a method to have less access.
               </p>
               <div class="example"><a name="d5e15518"></a><p class="title"><b>Example&nbsp;13.4.7-1.&nbsp;Changing Accessibility</b></p>
                  <div class="example-contents">
                     <p class="note">If the package <code class="literal">points</code> defines the
                        class <code class="literal">Point</code>:
                     </p><pre class="programlisting">
package points;
public class Point {
    public int x, y;
    protected void print() {
        System.out.println("(" + x + "," + y + ")");
    }
}
</pre><p class="note">used by the program:</p><pre class="programlisting">
class Test extends points.Point {
    public static void main(String[] args) {
        Test t = new Test();
        t.print();
    }
    protected void print() { 
        System.out.println("Test"); 
    }
}
</pre><p class="note">then these classes compile
                        and <code class="literal">Test</code> executes to produce the output:
                     </p><pre class="screen">
Test
</pre><p class="note">If the method <code class="literal">print</code> in
                        class <code class="literal">Point</code> is changed to be <code class="literal">public</code>, and then
                        only the <code class="literal">Point</code> class is recompiled, and then
                        executed with the previously existing binary
                        for <code class="literal">Test</code>, then no linkage error occurs. This
                        happens even though it is improper, at compile time, for a <code class="literal">public</code>
                        method to be overridden by a <code class="literal">protected</code> method (as shown by the fact
                        that the class <code class="literal">Test</code> could not be recompiled using
                        this new <code class="literal">Point</code> class
                        unless <code class="literal">print</code> in <code class="literal">Test</code> were
                        changed to be <code class="literal">public</code>.)
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.7-200"></a>Allowing superclasses to
                  change <code class="literal">protected</code> methods to be <code class="literal">public</code> without breaking binaries of
                  pre-existing subclasses helps make binaries less fragile. The
                  alternative, where such a change would cause a linkage error, would
                  create additional binary incompatibilities.
               </p>
            </div>
            <div class="section" title="13.4.8.&nbsp;Field Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.8"></a>13.4.8.&nbsp;Field Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.8-100"></a>Widely distributed programs
                  should not expose any fields to their clients. Apart from the binary
                  compatibility issues discussed below, this is generally good software
                  engineering practice. Adding a field to a class may break
                  compatibility with pre-existing binaries that are not
                  recompiled.
               </p>
               <p class="norm"><a name="jls-13.4.8-110"></a>Assume a reference to a
                  field <code class="varname">f</code> with qualifying type <span class="type">T</span>. Assume further that <code class="varname">f</code> is in fact
                  an instance (respectively <code class="literal">static</code>) field declared in a superclass of
                  <span class="type">T</span>, <span class="type">S</span>, and that the type of <code class="varname">f</code> is <span class="type">X</span>.
               </p>
               <p class="norm"><a name="jls-13.4.8-120"></a>If a new field of type <span class="type">X</span>
                  with the same name as <code class="varname">f</code> is added to a subclass of <span class="type">S</span> that is a
                  superclass of <span class="type">T</span> or <span class="type">T</span> itself, then a linkage error may occur. Such
                  a linkage error will occur only if, in addition to the above, either
                  one of the following conditions hold:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.8-120-A"></a>The new field is less
                               accessible than the old one.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.8-120-B"></a>The new field is a
                               <code class="literal">static</code> (respectively instance) field.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-13.4.8-200"></a>In particular, no linkage
                  error will occur in the case where a class could no longer be
                  recompiled because a field access previously referenced a field of a
                  superclass with an incompatible type. The previously compiled class
                  with such a reference will continue to reference the field declared in
                  a superclass.
               </p>
               <div class="example"><a name="d5e15570"></a><p class="title"><b>Example&nbsp;13.4.8-1.&nbsp;Adding A Field Declaration</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Hyper { String h = "hyper"; }
class Super extends Hyper { String s = "super"; }
class Test {
    public static void main(String[] args) {
        System.out.println(new Super().h);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
hyper
</pre><p class="note">Suppose a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super extends Hyper {
    String s = "super";
    int h = 0;
}
</pre><p class="note">Then, recompiling <code class="literal">Hyper</code>
                        and <code class="literal">Super</code>, and executing the resulting new binaries
                        with the old binary of <code class="literal">Test</code> produces the
                        output:
                     </p><pre class="screen">
hyper
</pre><p class="note">The field <code class="literal">h</code>
                        of <code class="literal">Hyper</code> is output by the original binary
                        of <code class="literal">Test</code>. While this may seem surprising at first,
                        it serves to reduce the number of incompatibilities that occur at run
                        time. (In an ideal world, all source files that needed recompilation
                        would be recompiled whenever any one of them changed, eliminating such
                        surprises. But such a mass recompilation is often impractical or
                        impossible, especially in the Internet. And, as was previously noted,
                        such recompilation would sometimes require further changes to the
                        source code.)
                     </p>
                     <p class="note">As another example, if the program:</p><pre class="programlisting">
class Hyper { String h = "Hyper"; }
class Super extends Hyper { }
class Test extends Super {
    public static void main(String[] args) {
        String s = new Test().h;
        System.out.println(s);
    }
}
</pre><p class="note">is compiled and executed, it produces the
                        output:
                     </p><pre class="screen">
Hyper
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is then compiled:
                     </p><pre class="programlisting">
class Super extends Hyper { char h = 'h'; }
</pre><p class="note">If the resulting binary is used with the existing
                        binaries for <code class="literal">Hyper</code> and <code class="literal">Test</code>,
                        then the output is still:
                     </p><pre class="screen">
Hyper
</pre><p class="note">even though compiling the source for these
                        binaries:
                     </p><pre class="programlisting">
class Hyper { String h = "Hyper"; }
class Super extends Hyper { char h = 'h'; }
class Test extends Super {
    public static void main(String[] args) {
        String s = new Test().h;
        System.out.println(s);
    }
}
</pre><p class="note">would result in a compile-time error, because
                        the <code class="literal">h</code> in the source code
                        for <code class="literal">main</code> would now be construed as referring to the
                        <code class="literal">char</code> field declared in <code class="literal">Super</code>, and a <code class="literal">char</code> value
                        can't be assigned to a <code class="literal">String</code>.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.8-300"></a>Deleting a field from a
                  class will break compatibility with any pre-existing binaries that
                  reference this field, and a <code class="literal">NoSuchFieldError</code> will be thrown when such a
                  reference from a pre-existing binary is linked. Only <code class="literal">private</code> fields
                  may be safely deleted from a widely distributed class.
               </p>
               <p class="norm"><a name="jls-13.4.8-400"></a>For purposes of binary
                  compatibility, adding or removing a field <code class="varname">f</code> whose type involves type
                  variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) or parameterized types
                  (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) is equivalent to the addition
                  (respectively, removal) of a field of the same name whose type is the
                  erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the type of <code class="varname">f</code>.
               </p>
            </div>
            <div class="section" title="13.4.9.&nbsp;final Fields and Constants">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.9"></a>13.4.9.&nbsp;<code class="literal">final</code> Fields and Constants
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.9-100"></a>If a field that was not
                  declared <code class="literal">final</code> is changed to be declared <code class="literal">final</code>, then it can break
                  compatibility with pre-existing binaries that attempt to assign new
                  values to the field.
               </p>
               <div class="example"><a name="d5e15622"></a><p class="title"><b>Example&nbsp;13.4.9-1.&nbsp;Changing A Variable To Be <code class="literal">final</code></b></p>
                  <div class="example-contents"><pre class="programlisting">
class Super { static char s; }
class Test extends Super {
    public static void main(String[] args) {
        s = 'a';
        System.out.println(s);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
a
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super { static final char s = 'b'; }
</pre><p class="note">If <code class="literal">Super</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of <code class="literal">Test</code> results in
                        a <code class="literal">IllegalAccessError</code>.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.9-200"></a>Deleting the keyword <code class="literal">final</code>
                  or changing the value to which a field is initialized does not break
                  compatibility with existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.9-300"></a>If a field is a constant
                  variable (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>), then deleting the keyword
                  <code class="literal">final</code> or changing its value will not break compatibility with
                  pre-existing binaries by causing them not to run, but they will not
                  see any new value for the usage of the field unless they are
                  recompiled. This is true even if the usage itself is not a
                  compile-time constant expression (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>).
               </p>
               <p class="norm"><a name="jls-13.4.9-310"></a>This result is a side-effect
                  of the decision to support conditional compilation, as discussed at
                  the end of <a class="xref" href="jls-14.html#jls-14.21" title="14.21.&nbsp;Unreachable Statements">&sect;14.21</a>.
               </p>
               <div class="example"><a name="d5e15644"></a><p class="title"><b>Example&nbsp;13.4.9-2.&nbsp;Conditional Compilation</b></p>
                  <div class="example-contents">
                     <p class="note">If the example:</p><pre class="programlisting">
class Flags { static final boolean debug = true; }
class Test {
    public static void main(String[] args) {
        if (Flags.debug)
            System.out.println("debug is true");
    }
}
</pre><p class="note">is compiled and executed, it produces the
                        output:
                     </p><pre class="screen">
debug is true
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Flags</code> is produced:
                     </p><pre class="programlisting">
class Flags { static final boolean debug = false; }
</pre><p class="note">If <code class="literal">Flags</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of <code class="literal">Test</code> produces the output:
                     </p><pre class="screen">
debug is true
</pre><p class="note">because the value of <code class="literal">debug</code> was a
                        compile-time constant expression, and could have been used in
                        compiling <code class="literal">Test</code> without making a reference to the
                        class <code class="literal">Flags</code>.
                     </p>
                     <p class="note">This behavior would not change
                        if <code class="literal">Flags</code> were changed to be an interface, as in the
                        modified example:
                     </p><pre class="programlisting">
interface Flags { boolean debug = true; }
class Test {
    public static void main(String[] args) {
        if (Flags.debug)
            System.out.println("debug is true");
    }
}
</pre></div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.9-400"></a>The best way to avoid
                  problems with "inconstant constants" in widely-distributed code is to
                  declare as compile-time constants only values which truly are unlikely
                  ever to change. Other than for true mathematical constants, we
                  recommend that source code make very sparing use of class variables
                  that are declared <code class="literal">static</code> and <code class="literal">final</code>. If the read-only nature of
                  <code class="literal">final</code> is required, a better choice is to declare a <code class="literal">private</code>
                  <code class="literal">static</code> variable and a suitable accessor method to get its
                  value.
               </p>
               <p class="norm"><a name="jls-13.4.9-410"></a>Thus we recommend:
               </p><pre class="programlisting">

private static int N;
public static int getN() { return N; }

</pre><p class="norm"><a name="jls-13.4.9-420"></a>rather than:
               </p><pre class="programlisting">

public static final int N = ...;

</pre><p class="norm"><a name="jls-13.4.9-430"></a>There is no problem
                  with:
               </p><pre class="programlisting">

public static int N = ...;

</pre><p class="norm"><a name="jls-13.4.9-440"></a>if <code class="literal">N</code> need
                  not be read-only. We also recommend, as a general rule, that only
                  truly constant values be declared in interfaces.
               </p>
               <p class="norm"><a name="jls-13.4.9-450"></a>We note, but do not
                  recommend, that if a field of primitive type of an interface may
                  change, its value may be expressed idiomatically as in:
               </p><pre class="programlisting">

interface Flags {
    boolean debug = new Boolean(true).booleanValue();
}

</pre><p class="norm"><a name="jls-13.4.9-460"></a>ensuring that this value is
                  not a constant. Similar idioms exist for the other primitive
                  types.
               </p>
               <p class="norm"><a name="jls-13.4.9-500"></a>One other thing to note is
                  that <code class="literal">static</code> <code class="literal">final</code> fields that have constant values (whether of
                  primitive or <code class="literal">String</code> type) must never appear to have the default
                  initial value for their type (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>). This
                  means that all such fields appear to be initialized first during class
                  initialization (<a class="xref" href="jls-8.html#jls-8.3.2.1" title="8.3.2.1.&nbsp;Initializers for Class Variables">&sect;8.3.2.1</a>,
                  <a class="xref" href="jls-9.html#jls-9.3.1" title="9.3.1.&nbsp;Initialization of Fields in Interfaces">&sect;9.3.1</a>, <a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>).
               </p>
            </div>
            <div class="section" title="13.4.10.&nbsp;static Fields">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.10"></a>13.4.10.&nbsp;<code class="literal">static</code> Fields
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.10-100"></a>If a field that is not
                  declared <code class="literal">private</code> was not declared <code class="literal">static</code> and is changed to be
                  declared <code class="literal">static</code>, or vice versa, then a linkage error, specifically
                  an <code class="literal">IncompatibleClassChangeError</code>, will result if the field is used by a pre-existing binary
                  which expected a field of the other kind. Such changes are not
                  recommended in code that has been widely distributed.
               </p>
            </div>
            <div class="section" title="13.4.11.&nbsp;transient Fields">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.11"></a>13.4.11.&nbsp;<code class="literal">transient</code> Fields
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.11-100"></a>Adding or deleting a
                  <code class="literal">transient</code> modifier of a field does not break compatibility with
                  pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.12.&nbsp;Method and Constructor Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.12"></a>13.4.12.&nbsp;Method and Constructor Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.12-100"></a>Adding a method or
                  constructor declaration to a class will not break compatibility with
                  any pre-existing binaries, even in the case where a type could no
                  longer be recompiled because an invocation previously referenced a
                  method or constructor of a superclass with an incompatible type. The
                  previously compiled class with such a reference will continue to
                  reference the method or constructor declared in a superclass.
               </p>
               <p class="norm"><a name="jls-13.4.12-110"></a>Assume a reference to a
                  method <code class="varname">m</code> with qualifying type <span class="type">T</span>. Assume further that <code class="varname">m</code> is in
                  fact an instance (respectively <code class="literal">static</code>) method declared in a
                  superclass of <span class="type">T</span>, <span class="type">S</span>.
               </p>
               <p class="norm"><a name="jls-13.4.12-120"></a>If a new method of type <span class="type">X</span>
                  with the same signature and return type as <code class="varname">m</code> is added to a subclass
                  of <span class="type">S</span> that is a superclass of <span class="type">T</span> or <span class="type">T</span> itself, then a linkage error
                  may occur. Such a linkage error will occur only if, in addition to the
                  above, either one of the following conditions hold:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.12-120-A"></a>The new method is
                               less accessible than the old one.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.12-120-B"></a>The new method is a
                               <code class="literal">static</code> (respectively instance) method.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-13.4.12-200"></a>Deleting a method or
                  constructor from a class may break compatibility with any pre-existing
                  binary that referenced this method or constructor; a <code class="literal">NoSuchMethodError</code> may be
                  thrown when such a reference from a pre-existing binary is
                  linked. Such an error will occur only if no method with a matching
                  signature and return type is declared in a superclass.
               </p>
               <p class="norm"><a name="jls-13.4.12-300"></a>If the source code for
                  a non-inner class contains no declared
                  constructors, the Java compiler automatically supplies a default
                  constructor with no parameters (<a class="xref" href="jls-8.html#jls-8.8.9" title="8.8.9.&nbsp;Default Constructor">&sect;8.8.9</a>). Adding
                  one or more constructor declarations to the source code of such a
                  class will prevent this default constructor from being supplied
                  automatically, effectively deleting a constructor, unless one of the
                  new constructors also has no parameters, thus replacing the default
                  constructor. The automatically supplied constructor with no parameters
                  is given the same access modifier as the class of its declaration, so
                  any replacement should have as much or more access if compatibility
                  with pre-existing binaries is to be preserved.
               </p>
            </div>
            <div class="section" title="13.4.13.&nbsp;Method and Constructor Type Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.13"></a>13.4.13.&nbsp;Method and Constructor Type Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.13-100"></a>Adding or removing a type
                  parameter of a method or constructor does not, in itself, have any
                  implications for binary compatibility.
               </p>
               <p class="norm"><a name="jls-13.4.13-110"></a>If such a type parameter is
                  used in the type of the method or constructor, that may have the
                  normal implications of changing the aforementioned type.
               </p>
               <p class="norm"><a name="jls-13.4.13-120"></a>Renaming a type parameter
                  of a method or constructor has no effect with respect to pre-existing
                  binaries.
               </p>
               <p class="norm"><a name="jls-13.4.13-130"></a>Changing the first bound of
                  a type parameter of a method or constructor may change the erasure
                  (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of any member that uses that type
                  parameter in its own type, and this may affect binary
                  compatibility. Specifically:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.13-130-A"></a>If the type parameter
                                 is used as the type of a field, the effect is as if the field
                                 was removed and a field with the same name, whose type is the
                                 new erasure of the type variable, was added.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.13-130-B"></a>If the type parameter
                                 is used as the type of any formal parameter of a method, but not
                                 as the return type, the effect is as if that method were
                                 removed, and replaced with a new method that is identical except
                                 for the types of the aforementioned formal parameters, which now
                                 have the new erasure of the type parameter as their type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.13-130-C"></a>If the type parameter
                                 is used as a return type of a method, but not as the type of any
                                 formal parameter of the method, the effect is as if that method
                                 were removed, and replaced with a new method that is identical
                                 except for the return type, which is now the new erasure of the
                                 type parameter.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.13-130-D"></a>If the type parameter
                                 is used as a return type of a method and as the type of one or
                                 more formal parameters of the method, the effect is as if that
                                 method were removed, and replaced with a new method that is
                                 identical except for the return type, which is now the new
                                 erasure of the type parameter, and except for the types of the
                                 aforementioned formal parameters, which now have the new erasure
                                 of the type parameter as their types.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-13.4.13-200"></a>Changing any other bound
                  has no effect on binary compatibility.
               </p>
            </div>
            <div class="section" title="13.4.14.&nbsp;Method and Constructor Formal Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.14"></a>13.4.14.&nbsp;Method and Constructor Formal Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.14-100"></a>Changing the name of a
                  formal parameter of a method or constructor does not impact
                  pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.14-110"></a>Changing the name of a
                  method, or the type of a formal parameter to a method or constructor,
                  or adding a parameter to or deleting a parameter from a method or
                  constructor declaration creates a method or constructor with a new
                  signature, and has the combined effect of deleting the method or
                  constructor with the old signature and adding a method or constructor
                  with the new signature (<a class="xref" href="jls-13.html#jls-13.4.12" title="13.4.12.&nbsp;Method and Constructor Declarations">&sect;13.4.12</a>).
               </p>
               <p class="norm"><a name="jls-13.4.14-120"></a>Changing the type of the last formal parameter of a
                  method from <span class="type">T</span><code class="literal">[]</code> to a variable arity parameter
                  (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) of type <span class="type">T</span> (i.e. to
                  <span class="type">T</span><code class="literal">...</code>), and vice versa, does not impact
                  pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.14-130"></a>For purposes of binary
                  compatibility, adding or removing a method or constructor <code class="varname">m</code> whose
                  signature involves type variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) or
                  parameterized types (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) is equivalent to the
                  addition (respectively, removal) of an otherwise equivalent method
                  whose signature is the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the
                  signature of <code class="varname">m</code>.
               </p>
            </div>
            <div class="section" title="13.4.15.&nbsp;Method Result Type">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.15"></a>13.4.15.&nbsp;Method Result Type
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.15-100"></a>Changing the result type of
                  a method, or replacing a result type with <code class="literal">void</code>, or replacing <code class="literal">void</code>
                  with a result type, has the combined effect of deleting the old method
                  and adding a new method with the new result type or newly <code class="literal">void</code>
                  result (see <a class="xref" href="jls-13.html#jls-13.4.12" title="13.4.12.&nbsp;Method and Constructor Declarations">&sect;13.4.12</a>).
               </p>
               <p class="norm"><a name="jls-13.4.15-110"></a>For purposes of binary
                  compatibility, adding or removing a method or constructor <code class="varname">m</code> whose
                  return type involves type variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) or
                  parameterized types (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) is equivalent to the
                  addition (respectively, removal) of the an otherwise equivalent method
                  whose return type is the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the
                  return type of <code class="varname">m</code>.
               </p>
            </div>
            <div class="section" title="13.4.16.&nbsp;abstract Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.16"></a>13.4.16.&nbsp;<code class="literal">abstract</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.16-100"></a>Changing a method that is
                  declared <code class="literal">abstract</code> to no longer be declared <code class="literal">abstract</code> does not break
                  compatibility with pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.16-110"></a>Changing a method that is
                  not declared <code class="literal">abstract</code> to be declared <code class="literal">abstract</code> will break
                  compatibility with pre-existing binaries that previously invoked the
                  method, causing an <code class="literal">AbstractMethodError</code>.
               </p>
               <div class="example"><a name="d5e15787"></a><p class="title"><b>Example&nbsp;13.4.16-1.&nbsp;Changing A Method To Be <code class="literal">abstract</code></b></p>
                  <div class="example-contents"><pre class="programlisting">
class Super { void out() { System.out.println("Out"); } }
class Test extends Super {
    public static void main(String[] args) {
        Test t = new Test();
        System.out.println("Way ");
        t.out();
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
Way
Out
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
abstract class Super {
    abstract void out();
}
</pre><p class="note">If <code class="literal">Super</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of <code class="literal">Test</code> results in an <code class="literal">AbstractMethodError</code>,
                        because class <code class="literal">Test</code> has no implementation of the
                        method <code class="literal">out</code>, and is therefore is (or should be)
                        <code class="literal">abstract</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="13.4.17.&nbsp;final Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.17"></a>13.4.17.&nbsp;<code class="literal">final</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.17-100"></a>Changing a method that is
                  declared <code class="literal">final</code> to no longer be declared <code class="literal">final</code> does not break
                  compatibility with pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.17-110"></a>Changing an instance method
                  that is not declared <code class="literal">final</code> to be declared <code class="literal">final</code> may break
                  compatibility with existing binaries that depend on the ability to
                  override the method.
               </p>
               <div class="example"><a name="d5e15813"></a><p class="title"><b>Example&nbsp;13.4.17-1.&nbsp;Changing A Method To Be <code class="literal">final</code></b></p>
                  <div class="example-contents"><pre class="programlisting">
class Super { void out() { System.out.println("out"); } }
class Test extends Super {
    public static void main(String[] args) {
        Test t = new Test();
        t.out();
    }
    void out() { super.out(); }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
out
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super { final void out() { System.out.println("!"); } }
</pre><p class="note">If <code class="literal">Super</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of <code class="literal">Test</code> results in a <code class="literal">VerifyError</code> because
                        the class <code class="literal">Test</code> improperly tries to override the
                        instance method <code class="literal">out</code>.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.17-120"></a>Changing a class (<code class="literal">static</code>)
                  method that is not declared <code class="literal">final</code> to be declared <code class="literal">final</code> does not
                  break compatibility with existing binaries, because the method could
                  not have been overridden.
               </p>
            </div>
            <div class="section" title="13.4.18.&nbsp;native Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.18"></a>13.4.18.&nbsp;<code class="literal">native</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.18-100"></a>Adding or deleting a
                  <code class="literal">native</code> modifier of a method does not break compatibility with
                  pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.18-110"></a>The impact of changes to
                  types on pre-existing <code class="literal">native</code> methods that are not recompiled is
                  beyond the scope of this specification and should be provided with the
                  description of an implementation. Implementations are encouraged, but
                  not required, to implement <code class="literal">native</code> methods in a way that limits such
                  impact.
               </p>
            </div>
            <div class="section" title="13.4.19.&nbsp;static Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.19"></a>13.4.19.&nbsp;<code class="literal">static</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.19-100"></a>If a method that is not
                  declared <code class="literal">private</code> is also declared <code class="literal">static</code> (that is, a class method)
                  and is changed to not be declared <code class="literal">static</code> (that is, to an instance
                  method), or vice versa, then compatibility with pre-existing binaries
                  may be broken, resulting in a linkage time error, namely an <code class="literal">IncompatibleClassChangeError</code>, if
                  these methods are used by the pre-existing binaries. Such changes are
                  not recommended in code that has been widely distributed.
               </p>
            </div>
            <div class="section" title="13.4.20.&nbsp;synchronized Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.20"></a>13.4.20.&nbsp;<code class="literal">synchronized</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.20-100"></a>Adding or deleting a
                  <code class="literal">synchronized</code> modifier of a method does not break compatibility with
                  pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.21.&nbsp;Method and Constructor Throws">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.21"></a>13.4.21.&nbsp;Method and Constructor Throws
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.21-100"></a>Changes to the <code class="literal">throws</code>
                  clause of methods or constructors do not break compatibility with
                  pre-existing binaries; these clauses are checked only at compile
                  time.
               </p>
            </div>
            <div class="section" title="13.4.22.&nbsp;Method and Constructor Body">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.22"></a>13.4.22.&nbsp;Method and Constructor Body
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.22-100"></a>Changes to the body of a
                  method or constructor do not break compatibility with pre-existing
                  binaries.
               </p>
               <p class="norm"><a name="jls-13.4.22-110"></a>The keyword <code class="literal">final</code> on a
                  method does not mean that the method can be safely inlined; it means
                  only that the method cannot be overridden. It is still possible that a
                  new version of that method will be provided at link-time. Furthermore,
                  the structure of the original program must be preserved for purposes
                  of reflection.
               </p>
               <p class="norm"><a name="jls-13.4.22-120"></a>Therefore, we note that a
                  Java compiler cannot expand a method inline at compile time. In
                  general we suggest that implementations use late-bound (run-time) code
                  generation and optimization.
               </p>
            </div>
            <div class="section" title="13.4.23.&nbsp;Method and Constructor Overloading">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.23"></a>13.4.23.&nbsp;Method and Constructor Overloading
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.23-100"></a>Adding new methods or
                  constructors that overload existing methods or constructors does not
                  break compatibility with pre-existing binaries. The signature to be
                  used for each invocation was determined when these existing binaries
                  were compiled; therefore newly added methods or constructors will not
                  be used, even if their signatures are both applicable and more
                  specific than the signature originally chosen.
               </p>
               <p class="norm"><a name="jls-13.4.23-110"></a>While adding a new
                  overloaded method or constructor may cause a compile-time error the
                  next time a class or interface is compiled because there is no method
                  or constructor that is most specific
                  (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>), no such error occurs when a program
                  is executed, because no overload resolution is done at execution
                  time.
               </p>
               <div class="example"><a name="d5e15869"></a><p class="title"><b>Example&nbsp;13.4.23-1.&nbsp;Adding An Overloaded Method</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Super {
    static void out(float f) {
        System.out.println("float");
    }
}
class Test {
    public static void main(String[] args) {
        Super.out(2);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
float
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super {
    static void out(float f) { System.out.println("float"); }
    static void out(int i)   { System.out.println("int");   }
}
</pre><p class="note">If <code class="literal">Super</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of Test still produces the output:
                     </p><pre class="screen">
float
</pre><p class="note">However, if <code class="literal">Test</code> is then
                        recompiled, using this new <code class="literal">Super</code>, the output is
                        then:
                     </p><pre class="screen">
int
</pre><p class="note">as might have been naively expected in the previous
                        case.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="13.4.24.&nbsp;Method Overriding">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.24"></a>13.4.24.&nbsp;Method Overriding
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.24-100"></a>If an instance method is
                  added to a subclass and it overrides a method in a superclass, then
                  the subclass method will be found by method invocations in
                  pre-existing binaries, and these binaries are not impacted.
               </p>
               <p class="norm"><a name="jls-13.4.24-110"></a>If a class method is added
                  to a class, then this method will not be found unless the qualifying
                  type of the reference is the subclass type.
               </p>
            </div>
            <div class="section" title="13.4.25.&nbsp;Static Initializers">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.25"></a>13.4.25.&nbsp;Static Initializers
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.25-100"></a>Adding, deleting, or
                  changing a static initializer (<a class="xref" href="jls-8.html#jls-8.7" title="8.7.&nbsp;Static Initializers">&sect;8.7</a>) of a class
                  does not impact pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.26.&nbsp;Evolution of Enums">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.26"></a>13.4.26.&nbsp;Evolution of Enums
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.26-100"></a>Adding or reordering
                  constants in an enum type will not break compatibility with
                  pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.26-110"></a>If a pre-existing binary
                  attempts to access an enum constant that no longer exists, the client
                  will fail at run time with a <code class="literal">NoSuchFieldError</code>. Therefore such a change is not
                  recommended for widely distributed enums.
               </p>
               <p class="norm"><a name="jls-13.4.26-120"></a>In all other respects, the
                  binary compatibility rules for enums are identical to those for
                  classes.
               </p>
            </div>
         </div>
         <div class="section" title="13.5.&nbsp;Evolution of Interfaces">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.5"></a>13.5.&nbsp;Evolution of Interfaces
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-13.5-100"></a>This section describes the
               impact of changes to the declaration of an interface and its members
               on pre-existing binaries.
            </p>
            <div class="section" title="13.5.1.&nbsp;public Interfaces">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.1"></a>13.5.1.&nbsp;<code class="literal">public</code> Interfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.1-100"></a>Changing an interface that
                  is not declared <code class="literal">public</code> to be declared <code class="literal">public</code> does not break
                  compatibility with pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.5.1-110"></a>If an interface that is
                  declared <code class="literal">public</code> is changed to not be declared <code class="literal">public</code>, then an
                  <code class="literal">IllegalAccessError</code> is thrown if a pre-existing binary is linked that needs but no
                  longer has access to the interface type, so such a change is not
                  recommended for widely distributed interfaces.
               </p>
            </div>
            <div class="section" title="13.5.2.&nbsp;Superinterfaces">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.2"></a>13.5.2.&nbsp;Superinterfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.2-100"></a>Changes to the interface
                  hierarchy cause errors in the same way that changes to the class
                  hierarchy do, as described in <a class="xref" href="jls-13.html#jls-13.4.4" title="13.4.4.&nbsp;Superclasses and Superinterfaces">&sect;13.4.4</a>. In
                  particular, changes that result in any previous superinterface of a
                  class no longer being a superinterface can break compatibility with
                  pre-existing binaries, resulting in a <code class="literal">VerifyError</code>.
               </p>
            </div>
            <div class="section" title="13.5.3.&nbsp;Interface Members">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.3"></a>13.5.3.&nbsp;Interface Members
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.3-100"></a>Adding a method to an
                  interface does not break compatibility with pre-existing
                  binaries.
               </p>
               <p class="norm"><a name="jls-13.5.3-110"></a>A field added to a
                  superinterface of <span class="type">C</span> may hide a field inherited from a superclass of
                  <span class="type">C</span>. If the original reference was to an instance field, an <code class="literal">IncompatibleClassChangeError</code>
                  will result. If the original reference was an assignment, an <code class="literal">IllegalAccessError</code>
                  will result.
               </p>
               <p class="norm"><a name="jls-13.5.3-120"></a>Deleting a member from an
                  interface may cause linkage errors in pre-existing binaries.
               </p>
               <div class="example"><a name="d5e15927"></a><p class="title"><b>Example&nbsp;13.5.3-1.&nbsp;Deleting An Interface Member</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface I { void hello(); }
class Test implements I {
    public static void main(String[] args) {
        I anI = new Test();
        anI.hello();
    }
    public void hello() { System.out.println("hello"); }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
hello
</pre><p class="note">Suppose that a new version of
                        interface <code class="literal">I</code> is compiled:
                     </p><pre class="programlisting">
interface I {}
</pre><p class="note">If <code class="literal">I</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary for <code class="literal">Test</code> will result in a
                        <code class="literal">NoSuchMethodError</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="13.5.4.&nbsp;Interface Type Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.4"></a>13.5.4.&nbsp;Interface Type Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.4-100"></a>The effects of changes to
                  the type parameters of an interface are the same as those of analogous
                  changes to the type parameters of a class.
               </p>
            </div>
            <div class="section" title="13.5.5.&nbsp;Field Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.5"></a>13.5.5.&nbsp;Field Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.5-100"></a>The considerations for
                  changing field declarations in interfaces are the same as those
                  for <code class="literal">static final</code> fields in classes, as described in
                  <a class="xref" href="jls-13.html#jls-13.4.8" title="13.4.8.&nbsp;Field Declarations">&sect;13.4.8</a> and <a class="xref" href="jls-13.html#jls-13.4.9" title="13.4.9.&nbsp;final Fields and Constants">&sect;13.4.9</a>.
               </p>
            </div>
            <div class="section" title="13.5.6.&nbsp;abstract Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.6"></a>13.5.6.&nbsp;<code class="literal">abstract</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.6-100"></a>The considerations for
                  changing <code class="literal">abstract</code> method declarations in interfaces are the same as
                  those for <code class="literal">abstract</code> methods in classes, as described in
                  <a class="xref" href="jls-13.html#jls-13.4.14" title="13.4.14.&nbsp;Method and Constructor Formal Parameters">&sect;13.4.14</a>, <a class="xref" href="jls-13.html#jls-13.4.15" title="13.4.15.&nbsp;Method Result Type">&sect;13.4.15</a>,
                  <a class="xref" href="jls-13.html#jls-13.4.21" title="13.4.21.&nbsp;Method and Constructor Throws">&sect;13.4.21</a>, and
                  <a class="xref" href="jls-13.html#jls-13.4.23" title="13.4.23.&nbsp;Method and Constructor Overloading">&sect;13.4.23</a>.
               </p>
            </div>
            <div class="section" title="13.5.7.&nbsp;Evolution of Annotation Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.7"></a>13.5.7.&nbsp;Evolution of Annotation Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.7-100"></a>Annotation types behave
                  exactly like any other interface. Adding or removing an element from
                  an annotation type is analogous to adding or removing a method. There
                  are important considerations governing other changes to annotation
                  types, but these have no effect on the linkage of binaries by the
                  Java Virtual Machine. Rather, such changes affect the behavior of reflective APIs
                  that manipulate annotations. The documentation of these APIs specifies
                  their behavior when various changes are made to the underlying
                  annotation types.
               </p>
               <p class="norm"><a name="jls-13.5.7-110"></a>Adding or removing
                  annotations has no effect on the correct linkage of the binary
                  representations of programs in the Java programming language.
               </p>
            </div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-12.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-14.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;12.&nbsp;Execution&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;14.&nbsp;Blocks and Statements</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>
