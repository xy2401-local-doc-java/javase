
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;4.&nbsp;Types, Values, and Variables</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-3.html" title="Chapter&nbsp;3.&nbsp;Lexical Structure">
      <link rel="next" href="jls-5.html" title="Chapter&nbsp;5.&nbsp;Conversions and Promotions">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo">
<img src="../../../../webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="../../../../7/docs/">Java SE</a> &gt; <a href="../../../index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;4.&nbsp;Types, Values, and Variables</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-3.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-5.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;4.&nbsp;Types, Values, and Variables">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-4"></a>Chapter&nbsp;4.&nbsp;Types, Values, and Variables
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-4.html#jls-4.1">4.1. The Kinds of Types and Values</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.2">4.2. Primitive Types and Values</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.1">4.2.1. Integral Types and Values</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.2">4.2.2. Integer Operations</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.3">4.2.3. Floating-Point Types, Formats, and Values</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.4">4.2.4. Floating-Point Operations</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.5">4.2.5. The <code class="literal">boolean</code> Type and boolean Values</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-4.html#jls-4.3">4.3. Reference Types and Values</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.3.1">4.3.1. Objects</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.3.2">4.3.2. The Class <code class="literal">Object</code></a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.3.3">4.3.3. The Class <code class="literal">String</code></a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.3.4">4.3.4. When Reference Types Are the Same</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-4.html#jls-4.4">4.4. Type Variables</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.5">4.5. Parameterized Types</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.5.1">4.5.1. Type Arguments and Wildcards</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.5.2">4.5.2. Members and Constructors of Parameterized Types</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-4.html#jls-4.6">4.6. Type Erasure</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.7">4.7. Reifiable Types</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.8">4.8. Raw Types</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.9">4.9. Intersection Types</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.10">4.10. Subtyping</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.10.1">4.10.1. Subtyping among Primitive Types</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.10.2">4.10.2. Subtyping among Class and Interface Types</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.10.3">4.10.3. Subtyping among Array Types</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-4.html#jls-4.11">4.11. Where Types Are Used</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.12">4.12. Variables</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.1">4.12.1. Variables of Primitive Type</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.2">4.12.2. Variables of Reference Type</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.3">4.12.3. Kinds of Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.4">4.12.4. <code class="literal">final</code> Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.5">4.12.5. Initial Values of Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.6">4.12.6. Types, Classes, and Interfaces</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <p class="norm"><a name="jls-4-100"></a>The Java programming language is
            a <span class="emphasis"><em>statically typed</em></span> language, which means that
            every variable and every expression has a type that is known at
            compile time.
         </p>
         <p class="norm"><a name="jls-4-110"></a>The Java programming language is also
            a <span class="emphasis"><em>strongly typed</em></span> language, because types limit
            the values that a variable (<a class="xref" href="jls-4.html#jls-4.12" title="4.12.&nbsp;Variables">&sect;4.12</a>) can hold or
            that an expression can produce, limit the operations supported on
            those values, and determine the meaning of the operations. Strong
            static typing helps detect errors at compile time.
         </p>
         <p class="norm"><a name="jls-4-120"></a>The types of the Java programming language are
            divided into two categories: primitive types and reference types. The
            primitive types (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>) are the <code class="literal">boolean</code> type and
            the numeric types. The numeric types are the integral types <code class="literal">byte</code>,
            <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code>, and <code class="literal">char</code>, and the floating-point types
            <code class="literal">float</code> and <code class="literal">double</code>. The reference types (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>)
            are class types, interface types, and array types. There is also a
            special null type. An object (<a class="xref" href="jls-4.html#jls-4.3.1" title="4.3.1.&nbsp;Objects">&sect;4.3.1</a>) is a
            dynamically created instance of a class type or a dynamically created
            array. The values of a reference type are references to objects. All
            objects, including arrays, support the methods of class <code class="literal">Object</code>
            (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>). String literals are represented by
            <code class="literal">String</code> objects (<a class="xref" href="jls-4.html#jls-4.3.3" title="4.3.3.&nbsp;The Class String">&sect;4.3.3</a>).
         </p>
         <div class="section" title="4.1.&nbsp;The Kinds of Types and Values">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.1"></a>4.1.&nbsp;The Kinds of Types and Values
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.1-100"></a>There are
               two kinds of types in the Java programming language: primitive types
               (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>) and reference types
               (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>). There are, correspondingly, two kinds of
               data values that can be stored in variables, passed as arguments,
               returned by methods, and operated on: primitive values
               (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>) and reference values
               (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>).
            </p>
            <div class="literallayout">
               <p><br>
                  Type:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;PrimitiveType<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ReferenceType<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-4.1-200"></a>There is
               also a special <span class="emphasis"><em>null type</em></span>, the type of the
               expression <code class="literal">null</code> (<a class="xref" href="jls-3.html#jls-3.10.7" title="3.10.7.&nbsp;The Null Literal">&sect;3.10.7</a>,
               <a class="xref" href="jls-15.html#jls-15.8.1" title="15.8.1.&nbsp;Lexical Literals">&sect;15.8.1</a>), which has no name.
            </p>
            <p class="norm-static"><a name="jls-4.1-210"></a>Because the
               null type has no name, it is impossible to declare a variable of the
               null type or to cast to the null type.
            </p>
            <p class="norm-dynamic"><a name="jls-4.1-220"></a>The null
               reference is the only possible value of an expression of null
               type.
            </p>
            <p class="norm-dynamic"><a name="jls-4.1-230"></a>The null
               reference can always  undergo a widening reference
               conversion to any reference type.
            </p>
            <p class="note">In practice, the programmer can ignore the null type
               and just pretend that null is merely a special literal that can be of
               any reference type.
            </p>
         </div>
         <div class="section" title="4.2.&nbsp;Primitive Types and Values">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.2"></a>4.2.&nbsp;Primitive Types and Values
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.2-100"></a>A primitive
               type is predefined by the Java programming language and named by its reserved keyword
               (<a class="xref" href="jls-3.html#jls-3.9" title="3.9.&nbsp;Keywords">&sect;3.9</a>):
            </p>
            <div class="literallayout">
               <p><br>
                  PrimitiveType:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;NumericType<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">boolean</code><br>
                  <br>
                  NumericType:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;IntegralType<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;FloatingPointType<br>
                  <br>
                  IntegralType:&nbsp;one&nbsp;of<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">byte</code>&nbsp;<code class="literal">short</code>&nbsp;<code class="literal">int</code>&nbsp;<code class="literal">long</code>&nbsp;<code class="literal">char</code><br>
                  <br>
                  FloatingPointType:&nbsp;one&nbsp;of<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">float</code>&nbsp;<code class="literal">double</code><br>
                  
               </p>
            </div>
            <p class="norm-dynamic"><a name="jls-4.2-120"></a>Primitive
               values do not share state with other primitive values.
            </p>
            <p class="norm-static"><a name="jls-4.2-200"></a>The <span class="emphasis"><em>numeric types</em></span> are the
               integral types and the floating-point types.
            </p>
            <p class="norm-static"><a name="jls-4.2-210"></a>The <span class="emphasis"><em>integral types</em></span> are
               <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, and <code class="literal">long</code>, whose values are 8-bit, 16-bit,
               32-bit and 64-bit signed two's-complement integers, respectively, and
               <code class="literal">char</code>, whose values are 16-bit unsigned integers representing UTF-16
               code units (<a class="xref" href="jls-3.html#jls-3.1" title="3.1.&nbsp;Unicode">&sect;3.1</a>).
            </p>
            <p class="norm-static"><a name="jls-4.2-220"></a>The <span class="emphasis"><em>floating-point types</em></span> are
               <code class="literal">float</code>, whose values include the 32-bit IEEE 754 floating-point
               numbers, and <code class="literal">double</code>, whose values include the 64-bit IEEE 754
               floating-point numbers.
            </p>
            <p class="norm-dynamic"><a name="jls-4.2-300"></a>The
               <code class="literal">boolean</code> type has exactly two values: <code class="literal">true</code> and <code class="literal">false</code>.
            </p>
            <div class="section" title="4.2.1.&nbsp;Integral Types and Values">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.1"></a>4.2.1.&nbsp;Integral Types and Values
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.2.1-100"></a>The
                  values of the integral types are integers in the following
                  ranges:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-A"></a>For
                                <code class="literal">byte</code>, from -128 to 127, inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-B"></a>For
                                <code class="literal">short</code>, from -32768 to 32767, inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-C"></a>For
                                <code class="literal">int</code>, from -2147483648 to 2147483647, inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-D"></a>For
                                <code class="literal">long</code>, from -9223372036854775808 to 9223372036854775807,
                                inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-E"></a>For
                                <code class="literal">char</code>, from <code class="literal">'\u0000'</code>
                                to <code class="literal">'\uffff'</code> inclusive, that is, from 0 to
                                65535
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="4.2.2.&nbsp;Integer Operations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.2"></a>4.2.2.&nbsp;Integer Operations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.2.2-100"></a>The Java programming language provides a
                  number of operators that act on integral values:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-A"></a>The comparison
                               operators, which result in a value of type <code class="literal">boolean</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-A-1"></a>The numerical
                                    	comparison operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>,
                                    	<code class="literal">&gt;</code>, and <code class="literal">&gt;=</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.20.1" title="15.20.1.&nbsp;Numerical Comparison Operators <, <=, &gt;, and &gt;=">&sect;15.20.1</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-A-2"></a>The numerical
                                    	equality operators <code class="literal">==</code> and <code class="literal">!=</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.21.1" title="15.21.1.&nbsp;Numerical Equality Operators == and !=">&sect;15.21.1</a>)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-B"></a>The numerical
                               operators, which result in a value of type <code class="literal">int</code> or <code class="literal">long</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-1"></a>The unary plus
                                    	and minus operators <code class="literal">+</code> and <code class="literal">-</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.15.3" title="15.15.3.&nbsp;Unary Plus Operator +">&sect;15.15.3</a>,
                                    	<a class="xref" href="jls-15.html#jls-15.15.4" title="15.15.4.&nbsp;Unary Minus Operator -">&sect;15.15.4</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-2"></a>The
                                    	multiplicative operators <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">%</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.17" title="15.17.&nbsp;Multiplicative Operators">&sect;15.17</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-3"></a>The additive
                                    	operators <code class="literal">+</code> and <code class="literal">-</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.18" title="15.18.&nbsp;Additive Operators">&sect;15.18</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-4"></a>The increment
                                    	operator <code class="literal">++</code>, both prefix
                                    	(<a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>) and postfix
                                    	(<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-5"></a>The decrement
                                    	operator <code class="literal">--</code>, both prefix
                                    	(<a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>) and postfix
                                    	(<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-6"></a>The signed and
                                    	unsigned shift operators <code class="literal">&lt;&lt;</code>, <code class="literal">&gt;&gt;</code>, and <code class="literal">&gt;&gt;&gt;</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.19" title="15.19.&nbsp;Shift Operators">&sect;15.19</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-7"></a>The bitwise
                                    	complement operator <code class="literal">~</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.15.5" title="15.15.5.&nbsp;Bitwise Complement Operator ~">&sect;15.15.5</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-8"></a>The integer
                                    	bitwise operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.22.1" title="15.22.1.&nbsp;Integer Bitwise Operators &amp;, ^, and |">&sect;15.22.1</a>)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-C"></a>The conditional
                               operator <code class="literal">? :</code> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-D"></a>The cast operator
                               (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>), which can convert from an integral
                               value to a value of any specified numeric type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-E"></a>The string
                               concatenation operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>),
                               which, when given a <code class="literal">String</code> operand and an integral operand, will
                               convert the integral operand to a <code class="literal">String</code> representing its value
                               in decimal form, and then produce a newly created <code class="literal">String</code> that is
                               the concatenation of the two strings
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-4.2.2-110"></a>Other useful constructors,
                  methods, and constants are predefined in the classes <code class="literal">Byte</code>, <code class="literal">Short</code>,
                  <code class="literal">Integer</code>, <code class="literal">Long</code>, and <code class="literal">Character</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.2-200"></a>If an
                  integer operator other than a shift operator has at least one operand
                  of type <code class="literal">long</code>, then the operation is carried out using 64-bit
                  precision, and the result of the numerical operator is of type
                  <code class="literal">long</code>. If the other operand is not <code class="literal">long</code>, it is first widened
                  (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>) to type <code class="literal">long</code> by numeric promotion
                  (<a class="xref" href="jls-5.html#jls-5.6" title="5.6.&nbsp;Numeric Promotions">&sect;5.6</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.2-210"></a>Otherwise, the operation is carried out using
                  32-bit precision, and the result of the numerical operator is of type
                  <code class="literal">int</code>. If either operand is not an <code class="literal">int</code>, it is first widened to type
                  <code class="literal">int</code> by numeric promotion.
               </p>
               <p class="norm"><a name="jls-4.2.2-220"></a>Any value of any integral
                  type may be cast to or from any numeric type. There are no casts
                  between integral types and the type <code class="literal">boolean</code>.
               </p>
               <p class="note">See <a class="xref" href="jls-4.html#jls-4.2.5" title="4.2.5.&nbsp;The boolean Type and boolean Values">&sect;4.2.5</a> for an idiom to
                  convert integer expressions to <code class="literal">boolean</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.2-300"></a>The
                   integer operators do not indicate overflow or
                  underflow in any way.
               </p>
               <p class="norm"><a name="jls-4.2.2-310"></a>An integer operator can throw
                  an exception (<a class="xref" href="jls-11.html" title="Chapter&nbsp;11.&nbsp;Exceptions">&sect;11</a>) for the following
                  reasons:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-310-A"></a>Any integer operator
                                 can throw a <code class="literal">NullPointerException</code> if unboxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) of a null reference is
                                 required.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-310-B"></a>The integer divide
                                 operator <code class="literal">/</code> (<a class="xref" href="jls-15.html#jls-15.17.2" title="15.17.2.&nbsp;Division Operator /">&sect;15.17.2</a>) and the
                                 integer remainder operator <code class="literal">%</code>
                                 (<a class="xref" href="jls-15.html#jls-15.17.3" title="15.17.3.&nbsp;Remainder Operator %">&sect;15.17.3</a>) can throw an
                                 <code class="literal">ArithmeticException</code> if the right-hand operand is zero.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-310-C"></a>The increment and
                                 decrement operators <code class="literal">++</code> (<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>,
                                 <a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>) and <code class="literal">--</code>
                                 (<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>, <a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>)
                                 can throw an <code class="literal">OutOfMemoryError</code> if boxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) is required and there is not
                                 sufficient memory available to perform the conversion.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e1624"></a><p class="title"><b>Example&nbsp;4.2.2-1.&nbsp;Integer Operations</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        int i = 1000000;
        System.out.println(i * i);
        long l = i;
        System.out.println(l * l);
        System.out.println(20296 / (l - i));
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
-727379968
1000000000000
</pre><p class="note">and then encounters an <code class="literal">ArithmeticException</code> in the
                        division by <code class="literal">l - i</code>, because <code class="literal">l - i</code>
                        is zero. The first multiplication is performed in 32-bit precision,
                        whereas the second multiplication is a <code class="literal">long</code> multiplication. The
                        value <code class="literal">-727379968</code> is the decimal value of the low 32
                        bits of the mathematical result, <code class="literal">1000000000000</code>,
                        which is a value too large for type <code class="literal">int</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.3"></a>4.2.3.&nbsp;Floating-Point Types, Formats, and Values
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.2.3-100"></a>The
                  floating-point types are <code class="literal">float</code> and <code class="literal">double</code>, which are conceptually
                  associated with the single-precision 32-bit and double-precision
                  64-bit format IEEE 754 values and operations as specified
                  in <em class="citetitle">IEEE Standard for Binary Floating-Point
                     Arithmetic</em>, ANSI/IEEE Standard 754-1985 (IEEE, New
                  York).
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-110"></a>The IEEE
                  754 standard includes not only positive and negative numbers that
                  consist of a sign and magnitude, but also positive and negative zeros,
                  positive and negative <span class="emphasis"><em>infinities</em></span>, and
                  special <span class="emphasis"><em>Not-a-Number</em></span> values (hereafter
                  abbreviated NaN). A NaN value is used to represent the result of
                  certain invalid operations such as dividing zero by zero. NaN
                  constants of both <code class="literal">float</code> and <code class="literal">double</code> type are predefined
                  as <code class="literal">Float.NaN</code>
                  and <code class="literal">Double.NaN</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-120"></a>Every
                  implementation of the Java programming language is required to support two standard
                  sets of floating-point values, called the <span class="emphasis"><em>float value
                        set</em></span> and the <span class="emphasis"><em>double value set</em></span>. In
                  addition, an implementation of the Java programming language may support either or
                  both of two extended-exponent floating-point value sets, called
                  the <span class="emphasis"><em>float-extended-exponent value set</em></span> and
                  the <span class="emphasis"><em>double-extended-exponent value set</em></span>. These
                  extended-exponent value sets may, under certain circumstances, be used
                  instead of the standard value sets to represent the values of
                  expressions of type <code class="literal">float</code> or <code class="literal">double</code> (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>,
                  <a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-130"></a>The
                  finite nonzero values of any floating-point value set can all be
                  expressed in the form <span class="emphasis"><em>s</em></span> &middot; <span class="emphasis"><em>m</em></span>
                  &middot; 2<sup>(<span class="emphasis"><em>e</em></span> - <span class="emphasis"><em>N</em></span> +
                     1)</sup>, where <span class="emphasis"><em>s</em></span> is +1 or
                  -1, <span class="emphasis"><em>m</em></span> is a positive integer less than
                  2<sup><span class="emphasis"><em>N</em></span></sup>,
                  and <span class="emphasis"><em>e</em></span> is an integer
                  between <span class="emphasis"><em>E<sub>min</sub></em></span> =
                  -(2<sup><span class="emphasis"><em>K</em></span>-1</sup>-2)
                  and <span class="emphasis"><em>E<sub>max</sub></em></span> =
                  2<sup><span class="emphasis"><em>K</em></span>-1</sup>-1, inclusive, and
                  where <span class="emphasis"><em>N</em></span> and <span class="emphasis"><em>K</em></span> are parameters
                  that depend on the value set. Some values can be represented in this
                  form in more than one way; for example, supposing that a
                  value <span class="emphasis"><em>v</em></span> in a value set might be represented in
                  this form using certain values for
                  <span class="emphasis"><em>s</em></span>, <span class="emphasis"><em>m</em></span>,
                  and <span class="emphasis"><em>e</em></span>, then if it happened
                  that <span class="emphasis"><em>m</em></span> were even and <span class="emphasis"><em>e</em></span> were
                  less than 2<sup><span class="emphasis"><em>K</em></span>-1</sup>, one
                  could halve <span class="emphasis"><em>m</em></span> and increase <span class="emphasis"><em>e</em></span>
                  by 1 to produce a second representation for the same
                  value <span class="emphasis"><em>v</em></span>. A representation in this form is
                  called <span class="emphasis"><em>normalized</em></span> if <span class="emphasis"><em>m</em></span> &#8805;
                  2<sup><span class="emphasis"><em>N</em></span>-1</sup>; otherwise the
                  representation is said to be <span class="emphasis"><em>denormalized</em></span>. If a
                  value in a value set cannot be represented in such a way
                  that <span class="emphasis"><em>m</em></span> &#8805;
                  2<sup><span class="emphasis"><em>N</em></span>-1</sup>, then the value
                  is said to be a <span class="emphasis"><em>denormalized value</em></span>, because it
                  has no normalized representation.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-140"></a>The
                  constraints on the parameters <span class="emphasis"><em>N</em></span>
                  and <span class="emphasis"><em>K</em></span> (and on the derived
                  parameters <span class="emphasis"><em>E<sub>min</sub></em></span>
                  and <span class="emphasis"><em>E<sub>max</sub></em></span>) for the two
                  required and two optional floating-point value sets are summarized in
                  <a class="xref" href="jls-4.html#jls-4.2.3-140-A" title="Table&nbsp;4.1.&nbsp;Floating-point value set parameters">Table&nbsp;4.1</a>.
               </p>
               <div class="table"><a name="jls-4.2.3-140-A"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Floating-point value set parameters</b></p>
                  <div class="table-contents">
                     <table summary="Floating-point value set parameters" border="1">
                        <colgroup>
                           <col>
                           <col>
                           <col>
                           <col>
                           <col>
                        </colgroup>
                        <thead>
                           <tr>
                              <th>Parameter</th>
                              <th>float</th>
                              <th>float-extended-exponent</th>
                              <th>double</th>
                              <th>double-extended-exponent</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td><span class="emphasis"><em>N</em></span></td>
                              <td>24</td>
                              <td>24</td>
                              <td>53</td>
                              <td>53</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>K</em></span></td>
                              <td>8</td>
                              <td>&#8805; 11</td>
                              <td>11</td>
                              <td>&#8805; 15</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>E<sub>max</sub></em></span></td>
                              <td>+127</td>
                              <td>&#8805; +1023</td>
                              <td>+1023</td>
                              <td>&#8805; +16383</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>E<sub>min</sub></em></span></td>
                              <td>-126</td>
                              <td>&#8804; -1022</td>
                              <td>-1022</td>
                              <td>&#8804; -16382</td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div><br class="table-break"><p class="norm-dynamic"><a name="jls-4.2.3-150"></a>Where one
                  or both extended-exponent value sets are supported by an
                  implementation, then for each supported extended-exponent value set
                  there is a specific implementation-dependent
                  constant <span class="emphasis"><em>K</em></span>, whose value is constrained by
                  <a class="xref" href="jls-4.html#jls-4.2.3-140-A" title="Table&nbsp;4.1.&nbsp;Floating-point value set parameters">Table&nbsp;4.1</a>; this value <span class="emphasis"><em>K</em></span>
                  in turn dictates the values
                  for <span class="emphasis"><em>E<sub>min</sub></em></span>
                  and <span class="emphasis"><em>E<sub>max</sub></em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-160"></a>Each of
                  the four value sets includes not only the finite nonzero values that
                  are ascribed to it above, but also NaN values and the four values
                  positive zero, negative zero, positive infinity, and negative
                  infinity.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-170"></a>Note that
                  the constraints in <a class="xref" href="jls-4.html#jls-4.2.3-140-A" title="Table&nbsp;4.1.&nbsp;Floating-point value set parameters">Table&nbsp;4.1</a> are designed so
                  that every element of the float value set is necessarily also an
                  element of the float-extended-exponent value set, the double value
                  set, and the double-extended-exponent value set. Likewise, each
                  element of the double value set is necessarily also an element of the
                  double-extended-exponent value set. Each extended-exponent value set
                  has a larger range of exponent values than the corresponding standard
                  value set, but does not have more precision.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-180"></a>The
                  elements of the float value set are exactly the values that can be
                  represented using the single floating-point format defined in the IEEE
                  754 standard. The elements of the double value set are exactly the
                  values that can be represented using the double floating-point format
                  defined in the IEEE 754 standard. Note, however, that the elements of
                  the float-extended-exponent and double-extended-exponent value sets
                  defined here do <span class="emphasis"><em>not</em></span> correspond to the values that
                  can be represented using IEEE 754 single extended and double extended
                  formats, respectively.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-190"></a>The
                  float, float-extended-exponent, double, and double-extended-exponent
                  value sets are not types. It is always correct for an implementation
                  of the Java programming language to use an element of the float value set to
                  represent a value of type <code class="literal">float</code>; however, it may be permissible in
                  certain regions of code for an implementation to use an element of the
                  float-extended-exponent value set instead. Similarly, it is always
                  correct for an implementation to use an element of the double value
                  set to represent a value of type <code class="literal">double</code>; however, it may be
                  permissible in certain regions of code for an implementation to use an
                  element of the double-extended-exponent value set instead.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-200"></a>Except
                  for NaN, floating-point values are <span class="emphasis"><em>ordered</em></span>;
                  arranged from smallest to largest, they are negative infinity,
                  negative finite nonzero values, positive and negative zero, positive
                  finite nonzero values, and positive infinity.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-210"></a>IEEE 754
                  allows multiple distinct NaN values for each of its single and double
                  floating-point formats. While each hardware architecture returns a
                  particular bit pattern for NaN when a new NaN is generated, a
                  programmer can also create NaNs with different bit patterns to encode,
                  for example, retrospective diagnostic information.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-220"></a>For the
                  most part, the Java SE platform treats NaN values of a given type as though
                  collapsed into a single canonical value, and hence this specification
                  normally refers to an arbitrary NaN as though to a canonical
                  value.
               </p>
               <p class="note">However, version 1.3 of the Java SE platform introduced
                  methods enabling the programmer to distinguish between NaN values:
                  the <code class="literal">Float.floatToRawIntBits</code>
                  and <code class="literal">Double.doubleToRawLongBits</code> methods. The
                  interested reader is referred to the specifications for the <code class="literal">Float</code>
                  and <code class="literal">Double</code> classes for more information.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-230"></a>Positive
                  zero and negative zero compare equal; thus the result of the
                  expression <code class="literal">0.0==-0.0</code> is <code class="literal">true</code> and the result
                  of <code class="literal">0.0&gt;-0.0</code> is false. But other operations can
                  distinguish positive and negative zero; for
                  example, <code class="literal">1.0/0.0</code> has the value positive infinity,
                  while the value of <code class="literal">1.0/-0.0</code> is negative
                  infinity.
               </p>
               <p class="norm"><a name="jls-4.2.3-240"></a>NaN
                  is <span class="emphasis"><em>unordered</em></span>, so:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.3-240-A"></a>The numerical
                                 comparison
                                 operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>,
                                 <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code> return
                                 <code class="literal">false</code> if either or both operands are NaN
                                 (<a class="xref" href="jls-15.html#jls-15.20.1" title="15.20.1.&nbsp;Numerical Comparison Operators <, <=, &gt;, and &gt;=">&sect;15.20.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.3-240-B"></a>The equality
                                 operator <code class="literal">==</code> returns <code class="literal">false</code> if either operand
                                 is NaN.
                        </p>
                        <p class="norm"><a name="jls-4.2.3-240-B.1"></a>In
                                 particular, <code class="literal">(x&lt;y) == !(x&gt;=y)</code> will be
                                 <code class="literal">false</code> if <code class="literal">x</code> or <code class="literal">y</code> is
                                 NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.3-240-C"></a>The inequality
                                 operator <code class="literal">!=</code> returns <code class="literal">true</code> if either operand
                                 is NaN (<a class="xref" href="jls-15.html#jls-15.21.1" title="15.21.1.&nbsp;Numerical Equality Operators == and !=">&sect;15.21.1</a>).
                        </p>
                        <p class="norm"><a name="jls-4.2.3-240-C.1"></a>In
                                 particular, <code class="literal">x!=x</code> is <code class="literal">true</code> if and only
                                 if <code class="literal">x</code> is NaN.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="4.2.4.&nbsp;Floating-Point Operations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.4"></a>4.2.4.&nbsp;Floating-Point Operations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.2.4-100"></a>The Java programming language provides a
                  number of operators that act on floating-point values:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-A"></a>The comparison
                               operators, which result in a value of type <code class="literal">boolean</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-A-1"></a>The numerical
                                    	comparison operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>,
                                    	<code class="literal">&gt;</code>, and <code class="literal">&gt;=</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.20.1" title="15.20.1.&nbsp;Numerical Comparison Operators <, <=, &gt;, and &gt;=">&sect;15.20.1</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-A-2"></a>The numerical
                                    	equality operators <code class="literal">==</code> and <code class="literal">!=</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.21.1" title="15.21.1.&nbsp;Numerical Equality Operators == and !=">&sect;15.21.1</a>)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-B"></a>The numerical
                               operators, which result in a value of type <code class="literal">float</code> or
                               <code class="literal">double</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-1"></a>The unary plus
                                    	and minus operators <code class="literal">+</code> and <code class="literal">-</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.15.3" title="15.15.3.&nbsp;Unary Plus Operator +">&sect;15.15.3</a>,
                                    	<a class="xref" href="jls-15.html#jls-15.15.4" title="15.15.4.&nbsp;Unary Minus Operator -">&sect;15.15.4</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-2"></a>The
                                    	multiplicative operators <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">%</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.17" title="15.17.&nbsp;Multiplicative Operators">&sect;15.17</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-3"></a>The additive
                                    	operators <code class="literal">+</code> and <code class="literal">-</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.18.2" title="15.18.2.&nbsp;Additive Operators (+ and -) for Numeric Types">&sect;15.18.2</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-4"></a>The increment
                                    	operator <code class="literal">++</code>, both prefix
                                    	(<a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>) and postfix
                                    	(<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-5"></a>The decrement
                                    	operator <code class="literal">--</code>, both prefix
                                    	(<a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>) and postfix
                                    	(<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-C"></a>The conditional
                               operator <code class="literal">? :</code> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-D"></a>The cast operator
                               (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>), which can convert from a
                               floating-point value to a value of any specified numeric
                               type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-E"></a>The string
                               concatenation operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>),
                               which, when given a <code class="literal">String</code> operand and a floating-point operand,
                               will convert the floating-point operand to a <code class="literal">String</code> representing
                               its value in decimal form (without information loss), and then
                               produce a newly created <code class="literal">String</code> by concatenating the two
                               strings
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-4.2.4-110"></a>Other useful constructors,
                  methods, and constants are predefined in the classes <code class="literal">Float</code>,
                  <code class="literal">Double</code>, and <code class="literal">Math</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-200"></a>If at
                  least one of the operands to a binary operator is of floating-point
                  type, then the operation is a floating-point operation, even if the
                  other is integral.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-210"></a>If at
                  least one of the operands to a numerical operator is of type <code class="literal">double</code>,
                  then the operation is carried out using 64-bit floating-point
                  arithmetic, and the result of the numerical operator is a value of
                  type <code class="literal">double</code>. If the other operand is not a <code class="literal">double</code>, it is first
                  widened (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>) to type <code class="literal">double</code> by numeric
                  promotion (<a class="xref" href="jls-5.html#jls-5.6" title="5.6.&nbsp;Numeric Promotions">&sect;5.6</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-220"></a>Otherwise, the operation is carried out using
                  32-bit floating-point arithmetic, and the result of the numerical
                  operator is a value of type <code class="literal">float</code>. (If the other operand is not a
                  <code class="literal">float</code>, it is first widened to type <code class="literal">float</code> by numeric
                  promotion.)
               </p>
               <p class="norm"><a name="jls-4.2.4-230"></a>Any value of a floating-point
                  type may be cast to or from any numeric type. There are no casts
                  between floating-point types and the type <code class="literal">boolean</code>.
               </p>
               <p class="note">See <a class="xref" href="jls-4.html#jls-4.2.5" title="4.2.5.&nbsp;The boolean Type and boolean Values">&sect;4.2.5</a> for an idiom to
                  convert floating-point expressions to <code class="literal">boolean</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-300"></a>Operators
                  on floating-point numbers behave as specified by IEEE 754 (with the
                  exception of the remainder operator
                  (<a class="xref" href="jls-15.html#jls-15.17.3" title="15.17.3.&nbsp;Remainder Operator %">&sect;15.17.3</a>)). In particular, the Java programming language
                  requires support of IEEE 754 <span class="emphasis"><em>denormalized</em></span>
                  floating-point numbers and <span class="emphasis"><em>gradual underflow</em></span>,
                  which make it easier to prove desirable properties of particular
                  numerical algorithms. Floating-point operations do not "flush to zero"
                  if the calculated result is a denormalized number.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-310"></a>The
                  Java programming language requires that floating-point arithmetic behave as if every
                  floating-point operator rounded its floating-point result to the
                  result precision. <span class="emphasis"><em>Inexact</em></span> results must be rounded
                  to the representable value nearest to the infinitely precise result;
                  if the two nearest representable values are equally near, the one with
                  its least significant bit zero is chosen. This is the IEEE 754
                  standard's default rounding mode known as <span class="emphasis"><em>round to
                        nearest</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-320"></a>The
                  Java programming language uses <span class="emphasis"><em>round toward zero</em></span> when converting
                  a floating value to an integer (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>), which
                  acts, in this case, as though the number were truncated, discarding
                  the mantissa bits. Rounding toward zero chooses at its result the
                  format's value closest to and no greater in magnitude than the
                  infinitely precise result.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-330"></a>A
                  floating-point operation that overflows produces a signed
                  infinity.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-340"></a>A
                  floating-point operation that underflows produces a denormalized value
                  or a signed zero.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-350"></a>A
                  floating-point operation that has no mathematically definite result
                  produces NaN.
               </p>
               <p class="norm"><a name="jls-4.2.4-360"></a>All numeric operations with
                  NaN as an operand produce NaN as a result.
               </p>
               <p class="norm"><a name="jls-4.2.4-370"></a>A floating-point operator can
                  throw an exception (<a class="xref" href="jls-11.html" title="Chapter&nbsp;11.&nbsp;Exceptions">&sect;11</a>) for the following
                  reasons:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-370-A"></a>Any floating-point
                                 operator can throw a <code class="literal">NullPointerException</code> if unboxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) of a null reference is
                                 required.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-370-B"></a>The increment and
                                 decrement operators <code class="literal">++</code> (<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>,
                                 <a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>) and <code class="literal">--</code>
                                 (<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>, <a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>)
                                 can throw an <code class="literal">OutOfMemoryError</code> if boxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) is required and there is not
                                 sufficient memory available to perform the conversion.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e1927"></a><p class="title"><b>Example&nbsp;4.2.4-1.&nbsp;Floating-point Operations</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        // An example of overflow:
        double d = 1e308;
        System.out.print("overflow produces infinity: ");
        System.out.println(d + "*10==" + d*10);
        // An example of gradual underflow:
        d = 1e-305 * Math.PI;
        System.out.print("gradual underflow: " + d + "\n   ");
        for (int i = 0; i &lt; 4; i++)
            System.out.print(" " + (d /= 100000));
        System.out.println();
        // An example of NaN:
        System.out.print("0.0/0.0 is Not-a-Number: ");
        d = 0.0/0.0;
        System.out.println(d);
        // An example of inexact results and rounding:
        System.out.print("inexact results with float:");
        for (int i = 0; i &lt; 100; i++) {
            float z = 1.0f / i;
            if (z * i != 1.0f)
                System.out.print(" " + i);
        }
        System.out.println();
        // Another example of inexact results and rounding:
        System.out.print("inexact results with double:");
        for (int i = 0; i &lt; 100; i++) {
            double z = 1.0 / i;
            if (z * i != 1.0)
                System.out.print(" " + i);
        }
        System.out.println();
        // An example of cast to integer rounding:
        System.out.print("cast to int rounds toward 0: ");
        d = 12345.6;
        System.out.println((int)d + " " + (int)(-d));
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
overflow produces infinity: 1.0e+308*10==Infinity
gradual underflow: 3.141592653589793E-305
3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0
0.0/0.0 is Not-a-Number: NaN
inexact results with float: 0 41 47 55 61 82 83 94 97
inexact results with double: 0 49 98
cast to int rounds toward 0: 12345 -12345
</pre><p class="note">This example demonstrates, among other things, that
                        gradual underflow can result in a gradual loss of precision.
                     </p>
                     <p class="note">The results when <code class="literal">i</code>
                        is <code class="literal">0</code> involve division by zero, so
                        that <code class="literal">z</code> becomes positive infinity, and <code class="literal">z *
                           0</code> is NaN, which is not equal
                        to <code class="literal">1.0</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="4.2.5.&nbsp;The boolean Type and boolean Values">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.5"></a>4.2.5.&nbsp;The <code class="literal">boolean</code> Type and boolean Values
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.2.5-100"></a>The
                  <code class="literal">boolean</code> type represents a logical quantity with two possible values,
                  indicated by the literals <code class="literal">true</code> and <code class="literal">false</code>
                  (<a class="xref" href="jls-3.html#jls-3.10.3" title="3.10.3.&nbsp;Boolean Literals">&sect;3.10.3</a>).
               </p>
               <p class="norm"><a name="jls-4.2.5-110"></a>The boolean operators
                  are:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-A"></a>The relational
                               operators <code class="literal">==</code> and <code class="literal">!=</code>
                               (<a class="xref" href="jls-15.html#jls-15.21.2" title="15.21.2.&nbsp;Boolean Equality Operators == and !=">&sect;15.21.2</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-B"></a>The logical complement
                               operator <code class="literal">!</code> (<a class="xref" href="jls-15.html#jls-15.15.6" title="15.15.6.&nbsp;Logical Complement Operator !">&sect;15.15.6</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-C"></a>The logical operators
                               <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code> (<a class="xref" href="jls-15.html#jls-15.22.2" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">&sect;15.22.2</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-D"></a>The conditional-and and
                               conditional-or operators <code class="literal">&amp;&amp;</code> (<a class="xref" href="jls-15.html#jls-15.23" title="15.23.&nbsp;Conditional-And Operator &amp;&amp;">&sect;15.23</a>)
                               and <code class="literal">||</code> (<a class="xref" href="jls-15.html#jls-15.24" title="15.24.&nbsp;Conditional-Or Operator ||">&sect;15.24</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-E"></a>The conditional
                               operator <code class="literal">? :</code> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-F"></a>The string
                               concatenation operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>),
                               which, when given a <code class="literal">String</code> operand and a <code class="literal">boolean</code> operand, will
                               convert the <code class="literal">boolean</code> operand to a <code class="literal">String</code>
                               (either <code class="literal">"true"</code> or <code class="literal">"false"</code>),
                               and then produce a newly created <code class="literal">String</code> that is the
                               concatenation of the two strings
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-4.2.5-120"></a>Boolean expressions determine
                  the control flow in several kinds of statements:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-120-A"></a>The <code class="literal">if</code> statement
                               (<a class="xref" href="jls-14.html#jls-14.9" title="14.9.&nbsp;The if Statement">&sect;14.9</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-120-B"></a>The <code class="literal">while</code> statement
                               (<a class="xref" href="jls-14.html#jls-14.12" title="14.12.&nbsp;The while Statement">&sect;14.12</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-120-C"></a>The <code class="literal">do</code> statement
                               (<a class="xref" href="jls-14.html#jls-14.13" title="14.13.&nbsp;The do Statement">&sect;14.13</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-120-D"></a>The <code class="literal">for</code> statement
                               (<a class="xref" href="jls-14.html#jls-14.14" title="14.14.&nbsp;The for Statement">&sect;14.14</a>)
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-4.2.5-130"></a>A <code class="literal">boolean</code> expression also
                  determines which subexpression is evaluated in the conditional
                  <code class="literal">? :</code> operator (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>).
               </p>
               <p class="norm"><a name="jls-4.2.5-140"></a>Only <code class="literal">boolean</code> and <code class="literal">Boolean</code>
                  expressions can be used in control flow statements and as the first
                  operand of the conditional operator <code class="literal">? :</code>.
               </p>
               <p class="norm-static"><a name="jls-4.2.5-200"></a>An integer
                  or floating-point expression <code class="literal">x</code>
                  can be converted to a <code class="literal">boolean</code>, following the C language convention
                  that any nonzero value is <code class="literal">true</code>, by the
                  expression <code class="literal">x!=0</code>.
               </p>
               <p class="norm-static"><a name="jls-4.2.5-210"></a>An object
                  reference <code class="literal">obj</code> can be converted to a <code class="literal">boolean</code>,
                  following the C language convention that any reference other than
                  <code class="literal">null</code> is <code class="literal">true</code>, by the
                  expression <code class="literal">obj!=null</code>.
               </p>
               <p class="norm"><a name="jls-4.2.5-220"></a>A <code class="literal">boolean</code> can be converted
                  to a <code class="literal">String</code> by string conversion (<a class="xref" href="jls-5.html#jls-5.4" title="5.4.&nbsp;String Conversion">&sect;5.4</a>).
               </p>
               <p class="norm"><a name="jls-4.2.5-230"></a>A cast of a <code class="literal">boolean</code> value
                  to type <code class="literal">boolean</code> or <code class="literal">Boolean</code> is allowed
                  (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>, <a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>). No other
                  casts on type <code class="literal">boolean</code> are allowed.
               </p>
            </div>
         </div>
         <div class="section" title="4.3.&nbsp;Reference Types and Values">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.3"></a>4.3.&nbsp;Reference Types and Values
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-4.3-100"></a>There
               are  four kinds of <span class="emphasis"><em>reference types</em></span>:
               class types (<a class="xref" href="jls-8.html" title="Chapter&nbsp;8.&nbsp;Classes">&sect;8</a>), interface types
               (<a class="xref" href="jls-9.html" title="Chapter&nbsp;9.&nbsp;Interfaces">&sect;9</a>),
                type variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>), 
               and array types (<a class="xref" href="jls-10.html" title="Chapter&nbsp;10.&nbsp;Arrays">&sect;10</a>).
            </p>
            <div class="literallayout">
               <p><br>
                  ReferenceType:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ClassOrInterfaceType<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;TypeVariable<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ArrayType<br>
                  <br>
                  ClassOrInterfaceType:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ClassType<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;InterfaceType<br>
                  <br>
                  ClassType:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;TypeDeclSpecifier&nbsp;TypeArguments<sub>opt</sub><br>
                  <br>
                  InterfaceType:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;TypeDeclSpecifier&nbsp;TypeArguments<sub>opt</sub><br>
                  <br>
                  TypeDeclSpecifier:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;TypeName&nbsp;&nbsp;<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;ClassOrInterfaceType&nbsp;<code class="literal">.</code>&nbsp;Identifier<br>
                  <br>
                  TypeName:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Identifier<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;TypeName&nbsp;<code class="literal">.</code>&nbsp;Identifier<br>
                  <br>
                  TypeVariable:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Identifier<br>
                  <br>
                  ArrayType:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;<code class="literal">[&nbsp;]</code><br>
                  
               </p>
            </div>
            <div class="informalexample">
               <p class="note">The sample code:</p><pre class="programlisting">
class Point { int[] metrics; }
interface Move { void move(int deltax, int deltay); }
</pre><p class="note">declares a class type
                  <code class="literal">Point</code>, an interface type <code class="literal">Move</code>,
                  and uses an array type <code class="literal">int</code><code class="literal">[]</code> (an array of <code class="literal">int</code>) to declare
                  the field <code class="literal">metrics</code> of the
                  class <code class="literal">Point</code>.
               </p>
            </div>
            <p class="norm-static"><a name="jls-4.3-200"></a>A class or interface type consists
               of a <span class="emphasis"><em>type declaration specifier</em></span>, optionally
               followed by type arguments (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments and Wildcards">&sect;4.5.1</a>). If
               type arguments appear anywhere in a class or interface type,
               it is a parameterized type (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>).
            </p>
            <p class="norm-static"><a name="jls-4.3-210"></a>A type
               declaration specifier may be either a type name
               (<a class="xref" href="jls-6.html#jls-6.5.5" title="6.5.5.&nbsp;Meaning of Type Names">&sect;6.5.5</a>), or a class or interface type followed
               by "." and an identifier. In the latter case, the specifier has the
               form <code class="varname">T.id</code>, where <code class="varname">id</code> must be the
               simple name of an accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) member type
               (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>, <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>)
               of <code class="varname">T</code>, or a compile-time error occurs. The specifier
               denotes that member type.
            </p>
            <p class="note">There are contexts in the Java programming language
               where a generic class or interface name is used without providing type
               arguments. Such contexts do not involve the use of raw types
               (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>). Rather, they are contexts where type
               arguments are unnecessary for, or irrelevant to, the meaning of the
               generic class or interface.
            </p>
            <p class="note">For example, a single-type-import declaration
               <code class="literal">import java.util.List;</code> puts the simple type name
               <code class="literal">List</code> in scope within a compilation unit so that
               parameterized types of the form <code class="literal">List&lt;...&gt;</code> may
               be used. As another example, invocation of a static method of a
               generic class needs only to give the (possibly qualified) name of the
               generic class without any type arguments, because such type arguments
               are irrelevant to a static method. (The method itself may be generic,
               and take its own type arguments, but the type parameters of a static
               method are necessarily unrelated to the type parameters of its
               enclosing generic class (<a class="xref" href="jls-6.html#jls-6.5.5" title="6.5.5.&nbsp;Meaning of Type Names">&sect;6.5.5</a>).)
            </p>
            <p class="note">Because of the occasional need to use a generic
               class or interface name without type arguments, type names are
               distinct from type declaration specifiers. A type name is always
               qualified by means of another type name. In some cases, this is
               necessary to access an inner class that is a member of a parameterized
               type.
            </p>
            <div class="informalexample">
               <p class="note">Here is an example of where a type declaration
                  specifier is distinct from a type name:
               </p><pre class="programlisting">
class GenericOuter&lt;T extends Number&gt; {
    public class Inner&lt;S extends Comparable&lt;S&gt;&gt; {
        T getT() { return null;}
        S getS() { return null;}
    }
}

class Test {
    public static void main(String[] args) {
        GenericOuter&lt;Integer&gt;.Inner&lt;Double&gt; x1 = null;
        Integer i = x1.getT();
        Double d = x1.getS();
    }
}
</pre><p class="note">If we accessed <code class="literal">Inner</code> by
                  qualifying it with a type name, as in:
               </p><pre class="programlisting">
GenericOuter.Inner x2 = null;
</pre><p class="note">we would force its use as a raw type, losing type
                  information.
               </p>
            </div>
            <div class="section" title="4.3.1.&nbsp;Objects">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.3.1"></a>4.3.1.&nbsp;Objects
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.3.1-100"></a>An 
                  <span class="emphasis"><em>object</em></span> is a <span class="emphasis"><em>class instance</em></span>
                  or an <span class="emphasis"><em>array</em></span>.
               </p>
               <p class="norm"><a name="jls-4.3.1-110"></a>The reference values (often
                  just <span class="emphasis"><em>references</em></span>) are pointers to these objects,
                  and a special null reference, which refers to no object.
               </p>
               <p class="norm"><a name="jls-4.3.1-120"></a>A class instance is
                  explicitly created by a class instance creation expression
                  (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>).
               </p>
               <p class="norm"><a name="jls-4.3.1-130"></a>An array is explicitly
                  created by an array creation expression
                  (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation Expressions">&sect;15.10</a>).
               </p>
               <p class="norm"><a name="jls-4.3.1-140"></a>A new class instance is
                  implicitly created when the string concatenation
                  operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>) is used
                  in a non-constant (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>) expression, resulting
                  in a new object of type <code class="literal">String</code> (<a class="xref" href="jls-4.html#jls-4.3.3" title="4.3.3.&nbsp;The Class String">&sect;4.3.3</a>).
               </p>
               <p class="norm"><a name="jls-4.3.1-150"></a>A new array object is
                  implicitly created when an array initializer expression
                  (<a class="xref" href="jls-10.html#jls-10.6" title="10.6.&nbsp;Array Initializers">&sect;10.6</a>) is evaluated; this can occur when a class
                  or interface is initialized (<a class="xref" href="jls-12.html#jls-12.4" title="12.4.&nbsp;Initialization of Classes and Interfaces">&sect;12.4</a>), when a new
                  instance of a class is created (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>), or when a
                  local variable declaration statement is executed
                  (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>).
               </p>
               <p class="norm"><a name="jls-4.3.1-160"></a>New objects of the types
                  <code class="literal">Boolean</code>, <code class="literal">Byte</code>, <code class="literal">Short</code>, <code class="literal">Character</code>, <code class="literal">Integer</code>, <code class="literal">Long</code>, <code class="literal">Float</code>,
                  and <code class="literal">Double</code> may be implicitly created by boxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>).
               </p>
               <div class="example"><a name="d5e2118"></a><p class="title"><b>Example&nbsp;4.3.1-1.&nbsp;Object Creation</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y;
    Point() { System.out.println("default"); }
    Point(int x, int y) { this.x = x; this.y = y; }

    /* A Point instance is explicitly created at 
       class initialization time: */
    static Point origin = new Point(0,0);

    /* A String can be implicitly created 
       by a + operator: */
    public String toString() { return "(" + x + "," + y + ")"; }
}

class Test {
    public static void main(String[] args) {
        /* A Point is explicitly created
           using newInstance: */
        Point p = null;
        try {
            p = (Point)Class.forName("Point").newInstance();
        } catch (Exception e) {
            System.out.println(e);
        }

        /* An array is implicitly created 
           by an array constructor: */
        Point a[] = { new Point(0,0), new Point(1,1) };

        /* Strings are implicitly created 
           by + operators: */
        System.out.println("p: " + p);
        System.out.println("a: { " + a[0] + ", " + a[1] + " }");
    
        /* An array is explicitly created
           by an array creation expression: */
        String sa[] = new String[2];
        sa[0] = "he"; sa[1] = "llo";
        System.out.println(sa[0] + sa[1]);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
default
p: (0,0)
a: { (0,0), (1,1) }
hello
</pre></div>
               </div><br class="example-break"><p class="norm"><a name="jls-4.3.1-200"></a>The operators on references
                  to objects are:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-A"></a>Field access, using
                               either a qualified name (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) or a field
                               access expression (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-B"></a>Method invocation
                               (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-C"></a>The cast operator
                               (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Conversion">&sect;5.5</a>, <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-D"></a>The string
                               concatenation operator <code class="literal">+</code>
                               (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>), which, when given a <code class="literal">String</code>
                               operand and a reference, will convert the reference to a <code class="literal">String</code>
                               by invoking the <code class="literal">toString</code> method of the
                               referenced object (using <code class="literal">"null"</code> if either the
                               reference or the result of <code class="literal">toString</code> is a null
                               reference), and then will produce a newly created <code class="literal">String</code> that is
                               the concatenation of the two strings
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-E"></a>The <code class="literal">instanceof</code>
                               operator (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-F"></a>The reference equality
                               operators <code class="literal">==</code> and <code class="literal">!=</code>
                               (<a class="xref" href="jls-15.html#jls-15.21.3" title="15.21.3.&nbsp;Reference Equality Operators == and !=">&sect;15.21.3</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-G"></a>The conditional
                               operator <code class="literal">? :</code> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-4.3.1-300"></a>There may
                  be many references to the same object. Most objects have state, stored
                  in the fields of objects that are instances of classes or in the
                  variables that are the components of an array object. If two variables
                  contain references to the same object, the state of the object can be
                  modified using one variable's reference to the object, and then the
                  altered state can be observed through the reference in the other
                  variable.
               </p>
               <div class="example"><a name="d5e2160"></a><p class="title"><b>Example&nbsp;4.3.1-2.&nbsp;Primitive and Reference Identity</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Value { int val; }

class Test {
    public static void main(String[] args) {
        int i1 = 3;
        int i2 = i1;
        i2 = 4;
        System.out.print("i1==" + i1);
        System.out.println(" but i2==" + i2);
        Value v1 = new Value();
        v1.val = 5;
        Value v2 = v1;
        v2.val = 6;
        System.out.print("v1.val==" + v1.val);
        System.out.println(" and v2.val==" + v2.val);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
i1==3 but i2==4
v1.val==6 and v2.val==6
</pre><p class="note">because <code class="literal">v1.val</code>
                        and <code class="literal">v2.val</code> reference the same instance variable
                        (<a class="xref" href="jls-4.html#jls-4.12.3" title="4.12.3.&nbsp;Kinds of Variables">&sect;4.12.3</a>) in the one <code class="literal">Value</code>
                        object created by the only <code class="literal">new</code> expression,
                        while <code class="literal">i1</code> and <code class="literal">i2</code> are different
                        variables.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-4.3.1-400"></a>Each object is associated
                  with a  monitor (<a class="xref" href="jls-17.html#jls-17.1" title="17.1.&nbsp;Synchronization">&sect;17.1</a>), which is used
                  by <code class="literal">synchronized</code> methods (<a class="xref" href="jls-8.html#jls-8.4.3" title="8.4.3.&nbsp;Method Modifiers">&sect;8.4.3</a>) and the
                  <code class="literal">synchronized</code> statement (<a class="xref" href="jls-14.html#jls-14.19" title="14.19.&nbsp;The synchronized Statement">&sect;14.19</a>) to provide
                  control over concurrent access to state by multiple threads
                  (<a class="xref" href="jls-17.html" title="Chapter&nbsp;17.&nbsp;Threads and Locks">&sect;17</a>).
               </p>
            </div>
            <div class="section" title="4.3.2.&nbsp;The Class Object">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.3.2"></a>4.3.2.&nbsp;The Class <code class="literal">Object</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.3.2-100"></a>The class
                  <code class="literal">Object</code> is a superclass (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>) of all other
                  classes.
               </p>
               <p class="norm"><a name="jls-4.3.2-200"></a>All class and array types
                  inherit (<a class="xref" href="jls-8.html#jls-8.4.8" title="8.4.8.&nbsp;Inheritance, Overriding, and Hiding">&sect;8.4.8</a>) the methods of class <code class="literal">Object</code>,
                  which are summarized as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-A"></a>The
                                 method <code class="literal">clone</code> is used to make a duplicate of
                                 an object.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-B"></a>The
                                 method <code class="literal">equals</code> defines a notion of object
                                 equality, which is based on value, not reference,
                                 comparison.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-C"></a>The
                                 method <code class="literal">finalize</code> is run just before an object
                                 is destroyed (<a class="xref" href="jls-12.html#jls-12.6" title="12.6.&nbsp;Finalization of Class Instances">&sect;12.6</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-D"></a>The
                                 method <code class="literal">getClass</code> returns the <code class="literal">Class</code> object
                                 that represents the class of the object.
                        </p>
                        <p class="norm"><a name="jls-4.3.2-200-D.1"></a>A <code class="literal">Class</code> object
                                exists for each reference type. It can be used, for example, to
                                discover the fully qualified name of a class, its members, its
                                immediate superclass, and any interfaces that it
                                implements.
                        </p>
                        <p class="norm-static"><a name="jls-4.3.2-200-D.2"></a>The type of a method
                                 invocation expression of <code class="literal">getClass</code> is
                                 <code class="literal">Class</code><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> |<span class="type">T</span>|<code class="literal">&gt;</code> where <span class="type">T</span> is the
                                 class or interface searched (<a class="xref" href="jls-15.html#jls-15.12.1" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">&sect;15.12.1</a>)
                                 for <code class="literal">getClass</code>.
                        </p>
                        <p class="norm"><a name="jls-4.3.2-200-D.3"></a>A class method that
                                 is declared <code class="literal">synchronized</code> (<a class="xref" href="jls-8.html#jls-8.4.3.6" title="8.4.3.6.&nbsp;synchronized Methods">&sect;8.4.3.6</a>)
                                 synchronizes on the  monitor associated with the
                                 <code class="literal">Class</code> object of the class.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-E"></a>The
                                 method <code class="literal">hashCode</code> is very useful, together with
                                 the method <code class="literal">equals</code>, in hashtables such
                                 as <code class="literal">java.util.Hashmap</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-F"></a>The
                                 methods <code class="literal">wait</code>, <code class="literal">notify</code>,
                                 and <code class="literal">notifyAll</code> are used in concurrent
                                 programming using threads (<a class="xref" href="jls-17.html#jls-17.2" title="17.2.&nbsp;Wait Sets and Notification">&sect;17.2</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-G"></a>The method <code class="literal">toString</code>
                                 returns a <code class="literal">String</code> representation of the object.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="4.3.3.&nbsp;The Class String">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.3.3"></a>4.3.3.&nbsp;The Class <code class="literal">String</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.3.3-100"></a>Instances
                  of class <code class="literal">String</code> represent sequences of Unicode 
                  code points.
               </p>
               <p class="norm-dynamic"><a name="jls-4.3.3-110"></a>A
                  <code class="literal">String</code> object has a constant (unchanging) value.
               </p>
               <p class="norm-dynamic"><a name="jls-4.3.3-120"></a>String
                  literals (<a class="xref" href="jls-3.html#jls-3.10.5" title="3.10.5.&nbsp;String Literals">&sect;3.10.5</a>) are references to instances of
                  class <code class="literal">String</code>.
               </p>
               <p class="norm"><a name="jls-4.3.3-130"></a>The string concatenation
                  operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>)
                  implicitly creates a new <code class="literal">String</code> object when the result is not a
                  compile-time constant expression (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>).
               </p>
            </div>
            <div class="section" title="4.3.4.&nbsp;When Reference Types Are the Same">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.3.4"></a>4.3.4.&nbsp;When Reference Types Are the Same
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.3.4-100"></a>Two
                  reference types are the <span class="emphasis"><em>same compile-time type</em></span> if
                  they have the same binary name (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>) and their
                  type  arguments, if any, are the
                  same, applying this definition recursively.
               </p>
               <p class="norm"><a name="jls-4.3.4-110"></a>When two reference types are
                  the same, they are sometimes said to be the <span class="emphasis"><em>same
                        class</em></span> or the <span class="emphasis"><em>same interface</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.3.4-200"></a>At run
                  time, several reference types with the same binary name may be loaded
                  simultaneously by different class loaders. These types may or may not
                  represent the same type declaration. Even if two such types do
                  represent the same type declaration, they are considered
                  distinct.
               </p>
               <p class="norm-dynamic"><a name="jls-4.3.4-300"></a>Two
                  reference types are the <span class="emphasis"><em>same run-time type</em></span>
                  if:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.3.4-310"></a>They
                                 are both class or both interface types, are defined by the same
                                 class loader, and have the same binary name
                                 (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>), in which case they are sometimes
                                 said to be the <span class="emphasis"><em>same run-time class</em></span> or
                                 the <span class="emphasis"><em>same run-time interface</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.3.4-320"></a>They
                                 are both array types, and their component types are the same
                                 run-time type (<a class="xref" href="jls-10.html" title="Chapter&nbsp;10.&nbsp;Arrays">&sect;10</a>).
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="4.4.&nbsp;Type Variables">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.4"></a>4.4.&nbsp;Type Variables
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-4.4-100"></a>A <span class="emphasis"><em>type
                     variable</em></span> is an unqualified identifier used as a type in
               class, interface, method, and constructor bodies.
            </p>
            <p class="norm-static"><a name="jls-4.4-110"></a>A type
               variable is declared as a <span class="emphasis"><em>type parameter</em></span> of a
               generic class declaration (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>), generic
               interface declaration (<a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>), generic method
               declaration (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>), or generic constructor
               declaration (<a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>).
            </p>
            <div class="literallayout">
               <p><br>
                  TypeParameter:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;TypeVariable&nbsp;TypeBound<sub>opt</sub><br>
                  <br>
                  TypeBound:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">extends</code>&nbsp;TypeVariable<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">extends</code>&nbsp;ClassOrInterfaceType&nbsp;AdditionalBoundList<sub>opt</sub><br>
                  <br>
                  AdditionalBoundList:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;AdditionalBound&nbsp;AdditionalBoundList<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;AdditionalBound<br>
                  <br>
                  AdditionalBound:<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">&amp;</code>&nbsp;InterfaceType<br>
                  
               </p>
            </div>
            <p class="norm-static"><a name="jls-4.4-130"></a>The scope of
               a type variable declared as a type parameter is specified in
               <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a>.
            </p>
            <p class="norm-static"><a name="jls-4.4-200"></a>Every type variable declared as a
               type parameter has a <span class="emphasis"><em>bound</em></span>. If no bound is
               declared for a type variable, <code class="literal">Object</code> is assumed. If a bound is
               declared, it consists of either:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.4-200-A"></a>a
                              single type variable <span class="type">T</span>, or
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.4-200-B"></a>a
                              class or interface type <span class="type">T</span> possibly followed by interface types
                              <span class="type">I<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">I<sub>n</sub></span>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-error"><a name="jls-4.4-210"></a>It is a
               compile-time error if any of the types <span class="type">I<sub>1</sub></span> ... <span class="type">I<sub>n</sub></span> is a class type
               or type variable.
            </p>
            <p class="norm-error"><a name="jls-4.4-220"></a>The erasures
               (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of all constituent types of a bound must
               be pairwise different, or a compile-time error occurs.
            </p>
            <p class="norm-error"><a name="jls-4.4-230"></a>A type
               variable must not at the same time be a subtype of two interface types
               which are different parameterizations of the same generic interface,
               or a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-4.4-240"></a>The order of
               types in a bound is only significant in that the erasure of a type
               variable is determined by the first type in its bound, and that a
               class type or type variable may only appear in the first
               position.
            </p>
            <p class="norm-static"><a name="jls-4.4-300"></a>The members
               of a type variable <span class="type">X</span> with bound <span class="type">T</span> <code class="literal">&amp;</code> <span class="type">I<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">I<sub>n</sub></span>
               are the members of the intersection type (<a class="xref" href="jls-4.html#jls-4.9" title="4.9.&nbsp;Intersection Types">&sect;4.9</a>)
               <span class="type">T</span> <code class="literal">&amp;</code> <span class="type">I<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">I<sub>n</sub></span> appearing at the point where the
               type variable is declared.
            </p>
            <div class="example"><a name="d5e2333"></a><p class="title"><b>Example&nbsp;4.4-1.&nbsp;Members of a Type Variable</b></p>
               <div class="example-contents"><pre class="programlisting">
package TypeVarMembers;

class C { 
    public    void mCPublic()    {}
    protected void mCProtected() {} 
              void mCDefault()   {}
    private   void mCPrivate()   {} 
} 

interface I {
    void mI();
}

class CT extends C implements I {
    public void mI() {}
}

class Test {
    &lt;T extends C &amp; I&gt; void test(T t) { 	
        t.mI();           // OK
        t.mCPublic();     // OK 
        t.mCProtected();  // OK 
        t.mCDefault();    // OK
        t.mCPrivate();    // Compile-time error
    } 
}
</pre><p class="note">The type variable <code class="literal">T</code> has the same
                     members as the intersection type <code class="literal">C &amp; I</code>, which
                     in turn has the same members as the empty class <code class="literal">CT</code>,
                     defined in the same scope with equivalent supertypes. The members of
                     an interface are always <code class="literal">public</code>, and therefore always inherited
                     (unless overridden). Hence <code class="literal">mI</code> is a member
                     of <code class="literal">CT</code> and of <code class="literal">T</code>. Among the
                     members of <code class="literal">C</code>, all but <code class="literal">mCPrivate</code>
                     are inherited by <code class="literal">CT</code>, and are therefore members of
                     both <code class="literal">CT</code> and <code class="literal">T</code>.
                  </p>
                  <p class="note">If <code class="literal">C</code> had been declared in a
                     different package than <code class="literal">T</code>, then the call
                     to <code class="literal">mCDefault</code> would give rise to a compile-time
                     error, as that member would not be accessible at the point
                     where <code class="literal">T</code> is declared.
                  </p>
               </div>
            </div><br class="example-break"></div>
         <div class="section" title="4.5.&nbsp;Parameterized Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.5"></a>4.5.&nbsp;Parameterized Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.5-100"></a>A generic
               class or interface declaration <span class="type">C</span> (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>,
               <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>) with one or more type parameters
               <span class="type">A<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span> which have corresponding bounds <span class="type">B<sub>1</sub></span>,...,<span class="type">B<sub>n</sub></span> defines a
               set of parameterized types, one for each possible invocation of the
               type parameter section.
            </p>
            <p class="norm-static"><a name="jls-4.5-110"></a>Each
               parameterized type in the set is of the form
               <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> where each type argument <span class="type">T<sub>i</sub></span> ranges
               over all types that are subtypes of all types listed in the
               corresponding bound. That is, for each bound type <span class="type">S<sub>i</sub></span> in <span class="type">B<sub>i</sub></span>, <span class="type">T<sub>i</sub></span>
               is a subtype of
               <span class="type">S<sub>i</sub></span><code class="literal">[<span class="type">F<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>:=<span class="type">T<sub>n</sub></span>]</code>.
            </p>
            <p class="norm-static"><a name="jls-4.5-120"></a>A
               parameterized type is written as a <span class="emphasis"><em>ClassType</em></span>
               or <span class="emphasis"><em>InterfaceType</em></span> that contains at least one type
               declaration specifier immediately followed by a type argument list
               <code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>. The type argument list denotes a
               particular invocation of the type parameters of the generic type
               indicated by the type declaration specifier.
            </p>
            <p class="norm-static"><a name="jls-4.5-200"></a>Given a type
               declaration specifier immediately followed by a type argument list,
               let <span class="type">C</span> be the final <span class="emphasis"><em>Identifier</em></span> in the specifier.
            </p>
            <p class="norm-error"><a name="jls-4.5-210"></a>It is a
               compile-time error if <span class="type">C</span> is not the name of a generic class or
               interface, or if the number of type arguments in the type argument
               list differs from the number of type parameters of <span class="type">C</span>.
            </p>
            <p class="norm-error"><a name="jls-4.5-220"></a>Let <span class="type">P</span> =
               <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> be a parameterized type. It must be
               the case that, after <span class="type">P</span> is subjected to capture conversion
               (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) resulting in the type
               <span class="type">C</span><code class="literal">&lt;</code><span class="type">X<sub>1</sub></span>,...,<span class="type">X<sub>n</sub></span><code class="literal">&gt;</code>, for each type argument <span class="type">X<sub>i</sub></span> (1 &#8804;
               <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>), <span class="type">X<sub>i</sub></span> <code class="literal">&lt;:</code>
               <span class="type">B<sub>i</sub></span><code class="literal">[<span class="type">A<sub>1</sub></span>:=<span class="type">X<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span>:=<span class="type">X<sub>n</sub></span>]</code>
               (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>), or a compile-time error occurs.
            </p>
            <p class="norm"><a name="jls-4.5-300"></a>The
               notation <code class="literal">[<span class="type">A<sub>i</sub></span>:=<span class="type">T<sub>i</sub></span>]</code> denotes substitution of the
               type variable <span class="type">A<sub>i</sub></span> with the type <span class="type">T<sub>i</sub></span> for 1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>,
               and is used throughout this specification.
            </p>
            <p class="norm"><a name="jls-4.5-310"></a>In this specification, whenever
               we speak of a class or interface type, we include the generic version
               as well, unless explicitly excluded.
            </p>
            <div class="informalexample">
               <p class="note">Examples of parameterized types:</p>
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note"><code class="literal">Vector&lt;String&gt;</code></p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Seq&lt;Seq&lt;A&gt;&gt;</code></p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Seq&lt;String&gt;.Zipper&lt;Integer&gt;</code></p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Collection&lt;Integer&gt;</code></p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Pair&lt;String,String&gt;</code></p>
                     </li>
                  </ul>
               </div>
               <p class="note">Examples of incorrect invocations of a generic
                  type:
               </p>
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note"><code class="literal">Vector&lt;int&gt;</code> is illegal,
                               as primitive types cannot be type arguments.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Pair&lt;String&gt;</code> is
                               illegal, as there are not enough type arguments.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Pair&lt;String,String,String&gt;</code>
                               is illegal, as there are too many type arguments.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <p class="note">A parameterized type may be an invocation of a
               generic class or interface which is nested. For example, if a
               non-generic class <span class="type">C</span> has a generic member class
               <span class="type">D</span><code class="literal">&lt;</code><span class="type">T</span><code class="literal">&gt;</code>, then <span class="type">C</span><code class="literal">.</code><span class="type">D</span><code class="literal">&lt;</code><code class="literal">Object</code><code class="literal">&gt;</code> is a
               parameterized type. And if a generic class <span class="type">C</span><code class="literal">&lt;</code><span class="type">T</span><code class="literal">&gt;</code> has
               a non-generic member class <span class="type">D</span>, then the member type
               <span class="type">C</span><code class="literal">&lt;</code><code class="literal">String</code><code class="literal">&gt;</code><code class="literal">.</code><span class="type">D</span> is a parameterized type, even
               though the class <span class="type">D</span> is not generic.
            </p>
            <p class="norm-static"><a name="jls-4.5-400"></a>Two
               parameterized types are provably distinct if either of the following
               conditions hold:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.5-400-A"></a>They
                              are invocations of distinct generic type declarations.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.5-400-B"></a>Any of
                              their type arguments are provably distinct.
                     </p>
                  </li>
               </ul>
            </div>
            <div class="section" title="4.5.1.&nbsp;Type Arguments and Wildcards">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.5.1"></a>4.5.1.&nbsp;Type Arguments and Wildcards
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.5.1-100"></a>Type
                  arguments may be either reference types or wildcards. Wildcards are
                  useful in situations where only partial knowledge about the type
                  parameter is required.
               </p>
               <div class="literallayout">
                  <p><br>
                     TypeArguments:<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">&lt;</code>&nbsp;TypeArgumentList&nbsp;<code class="literal">&gt;</code><br>
                     <br>
                     TypeArgumentList:&nbsp;<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;TypeArgument<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;TypeArgumentList&nbsp;<code class="literal">,</code>&nbsp;TypeArgument<br>
                     <br>
                     TypeArgument:<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;ReferenceType<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;Wildcard<br>
                     <br>
                     Wildcard:<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">?</code>&nbsp;WildcardBounds<sub>opt</sub><br>
                     <br>
                     WildcardBounds:<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">extends</code>&nbsp;ReferenceType<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;<code class="literal">super</code>&nbsp;ReferenceType<br>
                     
                  </p>
               </div>
               <div class="example"><a name="d5e2530"></a><p class="title"><b>Example&nbsp;4.5.1-1.&nbsp;Wildcards</b></p>
                  <div class="example-contents"><pre class="programlisting">
import java.util.Collection;
import java.util.ArrayList;

class Test {
    static void printCollection(Collection&lt;?&gt; c) {
                                // a wildcard collection
        for (Object o : c) {
            System.out.println(o);
        }
    }

    public static void main(String[] args) {
        Collection&lt;String&gt; cs = new ArrayList&lt;String&gt;();
        cs.add("hello");
        cs.add("world");
        printCollection(cs);
    }
}
</pre><p class="note">Note that using
                        <code class="literal">Collection&lt;Object&gt;</code> as the type of the
                        incoming parameter, <code class="literal">c</code>, would not be nearly as
                        useful; the method could only be used with an argument expression that
                        had type <code class="literal">Collection&lt;Object&gt;</code>, which would be
                        quite rare. In contrast, the use of an unbounded wildcard allows any
                        kind of collection to be used as a parameter.
                     </p>
                     <p class="note">Here is an example where the element type of an
                        array is parameterized by a wildcard:
                     </p><pre class="programlisting">

public Method getMethod(Class&lt;?&gt;[] parameterTypes) { ... }

</pre></div>
               </div><br class="example-break"><p class="norm-static"><a name="jls-4.5.1-200"></a>Wildcards
                  may be given explicit bounds, just like regular type variable
                  declarations. An upper bound is signified by the following syntax,
                  where <span class="type">B</span> is the bound:
               </p><pre class="screen">? extends <span class="type">B</span></pre><p class="norm-static"><a name="jls-4.5.1-210"></a>Unlike
                  ordinary type variables declared in a method signature, no type
                  inference is required when using a wildcard. Consequently, it is
                  permissible to declare lower bounds on a wildcard, using the following
                  syntax, where <span class="type">B</span> is a lower bound:
               </p><pre class="screen">? super <span class="type">B</span></pre><div class="example"><a name="d5e2547"></a><p class="title"><b>Example&nbsp;4.5.1-2.&nbsp;Bounded Wildcards</b></p>
                  <div class="example-contents"><pre class="screen">boolean addAll(Collection&lt;? extends E&gt; c)</pre><p class="note">Here, the method is declared within the
                        interface <code class="literal">Collection&lt;E&gt;</code>, and is designed to
                        add all the elements of its incoming argument to the collection upon
                        which it is invoked. A natural tendency would be to use
                        <code class="literal">Collection&lt;E&gt;</code> as the type
                        of <code class="literal">c</code>, but this is unnecessarily restrictive. An
                        alternative would be to declare the method itself to be
                        generic:
                     </p><pre class="screen">&lt;T&gt; boolean addAll(Collection&lt;T&gt; c)</pre><p class="note">This version is sufficiently flexible, but note that
                        the type parameter is used only once in the signature. This reflects
                        the fact that the type parameter is not being used to express any kind
                        of interdependency between the type(s) of the argument(s), the return
                        type and/or throws type. In the absence of such interdependency,
                        generic methods are considered bad style, and wildcards are
                        preferred.
                     </p><pre class="screen">Reference(T referent, ReferenceQueue&lt;? super T&gt; queue);</pre><p class="note">Here, the referent can be inserted into any queue
                        whose element type is a supertype of the type <code class="literal">T</code> of
                        the referent; <code class="literal">T</code> is the lower bound for the
                        wildcard.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm-static"><a name="jls-4.5.1-300"></a>Two type
                  arguments are provably distinct if one of the following is
                  true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-300-A"></a>Neither argument is a type variable or
                               wildcard, and the two arguments are not the same type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-300-B"></a>One type argument is a type
                               variable or wildcard, with an upper bound (from capture
                               conversion, if necessary) of <span class="type">S</span>; and the other type argument <span class="type">T</span>
                               is not a type variable or wildcard; and neither |<span class="type">S</span>| <code class="literal">&lt;:</code>
                               |<span class="type">T</span>| nor |<span class="type">T</span>| <code class="literal">&lt;:</code> |<span class="type">S</span>|.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-300-C"></a>Each type argument is a type
                               variable or wildcard, with upper bounds (from capture conversion,
                               if necessary) of <span class="type">S</span> and <span class="type">T</span>; and neither |<span class="type">S</span>| <code class="literal">&lt;:</code> |<span class="type">T</span>|
                               nor |<span class="type">T</span>| <code class="literal">&lt;:</code> |<span class="type">S</span>|.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.5.1-400"></a>A type argument
                  <span class="type">T<sub>1</sub></span> is said to <span class="emphasis"><em>contain</em></span> another type argument
                  <span class="type">T<sub>2</sub></span>, written <span class="type">T<sub>2</sub></span> <code class="literal">&lt;=</code> <span class="type">T<sub>1</sub></span>, if the set of types denoted by
                  <span class="type">T<sub>2</sub></span> is provably a subset of the set of types denoted by <span class="type">T<sub>1</sub></span>
                  under the reflexive and transitive closure of the
                  following rules (where <code class="literal">&lt;:</code> denotes subtyping
                  (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>)):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-A"></a><code class="literal">?</code> <code class="literal">extends</code> <span class="type">T</span> <code class="literal">&lt;=</code> <code class="literal">?</code>
                               <code class="literal">extends</code> <span class="type">S</span> if <span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">S</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-B"></a><code class="literal">?</code> <code class="literal">super</code> <span class="type">T</span> <code class="literal">&lt;=</code> <code class="literal">?</code>
                               <code class="literal">super</code> <span class="type">S</span> if <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-C"></a><span class="type">T</span>
                               <code class="literal">&lt;=</code> <span class="type">T</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-D"></a><span class="type">T</span>
                               <code class="literal">&lt;=</code> <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-E"></a><span class="type">T</span>
                               <code class="literal">&lt;=</code> <code class="literal">?</code> <code class="literal">super</code> <span class="type">T</span></p>
                     </li>
                  </ul>
               </div>
               <p class="note">The relationship of wildcards to established type
                  theory is an interesting one, which we briefly allude to
                  here. Wildcards are a restricted form of existential types. Given a
                  generic type declaration <span class="type">G</span><code class="literal">&lt;</code><span class="type">T</span> <code class="literal">extends</code> <span class="type">B</span><code class="literal">&gt;</code>,
                  <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code> is roughly analogous to <span class="type">Some <span class="type">X</span>
                     <code class="literal">&lt;:</code> <span class="type">B</span>. <span class="type">G</span><code class="literal">&lt;</code><span class="type">X</span><code class="literal">&gt;</code></span>.
               </p>
               <p class="note">Historically, wildcards are a direct descendant of
                  the work by Atsushi Igarashi and Mirko Viroli. Readers interested in a
                  more comprehensive discussion should refer to <em class="citetitle">On
                     Variance-Based Subtyping for Parametric Types</em> by Atsushi
                  Igarashi and Mirko Viroli, in the
                  <em class="citetitle">Proceedings of the 16th European Conference on Object
                     Oriented Programming (ECOOP 2002)</em>. This work itself builds
                  upon earlier work by Kresten Thorup and Mads Torgersen
                  (<em class="citetitle">Unifying Genericity</em>, ECOOP 99), as well as a
                  long tradition of work on declaration based variance that goes back to
                  Pierre America's work on POOL (OOPSLA 89).
               </p>
               <p class="note">Wildcards differ in certain details from the
                  constructs described in the aforementioned paper, in particular in the
                  use of capture conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) rather than
                  the <code class="literal">close</code> operation described by Igarashi and
                  Viroli. For a formal account of wildcards, see <em class="citetitle">Wild
                     FJ</em> by Mads Torgersen, Erik Ernst and Christian Plesner
                  Hansen, in the 12th workshop on Foundations of Object Oriented
                  Programming (FOOL 2005).
               </p>
            </div>
            <div class="section" title="4.5.2.&nbsp;Members and Constructors of Parameterized Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.5.2"></a>4.5.2.&nbsp;Members and Constructors of Parameterized Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.5.2-100"></a>Let <span class="type">C</span> be
                  a generic class or interface declaration with type parameters
                  <span class="type">A<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span>, and let <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> be an
                  invocation of <span class="type">C</span>, where, for 1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>, <span class="type">T<sub>i</sub></span> are
                  types (rather than wildcards). Then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.2-100-A"></a>Let <code class="varname">m</code> be a member or
                                 constructor declaration (<a class="xref" href="jls-8.html#jls-8.2" title="8.2.&nbsp;Class Members">&sect;8.2</a>,
                                 <a class="xref" href="jls-8.html#jls-8.8.6" title="8.8.6.&nbsp;The Type of a Constructor">&sect;8.8.6</a>) in <span class="type">C</span>, whose type as declared is
                                 <span class="type">T</span>.
                        </p>
                        <p class="norm-static"><a name="jls-4.5.2-100-A.1"></a>The type of <code class="varname">m</code> in
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> is
                                 <span class="type">T</span><code class="literal">[<span class="type">A<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span>:=<span class="type">T<sub>n</sub></span>]</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.2-100-B"></a>Let <code class="varname">m</code> be a member or
                                 constructor declaration in <span class="type">D</span>, where <span class="type">D</span> is a class extended by
                                 <span class="type">C</span> or an interface implemented by <span class="type">C</span>. Let
                                 <span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>,...,<span class="type">U<sub>k</sub></span><code class="literal">&gt;</code> be the supertype of
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> that corresponds to <span class="type">D</span>.
                        </p>
                        <p class="norm-static"><a name="jls-4.5.2-100-B.1"></a>The type of <code class="varname">m</code> in
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> is the type
                                 of <code class="varname">m</code> in
                                 <span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>,...,<span class="type">U<sub>k</sub></span><code class="literal">&gt;</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.5.2-200"></a>If any of
                  the type arguments  in the invocation of
                  <span class="type">C</span> are wildcards, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.2-200-A"></a>The
                                 types of the fields, methods, and constructors in
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> are  
                                 the types of the fields, methods, and constructors in the
                                 capture conversion (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>) of
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.2-200-B"></a>Let <code class="varname"><span class="type">D</span></code> be a
                               (possibly generic) class or interface declaration in <span class="type">C</span>. Then the
                               type of <span class="type">D</span> in <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> is <span class="type">D</span> where, if
                               <span class="type">D</span> is generic, all type arguments are unbounded wildcards.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">This is of no consequence, as it is impossible to
                  access a member of a parameterized type without performing capture
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>), and it is impossible to use
                  a wildcard type after the keyword <code class="literal">new</code> in a class instance creation
                  expression.
               </p>
               <p class="note">The sole exception
                  to the previous paragraph is when a nested parameterized type is used
                  as the expression in an <code class="literal">instanceof</code> operator
                  (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>), where capture conversion is not
                  applied.
               </p>
            </div>
         </div>
         <div class="section" title="4.6.&nbsp;Type Erasure">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.6"></a>4.6.&nbsp;Type Erasure
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.6-100"></a>Type erasure
               is a mapping from types (possibly including parameterized types and
               type variables) to types (that are never parameterized types or type
               variables). We write |<span class="type">T</span>| for the erasure of type <span class="type">T</span>. The erasure
               mapping is defined as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-A"></a>The
                            erasure of a parameterized type (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>)
                            <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> is |<span class="type">G</span>|.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-B"></a>The
                            erasure of a nested type <span class="type">T</span><code class="literal">.</code><span class="type">C</span> is |<span class="type">T</span>|.<span class="type">C</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-C"></a>The
                            erasure of an array type <span class="type">T</span><code class="literal">[]</code> is |<span class="type">T</span>|<code class="literal">[]</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-D"></a>The
                            erasure of a type variable (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) is the
                            erasure of its leftmost bound.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-E"></a>The
                            erasure of every other type is the type itself.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-4.6-200"></a>Type erasure
               also maps the signature (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of a constructor
               or method to a signature that has no parameterized types or type
               variables. The erasure of a constructor or method
               signature <span class="type">s</span> is a signature consisting of the same name
               as <span class="type">s</span> and the erasures of all the formal parameter types
               given in <span class="type">s</span>.
            </p>
            <p class="norm-static"><a name="jls-4.6-210"></a>The type
               parameters of a constructor or method (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>),
               and the return type (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Return Type">&sect;8.4.5</a>) of a method, also
               undergo erasure if the constructor or method's signature is
               erased.
            </p>
            <p class="norm-static"><a name="jls-4.6-220"></a>The erasure of
               the signature of a generic method has no type parameters.
            </p>
         </div>
         <div class="section" title="4.7.&nbsp;Reifiable Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.7"></a>4.7.&nbsp;Reifiable Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-4.7-100"></a>Because some type information
               is erased during compilation, not all types are available at run
               time. Types that are completely available at run time are known
               as <span class="emphasis"><em>reifiable types</em></span>.
            </p>
            <p class="norm-static"><a name="jls-4.7-110"></a>A type
               is <span class="emphasis"><em>reifiable</em></span> if and only if one of the following
               holds:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-A"></a>It
                            refers to a non-generic class or interface
                            type declaration.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-B"></a>It is
                            a parameterized type in which all type arguments are unbounded
                            wildcards (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments and Wildcards">&sect;4.5.1</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-C"></a>It is
                            a raw type (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-D"></a>It is
                            a primitive type (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-E"></a>It is
                            an array type (<a class="xref" href="jls-10.html#jls-10.1" title="10.1.&nbsp;Array Types">&sect;10.1</a>)
                            whose  element type is
                            reifiable.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-F"></a>It is a
                              nested type where, for each type <span class="type">T</span> separated by a "<code class="literal">.</code>", <span class="type">T</span>
                              itself is reifiable.
                     </p>
                     <p class="note">For example,
                              if a generic class <span class="type">X</span><code class="literal">&lt;</code><span class="type">T</span><code class="literal">&gt;</code> has a generic member
                              class <span class="type">Y</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code>, then the type
                              <span class="type">X</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code><code class="literal">.</code><span class="type">Y</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code> is
                              reifiable because <span class="type">X</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code> is reifiable and
                              <span class="type">Y</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code> is reifiable. The type
                              <span class="type">X</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code><code class="literal">.</code><span class="type">Y</span><code class="literal">&lt;</code><code class="literal">Object</code><code class="literal">&gt;</code> is not
                              reifiable because <span class="type">Y</span><code class="literal">&lt;</code><code class="literal">Object</code><code class="literal">&gt;</code> is not
                              reifiable.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-4.7-120"></a>An intersection
               type is not reifiable.
            </p>
            <p class="note">The decision not to make all generic types reifiable
               is one of the most crucial, and controversial design decisions
               involving the type system of the Java programming language.
            </p>
            <p class="note">Ultimately, the most important motivation for this
               decision is compatibility with existing code. In a naive sense, the
               addition of new constructs such as generics has no implications for
               pre-existing code. The Java programming language, per se, is compatible with earlier
               versions as long as every program written in the previous versions
               retains its meaning in the new version. However, this notion, which
               may be termed language compatibility, is of purely theoretical
               interest. Real programs (even trivial ones, such as "Hello World") are
               composed of several compilation units, some of which are provided by
               the Java SE platform (such as elements of <code class="literal">java.lang</code> or <code class="literal">java.util</code>). In
               practice, then, the minimum requirement is platform compatibility -
               that any program written for the prior version of the Java SE platform
               continues to function unchanged in the new version.
            </p>
            <p class="note">One way to provide platform compatibility is to
               leave existing platform functionality unchanged, only adding new
               functionality. For example, rather than modify the existing
               Collections hierarchy in <code class="literal">java.util</code>, one might introduce a new library
               utilizing generics.
            </p>
            <p class="note">The disadvantages of such a scheme is that it is
               extremely difficult for pre-existing clients of the Collection library
               to migrate to the new library. Collections are used to exchange data
               between independently developed modules; if a vendor decides to switch
               to the new, generic, library, that vendor must also distribute two
               versions of their code, to be compatible with their clients. Libraries
               that are dependent on other vendors code cannot be modified to use
               generics until the supplier's library is updated. If two modules are
               mutually dependent, the changes must be made simultaneously. 
            </p>
            <p class="note">Clearly, platform compatibility, as outlined above,
               does not provide a realistic path for adoption of a pervasive new
               feature such as generics. Therefore, the design of the generic type
               system seeks to support migration compatibility. Migration
               compatibiliy allows the evolution of existing code to take advantage
               of generics without imposing dependencies between independently
               developed software modules.
            </p>
            <p class="note">The price of migration compatibility is that a full
               and sound reification of the generic type system is not possible, at
               least while the migration is taking place.
            </p>
         </div>
         <div class="section" title="4.8.&nbsp;Raw Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.8"></a>4.8.&nbsp;Raw Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.8-100"></a>To facilitate
               interfacing with non-generic legacy code, it is possible to use as a
               type the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of a parameterized type
               (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) or the erasure of an array type
               (<a class="xref" href="jls-10.html#jls-10.1" title="10.1.&nbsp;Array Types">&sect;10.1</a>) whose element type is a parameterized
               type. Such a type is called a <span class="emphasis"><em>raw
                     type</em></span>.
            </p>
            <p class="norm-static"><a name="jls-4.8-110"></a>More
               precisely, a raw type is defined to be one of:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.8-110-A"></a>The
                              reference type that is formed by taking the name of a generic
                              type declaration without an accompanying type argument
                              list.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.8-110-B"></a>An array
                              type whose element type is a raw type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.8-110-C"></a>A
                              non-static member type of a raw type <span class="type">R</span> that is not inherited
                              from a superclass or superinterface of <span class="type">R</span>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-4.8-120"></a>A non-generic class or interface
               type is not a raw type.
            </p>
            <div class="informalexample">
               <p class="note">To see why a non-<code class="literal">static</code> type member of a raw type
                  is considered raw, consider the following example:
               </p><pre class="programlisting">
class Outer&lt;T&gt;{
    T t;
    class Inner {
        T setOuterT(T t1) { t = t1; return t; }
    }
}
</pre><p class="note">The type of the member(s)
                  of <code class="literal">Inner</code> depends on the type parameter
                  of <code class="literal">Outer</code>. If <code class="literal">Outer</code> is raw,
                  <code class="literal">Inner</code> must be treated as raw as well, as there is
                  no valid binding for <code class="literal">T</code>.
               </p>
               <p class="note">This rule applies only to type members that are not
                  inherited. Inherited type members that depend on type variables will
                  be inherited as raw types as a consequence of the rule that the
                  supertypes of a raw type are erased, described later in this
                  section.
               </p>
               <p class="note">Another implication of the rules above is that a
                  generic inner class of a raw type can itself only be used as a raw
                  type:
               </p><pre class="programlisting">
class Outer&lt;T&gt;{
    class Inner&lt;S&gt; {
        S s;
    }
}
</pre><p class="note">It is not possible to access
                  <code class="literal">Inner</code> as a partially raw type (a "rare"
                  type):
               </p><pre class="screen">
Outer.Inner&lt;Double&gt; x = null;  // illegal
Double d = x.s;
</pre><p class="note">because <code class="literal">Outer</code> itself is raw,
                  hence so are all its inner classes including <code class="literal">Inner</code>,
                  and so it is not possible to pass any type arguments to Inner.
               </p>
            </div>
            <p class="norm-static"><a name="jls-4.8-200"></a>The
               superclasses (respectively, superinterfaces) of a raw type are the
               erasures of the superclasses (superinterfaces) of any of its
               parameterized invocations.
            </p>
            <p class="norm-static"><a name="jls-4.8-210"></a>The type of a constructor
               (<a class="xref" href="jls-8.html#jls-8.8" title="8.8.&nbsp;Constructor Declarations">&sect;8.8</a>), instance method
               (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>, <a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Abstract Method Declarations">&sect;9.4</a>), or non-static
               field (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>) <code class="varname">M</code> of a raw type
               <span class="type">C</span> that is not inherited from its superclasses or superinterfaces
               is the raw type that corresponds to the erasure of
               its type in the generic declaration corresponding to <span class="type">C</span>.
            </p>
            <p class="norm-static"><a name="jls-4.8-220"></a>The type of
               a static method or static field of a raw type <span class="type">C</span> is the same as its
               type in the generic declaration corresponding to <span class="type">C</span>.
            </p>
            <p class="norm-error"><a name="jls-4.8-300"></a>It is a
               compile-time error to pass type arguments to a non-<code class="literal">static</code> type
               member of a raw type that is not inherited from its superclasses or
               superinterfaces.
            </p>
            <p class="norm-error"><a name="jls-4.8-310"></a>It is a
               compile-time error to attempt to use a type member of a parameterized
               type as a raw type.
            </p>
            <div class="informalexample">
               <p class="note">This means that the ban on "rare" types extends to
                  the case where the qualifying type is parameterized, but we attempt to
                  use the inner class as a raw type:
               </p><pre class="screen">
Outer&lt;Integer&gt;.Inner x = null; // illegal
</pre><p class="note">This is the opposite of the case discussed
                  above. There is no practical justification for this half-baked
                  type. In legacy code, no type arguments are used. In non-legacy code,
                  we should use the generic types correctly and pass all the required
                  type arguments.
               </p>
            </div>
            <p class="norm-static"><a name="jls-4.8-400"></a>The
               supertype of a class may be a raw type. Member accesses for the class
               are treated as normal, and member accesses for the supertype are
               treated as for raw types. In the constructor of the class, calls to
               <code class="literal">super</code> are treated as method calls on a raw type.
            </p>
            <p class="norm"><a name="jls-4.8-500"></a>The use of raw types is allowed
               only as a concession to compatibility of legacy code. The use of raw
               types in code written after the introduction of generics into the
               Java programming language is strongly discouraged. It is possible that future
               versions of the Java programming language will disallow the use of raw types.
            </p>
            <p class="norm-warning"><a name="jls-4.8-510"></a>To make
               sure that potential violations of the typing rules are always flagged,
               some accesses to members of a raw type will result in compile-time
               unchecked warnings. The rules for compile-time unchecked warnings when
               accessing members or constructors of raw types are as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-warning"><a name="jls-4.8-510-A"></a>At an
                              assignment to a field: if the type of the left-hand operand is a
                              raw type, then a compile-time unchecked warning occurs if
                              erasure changes the field's type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-warning"><a name="jls-4.8-510-B"></a>At an
                              invocation of a method or constructor: if the type of the class
                              or interface to search (<a class="xref" href="jls-15.html#jls-15.12.1" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">&sect;15.12.1</a>) is a raw
                              type, then a compile-time unchecked warning occurs if erasure
                              changes any of the 
                              formal parameter types of the method or constructor.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-warning"><a name="jls-4.8-510-C"></a>No
                              compile-time unchecked warning occurs for a method call when the
                              formal parameter types do not change under
                              erasure (even if the result type and/or <code class="literal">throws</code> clause
                              changes), for reading from a field, or for a class instance
                              creation of a raw type.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">Note that the
               unchecked warnings above are distinct from the unchecked warnings
               possible from unchecked conversion (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>),
               casts (<a class="xref" href="jls-5.html#jls-5.5.2" title="5.5.2.&nbsp;Checked Casts and Unchecked Casts">&sect;5.5.2</a>), method declarations
               (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>, <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>,
               <a class="xref" href="jls-8.html#jls-8.4.8.4" title="8.4.8.4.&nbsp;Inheriting Methods with Override-Equivalent Signatures">&sect;8.4.8.4</a>, <a class="xref" href="jls-9.html#jls-9.4.1.2" title="9.4.1.2.&nbsp;Requirements in Overriding">&sect;9.4.1.2</a>), and
               variable arity method invocations
               (<a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>).
            </p>
            <p class="note">The warnings here
               cover the case where a legacy consumer uses a generified library. For
               example, the library declares a generic class <code class="literal">Foo&lt;T
                  extends String&gt;</code> that has a field <code class="literal">f</code> of
               type <code class="literal">Vector&lt;T&gt;</code>, but the consumer assigns a
               vector of integers to <code class="varname">e</code><code class="literal">.</code><code class="literal">f</code>
               where <code class="varname">e</code> has the raw type <code class="literal">Foo</code>.
               The legacy consumer receives a warning because it may have caused heap
               pollution (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>) for generified consumers of
               the generified library.
            </p>
            <p class="note">(Note that the
               legacy consumer can assign a <code class="literal">Vector&lt;String&gt;</code>
               from the library to its own <code class="literal">Vector</code> variable without
               receiving a warning. That is, the subtyping rules
               (<a class="xref" href="jls-4.html#jls-4.10.2" title="4.10.2.&nbsp;Subtyping among Class and Interface Types">&sect;4.10.2</a>) of the Java programming language make it possible for
               a variable of a raw type to be assigned a value of any of the type's
               parameterized instances.)
            </p>
            <p class="note">The warnings from
               unchecked conversion cover the dual case, where a generified consumer
               uses a legacy library. For example, a method of the library has the
               raw return type <code class="literal">Vector</code>, but the consumer assigns
               the result of the method invocation to a variable of
               type <code class="literal">Vector&lt;String&gt;</code>. This is unsafe, since
               the raw vector might have had a different element type than <code class="literal">String</code>,
               but is still permitted using unchecked conversion in order to enable
               interfacing with legacy code. The warning from unchecked conversion
               indicates that the generified consumer may experience problems from
               heap pollution at other points in the program.
            </p>
            <div class="example"><a name="d5e3013"></a><p class="title"><b>Example&nbsp;4.8-1.&nbsp;Raw Types</b></p>
               <div class="example-contents"><pre class="programlisting">
class Cell&lt;E&gt; {
    E value;

    Cell(E v)     { value = v; }
    E get()       { return value; }
    void set(E v) { value = v; }

    public static void main(String[] args) {
        Cell x = new Cell&lt;String&gt;("abc");
        System.out.println(x.value);  // OK, has type Object
        System.out.println(x.get());  // OK, has type Object
        x.set("def");                 // unchecked warning
    }
}
</pre></div>
            </div><br class="example-break"><div class="example"><a name="d5e3016"></a><p class="title"><b>Example&nbsp;4.8-2.&nbsp;Raw Types and Inheritance</b></p>
               <div class="example-contents"><pre class="programlisting">
import java.util.*;
class NonGeneric {
    Collection&lt;Number&gt; myNumbers() { return null; }
}

abstract class RawMembers&lt;T&gt; extends NonGeneric
                             implements Collection&lt;String&gt; {
    static Collection&lt;NonGeneric&gt; cng =
        new ArrayList&lt;NonGeneric&gt;();

    public static void main(String[] args) {
        RawMembers rw = null;
        Collection&lt;Number&gt; cn = rw.myNumbers();
                              // OK
        Iterator&lt;String&gt; is = rw.iterator();
                            // Unchecked warning
        Collection&lt;NonGeneric&gt; cnn = rw.cng;
                                   // OK, static member
    }
}
</pre><p class="note">In this
                     program, <code class="literal">RawMembers&lt;T&gt;</code> inherits the
                     method:
                  </p><pre class="screen">
Iterator&lt;String&gt; iterator()
</pre><p class="note">from the <code class="literal">Collection&lt;String&gt;</code>
                     superinterface. However, the type <code class="literal">RawMembers</code>
                     inherits <code class="literal">iterator()</code> from
                     the <span class="emphasis"><em>erasure</em></span>
                     of <code class="literal">Collection&lt;String&gt;</code>, which means that the
                     return type of <code class="literal">iterator()</code> is the erasure
                     of <code class="literal">Iterator&lt;String&gt;</code>,
                     <code class="literal">Iterator</code>.
                  </p>
                  <p class="note">As a result, the attempt to assign
                     to <code class="literal">rw.iterator()</code> requires an unchecked conversion
                     (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>) from <code class="literal">Iterator</code>
                     to <code class="literal">Iterator&lt;String&gt;</code>, causing an unchecked
                     warning to be issued.
                  </p>
                  <p class="note">In contrast, the static
                     member <code class="literal">cng</code> retains its full parameterized type even
                     when accessed through a object of raw type. (Note that access to a
                     static member through an instance is considered bad style and is to be
                     discouraged.) The member <code class="literal">myNumbers</code> is inherited
                     from the <code class="literal">NonGeneric</code> class (whose erasure is
                     also <code class="literal">NonGeneric</code>) and so retains its full
                     parameterized type.
                  </p>
               </div>
            </div><br class="example-break"><p class="note">Raw types are closely related to wildcards. Both are
               based on existential types. Raw types can be thought of as wildcards
               whose type rules are deliberately unsound, to accommodate interaction
               with legacy code. Historically, raw types preceded wildcards; they
               were first introduced in GJ, and described in the
               paper <em class="citetitle">Making the future safe for the past: Adding
                  Genericity to the Java Programming Language</em> by Gilad
               Bracha, Martin Odersky, David Stoutamire, and Philip Wadler, in
               <em class="citetitle">Proceedings of the ACM Conference on Object-Oriented
                  Programming, Systems, Languages and Applications (OOPSLA
                  98)</em>, October 1998.
            </p>
         </div>
         <div class="section" title="4.9.&nbsp;Intersection Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.9"></a>4.9.&nbsp;Intersection Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.9-100"></a>An
               intersection type takes the form <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span> (<span class="emphasis"><em>n</em></span>
               &gt; 0), where <span class="type">T<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>) are type
               expressions.
            </p>
            <p class="norm"><a name="jls-4.9-110"></a>Intersection types arise in the
               processes of capture conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) and
               type inference (<a class="xref" href="jls-15.html#jls-15.12.2.7" title="15.12.2.7.&nbsp;Inferring Type Arguments Based on Actual Arguments">&sect;15.12.2.7</a>). It is not possible
               to write an intersection type directly as part of a program; no syntax
               supports this.
            </p>
            <p class="norm-dynamic"><a name="jls-4.9-200"></a>The values
               of an intersection type are those objects that are values of all of
               the types <span class="type">T<sub>i</sub></span> for 1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>.
            </p>
            <p class="norm-static"><a name="jls-4.9-300"></a>The members
               of an intersection type <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span> are determined as
               follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-4.9-300-A"></a>For
                            each <span class="type">T<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>), let <span class="type">C<sub>i</sub></span> be the most
                            specific class or array type such that <span class="type">T<sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">C<sub>i</sub></span>. Then
                            there must be some <span class="type">T<sub>k</sub></span> <code class="literal">&lt;:</code> <span class="type">C<sub>k</sub></span> such that <span class="type">C<sub>k</sub></span> <code class="literal">&lt;:</code>
                            <span class="type">C<sub>i</sub></span> for any <span class="emphasis"><em>i</em></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>), or a
                            compile-time error occurs.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.9-300-B"></a>For 1
                            &#8804; <span class="emphasis"><em>j</em></span> &#8804; <span class="emphasis"><em>n</em></span>, if <span class="type">T<sub>j</sub></span> is a type variable, then let
                            <span class="type">T<sub>j</sub></span>' be an interface whose members are the same as the public
                            members of <span class="type">T<sub>j</sub></span>; otherwise, if <span class="type">T<sub>j</sub></span> is an interface, then let
                            <span class="type">T<sub>j</sub></span>' be <span class="type">T<sub>j</sub></span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.9-300-C"></a>Then
                            the intersection type has the same members as a class type
                            (<a class="xref" href="jls-8.html" title="Chapter&nbsp;8.&nbsp;Classes">&sect;8</a>) with an empty body, direct superclass
                            <span class="type">C<sub>k</sub></span> and direct superinterfaces <span class="type">T<sub>1</sub></span>', ..., <span class="type">T<sub>n</sub></span>', declared in the
                            same package in which the intersection type appears.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">It is worth dwelling upon the distinction between
               intersection types and the bounds of type variables. Every type
               variable bound induces an intersection type. This intersection type is
               often trivial (i.e., consists of a single type). The form of a bound
               is restricted (only the first element may be a class or type variable,
               and only one type variable may appear in the bound) to preclude
               certain awkward situations coming into existence. However, capture
               conversion can lead to the creation of type variables whose bounds are
               more general (e.g., array types).
            </p>
         </div>
         <div class="section" title="4.10.&nbsp;Subtyping">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.10"></a>4.10.&nbsp;Subtyping
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-4.10-100"></a>The subtype and supertype
               relations are binary relations on types.
            </p>
            <p class="norm-static"><a name="jls-4.10-110"></a>The
               <span class="emphasis"><em>supertypes</em></span> of a type are obtained by reflexive
               and transitive closure over the direct supertype relation, written <span class="type">S</span>
               <code class="literal">&gt;<sub>1</sub></code> <span class="type">T</span>, which is defined by rules given later in this
               section. We write <span class="type">S</span> <code class="literal">:&gt;</code> <span class="type">T</span> to indicate that the supertype
               relation holds between <span class="type">S</span> and <span class="type">T</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-120"></a><span class="type">S</span> is
               a <span class="emphasis"><em>proper supertype</em></span> of <span class="type">T</span>, written <span class="type">S</span>
               <code class="literal">&gt;</code> <span class="type">T</span>, if <span class="type">S</span> <code class="literal">:&gt;</code> <span class="type">T</span> and <span class="type">S</span> &#8800; <span class="type">T</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-200"></a>The
               <span class="emphasis"><em>subtypes</em></span> of a type <span class="type">T</span> are all types <span class="type">U</span> such
               that <span class="type">T</span> is a supertype of <span class="type">U</span>, and the null type. We write <span class="type">T</span>
               <code class="literal">&lt;:</code> <span class="type">S</span> to indicate that that the subtype relation holds between
               types <span class="type">T</span> and <span class="type">S</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-210"></a><span class="type">T</span> is
               a <span class="emphasis"><em>proper subtype</em></span> of <span class="type">S</span>, written <span class="type">T</span>
               <code class="literal">&lt;</code> <span class="type">S</span>, if <span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">S</span> and <span class="type">S</span> &#8800; <span class="type">T</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-220"></a><span class="type">T</span> is
               a <span class="emphasis"><em>direct subtype</em></span> of <span class="type">S</span>, written <span class="type">T</span>
               <code class="literal">&lt;<sub>1</sub></code> <span class="type">S</span>, if <span class="type">S</span> <code class="literal">&gt;<sub>1</sub></code> <span class="type">T</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-300"></a>Subtyping
               does not extend through  parameterized types: <span class="type">T</span>
               <code class="literal">&lt;:</code> <span class="type">S</span> does not imply that <span class="type">C</span><code class="literal">&lt;</code><span class="type">T</span><code class="literal">&gt;</code> <code class="literal">&lt;:</code>
               <span class="type">C</span><code class="literal">&lt;</code><span class="type">S</span><code class="literal">&gt;</code>.
            </p>
            <div class="section" title="4.10.1.&nbsp;Subtyping among Primitive Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.10.1"></a>4.10.1.&nbsp;Subtyping among Primitive Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.10.1-100"></a>The
                  following rules define the direct supertype relation among the
                  primitive types:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-A"></a>
                                 <code class="literal">double</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">float</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-B"></a>
                                 <code class="literal">float</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">long</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-C"></a>
                                 <code class="literal">long</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">int</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-D"></a>
                                 <code class="literal">int</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">char</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-E"></a>
                                 <code class="literal">int</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">short</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-F"></a>
                                 <code class="literal">short</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">byte</code></p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="4.10.2.&nbsp;Subtyping among Class and Interface Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.10.2"></a>4.10.2.&nbsp;Subtyping among Class and Interface Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.10.2-100"></a>Given a
                  generic type declaration <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code>, the direct
                  supertypes of the parameterized type <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>
                  are all of the following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-100-A"></a>The
                               direct superclasses of <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-100-B"></a>The
                               direct superinterfaces of <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-100-C"></a>The
                               type <code class="literal">Object</code>, if <span class="type">C</span> is an interface type with no direct
                               superinterfaces.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-100-D"></a>The
                               raw type <span class="type">C</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.10.2-200"></a>The
                  direct supertypes of the parameterized type
                  <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>, where <span class="type">T<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804;
                  <span class="emphasis"><em>n</em></span>) is a type, are all of the following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-200-A"></a><span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span> &#952;,...,<span class="type">U<sub>k</sub></span>
                               &#952;<code class="literal">&gt;</code>, where <span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>,...,<span class="type">U<sub>k</sub></span><code class="literal">&gt;</code> is a
                               direct supertype of <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> and &#952;
                               is the
                               substitution <code class="literal">[<span class="type">F<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>:=<span class="type">T<sub>n</sub></span>]</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-200-B"></a><span class="type">C</span><code class="literal">&lt;</code><span class="type">S<sub>1</sub></span>,...,<span class="type">S<sub>n</sub></span><code class="literal">&gt;</code>, where
                               <span class="type">S<sub>i</sub></span> contains <span class="type">T<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>)
                               (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments and Wildcards">&sect;4.5.1</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.10.2-300"></a>The
                  direct supertypes of the parameterized type
                  <span class="type">C</span><code class="literal">&lt;</code><span class="type">R<sub>1</sub></span>,...,<span class="type">R<sub>n</sub></span><code class="literal">&gt;</code>, where at least one of the <span class="type">R<sub>i</sub></span> (1
                  &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>) is a wildcard type argument, are the direct
                  supertypes of <span class="type">C</span><code class="literal">&lt;</code><span class="type">X<sub>1</sub></span>,...,<span class="type">X<sub>n</sub></span><code class="literal">&gt;</code> which is the result of
                  applying capture conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to
                  <span class="type">C</span><code class="literal">&lt;</code><span class="type">R<sub>1</sub></span>,...,<span class="type">R<sub>n</sub></span><code class="literal">&gt;</code>.
               </p>
               <p class="norm-static"><a name="jls-4.10.2-400"></a>The
                  direct supertypes of an intersection type <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span>
                  are <span class="type">T<sub>i</sub></span> (1 &#8804; <span class="emphasis"><em>i</em></span> &#8804; <span class="emphasis"><em>n</em></span>).
               </p>
               <p class="norm-static"><a name="jls-4.10.2-500"></a>The
                  direct supertypes of a type variable are the types listed in its
                  bound.
               </p>
               <p class="norm-static"><a name="jls-4.10.2-510"></a>A type
                  variable is a direct supertype of its lower bound.
               </p>
               <p class="norm-static"><a name="jls-4.10.2-600"></a>The
                  direct supertypes of the null type are all reference types other than
                  the null type itself.
               </p>
            </div>
            <div class="section" title="4.10.3.&nbsp;Subtyping among Array Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.10.3"></a>4.10.3.&nbsp;Subtyping among Array Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.10.3-100"></a>The
                  following rules define the direct supertype relation among array
                  types:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-A"></a>If
                                 <span class="type">S</span> and <span class="type">T</span> are both reference types, then <span class="type">S</span><code class="literal">[]</code>
                                 <code class="literal">&gt;<sub>1</sub></code> <span class="type">T</span><code class="literal">[]</code> iff <span class="type">S</span> <code class="literal">&gt;<sub>1</sub></code>
                                 <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-B"></a><code class="literal">Object</code> <code class="literal">&gt;<sub>1</sub></code>
                               <code class="literal">Object</code><code class="literal">[]</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-C"></a><code class="literal">Cloneable</code> <code class="literal">&gt;<sub>1</sub></code>
                               <code class="literal">Object</code><code class="literal">[]</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-D"></a><code class="literal">java.io.Serializable</code> <code class="literal">&gt;<sub>1</sub></code>
                               <code class="literal">Object</code><code class="literal">[]</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-E"></a>If
                               <span class="type">P</span> is a primitive type, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.3-100-E-1"></a><code class="literal">Object</code> <code class="literal">&gt;<sub>1</sub></code>
                                    	<span class="type">P</span><code class="literal">[]</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.3-100-E-2"></a><code class="literal">Cloneable</code> <code class="literal">&gt;<sub>1</sub></code>
                                    	<span class="type">P</span><code class="literal">[]</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.3-100-E-3"></a><code class="literal">java.io.Serializable</code> <code class="literal">&gt;<sub>1</sub></code>
                                    	<span class="type">P</span><code class="literal">[]</code></p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="4.11.&nbsp;Where Types Are Used">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.11"></a>4.11.&nbsp;Where Types Are Used
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-4.11-100"></a>Types are used when they
               appear in declarations or in certain expressions.
            </p>
            <div class="example"><a name="d5e3440"></a><p class="title"><b>Example&nbsp;4.11-1.&nbsp;Usage of a Type</b></p>
               <div class="example-contents"><pre class="programlisting">
import java.util.Random;
import java.util.Collection;
import java.util.ArrayList;

class MiscMath&lt;T extends Number&gt; {
    int divisor;
    MiscMath(int divisor) { this.divisor = divisor; }
    float ratio(long l) {
        try {
            l /= divisor;
        } catch (Exception e) {
            if (e instanceof ArithmeticException)
                l = Long.MAX_VALUE;
            else
                l = 0;
        }
        return (float)l;
    }
    double gausser() {
        Random r = new Random();
        double[] val = new double[2];
        val[0] = r.nextGaussian();
        val[1] = r.nextGaussian();
        return (val[0] + val[1]) / 2;
    }
    Collection&lt;Number&gt; fromArray(Number[] na) {
        Collection&lt;Number&gt; cn = new ArrayList&lt;Number&gt;();
        for (Number n : na) cn.add(n);
        return cn;
    }
    &lt;S&gt; void loop(S s) { this.&lt;S&gt;loop(s); }  
}
</pre><p class="note">In this example, types are used in declarations of
                     the following:
                  </p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">Imported types (<a class="xref" href="jls-7.html#jls-7.5" title="7.5.&nbsp;Import Declarations">&sect;7.5</a>); here
                                    the type <code class="literal">Random</code>, imported from the
                                    type <code class="literal">java.util.Random</code> of the
                                    package <code class="literal">java.util</code>, is declared
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">Fields, which are the class variables and
                                    instance variables of classes (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>), and
                                    constants of interfaces (<a class="xref" href="jls-9.html#jls-9.3" title="9.3.&nbsp;Field (Constant) Declarations">&sect;9.3</a>); here the
                                    field <code class="literal">divisor</code> in the
                                    class <code class="literal">MiscMath</code> is declared to be of type
                                    <code class="literal">int</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Method parameters (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>);
                                    here the parameter <code class="literal">l</code> of the
                                    method <code class="literal">ratio</code> is declared to be of type
                                    <code class="literal">long</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Method results (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>); here
                                    the result of the method <code class="literal">ratio</code> is declared to
                                    be of type <code class="literal">float</code>, and the result of the
                                    method <code class="literal">gausser</code> is declared to be of type
                                    <code class="literal">double</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Constructor parameters
                                    (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters and Type Parameters">&sect;8.8.1</a>); here the parameter of the
                                    constructor for <code class="literal">MiscMath</code> is declared to be of
                                    type <code class="literal">int</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Local variables (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>,
                                    <a class="xref" href="jls-14.html#jls-14.14" title="14.14.&nbsp;The for Statement">&sect;14.14</a>); the local
                                    variables <code class="literal">r</code> and <code class="literal">val</code> of the
                                    method <code class="literal">gausser</code> are declared to be of
                                    types <code class="literal">Random</code> and <code class="literal">double</code><code class="literal">[]</code> (array of
                                    <code class="literal">double</code>)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">Exception parameters
                                    (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>); here the exception
                                    parameter <code class="literal">e</code> of the <code class="literal">catch</code> clause is declared
                                    to be of type <code class="literal">Exception</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Type parameters (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>);
                                    here the type parameter of <code class="literal">MiscMath</code> is a type
                                    variable <code class="literal">T</code> with the
                                    type <code class="literal">Number</code> as its declared bound
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">In any declaration that uses a parameterized
                                    type; here the type <code class="literal">Number</code> is used as a type
                                    argument (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments and Wildcards">&sect;4.5.1</a>) in the parameterized
                                    type <code class="literal">Collection&lt;Number&gt;</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">and in expressions of the following kinds:</p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">Class instance creations
                                    (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>); here a local
                                    variable <code class="literal">r</code> of
                                    method <code class="literal">gausser</code> is initialized by a class
                                    instance creation expression that uses the
                                    type <code class="literal">Random</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Generic class (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>)
                                    instance creations (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>);
                                    here <code class="literal">Number</code> is used as a type argument in the
                                    expression <code class="literal">new
                                       ArrayList&lt;Number&gt;()</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Array creations (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation Expressions">&sect;15.10</a>);
                                    here the local variable <code class="literal">val</code> of
                                    method <code class="literal">gausser</code> is initialized by an array
                                    creation expression that creates an array of <code class="literal">double</code> with size
                                    2
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">Generic method (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>) or
                                    constructor (<a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>) invocations
                                    (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>); here the
                                    method <code class="literal">loop</code> calls itself with an explicit
                                    type argument <code class="literal">S</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Casts (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>); here the
                                    <code class="literal">return</code> statement of the method <code class="literal">ratio</code> uses
                                    the <code class="literal">float</code> type in a cast
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">The <code class="literal">instanceof</code> operator
                                   (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>); here the <code class="literal">instanceof</code> operator
                                   tests whether <code class="literal">e</code> is assignment-compatible with
                                   the type <code class="literal">ArithmeticException</code></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><br class="example-break"></div>
         <div class="section" title="4.12.&nbsp;Variables">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.12"></a>4.12.&nbsp;Variables
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.12-100"></a>A variable
               is a storage location and has an associated type, sometimes called
               its <span class="emphasis"><em>compile-time type</em></span>, that is either a primitive
               type (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>) or a reference type
               (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>).
            </p>
            <p class="norm"><a name="jls-4.12-110"></a>A variable's value is changed
               by an assignment (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>) or by a prefix or
               postfix <code class="literal">++</code> (increment) or <code class="literal">--</code>
               (decrement) operator (<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>,
               <a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>, <a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>,
               <a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>).
            </p>
            <p class="norm"><a name="jls-4.12-120"></a>Compatibility of the value of
               a variable with its type is guaranteed by the design of the
               Java programming language, as long as a program does not give rise to compile-time
               unchecked warnings (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>). Default values
               (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>) are compatible and all assignments to a
               variable are checked for assignment compatibility
               (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Conversion">&sect;5.2</a>), usually at compile time, but, in a single
               case involving arrays, a run-time check is made
               (<a class="xref" href="jls-10.html#jls-10.5" title="10.5.&nbsp;Array Store Exception">&sect;10.5</a>).
            </p>
            <div class="section" title="4.12.1.&nbsp;Variables of Primitive Type">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.1"></a>4.12.1.&nbsp;Variables of Primitive Type
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.12.1-100"></a>A
                  variable of a primitive type always holds
                  a primitive value of that exact primitive
                  type.
               </p>
            </div>
            <div class="section" title="4.12.2.&nbsp;Variables of Reference Type">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.2"></a>4.12.2.&nbsp;Variables of Reference Type
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.12.2-100"></a>A
                  variable of a class type <span class="type">T</span> can hold a null reference or a reference
                  to an instance of class <span class="type">T</span> or of any class that is a subclass of
                  <span class="type">T</span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-110"></a>A
                  variable of an interface type can hold a null reference or a reference
                  to any instance of any class that implements the interface.
               </p>
               <p class="note">Note that a variable is not guaranteed to always
                  refer to a subtype of its declared type, but only to subclasses or
                  subinterfaces of the declared type. This is due to the possibility of
                  heap pollution discussed below.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-200"></a>If <span class="type">T</span>
                  is a primitive type, then a variable of type "array of <span class="type">T</span>" can hold a
                  null reference or a reference to any array of type "array of
                  <span class="type">T</span>".
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-210"></a>If <span class="type">T</span>
                  is a reference type, then a variable of type "array of <span class="type">T</span>" can hold a
                  null reference or a reference to any array of type "array of <span class="type">S</span>" such
                  that type <span class="type">S</span> is a subclass or subinterface of type <span class="type">T</span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-220"></a>A
                  variable of type <code class="literal">Object</code><code class="literal">[]</code> can hold a reference to an array
                  of any reference type.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-230"></a>A
                  variable of type <code class="literal">Object</code> can hold a null reference or a reference to
                  any object, whether it is an instance of a class or an array.
               </p>
               <p class="norm"><a name="jls-4.12.2-300"></a>It is possible that a variable of a
                  parameterized type will refer to an object that is not of that
                  parameterized type. This situation is known as <span class="emphasis"><em>heap
                        pollution</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-310"></a>Heap
                  pollution can only occur if the program performed some operation
                  involving a raw type that would give rise to a compile-time unchecked
                  warning (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>, <a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>,
                  <a class="xref" href="jls-5.html#jls-5.5.2" title="5.5.2.&nbsp;Checked Casts and Unchecked Casts">&sect;5.5.2</a>, <a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>,
                  <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>, <a class="xref" href="jls-8.html#jls-8.4.8.4" title="8.4.8.4.&nbsp;Inheriting Methods with Override-Equivalent Signatures">&sect;8.4.8.4</a>,
                  <a class="xref" href="jls-9.html#jls-9.4.1.2" title="9.4.1.2.&nbsp;Requirements in Overriding">&sect;9.4.1.2</a>, <a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>), or if
                  the program aliases an array variable of non-reifiable element type
                  through an array variable of a supertype which is either raw or
                  non-generic.
               </p>
               <div class="informalexample">
                  <p class="note">For example, the code:</p><pre class="programlisting">
List l = new ArrayList&lt;Number&gt;();
List&lt;String&gt; ls = l;  // Unchecked warning
</pre><p class="note">gives rise to a compile-time unchecked warning,
                     because it is not possible to ascertain, either at compile time
                     (within the limits of the compile-time type checking rules) or at run
                     time, whether the variable <code class="literal">l</code> does indeed refer to
                     a <code class="literal">List&lt;String&gt;</code>.
                  </p>
                  <p class="note">If the code above is executed, heap pollution
                     arises, as the variable <code class="literal">ls</code>, declared to be
                     a <code class="literal">List&lt;String&gt;</code>, refers to a value that is not
                     in fact a <code class="literal">List&lt;String&gt;</code>.
                  </p>
                  <p class="note">The problem cannot be identified at run time
                     because type variables are not reified, and thus instances do not
                     carry any information at run time regarding the type arguments used to
                     create them.
                  </p>
                  <p class="note">In a simple example as given above, it may appear
                     that it should be straightforward to identify the situation at compile
                     time and give an error. However, in the general (and typical) case,
                     the value of the variable <code class="literal">l</code> may be the result of an
                     invocation of a separately compiled method, or its value may depend
                     upon arbitrary control flow. The code above is therefore very
                     atypical, and indeed very bad style.
                  </p>
                  <p class="note">Furthermore, the fact that <code class="literal">Object</code><code class="literal">[]</code> is a
                     supertype of all array types means that unsafe aliasing can occur
                     which leads to heap pollution. For example, the following code
                     compiles because it is statically type-correct:
                  </p><pre class="programlisting">

static void m(List&lt;String&gt;... stringLists) {
    Object[] array = stringLists;
    List&lt;Integer&gt; tmpList = Arrays.asList(42);
    array[0] = tmpList;                // (1)
    String s = stringLists[0].get(0);  // (2)
}

</pre><p class="note">Heap pollution occurs at (1) because a component in
                     the <code class="literal">stringLists</code> array that should refer to a
                     <code class="literal">List&lt;String&gt;</code> now refers to
                     a <code class="literal">List&lt;Integer&gt;</code>. There is no way to detect
                     this pollution in the presence of both a universal supertype
                     (<code class="literal">Object</code><code class="literal">[]</code>) and a non-reifiable type (the declared type of
                     the formal
                     parameter, <code class="literal">List&lt;String&gt;</code><code class="literal">[]</code>). No
                     unchecked warning is justified at (1); nevertheless, at run time, a
                     <code class="literal">ClassCastException</code> will occur at (2).
                  </p>
                  <p class="note">A compile-time unchecked warning will be given at
                     any invocation of the method above because an invocation is considered
                     by the Java programming language's static type system to create an array whose
                     element type, <code class="literal">List&lt;String&gt;</code>, is non-reifiable
                     (<a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>). <span class="emphasis"><em>If and only if</em></span>
                     the body of the method was type-safe with respect to the variable
                     arity parameter, then the programmer could use the <code class="literal">SafeVarargs</code>
                     annotation to silence warnings at invocations
                     (<a class="xref" href="jls-9.html#jls-9.6.3.7" title="9.6.3.7.&nbsp;@SafeVarargs">&sect;9.6.3.7</a>). Since the body of the method as
                     written above causes heap pollution, it would be completely
                     inappropriate to use the annotation to disable warnings for
                     callers.
                  </p>
                  <p class="note">Finally, note that
                     the <code class="literal">stringLists</code> array could be aliased through
                     variables of types other than <code class="literal">Object</code><code class="literal">[]</code>, and heap pollution
                     could still occur. For example, the type of
                     the <code class="literal">array</code> variable could
                     be <code class="literal">java.util.Collection[]</code> - a raw element type -
                     and the body of the method above would compile without warnings or
                     errors and still cause heap pollution. And if the Java SE platform defined,
                     say, <code class="literal">Sequence</code> as a non-generic supertype
                     of <code class="literal">List&lt;T&gt;</code>, then
                     using <code class="literal">Sequence</code> as the type
                     of <code class="literal">array</code> would also cause heap pollution.
                  </p>
               </div>
               <p class="norm-static"><a name="jls-4.12.2-320"></a>The
                  variable will always refer to an object that is an instance of a class
                  that represents the parameterized type.
               </p>
               <p class="note">The value of <code class="literal">ls</code> in the example
                  above is always an instance of a class that provides a representation
                  of a <code class="literal">List</code>.
               </p>
               <p class="note">Assignment from an expression of a raw type to a
                  variable of a parameterized type should only be used when combining
                  legacy code which does not make use of parameterized types with more
                  modern code that does.
               </p>
               <p class="note">If no operation that requires a compile-time
                  unchecked warning to be issued takes place, and no unsafe
                  aliasing occurs of array variables with non-reifiable element
                  types, then heap pollution cannot occur. Note that this does
                  not imply that heap pollution only occurs if a compile-time unchecked
                  warning actually occurred. It is possible to run a program where some
                  of the binaries were produced by a compiler for an older version of
                  the Java programming language, or from sources that explicitly suppressed unchecked
                  warnings. This practice is unhealthy at best.
               </p>
               <p class="note">Conversely, it is possible that despite executing
                  code that could (and perhaps did) give rise to a compile-time
                  unchecked warning, no heap pollution takes place. Indeed, good
                  programming practice requires that the programmer satisfy herself that
                  despite any unchecked warning, the code is correct and heap pollution
                  will not occur.
               </p>
            </div>
            <div class="section" title="4.12.3.&nbsp;Kinds of Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.3"></a>4.12.3.&nbsp;Kinds of Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.12.3-100"></a>There are seven kinds of
                  variables:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-A"></a>A <span class="emphasis"><em>class
                                      variable</em></span> is a field declared using the keyword
                                <code class="literal">static</code> within a class declaration
                                (<a class="xref" href="jls-8.html#jls-8.3.1.1" title="8.3.1.1.&nbsp;static Fields">&sect;8.3.1.1</a>), or with or without the keyword
                                <code class="literal">static</code> within an interface declaration
                                (<a class="xref" href="jls-9.html#jls-9.3" title="9.3.&nbsp;Field (Constant) Declarations">&sect;9.3</a>).
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-A.1"></a>A class variable is
                                created when its class or interface is prepared
                                (<a class="xref" href="jls-12.html#jls-12.3.2" title="12.3.2.&nbsp;Preparation of a Class or Interface Type">&sect;12.3.2</a>) and is initialized to a default
                                value (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>). The class variable
                                effectively ceases to exist when its class or interface is
                                unloaded (<a class="xref" href="jls-12.html#jls-12.7" title="12.7.&nbsp;Unloading of Classes and Interfaces">&sect;12.7</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-B"></a>An <span class="emphasis"><em>instance
                                       variable</em></span> is a field declared within a class
                                 declaration without using the keyword <code class="literal">static</code>
                                 (<a class="xref" href="jls-8.html#jls-8.3.1.1" title="8.3.1.1.&nbsp;static Fields">&sect;8.3.1.1</a>).
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-B.1"></a>If a class <span class="type">T</span> has a
                                 field <code class="literal">a</code> that is an instance variable, then a
                                 new instance variable <code class="literal">a</code> is created and
                                 initialized to a default value (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>) as
                                 part of each newly created object of class <span class="type">T</span> or of any class
                                 that is a subclass of <span class="type">T</span> (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>). The
                                 instance variable effectively ceases to exist when the object of
                                 which it is a field is no longer referenced, after any necessary
                                 finalization of the object (<a class="xref" href="jls-12.html#jls-12.6" title="12.6.&nbsp;Finalization of Class Instances">&sect;12.6</a>) has been
                                 completed.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-C"></a><span class="emphasis"><em>Array
                                      components</em></span> are unnamed variables that are created and
                                initialized to default values (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>)
                                whenever a new object that is an array is created
                                (<a class="xref" href="jls-10.html" title="Chapter&nbsp;10.&nbsp;Arrays">&sect;10</a>, <a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation Expressions">&sect;15.10</a>). The
                                array components effectively cease to exist when the array is no
                                longer referenced.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-D"></a><span class="emphasis"><em>Method
                                       parameters</em></span> (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) name
                                 argument values passed to a method.
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-D.1"></a>For every parameter
                                 declared in a method declaration, a new parameter variable is
                                 created each time that method is invoked
                                 (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>). The new variable is initialized
                                 with the corresponding argument value from the method
                                 invocation. The method parameter effectively ceases to exist
                                 when the execution of the body of the method is complete.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-E"></a><span class="emphasis"><em>Constructor
                                       parameters</em></span> (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters and Type Parameters">&sect;8.8.1</a>) name
                                 argument values passed to a constructor.
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-E.1"></a>For every parameter
                                 declared in a constructor declaration, a new parameter variable
                                 is created each time a class instance creation expression
                                 (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) or explicit constructor invocation
                                 (<a class="xref" href="jls-8.html#jls-8.8.7" title="8.8.7.&nbsp;Constructor Body">&sect;8.8.7</a>) invokes that constructor. The new
                                 variable is initialized with the corresponding argument value
                                 from the creation expression or constructor invocation. The
                                 constructor parameter effectively ceases to exist when the
                                 execution of the body of the constructor is complete.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-F"></a>An
                                 <span class="emphasis"><em>exception parameter</em></span> is created each time an
                                 exception is caught by a <code class="literal">catch</code> clause of a <code class="literal">try</code> statement
                                 (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>).
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-F.1"></a>The new variable is
                                 initialized with the actual object associated with the exception
                                 (<a class="xref" href="jls-11.html#jls-11.3" title="11.3.&nbsp;Run-Time Handling of an Exception">&sect;11.3</a>, <a class="xref" href="jls-14.html#jls-14.18" title="14.18.&nbsp;The throw Statement">&sect;14.18</a>). The
                                 exception parameter effectively ceases to exist when execution
                                 of the block associated with the <code class="literal">catch</code> clause is
                                 complete.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-G"></a><span class="emphasis"><em>Local
                                       variables</em></span> are declared by local variable declaration
                                 statements (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>).
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-G.1"></a>Whenever the flow of
                                 control enters a block (<a class="xref" href="jls-14.html#jls-14.2" title="14.2.&nbsp;Blocks">&sect;14.2</a>) or <code class="literal">for</code>
                                 statement (<a class="xref" href="jls-14.html#jls-14.14" title="14.14.&nbsp;The for Statement">&sect;14.14</a>), a new variable is
                                 created for each local variable declared in a local variable
                                 declaration statement immediately contained within that block or
                                 <code class="literal">for</code> statement.
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-G.2"></a>A local variable
                                 declaration statement may contain an expression which
                                 initializes the variable. The local variable with an
                                 initializing expression is not initialized, however, until the
                                 local variable declaration statement that declares it is
                                 executed. (The rules of definite assignment
                                 (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16</a>) prevent the value of a local variable
                                 from being used before it has been initialized or otherwise
                                 assigned a value.) The local variable effectively ceases to
                                 exist when the execution of the block or for statement is
                                 complete.
                        </p>
                        <p class="note">Were it not for one exceptional situation, a
                                 local variable could always be regarded as being created when
                                 its local variable declaration statement is executed. The
                                 exceptional situation involves the <code class="literal">switch</code> statement
                                 (<a class="xref" href="jls-14.html#jls-14.11" title="14.11.&nbsp;The switch Statement">&sect;14.11</a>), where it is possible for control
                                 to enter a block but bypass execution of a local variable
                                 declaration statement. Because of the restrictions imposed by
                                 the rules of definite assignment (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16</a>),
                                 however, the local variable declared by such a bypassed local
                                 variable declaration statement cannot be used before it has been
                                 definitely assigned a value by an assignment expression
                                 (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>).
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="example"><a name="d5e3723"></a><p class="title"><b>Example&nbsp;4.12.3-1.&nbsp;Different Kinds of Variables</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    static int numPoints;   // numPoints is a class variable
    int x, y;               // x and y are instance variables
    int[] w = new int[10];  // w[0] is an array component
    int setX(int x) {       // x is a method parameter
        int oldx = this.x;  // oldx is a local variable
        this.x = x;
        return oldx;
    }
}
</pre></div>
               </div><br class="example-break"></div>
            <div class="section" title="4.12.4.&nbsp;final Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.4"></a>4.12.4.&nbsp;<code class="literal">final</code> Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.12.4-100"></a>A
                  variable can be declared <code class="literal">final</code>. A <code class="literal">final</code> variable may only be
                  assigned to once. Declaring a variable <code class="literal">final</code> can serve as useful
                  documentation that its value will not change and can help avoid
                  programming errors.
               </p>
               <p class="norm-error"><a name="jls-4.12.4-110"></a>It is a
                  compile-time error if a <code class="literal">final</code> variable is assigned to unless it is
                  definitely unassigned (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16</a>) immediately prior to
                  the assignment.
               </p>
               <p class="norm-static"><a name="jls-4.12.4-120"></a>A <span class="emphasis"><em>blank <code class="literal">final</code></em></span> is a
                  <code class="literal">final</code> variable whose declaration lacks an initializer.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.4-200"></a>Once a
                  <code class="literal">final</code> variable has been assigned, it always contains the same
                  value. If a <code class="literal">final</code> variable holds a reference to an object, then the
                  state of the object may be changed by operations on the object, but
                  the variable will always refer to the same object.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.4-210"></a>This
                  applies also to arrays, because arrays are objects; if a <code class="literal">final</code>
                  variable holds a reference to an array, then the components of the
                  array may be changed by operations on the array, but the variable will
                  always refer to the same array.
               </p>
               <div class="example"><a name="d5e3745"></a><p class="title"><b>Example&nbsp;4.12.4-1.&nbsp;Final Variables</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y;
    int useCount;
    Point(int x, int y) { this.x = x; this.y = y; }
    static final Point origin = new Point(0, 0);
}
</pre><p class="note">In this program, the class <code class="literal">Point</code>
                        declares a <code class="literal">final</code> class variable <code class="literal">origin</code>. The
                        <code class="literal">origin</code> variable holds a reference to an object that
                        is an instance of class <code class="literal">Point</code> whose coordinates are
                        (0, 0). The value of the variable <code class="literal">Point.origin</code> can
                        never change, so it always refers to the same <code class="literal">Point</code>
                        object, the one created by its initializer. However, an operation on
                        this <code class="literal">Point</code> object might change its state - for
                        example, modifying its <code class="literal">useCount</code> or even,
                        misleadingly, its <code class="literal">x</code> or <code class="literal">y</code>
                        coordinate.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm-static"><a name="jls-4.12.4-300"></a>A
                  variable of primitive type or type <code class="literal">String</code>, that is <code class="literal">final</code> and
                  initialized with a compile-time constant expression
                  (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>), is called a <span class="emphasis"><em>constant
                        variable</em></span>.
               </p>
               <p class="norm"><a name="jls-4.12.4-310"></a>Whether a variable is a
                  constant variable or not may have implications with respect to class
                  initialization (<a class="xref" href="jls-12.html#jls-12.4.1" title="12.4.1.&nbsp;When Initialization Occurs">&sect;12.4.1</a>), binary compatibility
                  (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>, <a class="xref" href="jls-13.html#jls-13.4.9" title="13.4.9.&nbsp;final Fields and Constants">&sect;13.4.9</a>) and
                  definite assignment (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16</a>).
               </p>
               <p class="norm-static"><a name="jls-4.12.4-400"></a>A resource of a
                  <code class="literal">try</code>-with-resources statement (<a class="xref" href="jls-14.html#jls-14.20.3" title="14.20.3.&nbsp;try-with-resources">&sect;14.20.3</a>) and an
                  exception parameter of a multi-<code class="literal">catch</code> clause
                  (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>) are implicitly declared <code class="literal">final</code>.
               </p>
               <p class="norm-static"><a name="jls-4.12.4-410"></a>An exception
                  parameter of a uni-<code class="literal">catch</code> clause (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>) may
                  be <span class="emphasis"><em>effectively final</em></span> instead of being explicitly
                  declared <code class="literal">final</code>. Such a parameter is never implicitly declared
                  <code class="literal">final</code>.
               </p>
            </div>
            <div class="section" title="4.12.5.&nbsp;Initial Values of Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.5"></a>4.12.5.&nbsp;Initial Values of Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.12.5-100"></a>Every
                  variable in a program must have a value before its value is
                  used:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-A"></a>Each class variable, instance variable,
                               or array component is initialized with a <span class="emphasis"><em>default
                                     value</em></span> when it is created (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>,
                               <a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation Expressions">&sect;15.10</a>):
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-1"></a>For type <code class="literal">byte</code>, the default value
                                    	is zero, that is, the value
                                    	of <code class="literal">(byte)0</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-2"></a>For type <code class="literal">short</code>, the default
                                    	value is zero, that is, the value
                                    	of <code class="literal">(short)0</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-3"></a>For type <code class="literal">int</code>, the default value
                                    	is zero, that is, <code class="literal">0</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-4"></a>For type <code class="literal">long</code>, the default value
                                    	is zero, that is, <code class="literal">0L</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-5"></a>For type <code class="literal">float</code>, the default
                                    	value is positive zero, that
                                    	is, <code class="literal">0.0f</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-6"></a>For type <code class="literal">double</code>, the default
                                    	value is positive zero, that
                                    	is, <code class="literal">0.0d</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-7"></a>For type <code class="literal">char</code>, the default value
                                    	is the null character, that
                                    	is, <code class="literal">'\u0000'</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-8"></a>For type <code class="literal">boolean</code>, the default
                                    	value is <code class="literal">false</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-9"></a>For all reference types
                                    	(<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>), the default value is
                                    	<code class="literal">null</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-B"></a>Each method parameter
                               (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) is initialized to the corresponding
                               argument value provided by the invoker of the method
                               (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-C"></a>Each constructor parameter
                               (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters and Type Parameters">&sect;8.8.1</a>) is initialized to the corresponding
                               argument value provided by a class instance creation expression
                               (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) or explicit constructor invocation
                               (<a class="xref" href="jls-8.html#jls-8.8.7" title="8.8.7.&nbsp;Constructor Body">&sect;8.8.7</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-D"></a>An
                               exception parameter (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>) is initialized
                               to the thrown object representing the exception
                               (<a class="xref" href="jls-11.html#jls-11.3" title="11.3.&nbsp;Run-Time Handling of an Exception">&sect;11.3</a>, <a class="xref" href="jls-14.html#jls-14.18" title="14.18.&nbsp;The throw Statement">&sect;14.18</a>). 
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-E"></a>A
                               local variable (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>,
                               <a class="xref" href="jls-14.html#jls-14.14" title="14.14.&nbsp;The for Statement">&sect;14.14</a>) must be explicitly given a value
                               before it is used, by either initialization
                               (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>) or assignment
                               (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>), in a way that can be
                               verified  using the rules for definite
                               assignment (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e3849"></a><p class="title"><b>Example&nbsp;4.12.5-1.&nbsp;Initial Values of Variables</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    static int npoints;
    int x, y;
    Point root;
}

class Test {
    public static void main(String[] args) {
        System.out.println("npoints=" + Point.npoints);
        Point p = new Point();
        System.out.println("p.x=" + p.x + ", p.y=" + p.y);
        System.out.println("p.root=" + p.root);
    }
}
</pre><p class="note">This program prints:</p><pre class="programlisting">
npoints=0
p.x=0, p.y=0
p.root=null
</pre><p class="note">illustrating the default initialization
                        of <code class="literal">npoints</code>, which occurs when the
                        class <code class="literal">Point</code> is prepared
                        (<a class="xref" href="jls-12.html#jls-12.3.2" title="12.3.2.&nbsp;Preparation of a Class or Interface Type">&sect;12.3.2</a>), and the default initialization
                        of <code class="literal">x</code>, <code class="literal">y</code>,
                        and <code class="literal">root</code>, which occurs when a
                        new <code class="literal">Point</code> is instantiated. See
                        <a class="xref" href="jls-12.html" title="Chapter&nbsp;12.&nbsp;Execution">&sect;12</a> for a full description of all aspects of
                        loading, linking, and initialization of classes and interfaces, plus a
                        description of the instantiation of classes to make new class
                        instances.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="4.12.6.&nbsp;Types, Classes, and Interfaces">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.6"></a>4.12.6.&nbsp;Types, Classes, and Interfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.12.6-100"></a>In the Java programming language, every
                  variable and every expression has a type that can be determined at
                  compile time. The type may be a primitive type or a reference
                  type. Reference types include class types and interface
                  types. Reference types are introduced by <span class="emphasis"><em>type
                        declarations</em></span>, which include class declarations
                  (<a class="xref" href="jls-8.html#jls-8.1" title="8.1.&nbsp;Class Declarations">&sect;8.1</a>) and interface declarations
                  (<a class="xref" href="jls-9.html#jls-9.1" title="9.1.&nbsp;Interface Declarations">&sect;9.1</a>). We often use the
                  term <span class="emphasis"><em>type</em></span> to refer to either a class or an
                  interface.
               </p>
               <p class="norm"><a name="jls-4.12.6-110"></a>In the Java Virtual Machine, every object
                  belongs to some particular class: the class that was mentioned in the
                  creation expression that produced the object
                  (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>), or the class whose <code class="literal">Class</code> object was
                  used to invoke a reflective method to produce the object, or the
                  <code class="literal">String</code> class for objects implicitly created by the string
                  concatenation operator <code class="literal">+</code>
                  (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>). This class is called
                  the <span class="emphasis"><em>class of the object</em></span>. An object is said to be
                  an <span class="emphasis"><em>instance</em></span> of its class and of all superclasses
                  of its class.
               </p>
               <p class="norm"><a name="jls-4.12.6-120"></a>Every array also has a
                  class. The method <code class="literal">getClass</code>, when invoked for an
                  array object, will return a class object (of class <code class="literal">Class</code>) that
                  represents the <span class="emphasis"><em>class of the array</em></span>
                  (<a class="xref" href="jls-10.html#jls-10.8" title="10.8.&nbsp;Class Objects for Arrays">&sect;10.8</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.6-200"></a>The
                  compile-time type of a variable is always declared, and the
                  compile-time type of an expression can be deduced at compile time. The
                  compile-time type limits the possible values that the variable can
                  hold at run time or the expression can produce at run time. If a
                  run-time value is a reference that is not <code class="literal">null</code>, it refers to an
                  object or array that has a class, and that class will necessarily be
                  compatible with the compile-time type.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.6-210"></a>Even
                  though a variable or expression may have a compile-time type that is
                  an interface type, there are no instances of interfaces. A variable or
                  expression whose type is an interface type can reference any object
                  whose class implements (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>) that
                  interface.
               </p>
               <p class="norm"><a name="jls-4.12.6-300"></a>Sometimes a variable or
                  expression is said to have a "run-time type". This refers to the class
                  of the object referred to by the value of the variable or expression
                  at run time, assuming that the value is not <code class="literal">null</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.6-310"></a>The
                  correspondence between compile-time types and run-time types is
                  incomplete for two reasons:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.6-310-A"></a>At
                                 run time, classes and interfaces are loaded by the Java Virtual Machine using
                                 class loaders. Each class loader defines its own set of classes
                                 and interfaces. As a result, it is possible for two loaders to
                                 load an identical class or interface definition but produce
                                 distinct classes or interfaces at run time. Consequently, code
                                 that compiled correctly may fail at link time if the class
                                 loaders that load it are inconsistent.
                        </p>
                        <p class="note">See the paper <em class="citetitle">Dynamic Class Loading
                                    in the Java Virtual Machine</em>, by Sheng Liang and
                                 Gilad Bracha, in <em class="citetitle">Proceedings of OOPSLA
                                    '98</em>, published as <em class="citetitle">ACM SIGPLAN
                                    Notices</em>, Volume 33, Number 10, October 1998, pages
                                 36-44, and <em class="citetitle">The Java Virtual Machine Specification, Java SE 7 Edition</em> for more details.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.6-310-B"></a>Type variables
                                 (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) and type arguments
                                 (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments and Wildcards">&sect;4.5.1</a>) are not reified at run time. As a
                                 result, the same class or interface at run time represents
                                  multiple parameterized types
                                 (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) from compile-time. Specifically, all
                                 compile-time invocations of a given generic type declaration
                                 (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>, <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>) share
                                 a single run-time representation.
                        </p>
                        <p class="note-dynamic">Under certain conditions, it is possible that a
                                 variable of a parameterized type refers to an object that is not
                                 of that parameterized type. This situation is known
                                 as <span class="emphasis"><em>heap pollution</em></span>
                                 (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>). The variable will always refer
                                 to an object that is an instance of a class that represents the
                                 parameterized type.
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="example"><a name="d5e3908"></a><p class="title"><b>Example&nbsp;4.12.6-1.&nbsp;Type of a Variable versus Class of an Object</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface Colorable {
    void setColor(byte r, byte g, byte b);
}

class Point { int x, y; }

class ColoredPoint extends Point implements Colorable {
    byte r, g, b;
    public void setColor(byte rv, byte gv, byte bv) {
        r = rv; g = gv; b = bv;
    }
}

class Test {
    public static void main(String[] args) {
        Point p = new Point();
        ColoredPoint cp = new ColoredPoint();
        p = cp;
        Colorable c = cp;
    }
}
</pre><p class="note">In this example:</p>
                     <div class="note">
                        <ul class="note" type="disc">
                           <li class="listitem">
                              <p class="note">The local variable <code class="literal">p</code> of the
                                       method <code class="literal">main</code> of class <code class="literal">Test</code>
                                       has type <code class="literal">Point</code> and is initially assigned a
                                       reference to a new instance of
                                       class <code class="literal">Point</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The local variable <code class="literal">cp</code>
                                       similarly has as its type <code class="literal">ColoredPoint</code>, and
                                       is initially assigned a reference to a new instance of
                                       class <code class="literal">ColoredPoint</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The assignment of the value
                                       of <code class="literal">cp</code> to the variable <code class="literal">p</code>
                                       causes <code class="literal">p</code> to hold a reference to
                                       a <code class="literal">ColoredPoint</code> object. This is permitted
                                       because <code class="literal">ColoredPoint</code> is a subclass
                                       of <code class="literal">Point</code>, so the
                                       class <code class="literal">ColoredPoint</code> is assignment-compatible
                                       (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Conversion">&sect;5.2</a>) with the
                                       type <code class="literal">Point</code>. A <code class="literal">ColoredPoint</code>
                                       object includes support for all the methods of
                                       a <code class="literal">Point</code>. In addition to its particular
                                       fields <code class="literal">r</code>, <code class="literal">g</code>,
                                       and <code class="literal">b</code>, it has the fields of
                                       class <code class="literal">Point</code>, namely <code class="literal">x</code>
                                       and <code class="literal">y</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The local variable <code class="literal">c</code> has as
                                       its type the interface type <code class="literal">Colorable</code>, so it
                                       can hold a reference to any object whose class
                                       implements <code class="literal">Colorable</code>; specifically, it can
                                       hold a reference to a <code class="literal">ColoredPoint</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="note">Note that an expression such as <code class="literal">new
                           Colorable()</code> is not valid because it is not possible to
                        create an instance of an interface, only of a class. However, the
                        expression <code class="literal">new Colorable() { public void
                           setColor... }</code> is valid because it declares an anonymous
                        class (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>) that implements
                        the <code class="literal">Colorable</code> interface.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-3.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-5.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;3.&nbsp;Lexical Structure&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;5.&nbsp;Conversions and Promotions</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>
