
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;5.&nbsp;Conversions and Contexts</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-4.html" title="Chapter&nbsp;4.&nbsp;Types, Values, and Variables">
      <link rel="next" href="jls-6.html" title="Chapter&nbsp;6.&nbsp;Names">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="../../../../webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="../../../../8/docs/">Java SE</a> &gt; <a href="../../../index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;5.&nbsp;Conversions and Contexts</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-4.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-6.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;5.&nbsp;Conversions and Contexts">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-5"></a>Chapter&nbsp;5.&nbsp;Conversions and Contexts
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-5.html#jls-5.1">5.1. Kinds of Conversion</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.1">5.1.1. Identity Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.2">5.1.2. Widening Primitive Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.3">5.1.3. Narrowing Primitive Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.4">5.1.4. Widening and Narrowing Primitive Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.5">5.1.5. Widening Reference Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.6">5.1.6. Narrowing Reference Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.7">5.1.7. Boxing Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.8">5.1.8. Unboxing Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.9">5.1.9. Unchecked Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.10">5.1.10. Capture Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.11">5.1.11. String Conversion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.12">5.1.12. Forbidden Conversions</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.1.13">5.1.13. Value Set Conversion</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-5.html#jls-5.2">5.2. Assignment Contexts</a></span></dt>
               <dt><span class="section"><a href="jls-5.html#jls-5.3">5.3. Invocation Contexts</a></span></dt>
               <dt><span class="section"><a href="jls-5.html#jls-5.4">5.4. String Contexts</a></span></dt>
               <dt><span class="section"><a href="jls-5.html#jls-5.5">5.5. Casting Contexts</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-5.html#jls-5.5.1">5.5.1. Reference Type Casting</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.5.2">5.5.2. Checked Casts and Unchecked Casts</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.5.3">5.5.3. Checked Casts at Run Time</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-5.html#jls-5.6">5.6. Numeric Contexts</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-5.html#jls-5.6.1">5.6.1. Unary Numeric Promotion</a></span></dt>
                     <dt><span class="section"><a href="jls-5.html#jls-5.6.2">5.6.2. Binary Numeric Promotion</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <p class="norm"><a name="jls-5-100"></a>Every expression written in the Java programming language either
            produces no result (<a class="xref" href="jls-15.html#jls-15.1" title="15.1.&nbsp;Evaluation, Denotation, and Result">&sect;15.1</a>) or has a type that can
            be deduced at compile time (<a class="xref" href="jls-15.html#jls-15.3" title="15.3.&nbsp;Type of an Expression">&sect;15.3</a>). When an
            expression appears in most contexts, it must
            be <span class="emphasis"><em>compatible</em></span> with a type expected in that
            context; this type is called the <span class="emphasis"><em>target type</em></span>. For
            convenience, compatibility of an expression with its surrounding
            context is facilitated in two ways:
         </p>
         <div class="norm">
            <ul class="norm" type="disc">
               <li class="listitem">
                  <p class="norm"><a name="jls-5-100-A"></a>
                           First, for some expressions, termed <span class="emphasis"><em>poly
                                 expressions</em></span> (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>), the deduced
                           type can be influenced by the target type. The same expression
                           can have different types in different contexts.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-100-B"></a>
                           Second, after the type of the expression has been deduced, an
                           implicit <span class="emphasis"><em>conversion</em></span> from the type of the
                           expression to the target type can sometimes be performed.
                  </p>
               </li>
            </ul>
         </div>
         <p class="norm"><a name="jls-5-110"></a>If neither strategy is able to produce the
            appropriate type, a compile-time error occurs.
         </p>
         <p class="norm"><a name="jls-5-120"></a>The rules determining whether an expression is a
            poly expression, and if so, its type and compatibility in a particular
            context, vary depending on the kind of context and the form of the
            expression. In addition to influencing the type of the expression, the
            target type may in some cases influence the run time behavior of the
            expression in order to produce a value of the appropriate type.
         </p>
         <p class="norm"><a name="jls-5-130"></a>Similarly, the rules determining whether a target
            type allows an implicit conversion vary depending on the kind of
            context, the type of the expression, and, in one special case, the
            value of a constant expression (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>). A
            conversion from type <span class="type">S</span> to type <span class="type">T</span> allows an expression of type <span class="type">S</span>
            to be treated at compile time as if it had type <span class="type">T</span> instead. In some
            cases this will require a corresponding action at run time to check
            the validity of the conversion or to translate the run-time value of
            the expression into a form appropriate for the new type <span class="type">T</span>.
         </p>
         <div class="example"><a name="d5e5264"></a><p class="title"><b>Example&nbsp;5.0-1.&nbsp;Conversions at Compile Time and Run Time</b></p>
            <div class="example-contents">
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note">A conversion from type <code class="literal">Object</code> to type <code class="literal">Thread</code>
                                 requires a run-time check to make sure that the run-time value
                                 is actually an instance of class <code class="literal">Thread</code> or one of its
                                 subclasses; if it is not, an exception is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">A conversion from type <code class="literal">Thread</code> to type <code class="literal">Object</code>
                                 requires no run-time action; <code class="literal">Thread</code> is a subclass of <code class="literal">Object</code>,
                                 so any reference produced by an expression of type <code class="literal">Thread</code> is a
                                 valid reference value of type <code class="literal">Object</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">A conversion from type <code class="literal">int</code> to type <code class="literal">long</code>
                                 requires run-time sign-extension of a 32-bit integer value to
                                 the 64-bit <code class="literal">long</code> representation. No information is lost.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">A conversion from type <code class="literal">double</code> to type <code class="literal">long</code>
                                 requires a non-trivial translation from a 64-bit floating-point
                                 value to the 64-bit integer representation. Depending on the
                                 actual run-time value, information may be lost.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div><br class="example-break"><p class="norm"><a name="jls-5-200"></a>The conversions possible in the
            Java programming language are grouped into several broad categories:
         </p>
         <div class="norm">
            <ul class="norm" type="disc">
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-A"></a>
                           Identity conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-B"></a>
                           Widening primitive conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-C"></a>
                           Narrowing primitive conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-D"></a>
                           Widening reference conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-E"></a>
                           Narrowing reference conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-F"></a>
                           Boxing conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-G"></a>
                           Unboxing conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-H"></a>
                           Unchecked conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-I"></a>
                           Capture conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-J"></a>
                           String conversions
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-200-K"></a>
                           Value set conversions
                  </p>
               </li>
            </ul>
         </div>
         <p class="norm"><a name="jls-5-300"></a>There are six kinds of <span class="emphasis"><em>conversion
                  contexts</em></span> in which poly expressions may be influenced by
            context or implicit conversions may occur. Each kind of context has
            different rules for poly expression typing and allows conversions in
            some of the categories above but not others. The contexts are:
         </p>
         <div class="norm">
            <ul class="norm" type="disc">
               <li class="listitem">
                  <p class="norm"><a name="jls-5-300-A"></a>
                           Assignment contexts (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>,
                           <a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>), in which an expression's value is
                           bound to a named variable.  Primitive and reference types are
                           subject to widening, values may be boxed or unboxed, and some
                           primitive constant expressions may be subject to narrowing. An
                           unchecked conversion may also occur.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-300-B"></a>
                           Strict invocation contexts (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>,
                           <a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>, <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), in
                           which an argument is bound to a formal parameter of a
                           constructor or method. Widening primitive, widening reference,
                           and unchecked conversions may occur.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-300-C"></a>
                           Loose invocation contexts (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>,
                           <a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>, <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), in
                           which, like strict invocation contexts, an argument is bound to
                           a formal parameter. Method or constructor invocations may
                           provide this context if no applicable declaration can be found
                           using only strict invocation contexts. In addition to widening
                           and unchecked conversions, this context allows boxing and
                           unboxing conversions to occur.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-300-D"></a>
                           String contexts (<a class="xref" href="jls-5.html#jls-5.4" title="5.4.&nbsp;String Contexts">&sect;5.4</a>,
                           <a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>), in which a value of any type is
                           converted to an object of type <code class="literal">String</code>.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-300-E"></a>
                           Casting contexts (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>), in which an
                           expression's value is converted to a type explicitly specified
                           by a cast operator (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>). Casting
                           contexts are more inclusive than assignment or loose invocation
                           contexts, allowing any specific conversion other than a string
                           conversion, but certain casts to a reference type are checked
                           for correctness at run time.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-5-300-F"></a>
                           Numeric contexts (<a class="xref" href="jls-5.html#jls-5.6" title="5.6.&nbsp;Numeric Contexts">&sect;5.6</a>), in which the
                           operands of a numeric operator may be widened to a common type
                           so that an operation can be performed.
                  </p>
               </li>
            </ul>
         </div>
         <p class="norm">The term "conversion" is also used to describe,
            without being specific, any conversions allowed in a particular
            context. For example, we say that an expression that is the
            initializer of a local variable is subject to "assignment conversion",
            meaning that a specific conversion will be implicitly chosen for that
            expression according to the rules for the assignment context.
         </p>
         <div class="example"><a name="d5e5343"></a><p class="title"><b>Example&nbsp;5.0-2.&nbsp;Conversions In Various Contexts</b></p>
            <div class="example-contents"><pre class="programlisting">
class Test {			
    public static void main(String[] args) {
        // Casting conversion (5.4) of a float literal to
        // type int. Without the cast operator, this would
        // be a compile-time error, because this is a
        // narrowing conversion (5.1.3):
        int i = (int)12.5f;

        // String conversion (5.4) of i's int value:
        System.out.println("(int)12.5f==" + i);

        // Assignment conversion (5.2) of i's value to type
        // float. This is a widening conversion (5.1.2):
        float f = i;

        // String conversion of f's float value:
        System.out.println("after float widening: " + f);

        // Numeric promotion (5.6) of i's value to type
        // float. This is a binary numeric promotion.
        // After promotion, the operation is float*float:
        System.out.print(f);
        f = f * i;

        // Two string conversions of i and f:
        System.out.println("*" + i + "==" + f);

        // Invocation conversion (5.3) of f's value
        // to type double, needed because the method Math.sin
        // accepts only a double argument:
        double d = Math.sin(f);

        // Two string conversions of f and d:
        System.out.println("Math.sin(" + f + ")==" + d);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
(int)12.5f==12
after float widening: 12.0
12.0*12==144.0
Math.sin(144.0)==-0.49102159389846934
</pre></div>
         </div><br class="example-break"><div class="section" title="5.1.&nbsp;Kinds of Conversion">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-5.1"></a>5.1.&nbsp;Kinds of Conversion
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-5.1-100"></a>Specific type conversions in
               the Java programming language are divided into 13 categories.
            </p>
            <div class="section" title="5.1.1.&nbsp;Identity Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.1"></a>5.1.1.&nbsp;Identity Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.1-100"></a>A
                  conversion from a type to that same type is permitted for any
                  type.
               </p>
               <p class="note">This may seem trivial, but it has two practical
                  consequences. First, it is always permitted for an expression to have
                  the desired type to begin with, thus allowing the simply stated rule
                  that every expression is subject to conversion, if only a trivial
                  identity conversion. Second, it implies that it is permitted for a
                  program to include redundant cast operators for the sake of
                  clarity.
               </p>
            </div>
            <div class="section" title="5.1.2.&nbsp;Widening Primitive Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.2"></a>5.1.2.&nbsp;Widening Primitive Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.2-100"></a>19
                  specific conversions on primitive types are called
                  the <span class="emphasis"><em>widening primitive conversions</em></span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.2-100-A"></a><code class="literal">byte</code> to <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code>,
                               <code class="literal">float</code>, or <code class="literal">double</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.2-100-B"></a><code class="literal">short</code> to <code class="literal">int</code>, <code class="literal">long</code>, <code class="literal">float</code>, or
                               <code class="literal">double</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.2-100-C"></a><code class="literal">char</code> to <code class="literal">int</code>, <code class="literal">long</code>, <code class="literal">float</code>, or
                               <code class="literal">double</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.2-100-D"></a><code class="literal">int</code> to <code class="literal">long</code>, <code class="literal">float</code>, or
                               <code class="literal">double</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.2-100-E"></a><code class="literal">long</code> to <code class="literal">float</code> or <code class="literal">double</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.2-100-F"></a><code class="literal">float</code> to <code class="literal">double</code></p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.2-200"></a>A
                  widening primitive conversion does not lose information about the
                  overall magnitude of a numeric value in the following cases, where the
                  numeric value is preserved exactly:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.2-200-A"></a>from an integral type to another integral type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.2-200-B"></a>from <code class="literal">byte</code>, <code class="literal">short</code>, or <code class="literal">char</code> to a floating point type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.2-200-C"></a>from <code class="literal">int</code> to <code class="literal">double</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.2-200-D"></a>from <code class="literal">float</code> to <code class="literal">double</code> in a <code class="literal">strictfp</code> expression (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>)
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.2-220"></a>A widening primitive conversion
                  from <code class="literal">float</code> to <code class="literal">double</code> that is not <code class="literal">strictfp</code> may lose information
                  about the overall magnitude of the converted value.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.2-300"></a>A
                  widening primitive conversion from <code class="literal">int</code> to <code class="literal">float</code>, or from <code class="literal">long</code> to
                  <code class="literal">float</code>, or from <code class="literal">long</code> to <code class="literal">double</code>, may result in <span class="emphasis"><em>loss of
                        precision</em></span> - that is, the result may lose some of the least
                  significant bits of the value. In this case, the resulting
                  floating-point value will be a correctly rounded version of the
                  integer value, using IEEE 754 round-to-nearest mode
                  (<a class="xref" href="jls-4.html#jls-4.2.4" title="4.2.4.&nbsp;Floating-Point Operations">&sect;4.2.4</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.2-400"></a>A
                  widening conversion of a signed integer value to an integral type <span class="type">T</span>
                  simply sign-extends the two's-complement representation of the integer
                  value to fill the wider format.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.2-410"></a>A
                  widening conversion of a <code class="literal">char</code> to an integral type <span class="type">T</span> zero-extends
                  the representation of the <code class="literal">char</code> value to fill the wider
                  format.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.2-500"></a>Despite
                  the fact that loss of precision may occur, a widening primitive
                  conversion never results in a run-time exception
                  (<a class="xref" href="jls-11.html#jls-11.1.1" title="11.1.1.&nbsp;The Kinds of Exceptions">&sect;11.1.1</a>).
               </p>
               <div class="example"><a name="d5e5437"></a><p class="title"><b>Example&nbsp;5.1.2-1.&nbsp;Widening Primitive Conversion</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        int big = 1234567890;
        float approx = big;
        System.out.println(big - (int)approx);
    }
}
</pre><p class="note">This program prints:</p><pre class="screen">
-46
</pre><p class="note">thus indicating that information was lost during the
                        conversion from type <code class="literal">int</code> to type <code class="literal">float</code> because values of type
                        <code class="literal">float</code> are not precise to nine significant digits.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="5.1.3.&nbsp;Narrowing Primitive Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.3"></a>5.1.3.&nbsp;Narrowing Primitive Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.3-100"></a>22
                  specific conversions on primitive types are called
                  the <span class="emphasis"><em>narrowing primitive conversions</em></span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.3-100-A"></a><code class="literal">short</code> to <code class="literal">byte</code> or <code class="literal">char</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.3-100-B"></a><code class="literal">char</code> to <code class="literal">byte</code> or <code class="literal">short</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.3-100-C"></a><code class="literal">int</code> to <code class="literal">byte</code>, <code class="literal">short</code>, or
                               <code class="literal">char</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.3-100-D"></a><code class="literal">long</code> to <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">char</code>, or
                               <code class="literal">int</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.3-100-E"></a><code class="literal">float</code> to <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">char</code>,
                               <code class="literal">int</code>, or <code class="literal">long</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.3-100-F"></a><code class="literal">double</code> to <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">char</code>,
                               <code class="literal">int</code>, <code class="literal">long</code>, or <code class="literal">float</code></p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.3-200"></a>A
                  narrowing primitive conversion may lose information about the overall
                  magnitude of a numeric value and may also lose precision and
                  range.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.3-210"></a>A narrowing
                  primitive conversion from <code class="literal">double</code> to <code class="literal">float</code> is governed by the IEEE
                  754 rounding rules (<a class="xref" href="jls-4.html#jls-4.2.4" title="4.2.4.&nbsp;Floating-Point Operations">&sect;4.2.4</a>). This conversion can
                  lose precision, but also lose range, resulting in a <code class="literal">float</code> zero from
                  a nonzero <code class="literal">double</code> and a <code class="literal">float</code> infinity from a finite <code class="literal">double</code>. A
                  <code class="literal">double</code> NaN is converted to a <code class="literal">float</code> NaN and a <code class="literal">double</code> infinity is
                  converted to the same-signed <code class="literal">float</code> infinity.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.3-220"></a>A
                  narrowing conversion of a signed integer to an integral type <span class="type">T</span>
                  simply discards all but the <span class="emphasis"><em>n</em></span> lowest order bits, where <span class="emphasis"><em>n</em></span> is
                  the number of bits used to represent type <span class="type">T</span>. In addition to a
                  possible loss of information about the magnitude of the numeric value,
                  this may cause the sign of the resulting value to differ from the sign
                  of the input value.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.3-230"></a>A
                  narrowing conversion of a <code class="literal">char</code> to an integral type <span class="type">T</span> likewise
                  simply discards all but the <span class="emphasis"><em>n</em></span> lowest order bits, where <span class="emphasis"><em>n</em></span> is
                  the number of bits used to represent type <span class="type">T</span>. In addition to a
                  possible loss of information about the magnitude of the numeric value,
                  this may cause the resulting value to be a negative number, even
                  though chars represent 16-bit unsigned integer values.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.3-300"></a>A
                  narrowing conversion of a floating-point number to an integral type
                  <span class="type">T</span> takes two steps:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.3-300-A"></a>In
                                 the first step, the floating-point number is converted either to
                                 a <code class="literal">long</code>, if <span class="type">T</span> is <code class="literal">long</code>, or to an <code class="literal">int</code>, if <span class="type">T</span> is <code class="literal">byte</code>,
                                 <code class="literal">short</code>, <code class="literal">char</code>, or <code class="literal">int</code>, as follows:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="disc">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.1.3-300-A-A"></a>If the floating-point number is
                                    	  NaN (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>), the result of the first
                                    	  step of the conversion is an <code class="literal">int</code> or <code class="literal">long</code> <code class="literal">0</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.1.3-300-A-B"></a>Otherwise, if the floating-point
                                    	  number is not an infinity, the floating-point value is
                                    	  rounded to an integer value <code class="varname">V</code>, rounding
                                    	  toward zero using IEEE 754 round-toward-zero mode
                                    	  (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>). Then there are two
                                    	  cases:
                                 </p>
                                 <div class="orderedlist">
                                    <ol class="orderedlist" type="a">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-5.1.3-300-A-B-A"></a>If <span class="type">T</span> is <code class="literal">long</code>, and this
                                             	     integer value can be represented as a <code class="literal">long</code>, then the
                                             	     result of the first step is the <code class="literal">long</code>
                                             	     value <code class="varname">V</code>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-5.1.3-300-A-B-B"></a>Otherwise, if this integer
                                                           value can be represented as an <code class="literal">int</code>, then the result of
                                                           the first step is the <code class="literal">int</code>
                                                           value <code class="varname">V</code>.
                                          </p>
                                       </li>
                                    </ol>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.1.3-300-A-C"></a>Otherwise, one of the following
                                    	  two cases must be true:
                                 </p>
                                 <div class="orderedlist">
                                    <ol class="orderedlist" type="a">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-5.1.3-300-A-C-A"></a>The value must be too small
                                                           (a negative value of large magnitude or negative
                                                           infinity), and the result of the first step is the
                                                           smallest representable value of type <code class="literal">int</code> or
                                                           <code class="literal">long</code>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-5.1.3-300-A-C-B"></a>The value must be too large
                                                           (a positive value of large magnitude or positive
                                                           infinity), and the result of the first step is the
                                                           largest representable value of type <code class="literal">int</code> or
                                                           <code class="literal">long</code>.
                                          </p>
                                       </li>
                                    </ol>
                                 </div>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.3-300-B"></a>In
                                 the second step:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="disc">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.1.3-300-B-A"></a>If <span class="type">T</span> is <code class="literal">int</code> or <code class="literal">long</code>, the
                                    	  result of the conversion is the result of the first
                                    	  step.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.1.3-300-B-B"></a>If <span class="type">T</span> is <code class="literal">byte</code>, <code class="literal">char</code>, or
                                    	  <code class="literal">short</code>, the result of the conversion is the result of a
                                    	  narrowing conversion to type <span class="type">T</span>
                                    	  (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>) of the result of the first
                                    	  step.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ol>
               </div>
               <p class="norm"><a name="jls-5.1.3-400"></a>Despite the fact that
                  overflow, underflow, or other loss of information may occur, a
                  narrowing primitive conversion never results in a run-time exception
                  (<a class="xref" href="jls-11.html#jls-11.1.1" title="11.1.1.&nbsp;The Kinds of Exceptions">&sect;11.1.1</a>).
               </p>
               <div class="example"><a name="d5e5582"></a><p class="title"><b>Example&nbsp;5.1.3-1.&nbsp;Narrowing Primitive Conversion</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        float fmin = Float.NEGATIVE_INFINITY;
        float fmax = Float.POSITIVE_INFINITY;
        System.out.println("long: " + (long)fmin +
                           ".." + (long)fmax);
        System.out.println("int: " + (int)fmin +
                           ".." + (int)fmax);
        System.out.println("short: " + (short)fmin +
                           ".." + (short)fmax);
        System.out.println("char: " + (int)(char)fmin +
                           ".." + (int)(char)fmax);
        System.out.println("byte: " + (byte)fmin +
                           ".." + (byte)fmax);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
long: -9223372036854775808..9223372036854775807
int: -2147483648..2147483647
short: 0..-1
char: 0..65535
byte: 0..-1
</pre><p class="note">The results for <code class="literal">char</code>, <code class="literal">int</code>, and <code class="literal">long</code> are
                        unsurprising, producing the minimum and maximum representable values
                        of the type.
                     </p>
                     <p class="note">The results for <code class="literal">byte</code> and <code class="literal">short</code> lose information
                        about the sign and magnitude of the numeric values and also lose
                        precision. The results can be understood by examining the low order
                        bits of the minimum and maximum <code class="literal">int</code>. The minimum <code class="literal">int</code> is, in
                        hexadecimal, <code class="literal">0x80000000</code>, and the maximum int
                        is <code class="literal">0x7fffffff</code>. This explains the <code class="literal">short</code> results,
                        which are the low 16 bits of these values,
                        namely, <code class="literal">0x0000</code> and <code class="literal">0xffff</code>; it
                        explains the char results, which also are the low 16 bits of these
                        values, namely, <code class="literal">'\u0000'</code>
                        and <code class="literal">'\uffff'</code>; and it explains the byte results,
                        which are the low 8 bits of these values,
                        namely, <code class="literal">0x00</code> and <code class="literal">0xff</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e5605"></a><p class="title"><b>Example&nbsp;5.1.3-2.&nbsp;Narrowing Primitive Conversions that lose information</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        // A narrowing of int to short loses high bits:
        System.out.println("(short)0x12345678==0x" +
                           Integer.toHexString((short)0x12345678));
        // An int value too big for byte changes sign and magnitude:
        System.out.println("(byte)255==" + (byte)255);
        // A float value too big to fit gives largest int value:
        System.out.println("(int)1e20f==" + (int)1e20f);
        // A NaN converted to int yields zero:
        System.out.println("(int)NaN==" + (int)Float.NaN);
        // A double value too large for float yields infinity:
        System.out.println("(float)-1e100==" + (float)-1e100);
        // A double value too small for float underflows to zero:
        System.out.println("(float)1e-50==" + (float)1e-50);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
(short)0x12345678==0x5678
(byte)255==-1
(int)1e20f==2147483647
(int)NaN==0
(float)-1e100==-Infinity
(float)1e-50==0.0
</pre></div>
               </div><br class="example-break"></div>
            <div class="section" title="5.1.4.&nbsp;Widening and Narrowing Primitive Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.4"></a>5.1.4.&nbsp;Widening and Narrowing Primitive Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.4-100"></a>The
                  following conversion combines both widening and narrowing primitive
                  conversions:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.4-100-A"></a><code class="literal">byte</code> to <code class="literal">char</code></p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.4-200"></a>First,
                  the <code class="literal">byte</code> is converted to an <code class="literal">int</code> via widening primitive conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>), and then the resulting <code class="literal">int</code> is
                  converted to a <code class="literal">char</code> by narrowing primitive conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>).
               </p>
            </div>
            <div class="section" title="5.1.5.&nbsp;Widening Reference Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.5"></a>5.1.5.&nbsp;Widening Reference Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.5-100"></a>A <span class="emphasis"><em>widening reference</em></span>
                  conversion exists from any reference type <span class="type">S</span> to
                  any reference type <span class="type">T</span>, provided <span class="type">S</span> is a subtype
                  (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>) of <span class="type">T</span>.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.5-200"></a>Widening
                  reference conversions never require a special action at run time and
                  therefore never throw an exception at run time. They consist simply in
                  regarding a reference as having some other type in a manner that can
                  be proved correct at compile time.
               </p>
            </div>
            <div class="section" title="5.1.6.&nbsp;Narrowing Reference Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.6"></a>5.1.6.&nbsp;Narrowing Reference Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.6-100"></a>Six kinds
                  of conversions are called the <span class="emphasis"><em>narrowing reference
                        conversions</em></span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.6-100-A"></a>From
                                 any reference type <span class="type">S</span> to any reference type <span class="type">T</span>, provided that
                                 <span class="type">S</span> is a proper supertype of <span class="type">T</span>
                                 (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>).
                        </p>
                        <p class="norm-static"><a name="jls-5.1.6-100-A.1"></a>An
                                 important special case is that there is a narrowing reference
                                 conversion from the class type <code class="literal">Object</code> to any other reference
                                 type (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.6-100-B"></a>From
                                 any class type <span class="type">C</span> to any non-parameterized interface type <span class="type">K</span>,
                                 provided that <span class="type">C</span> is not <code class="literal">final</code> and does not implement
                                 <span class="type">K</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.6-100-C"></a>From
                                 any interface type <span class="type">J</span> to any non-parameterized class type <span class="type">C</span>
                                 that is not <code class="literal">final</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.6-100-D"></a>From
                                 any interface type <span class="type">J</span> to any non-parameterized interface type
                                 <span class="type">K</span>, provided that <span class="type">J</span> is not a subinterface of <span class="type">K</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.6-100-E"></a>From
                                 the interface types <code class="literal">Cloneable</code> and <code class="literal">java.io.Serializable</code> to any array
                                 type <span class="type">T</span><code class="literal">[]</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.6-100-F"></a>From
                                 any array type <span class="type">SC</span><code class="literal">[]</code> to any array type <span class="type">TC</span><code class="literal">[]</code>,
                                 provided that <span class="type">SC</span> and <span class="type">TC</span> are reference types and there is a
                                 narrowing reference conversion from <span class="type">SC</span> to <span class="type">TC</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.6-200"></a>Such
                  conversions require a test at run time to find out whether the actual
                  reference value is a legitimate value of the new type. If not, then a
                  <code class="literal">ClassCastException</code> is thrown.
               </p>
            </div>
            <div class="section" title="5.1.7.&nbsp;Boxing Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.7"></a>5.1.7.&nbsp;Boxing Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.7-100"></a>Boxing conversion converts
                  expressions of primitive type to corresponding expressions of
                  reference type. Specifically, the following nine conversions are
                  called the <span class="emphasis"><em>boxing conversions</em></span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.7-100-A"></a>From
                               type <code class="literal">boolean</code> to type <code class="literal">Boolean</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.7-100-B"></a>From
                               type <code class="literal">byte</code> to type <code class="literal">Byte</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.7-100-C"></a>From
                               type <code class="literal">short</code> to type <code class="literal">Short</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.7-100-D"></a>From
                               type <code class="literal">char</code> to type <code class="literal">Character</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.7-100-E"></a>From
                               type <code class="literal">int</code> to type <code class="literal">Integer</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.7-100-F"></a>From
                               type <code class="literal">long</code> to type <code class="literal">Long</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.7-100-G"></a>From
                               type <code class="literal">float</code> to type <code class="literal">Float</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.7-100-H"></a>From
                               type <code class="literal">double</code> to type <code class="literal">Double</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.7-100-I"></a>From the
                                null type to the null type
                        </p>
                        <p class="note">This rule is necessary because the conditional
                               operator (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>) applies boxing conversion
                               to the types of its operands, and uses the result in further
                               calculations.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.7-200"></a>At run
                  time, boxing conversion proceeds as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.7-200-A"></a>If
                               <code class="varname">p</code> is a value of type <code class="literal">boolean</code>, then boxing conversion converts
                               <code class="varname">p</code> into a reference <code class="varname">r</code> of class and type <code class="literal">Boolean</code>, such
                               that <code class="literal"><code class="varname">r</code>.booleanValue() == <code class="varname">p</code></code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.7-200-B"></a>If
                               <code class="varname">p</code> is a value of type <code class="literal">byte</code>, then boxing conversion converts <code class="varname">p</code>
                               into a reference <code class="varname">r</code> of class and type <code class="literal">Byte</code>, such
                               that <code class="literal"><code class="varname">r</code>.byteValue() == <code class="varname">p</code></code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.7-200-C"></a>If
                               <code class="varname">p</code> is a value of type <code class="literal">char</code>, then boxing conversion converts <code class="varname">p</code>
                               into a reference <code class="varname">r</code> of class and type <code class="literal">Character</code>, such
                               that <code class="literal"><code class="varname">r</code>.charValue() == <code class="varname">p</code></code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.7-200-D"></a>If
                               <code class="varname">p</code> is a value of type <code class="literal">short</code>, then boxing conversion converts
                               <code class="varname">p</code> into a reference <code class="varname">r</code> of class and type <code class="literal">Short</code>, such
                               that <code class="literal"><code class="varname">r</code>.shortValue() == <code class="varname">p</code></code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.7-200-E"></a>If
                               <code class="varname">p</code> is a value of type <code class="literal">int</code>, then boxing conversion converts <code class="varname">p</code>
                               into a reference <code class="varname">r</code> of class and type <code class="literal">Integer</code>, such
                               that <code class="literal"><code class="varname">r</code>.intValue() == <code class="varname">p</code></code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.7-200-F"></a>If
                               <code class="varname">p</code> is a value of type <code class="literal">long</code>, then boxing conversion converts <code class="varname">p</code>
                               into a reference <code class="varname">r</code> of class and type <code class="literal">Long</code>, such
                               that <code class="literal"><code class="varname">r</code>.longValue() == <code class="varname">p</code></code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.7-200-G"></a>If
                               <code class="varname">p</code> is a value of type <code class="literal">float</code> then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.1.7-200-G-A"></a>If <code class="varname">p</code> is not NaN, then boxing
                                            conversion converts <code class="varname">p</code> into a reference <code class="varname">r</code> of class and type
                                            <code class="literal">Float</code>, such that <code class="literal"><code class="varname">r</code>.floatValue()</code>
                                            evaluates to <code class="varname">p</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.1.7-200-G-B"></a>Otherwise, boxing conversion
                                            converts <code class="varname">p</code> into a reference <code class="varname">r</code> of class and type <code class="literal">Float</code>
                                            such that <code class="literal"><code class="varname">r</code>.isNaN()</code> evaluates to
                                            <code class="literal">true</code></p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.7-200-H"></a>If
                               <code class="varname">p</code> is a value of type <code class="literal">double</code>, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.1.7-200-H-A"></a>If <code class="varname">p</code> is not NaN, boxing
                                            conversion converts <code class="varname">p</code> into a reference <code class="varname">r</code> of class and type
                                            <code class="literal">Double</code>, such that <code class="literal"><code class="varname">r</code>.doubleValue()</code>
                                            evaluates to <code class="varname">p</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.1.7-200-H-B"></a>Otherwise, boxing conversion
                                            converts <code class="varname">p</code> into a reference <code class="varname">r</code> of class and type <code class="literal">Double</code>
                                            such that <code class="literal"><code class="varname">r</code>.isNaN()</code> evaluates to
                                            <code class="literal">true</code></p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.7-200-I"></a>If
                               <code class="varname">p</code> is a value of any other type, boxing conversion is equivalent
                               to an identity conversion (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.7-300"></a>If the value
                  <code class="varname">p</code> being boxed is an integer literal of type <code class="literal">int</code>
                  between <code class="literal">-128</code> and <code class="literal">127</code> inclusive
                  (<a class="xref" href="jls-3.html#jls-3.10.1" title="3.10.1.&nbsp;Integer Literals">&sect;3.10.1</a>), or the boolean literal <code class="literal">true</code> or
                  <code class="literal">false</code> (<a class="xref" href="jls-3.html#jls-3.10.3" title="3.10.3.&nbsp;Boolean Literals">&sect;3.10.3</a>), or a character literal
                  between <code class="literal">'\u0000'</code> and <code class="literal">'\u007f'</code>
                  inclusive (<a class="xref" href="jls-3.html#jls-3.10.4" title="3.10.4.&nbsp;Character Literals">&sect;3.10.4</a>), then let <code class="varname">a</code> and <code class="varname">b</code> be the
                  results of any two boxing conversions of <code class="varname">p</code>. It is always the case
                  that <code class="varname">a</code> <code class="literal">==</code> <code class="varname">b</code>.
               </p>
               <p class="note">Ideally, boxing a primitive value would always yield
                  an identical reference. In practice, this may not be feasible using
                  existing implementation techniques. The rule above is a pragmatic
                  compromise, requiring that certain common values always be boxed into
                  indistinguishable objects. The implementation may cache these, lazily
                  or eagerly. For other values, the rule disallows any assumptions about
                  the identity of the boxed values on the programmer's part. This allows
                  (but does not require) sharing of some or all of these
                  references. Notice that integer literals of type <code class="literal">long</code> are allowed,
                  but not required, to be shared.
               </p>
               <p class="note">This ensures that in most common cases, the behavior
                  will be the desired one, without imposing an undue performance
                  penalty, especially on small devices. Less memory-limited
                  implementations might, for example, cache all <code class="literal">char</code> and <code class="literal">short</code>
                  values, as well as <code class="literal">int</code> and <code class="literal">long</code> values in the range of -32K to
                  +32K.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.7-400"></a>A boxing
                  conversion may result in an <code class="literal">OutOfMemoryError</code> if a new instance of one of the
                  wrapper classes (<code class="literal">Boolean</code>, <code class="literal">Byte</code>, <code class="literal">Character</code>, <code class="literal">Short</code>, <code class="literal">Integer</code>,
                  <code class="literal">Long</code>, <code class="literal">Float</code>, or <code class="literal">Double</code>) needs to be allocated and insufficient
                  storage is available.
               </p>
            </div>
            <div class="section" title="5.1.8.&nbsp;Unboxing Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.8"></a>5.1.8.&nbsp;Unboxing Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.8-100"></a>Unboxing
                  conversion converts expressions of reference type to corresponding
                  expressions of primitive type. Specifically, the following eight
                  conversions are called the <span class="emphasis"><em>unboxing
                        conversions</em></span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.8-100-A"></a>From
                               type <code class="literal">Boolean</code> to type <code class="literal">boolean</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.8-100-B"></a>From
                               type <code class="literal">Byte</code> to type <code class="literal">byte</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.8-100-C"></a>From
                               type <code class="literal">Short</code> to type <code class="literal">short</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.8-100-D"></a>From
                               type <code class="literal">Character</code> to type <code class="literal">char</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.8-100-E"></a>From
                               type <code class="literal">Integer</code> to type <code class="literal">int</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.8-100-F"></a>From
                               type <code class="literal">Long</code> to type <code class="literal">long</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.8-100-G"></a>From
                               type <code class="literal">Float</code> to type <code class="literal">float</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.8-100-H"></a>From
                               type <code class="literal">Double</code> to type <code class="literal">double</code></p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.8-200"></a>At run
                  time, unboxing conversion proceeds as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.8-200-A"></a>If
                                <code class="varname">r</code> is a reference of type <code class="literal">Boolean</code>, then unboxing conversion
                                converts <code class="varname">r</code> into <code class="literal"><code class="varname">r</code>.booleanValue()</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.8-200-B"></a>If
                                <code class="varname">r</code> is a reference of type <code class="literal">Byte</code>, then unboxing conversion
                                converts <code class="varname">r</code> into <code class="literal"><code class="varname">r</code>.byteValue()</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.8-200-C"></a>If
                                <code class="varname">r</code> is a reference of type <code class="literal">Character</code>, then unboxing conversion
                                converts <code class="varname">r</code> into <code class="literal"><code class="varname">r</code>.charValue()</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.8-200-D"></a>If
                                <code class="varname">r</code> is a reference of type <code class="literal">Short</code>, then unboxing conversion
                                converts <code class="varname">r</code> into <code class="literal"><code class="varname">r</code>.shortValue()</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.8-200-E"></a>If
                                <code class="varname">r</code> is a reference of type <code class="literal">Integer</code>, then unboxing conversion
                                converts <code class="varname">r</code> into <code class="literal"><code class="varname">r</code>.intValue()</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.8-200-F"></a>If
                                <code class="varname">r</code> is a reference of type <code class="literal">Long</code>, then unboxing conversion
                                converts <code class="varname">r</code> into <code class="literal"><code class="varname">r</code>.longValue()</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.8-200-G"></a>If
                                <code class="varname">r</code> is a reference of type <code class="literal">Float</code>, unboxing conversion converts
                                <code class="varname">r</code> into <code class="literal"><code class="varname">r</code>.floatValue()</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.8-200-H"></a>If
                                <code class="varname">r</code> is a reference of type <code class="literal">Double</code>, then unboxing conversion
                                converts <code class="varname">r</code> into <code class="literal"><code class="varname">r</code>.doubleValue()</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.8-200-I"></a>If
                                <code class="varname">r</code> is <code class="literal">null</code>, unboxing conversion throws a <code class="literal">NullPointerException</code></p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-5.1.8-300"></a>A type is said to
                  be <span class="emphasis"><em>convertible to a numeric type</em></span> if it is a
                  numeric type (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>), or it is a reference type
                  that may be converted to a numeric type by unboxing conversion.
               </p>
               <p class="norm"><a name="jls-5.1.8-310"></a>A type is said to
                  be <span class="emphasis"><em>convertible to an integral type</em></span> if it is an
                  integral type, or it is a reference type that may be converted to an
                  integral type by unboxing conversion.
               </p>
            </div>
            <div class="section" title="5.1.9.&nbsp;Unchecked Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.9"></a>5.1.9.&nbsp;Unchecked Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-5.1.9-100"></a>Let <span class="type">G</span> name a generic type
                  declaration with <span class="emphasis"><em>n</em></span> type parameters.
               </p>
               <p class="norm-static"><a name="jls-5.1.9-110"></a>There is
                  an <span class="emphasis"><em>unchecked conversion</em></span> from the
                  raw class or interface type
                  (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>) <span class="type">G</span> to any parameterized type of the form
                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>.
               </p>
               <p class="norm-static"><a name="jls-5.1.9-120"></a>There is
                  an <span class="emphasis"><em>unchecked conversion</em></span> from the raw array type
                  <span class="type">G</span><code class="literal">[]</code><sup>k</sup> to any array type of the
                  form
                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code><code class="literal">[]</code><sup>k</sup>.
                  (The notation <code class="literal">[]</code><sup>k</sup> indicates an
                  array type of <span class="emphasis"><em>k</em></span> dimensions.)
               </p>
               <p class="norm-static"><a name="jls-5.1.9-200"></a>Use of an unchecked conversion
                  causes a  compile-time <span class="emphasis"><em>unchecked
                        warning</em></span> unless  all type arguments <span class="type">T<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                  <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) are unbounded wildcards (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>),
                  or the unchecked warning is suppressed by the <code class="literal">SuppressWarnings</code>
                  annotation (<a class="xref" href="jls-9.html#jls-9.6.4.5" title="9.6.4.5.&nbsp;@SuppressWarnings">&sect;9.6.4.5</a>).
               </p>
               <p class="note">Unchecked conversion is used to enable a smooth
                  interoperation of legacy code, written before the introduction of
                  generic types, with libraries that have undergone a conversion to use
                  genericity (a process we call generification). In such circumstances
                  (most notably, clients of the Collections Framework
                  in <code class="literal">java.util</code>), legacy code uses raw types
                  (e.g. <code class="literal">Collection</code> instead
                  of <code class="literal">Collection&lt;String&gt;</code>). Expressions of raw
                  types are passed as arguments to library methods that use
                  parameterized versions of those same types as the types of their
                  corresponding formal parameters.
               </p>
               <p class="note">Such calls cannot be shown to be statically safe
                  under the type system using generics. Rejecting such calls would
                  invalidate large bodies of existing code, and prevent them from using
                  newer versions of the libraries. This in turn, would discourage
                  library vendors from taking advantage of genericity. To prevent such
                  an unwelcome turn of events, a raw type may be converted to an
                  arbitrary invocation of the generic type declaration to which the raw
                  type refers. While the conversion is unsound, it is tolerated as a
                  concession to practicality. An unchecked warning is issued in such
                  cases.
               </p>
            </div>
            <div class="section" title="5.1.10.&nbsp;Capture Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.10"></a>5.1.10.&nbsp;Capture Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.10-100"></a>
                  Let <span class="type">G</span> name a generic type declaration (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>,
                  <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>) with <span class="emphasis"><em>n</em></span> type parameters <span class="type">A<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span>
                  with corresponding bounds <span class="type">U<sub>1</sub></span>,...,<span class="type">U<sub>n</sub></span>.
               </p>
               <p class="norm-static"><a name="jls-5.1.10-110"></a>
                  There exists a <span class="emphasis"><em>capture conversion</em></span>
                  from a parameterized type
                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>)
                  to a parameterized type
                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">S<sub>1</sub></span>,...,<span class="type">S<sub>n</sub></span><code class="literal">&gt;</code>, where, for 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                  <span class="emphasis"><em>n</em></span> :
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.10-110-A"></a>If
                               <span class="type">T<sub>i</sub></span> is a wildcard type argument (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>) of
                               the form <code class="literal">?</code>, then <span class="type">S<sub>i</sub></span> is a fresh type variable whose upper
                               bound is <span class="type">U<sub>i</sub></span><code class="literal">[<span class="type">A<sub>1</sub></span>:=<span class="type">S<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span>:=<span class="type">S<sub>n</sub></span>]</code> and
                               whose lower bound is the null type
                               (<a class="xref" href="jls-4.html#jls-4.1" title="4.1.&nbsp;The Kinds of Types and Values">&sect;4.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.10-110-B"></a>If
                               <span class="type">T<sub>i</sub></span> is a wildcard type argument of the form <code class="literal">?</code> <code class="literal">extends</code>
                               <span class="type">B<sub>i</sub></span>, then <span class="type">S<sub>i</sub></span> is a fresh type variable whose upper bound is
                               glb(<span class="type">B<sub>i</sub></span>, <span class="type">U<sub>i</sub></span><code class="literal">[<span class="type">A<sub>1</sub></span>:=<span class="type">S<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span>:=<span class="type">S<sub>n</sub></span>]</code>) and
                               whose lower bound is the null type.
                        </p>
                        <p class="norm"><a name="jls-5.1.10-110-B.1"></a>glb(<span class="type">V<sub>1</sub></span>,...,<span class="type">V<sub>m</sub></span>)
                                is defined as <span class="type">V<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">V<sub>m</sub></span>.
                        </p>
                        <p class="norm-error"><a name="jls-5.1.10-110-B.2"></a>It
                                is a compile-time error if, for any two classes (not interfaces)
                                <span class="type">V<sub>i</sub></span> and <span class="type">V<sub>j</sub></span>, <span class="type">V<sub>i</sub></span> is not a subclass of <span class="type">V<sub>j</sub></span> or vice
                                versa.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.10-110-C"></a>If
                               <span class="type">T<sub>i</sub></span> is a wildcard type argument of the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">B<sub>i</sub></span>,
                               then <span class="type">S<sub>i</sub></span> is a fresh type variable whose upper bound is
                               <span class="type">U<sub>i</sub></span><code class="literal">[<span class="type">A<sub>1</sub></span>:=<span class="type">S<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span>:=<span class="type">S<sub>n</sub></span>]</code> and whose lower
                               bound is <span class="type">B<sub>i</sub></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.1.10-110-D"></a>Otherwise, <span class="type">S<sub>i</sub></span> = <span class="type">T<sub>i</sub></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-5.1.10-200"></a>Capture
                  conversion on any type other than a parameterized type
                  (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) acts as an identity conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>).
               </p>
               <p class="norm-static"><a name="jls-5.1.10-300"></a>Capture
                  conversion is not applied recursively.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.10-400"></a>Capture
                  conversion never requires a special action at run time and therefore
                  never throws an exception at run time.
               </p>
               <div class="informalexample">
                  <p class="note">Capture conversion is designed to make wildcards
                     more useful. To understand the motivation, let's begin by looking at
                     the method <code class="literal">java.util.Collections.reverse()</code>:
                  </p><pre class="programlisting">

public static void reverse(List&lt;?&gt; list);

</pre><p class="note">The method reverses the list provided as a
                     parameter. It works for any type of list, and so the use of the
                     wildcard type <code class="literal">List&lt;?&gt;</code> as the type of the
                     formal parameter is entirely appropriate.
                  </p>
                  <p class="note">Now consider how one would
                     implement <code class="literal">reverse()</code>:
                  </p><pre class="programlisting">

public static void reverse(List&lt;?&gt; list) { rev(list); }
private static &lt;T&gt; void rev(List&lt;T&gt; list) {
    List&lt;T&gt; tmp = new ArrayList&lt;T&gt;(list);
    for (int i = 0; i &lt; list.size(); i++) {
        list.set(i, tmp.get(list.size() - i - 1));
    }
}

</pre><p class="note">The implementation needs to copy the list, extract
                     elements from the copy, and insert them into the original. To do this
                     in a type-safe manner, we need to give a name, <code class="literal">T</code>,
                     to the element type of the incoming list. We do this in the private
                     service method <code class="literal">rev()</code>. This requires us to pass the
                     incoming argument list, of type <code class="literal">List&lt;?&gt;</code>, as
                     an argument to <code class="literal">rev()</code>. In
                     general, <code class="literal">List&lt;?&gt;</code> is a list of unknown
                     type. It is not a subtype of <code class="literal">List&lt;T&gt;</code>, for any
                     type <span class="type">T</span>. Allowing such a subtype relation would be unsound. Given the
                     method:
                  </p><pre class="programlisting">

public static &lt;T&gt; void fill(List&lt;T&gt; l, T obj)

</pre><p class="note">the following code would undermine the type
                     system:
                  </p><pre class="programlisting">

List&lt;String&gt; ls = new ArrayList&lt;String&gt;();
List&lt;?&gt; l = ls;
Collections.fill(l, new Object());  // not legal - but assume it was!
String s = ls.get(0); // ClassCastException - ls contains
                      // Objects, not Strings.

</pre><p class="note">So, without some special dispensation, we can see
                     that the call from <code class="literal">reverse()</code>
                     to <code class="literal">rev()</code> would be disallowed. If this were the
                     case, the author of <code class="literal">reverse()</code> would be forced to
                     write its signature as:
                  </p><pre class="programlisting">

public static &lt;T&gt; void reverse(List&lt;T&gt; list)

</pre><p class="note">This is undesirable, as it exposes implementation
                     information to the caller. Worse, the designer of an API might reason
                     that the signature using a wildcard is what the callers of the API
                     require, and only later realize that a type safe implementation was
                     precluded.
                  </p>
                  <p class="note">The call from <code class="literal">reverse()</code>
                     to <code class="literal">rev()</code> is in fact harmless, but it cannot be
                     justified on the basis of a general subtyping relation
                     between <code class="literal">List&lt;?&gt;</code>
                     and <code class="literal">List&lt;T&gt;</code>. The call is harmless, because
                     the incoming argument is doubtless a list of some type (albeit an
                     unknown one). If we can capture this unknown type in a type
                     variable <code class="literal">X</code>, we can infer <code class="literal">T</code> to
                     be <code class="literal">X</code>. That is the essence of capture
                     conversion. The specification of course must cope with complications,
                     like non-trivial (and possibly recursively defined) upper or lower
                     bounds, the presence of multiple arguments etc.
                  </p>
               </div>
               <p class="note">Mathematically sophisticated readers will want to
                  relate capture conversion to established type theory. Readers
                  unfamiliar with type theory can skip this discussion - or else study a
                  suitable text, such as <em class="citetitle">Types and Programming
                     Languages</em> by Benjamin Pierce, and then revisit this
                  section.
               </p>
               <p class="note">Here then is a brief summary of the relationship of
                  capture conversion to established type theoretical notions. Wildcard
                  types are a restricted form of existential types. Capture conversion
                  corresponds loosely to an opening of a value of existential type. A
                  capture conversion of an expression <code class="varname">e</code> can be
                  thought of as an <code class="literal">open</code> of <code class="varname">e</code> in a
                  scope that comprises the top level expression that
                  encloses <code class="varname">e</code>.
               </p>
               <p class="note">The classical <code class="literal">open</code> operation on
                  existentials requires that the captured type variable must not escape
                  the opened expression. The <code class="literal">open</code> that corresponds to
                  capture conversion is always on a scope sufficiently large that the
                  captured type variable can never be visible outside that scope. The
                  advantage of this scheme is that there is no need for
                  a <code class="literal">close</code> operation, as defined in the
                  paper <em class="citetitle">On Variance-Based Subtyping for Parametric
                     Types</em> by Atsushi Igarashi and Mirko Viroli, in the
                  proceedings of the 16th European Conference on Object Oriented
                  Programming (ECOOP 2002). For a formal account of wildcards,
                  see <em class="citetitle">Wild FJ</em> by Mads Torgersen, Erik Ernst and
                  Christian Plesner Hansen, in the 12th workshop on Foundations of
                  Object Oriented Programming (FOOL 2005).
               </p>
            </div>
            <div class="section" title="5.1.11.&nbsp;String Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.11"></a>5.1.11.&nbsp;String Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.11-100"></a>Any type
                  may be converted to type <code class="literal">String</code> by <span class="emphasis"><em>string
                        conversion</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.11-110"></a>A
                  value <code class="varname">x</code> of primitive type <span class="type">T</span> is first converted to
                  a reference value as if by giving it as an argument to an appropriate
                  class instance creation expression
                  (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.11-110-A"></a>If
                               <span class="type">T</span> is <code class="literal">boolean</code>, then use <code class="literal">new
                                  Boolean(<code class="varname">x</code>)</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.11-110-B"></a>If
                               <span class="type">T</span> is <code class="literal">char</code>, then use <code class="literal">new
                                  Character(<code class="varname">x</code>)</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.11-110-C"></a>If
                               <span class="type">T</span> is <code class="literal">byte</code>, <code class="literal">short</code>, or <code class="literal">int</code>, then use <code class="literal">new
                                  Integer(<code class="varname">x</code>)</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.11-110-D"></a>If
                               <span class="type">T</span> is <code class="literal">long</code>, then use <code class="literal">new
                                  Long(<code class="varname">x</code>)</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.11-110-E"></a>If
                               <span class="type">T</span> is <code class="literal">float</code>, then use <code class="literal">new
                                  Float(<code class="varname">x</code>)</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.11-110-F"></a>If
                               <span class="type">T</span> is <code class="literal">double</code>, then use <code class="literal">new
                                  Double(<code class="varname">x</code>)</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.11-120"></a>This
                  reference value is then converted to type <code class="literal">String</code> by string
                  conversion.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.11-200"></a>Now only
                  reference values need to be considered:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.11-200-A"></a>If
                               the reference is <code class="literal">null</code>, it is converted to the string "<code class="literal">null</code>"
                               (four ASCII characters <code class="literal">n</code>, <code class="literal">u</code>,
                                 <code class="literal">l</code>, <code class="literal">l</code>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.11-200-B"></a>Otherwise, the conversion is performed
                               as if by an invocation of the <code class="literal">toString</code> method of the referenced
                               object with no arguments; but if the result of invoking the
                               <code class="literal">toString</code> method is <code class="literal">null</code>, then the string "<code class="literal">null</code>" is used
                               instead.
                        </p>
                        <p class="note">The <code class="literal">toString</code> method is defined by the
                               primordial class <code class="literal">Object</code> (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>). Many
                               classes override it, notably <code class="literal">Boolean</code>, <code class="literal">Character</code>, <code class="literal">Integer</code>,
                               <code class="literal">Long</code>, <code class="literal">Float</code>, <code class="literal">Double</code>, and <code class="literal">String</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">See <a class="xref" href="jls-5.html#jls-5.4" title="5.4.&nbsp;String Contexts">&sect;5.4</a> for details of the
                  string context.
               </p>
            </div>
            <div class="section" title="5.1.12.&nbsp;Forbidden Conversions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.12"></a>5.1.12.&nbsp;Forbidden Conversions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.12-100"></a>Any
                  conversion that is not explicitly allowed is forbidden.
               </p>
            </div>
            <div class="section" title="5.1.13.&nbsp;Value Set Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.1.13"></a>5.1.13.&nbsp;Value Set Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.1.13-100"></a><span class="emphasis"><em>Value set conversion</em></span> is
                  the process of mapping a floating-point value from one value set to
                  another without changing its type.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.13-110"></a>Within
                  an expression that is not FP-strict (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>),
                  value set conversion provides choices to an implementation of the
                  Java programming language:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.13-110-A"></a>If
                                 the value is an element of the float-extended-exponent value
                                 set, then the implementation may, at its option, map the value
                                 to the nearest element of the float value set. This conversion
                                 may result in overflow (in which case the value is replaced by
                                 an infinity of the same sign) or underflow (in which case the
                                 value may lose precision because it is replaced by a
                                 denormalized number or zero of the same sign).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.13-110-B"></a>If
                                 the value is an element of the double-extended-exponent value
                                 set, then the implementation may, at its option, map the value
                                 to the nearest element of the double value set. This conversion
                                 may result in overflow (in which case the value is replaced by
                                 an infinity of the same sign) or underflow (in which case the
                                 value may lose precision because it is replaced by a
                                 denormalized number or zero of the same sign).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.13-120"></a>Within
                  an FP-strict expression (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>), value set
                  conversion does not provide any choices; every implementation must
                  behave in the same way:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.13-120-A"></a>If
                                 the value is of type <code class="literal">float</code> and is not an element of the float
                                 value set, then the implementation must map the value to the
                                 nearest element of the float value set. This conversion may
                                 result in overflow or underflow.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-5.1.13-120-B"></a>If
                                 the value is of type <code class="literal">double</code> and is not an element of the
                                 double value set, then the implementation must map the value to
                                 the nearest element of the double value set. This conversion may
                                 result in overflow or underflow.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.1.13-130"></a>Within
                  an FP-strict expression, mapping values from the
                  float-extended-exponent value set or double-extended-exponent value
                  set is necessary only when a method is invoked whose declaration is
                  not FP-strict and the implementation has chosen to represent the
                  result of the method invocation as an element of an extended-exponent
                  value set.
               </p>
               <p class="norm-dynamic"><a name="jls-5.1.13-200"></a>Whether
                  in FP-strict code or code that is not FP-strict, value set conversion
                  always leaves unchanged any value whose type is neither <code class="literal">float</code> nor
                  <code class="literal">double</code>.
               </p>
            </div>
         </div>
         <div class="section" title="5.2.&nbsp;Assignment Contexts">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-5.2"></a>5.2.&nbsp;Assignment Contexts
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-5.2-100"></a>
               <span class="emphasis"><em>Assignment contexts</em></span> allow the value of an
               expression to be assigned (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>) to a variable;
               the type of the expression must be converted to the type of the
               variable.
            </p>
            <p class="norm-static"><a name="jls-5.2-110"></a>Assignment
               contexts allow the use of one of the following:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.2-110-A"></a>an
                              identity conversion (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.2-110-B"></a>a
                              widening primitive conversion
                              (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.2-110-C"></a>a
                              widening reference conversion
                              (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.2-110-D"></a>a
                              boxing conversion (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) optionally
                              followed by a widening reference conversion
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.2-110-E"></a>an
                              unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) optionally
                              followed by a widening primitive conversion.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-5.2-120"></a>If, after
               the conversions listed above have been applied, the resulting type is
               a raw type (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>), an unchecked conversion
               (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>) may then be applied.
            </p>
            <p class="norm-static"><a name="jls-5.2-200"></a>In addition,
               if the expression is a constant expression
               (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>) of type <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">char</code>, or
               <code class="literal">int</code>:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.2-200-A"></a>
                              A narrowing primitive conversion may be used if the type of the
                              variable is <code class="literal">byte</code>, <code class="literal">short</code>, or <code class="literal">char</code>, and the value of the
                              constant expression is representable in the type of the
                              variable.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.2-200-B"></a>
                              A narrowing primitive conversion followed by a boxing conversion
                              may be used if the type of the variable is:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-5.2-200-B-A"></a>
                                 	  <code class="literal">Byte</code> and the value of the constant expression is
                                 	  representable in the type <code class="literal">byte</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-5.2-200-B-B"></a>
                                 	  <code class="literal">Short</code> and the value of the constant expression is
                                 	  representable in the type <code class="literal">short</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-5.2-200-B-C"></a>
                                 	  <code class="literal">Character</code> and the value of the constant expression is
                                 	  representable in the type <code class="literal">char</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
               </ul>
            </div>
            <div class="informalexample">
               <p class="note">The compile-time narrowing of constant expressions
                  means that code such as:
               </p><pre class="screen">
byte theAnswer = 42;
</pre><p class="note">is allowed. Without the narrowing, the fact that the
                  integer literal <code class="literal">42</code> has type <code class="literal">int</code> would mean that a
                  cast to <code class="literal">byte</code> would be required:
               </p><pre class="screen">
byte theAnswer = (byte)42;  // cast is permitted but not required
</pre></div>
            <p class="norm-static"><a name="jls-5.2-210"></a>Finally, a
               value of the null type (the null reference is the only such value) may
               be assigned to any reference type, resulting in a null reference of
               that type.
            </p>
            <p class="norm-error"><a name="jls-5.2-300"></a>It is a
               compile-time error if the chain of conversions contains two
               parameterized types that are not in the subtype relation
               (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>).
            </p>
            <div class="informalexample">
               <p class="note">An example of such an illegal chain would be:</p><pre class="screen">
Integer, Comparable&lt;Integer&gt;, Comparable, Comparable&lt;String&gt;
</pre><p class="note">The first three elements of the chain are related by
                  widening reference conversion, while the last entry is derived from
                  its predecessor by unchecked conversion. However, this is not a valid
                  assignment conversion, because the chain contains two parameterized
                  types, <code class="literal">Comparable&lt;Integer&gt;</code>
                  and <code class="literal">Comparable&lt;String&gt;</code>, that are not
                  subtypes.
               </p>
            </div>
            <p class="norm-error"><a name="jls-5.2-310"></a>If the type
               of the expression cannot be converted to the type of the variable by a
               conversion permitted in an assignment context, then a compile-time
               error occurs.
            </p>
            <p class="norm-static"><a name="jls-5.2-320"></a>If the type
               of an expression can be converted to the type of a variable by
               assignment conversion, we say the expression (or its value)
               is <span class="emphasis"><em>assignable to</em></span> the variable or, equivalently,
               that the type of the expression is <span class="emphasis"><em>assignment compatible
                     with</em></span> the type of the variable.
            </p>
            <p class="norm-static"><a name="jls-5.2-400"></a>If the type
               of the variable is <code class="literal">float</code> or <code class="literal">double</code>, then value set conversion
               (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) is applied to the value <code class="varname">v</code> that is the
               result of the conversion(s):
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.2-400-A"></a>
                              If <code class="varname">v</code> is of type <code class="literal">float</code> and is an element of the
                              float-extended-exponent value set, then the implementation must
                              map <code class="varname">v</code> to the nearest element of the float value set. This
                              conversion may result in overflow or underflow.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.2-400-B"></a>
                              If <code class="varname">v</code> is of type <code class="literal">double</code> and is an element of the
                              double-extended-exponent value set, then the implementation must
                              map <code class="varname">v</code> to the nearest element of the double value set. This
                              conversion may result in overflow or underflow.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-dynamic"><a name="jls-5.2-500"></a>The only
               exceptions that may arise from conversions in an assignment context
               are:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-5.2-500-A"></a>
                              A <code class="literal">ClassCastException</code> if, after the conversions above have been applied, the
                              resulting value is an object which is not an instance of a
                              subclass or subinterface of the erasure
                              (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the type of the variable.
                     </p>
                     <p class="note">This circumstance can only arise as a result of
                              heap pollution (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>). In practice,
                              implementations need only perform casts when accessing a field
                              or method of an object of parameterized type when the erased
                              type of the field, or the erased return type of the method,
                              differ from its unerased type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-5.2-500-B"></a>
                              An <code class="literal">OutOfMemoryError</code> as a result of a boxing conversion.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-5.2-500-C"></a>
                              A <code class="literal">NullPointerException</code> as a result of an unboxing conversion on a null
                              reference.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-5.2-500-D"></a>
                              An <code class="literal">ArrayStoreException</code> in special cases involving array elements or field
                              access (<a class="xref" href="jls-10.html#jls-10.5" title="10.5.&nbsp;Array Store Exception">&sect;10.5</a>,
                              <a class="xref" href="jls-15.html#jls-15.26.1" title="15.26.1.&nbsp;Simple Assignment Operator =">&sect;15.26.1</a>).
                     </p>
                  </li>
               </ul>
            </div>
            <div class="example"><a name="d5e6421"></a><p class="title"><b>Example&nbsp;5.2-1.&nbsp;Assignment Conversion for Primitive Types</b></p>
               <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        short s = 12;      // narrow 12 to short
        float f = s;       // widen short to float
        System.out.println("f=" + f);
        char c = '\u0123';
        long l = c;        // widen char to long
        System.out.println("l=0x" + Long.toString(l,16));
        f = 1.23f;
        double d = f;      // widen float to double
        System.out.println("d=" + d);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
f=12.0
l=0x123
d=1.2300000190734863
</pre><p class="note">The following program, however, produces compile-time
                     errors:
                  </p><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        short s = 123;
        char c = s;    // error: would require cast
        s = c;         // error: would require cast
    }
}
</pre><p class="note">because not all <code class="literal">short</code> values are <code class="literal">char</code> values,
                     and neither are all <code class="literal">char</code> values <code class="literal">short</code> values.
                  </p>
               </div>
            </div><br class="example-break"><div class="example"><a name="d5e6433"></a><p class="title"><b>Example&nbsp;5.2-2.&nbsp;Assignment Conversion for Reference Types</b></p>
               <div class="example-contents"><pre class="programlisting">
class Point { int x, y; }
class Point3D extends Point { int z; }
interface Colorable { void setColor(int color); }

class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}

class Test {
    public static void main(String[] args) {
        // Assignments to variables of class type:
        Point p = new Point();
        p = new Point3D(); 
          // OK because Point3D is a subclass of Point
        Point3D p3d = p; 
          // Error: will require a cast because a Point
          // might not be a Point3D (even though it is,
          // dynamically, in this example.)

        // Assignments to variables of type Object:
        Object o  = p;          // OK: any object to Object
        int[] a   = new int[3];
        Object o2 = a;          // OK: an array to Object

        // Assignments to variables of interface type:
        ColoredPoint cp = new ColoredPoint();
        Colorable c = cp;
          // OK: ColoredPoint implements Colorable

        // Assignments to variables of array type:
        byte[] b = new byte[4];
        a = b;
          // Error: these are not arrays of the same primitive type
        Point3D[] p3da = new Point3D[3];
        Point[] pa = p3da; 
          // OK: since we can assign a Point3D to a Point
        p3da = pa;
          // Error: (cast needed) since a Point
          // can't be assigned to a Point3D
    }
}
</pre><p class="note">The following test program illustrates assignment
                     conversions on reference values, but fails to compile, as described in
                     its comments. This example should be compared to the preceding
                     one.
                  </p><pre class="programlisting">
class Point { int x, y; }
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}

class Test {
    public static void main(String[] args) {
        Point p = new Point();
        ColoredPoint cp = new ColoredPoint();
        // Okay because ColoredPoint is a subclass of Point:
        p = cp;
        // Okay because ColoredPoint implements Colorable:
        Colorable c = cp;
        // The following cause compile-time errors because
        // we cannot be sure they will succeed, depending on
        // the run-time type of p; a run-time check will be
        // necessary for the needed narrowing conversion and
        // must be indicated by including a cast:
        cp = p;    // p might be neither a ColoredPoint
                   // nor a subclass of ColoredPoint
        c = p;     // p might not implement Colorable
    }
}
</pre></div>
            </div><br class="example-break"><div class="example"><a name="d5e6438"></a><p class="title"><b>Example&nbsp;5.2-3.&nbsp;Assignment Conversion for Array Types</b></p>
               <div class="example-contents"><pre class="programlisting">
class Point { int x, y; }
class ColoredPoint extends Point { int color; }

class Test {
    public static void main(String[] args) {
        long[] veclong = new long[100];
        Object o = veclong;          // okay
        Long l = veclong;            // compile-time error
        short[] vecshort = veclong;  // compile-time error
        Point[] pvec = new Point[100];
        ColoredPoint[] cpvec = new ColoredPoint[100];
        pvec = cpvec;                // okay
        pvec[0] = new Point();       // okay at compile time,
                                     // but would throw an
                                     // exception at run time
        cpvec = pvec;                // compile-time error
    }
}
</pre><p class="note">In this example:</p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">The value of <code class="literal">veclong</code> cannot
                                    be assigned to a <code class="literal">Long</code> variable, because <code class="literal">Long</code> is a class type
                                    other than <code class="literal">Object</code>. An array can be assigned only to a variable
                                    of a compatible array type, or to a variable of type <code class="literal">Object</code>,
                                    <code class="literal">Cloneable</code> or <code class="literal">java.io.Serializable</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">The value of <code class="literal">veclong</code> cannot
                                    be assigned to <code class="literal">vecshort</code>, because they are
                                    arrays of primitive type, and <code class="literal">short</code> and <code class="literal">long</code> are not the
                                    same primitive type.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">The value of <code class="literal">cpvec</code> can be
                                    assigned to <code class="literal">pvec</code>, because any reference that
                                    could be the value of an expression of
                                    type <code class="literal">ColoredPoint</code> can be the value of a
                                    variable of type <code class="literal">Point</code>. The subsequent
                                    assignment of the new <code class="literal">Point</code> to a component
                                    of <code class="literal">pvec</code> then would throw an <code class="literal">ArrayStoreException</code> (if the
                                    program were otherwise corrected so that it could be compiled),
                                    because a <code class="literal">ColoredPoint</code> array cannot have an
                                    instance of <code class="literal">Point</code> as the value of a
                                    component.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">The value of <code class="literal">pvec</code> cannot be
                                    assigned to <code class="literal">cpvec</code>, because not every
                                    reference that could be the value of an expression of
                                    type <code class="literal">ColoredPoint</code> can correctly be the value
                                    of a variable of type <code class="literal">Point</code>. If the value
                                    of <code class="literal">pvec</code> at run time were a reference to an
                                    instance of <code class="literal">Point[]</code>, and the assignment
                                    to <code class="literal">cpvec</code> were allowed, a simple reference to
                                    a component of <code class="literal">cpvec</code>,
                                    say, <code class="literal">cpvec[0]</code>, could return
                                    a <code class="literal">Point</code>, and a <code class="literal">Point</code> is
                                    not a <code class="literal">ColoredPoint</code>. Thus to allow such an
                                    assignment would allow a violation of the type system. A cast
                                    may be used (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>,
                                    <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>) to ensure
                                    that <code class="literal">pvec</code> references
                                    a <code class="literal">ColoredPoint[]</code>:
                           </p><pre class="programlisting">
      cpvec = (ColoredPoint[])pvec;  // OK, but may throw an 
                               // exception at run time
    </pre></li>
                     </ul>
                  </div>
               </div>
            </div><br class="example-break"></div>
         <div class="section" title="5.3.&nbsp;Invocation Contexts">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-5.3"></a>5.3.&nbsp;Invocation Contexts
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-5.3-100"></a>
               <span class="emphasis"><em>Invocation contexts</em></span> allow an argument value in a
               method or constructor invocation (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>,
               <a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>, <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>) to be
               assigned to a corresponding formal parameter.
            </p>
            <p class="norm-static"><a name="jls-5.3-200"></a>
               <span class="emphasis"><em>Strict</em></span> invocation contexts allow the use of one
               of the following:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-200-A"></a>
                              an identity conversion (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-200-B"></a>
                              a widening primitive conversion (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-200-C"></a>
                              a widening reference conversion (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>)
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-5.3-210"></a>
               <span class="emphasis"><em>Loose</em></span> invocation contexts allow a more permissive
               set of conversions, because they are only used for a particular
               invocation if no applicable declaration can be found using strict
               invocation contexts. Loose invocation contexts allow the use of one of
               the following:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-210-A"></a>
                              an identity conversion (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-210-B"></a>
                              a widening primitive conversion (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-210-C"></a>
                              a widening reference conversion (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-210-D"></a>
                              a boxing conversion (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) optionally
                              followed by widening reference conversion
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-210-E"></a>
                              an unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) optionally
                              followed by a widening primitive conversion
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-5.3-220"></a>If, after
               the conversions listed for an invocation context have been applied,
               the resulting type is a raw type (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>), an
               unchecked conversion (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>) may then be
               applied.
            </p>
            <p class="norm-static"><a name="jls-5.3-230"></a>A value of the null type (the null
               reference is the only such value) may be assigned to any reference
               type.
            </p>
            <p class="norm-error"><a name="jls-5.3-300"></a>It is a
               compile-time error if the chain of conversions contains two
               parameterized types that are not in the subtype relation
               (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>).
            </p>
            <p class="norm-error"><a name="jls-5.3-310"></a>If the type of
               the expression cannot be converted to the type of the parameter by a
               conversion permitted in a loose invocation context, then a
               compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-5.3-400"></a>If the type
               of an argument expression is either <code class="literal">float</code> or <code class="literal">double</code>, then value
               set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) is applied after the
               conversion(s):
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-400-A"></a>
                              If an argument value of type <code class="literal">float</code> is an element of the
                              float-extended-exponent value set, then the implementation must
                              map the value to the nearest element of the float value
                              set. This conversion may result in overflow or underflow.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.3-400-B"></a>
                              If an argument value of type <code class="literal">double</code> is an element of the
                              double-extended-exponent value set, then the implementation must
                              map the value to the nearest element of the double value
                              set. This conversion may result in overflow or underflow.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-dynamic"><a name="jls-5.3-500"></a>The only exceptions that may arise
               in an invocation context are:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-5.3-500-A"></a>
                              A <code class="literal">ClassCastException</code> if, after the type conversions above have been applied,
                              the resulting value is an object which is not an instance of a
                              subclass or subinterface of the erasure
                              (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the corresponding formal
                              parameter type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-5.3-500-B"></a>
                              An <code class="literal">OutOfMemoryError</code> as a result of a boxing conversion.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-5.3-500-C"></a>
                              A <code class="literal">NullPointerException</code> as a result of an unboxing conversion on a null
                              reference.
                     </p>
                  </li>
               </ul>
            </div>
            <div class="informalexample">
               <p class="note">Neither strict nor loose invocation contexts include
                  the implicit narrowing of integer constant expressions which is
                  allowed in assignment contexts. The designers of the Java programming language felt
                  that including these implicit narrowing conversions would add
                  additional complexity to the rules of overload resolution
                  (<a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>).
               </p>
               <p class="note">Thus, the program:</p><pre class="programlisting">
class Test {
    static int m(byte a, int b) { return a+b; }
    static int m(short a, short b) { return a-b; }
    public static void main(String[] args) {
        System.out.println(m(12, 2));  // compile-time error
    }
}
</pre><p class="note">causes a compile-time error because the integer
                  literals <code class="literal">12</code> and <code class="literal">2</code> have type
                  <code class="literal">int</code>, so neither method <code class="literal">m</code> matches under the rules
                  of overload resolution. A language that included implicit narrowing of
                  integer constant expressions would need additional rules to resolve
                  cases like this example.
               </p>
            </div>
         </div>
         <div class="section" title="5.4.&nbsp;String Contexts">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-5.4"></a>5.4.&nbsp;String Contexts
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-5.4-100"></a>String contexts
               apply only to an operand of the binary <code class="literal">+</code> operator which is not a
               <code class="literal">String</code> when the other operand is a <code class="literal">String</code>.
            </p>
            <p class="norm-static"><a name="jls-5.4-110"></a>The target type
               in these contexts is always <code class="literal">String</code>, and a string conversion
               (<a class="xref" href="jls-5.html#jls-5.1.11" title="5.1.11.&nbsp;String Conversion">&sect;5.1.11</a>) of the non-<code class="literal">String</code> operand always
               occurs. Evaluation of the <code class="literal">+</code> operator then proceeds as specified
               in <a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>.
            </p>
         </div>
         <div class="section" title="5.5.&nbsp;Casting Contexts">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-5.5"></a>5.5.&nbsp;Casting Contexts
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-5.5-100"></a>
               <span class="emphasis"><em>Casting contexts</em></span> allow the operand of a cast
               operator (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>) to be converted to the type
               explicitly named by the cast operator.
            </p>
            <p class="norm-static"><a name="jls-5.5-110"></a>Casting
               contexts allow the use of one of:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-110-A"></a>an
                            identity conversion (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-110-B"></a>a
                            widening primitive conversion (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-110-C"></a>a
                            narrowing primitive conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-110-D"></a>a widening
                            and narrowing primitive conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.4" title="5.1.4.&nbsp;Widening and Narrowing Primitive Conversion">&sect;5.1.4</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-110-E"></a>a widening reference conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>) optionally followed by
                            either an unboxing conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) or an unchecked conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-110-F"></a>a narrowing reference conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.6" title="5.1.6.&nbsp;Narrowing Reference Conversion">&sect;5.1.6</a>) optionally followed
                            by either an unboxing conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) or an unchecked conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-110-G"></a>a boxing
                            conversion (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) optionally
                            followed by a widening reference conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-110-H"></a>an
                            unboxing conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) optionally followed by a
                            widening primitive conversion
                            (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>).
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-5.5-120"></a>Value set
               conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) is applied after the type
               conversion.
            </p>
            <p class="norm-static"><a name="jls-5.5-200"></a>The
               compile-time legality of a casting conversion is as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-200-A"></a>An
                              expression of a primitive type may undergo casting conversion to
                              another primitive type, by an identity conversion (if the types
                              are the same), or by a widening primitive conversion, or by a
                              narrowing primitive conversion, or by a widening and
                              narrowing primitive conversion.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-200-B"></a>An
                              expression of a primitive type may undergo casting conversion to
                              a reference type without error, by boxing conversion.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-200-C"></a>An
                              expression of a reference type may undergo casting conversion to
                              a primitive type without error, by unboxing conversion.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.5-200-D"></a>An
                              expression of a reference type may undergo casting conversion to
                              another reference type if no compile-time error occurs given the
                              rules in <a class="xref" href="jls-5.html#jls-5.5.1" title="5.5.1.&nbsp;Reference Type Casting">&sect;5.5.1</a>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-5.5-300"></a>The following tables enumerate which conversions are used
               in certain casting conversions. Each conversion is signified by a
               symbol:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p><a name="jls-5.5-300-A"></a>- signifies no casting conversion
                              allowed
                     </p>
                  </li>
                  <li class="listitem">
                     <p><a name="jls-5.5-300-B"></a><span class="symbol">&#8776;</span> signifies identity conversion
                              (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p><a name="jls-5.5-300-C"></a><span class="symbol">&#969;</span> signifies widening primitive
                              conversion (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p><a name="jls-5.5-300-D"></a><span class="symbol">&#951;</span> signifies narrowing primitive
                              conversion (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p><a name="jls-5.5-300-E"></a><span class="symbol">&#969;</span><span class="symbol">&#951;</span> signifies widening and
                              narrowing primitive conversion
                              (<a class="xref" href="jls-5.html#jls-5.1.4" title="5.1.4.&nbsp;Widening and Narrowing Primitive Conversion">&sect;5.1.4</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p><a name="jls-5.5-300-F"></a><span class="symbol">&#8657;</span> signifies widening reference
                              conversion (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p><a name="jls-5.5-300-G"></a><span class="symbol">&#8659;</span> signifies narrowing reference
                              conversion (<a class="xref" href="jls-5.html#jls-5.1.6" title="5.1.6.&nbsp;Narrowing Reference Conversion">&sect;5.1.6</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p><a name="jls-5.5-300-H"></a><span class="symbol">&#8853;</span> signifies boxing conversion
                              (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p><a name="jls-5.5-300-I"></a><span class="symbol">&#8855;</span> signifies unboxing conversion
                              (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>)
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-5.5-310"></a>In the tables, a comma between symbols indicates that a
               casting conversion uses one conversion followed by another. The type
               <code class="literal">Object</code> means any reference type other than the eight wrapper classes
               <code class="literal">Boolean</code>, <code class="literal">Byte</code>, <code class="literal">Short</code>, <code class="literal">Character</code>, <code class="literal">Integer</code>, <code class="literal">Long</code>, <code class="literal">Float</code>,
               <code class="literal">Double</code>.
            </p>
            <div class="table"><a name="jls-5.5-320"></a><p class="title"><b>Table&nbsp;5.5-A.&nbsp;Casting conversions to primitive types</b></p>
               <div class="table-contents">
                  <table summary="Casting conversions to primitive types" border="1">
                     <colgroup>
                        <col align="left">
                        <col>
                        <col>
                        <col>
                        <col>
                        <col>
                        <col>
                        <col>
                        <col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th align="left">To <span class="symbol">&#8594;</span></th>
                           <th align="center"><code class="literal">byte</code></th>
                           <th align="center"><code class="literal">short</code></th>
                           <th align="center"><code class="literal">char</code></th>
                           <th align="center"><code class="literal">int</code></th>
                           <th align="center"><code class="literal">long</code></th>
                           <th align="center"><code class="literal">float</code></th>
                           <th align="center"><code class="literal">double</code></th>
                           <th align="center"><code class="literal">boolean</code></th>
                        </tr>
                        <tr>
                           <th align="left">From <span class="symbol">&#8595;</span></th>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td align="left"><code class="literal">byte</code></td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">short</code></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">char</code></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">int</code></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">long</code></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">float</code></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center"><span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">double</code></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#951;</span></td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">boolean</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Byte</code></td>
                           <td align="center"><span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Short</code></td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8855;</span></td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Character</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Integer</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Long</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Float</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8855;</span>,<span class="symbol">&#969;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Double</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8855;</span></td>
                           <td align="center">-</td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Boolean</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8855;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Object</code></td>
                           <td align="center"><span class="symbol">&#8659;</span>,<span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span>,<span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span>,<span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span>,<span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span>,<span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span>,<span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span>,<span class="symbol">&#8855;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span>,<span class="symbol">&#8855;</span></td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </div><br class="table-break"><div class="table"><a name="jls-5.5-330"></a><p class="title"><b>Table&nbsp;5.5-B.&nbsp;Casting conversions to reference types</b></p>
               <div class="table-contents">
                  <table summary="Casting conversions to reference types" border="1">
                     <colgroup>
                        <col align="left">
                        <col align="center">
                        <col align="center">
                        <col align="center">
                        <col align="center">
                        <col align="center">
                        <col align="center">
                        <col>
                        <col>
                        <col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th align="left">To <span class="symbol">&#8594;</span></th>
                           <th align="center"><code class="literal">Byte</code></th>
                           <th align="center"><code class="literal">Short</code></th>
                           <th align="center"><code class="literal">Character</code></th>
                           <th align="center"><code class="literal">Integer</code></th>
                           <th align="center"><code class="literal">Long</code></th>
                           <th align="center"><code class="literal">Float</code></th>
                           <th align="center"><code class="literal">Double</code></th>
                           <th align="center"><code class="literal">Boolean</code></th>
                           <th align="center"><code class="literal">Object</code></th>
                        </tr>
                        <tr>
                           <th align="left">From <span class="symbol">&#8595;</span></th>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td align="left"><code class="literal">byte</code></td>
                           <td align="center"><span class="symbol">&#8853;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span>,<span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">short</code></td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span>,<span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">char</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span>,<span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">int</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span>,<span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">long</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span>,<span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">float</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span>,<span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">double</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span></td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span>,<span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">boolean</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8853;</span></td>
                           <td align="center"><span class="symbol">&#8853;</span>,<span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Byte</code></td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Short</code></td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Character</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Integer</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Long</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Float</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Double</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Boolean</code></td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center">-</td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                           <td align="center"><span class="symbol">&#8657;</span></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Object</code></td>
                           <td align="center"><span class="symbol">&#8659;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span></td>
                           <td align="center"><span class="symbol">&#8659;</span></td>
                           <td align="center"><span class="symbol">&#8776;</span></td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </div><br class="table-break"><div class="section" title="5.5.1.&nbsp;Reference Type Casting">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.5.1"></a>5.5.1.&nbsp;Reference Type Casting
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.5.1-100"></a>Given a
                  compile-time reference type <span class="type">S</span> (source) and a compile-time reference
                  type <span class="type">T</span> (target), a casting conversion exists from <span class="type">S</span> to <span class="type">T</span> if no
                  compile-time errors occur due to the following rules.
               </p>
               <p class="norm-static"><a name="jls-5.5.1-200"></a>If <span class="type">S</span> is
                  a class type:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.1-200-A"></a>If
                                 <span class="type">T</span> is a class type, then either |<span class="type">S</span>| <code class="literal">&lt;:</code> |<span class="type">T</span>|, or |<span class="type">T</span>|
                                 <code class="literal">&lt;:</code> |<span class="type">S</span>|. Otherwise, a compile-time error occurs.
                        </p>
                        <p class="norm-error"><a name="jls-5.5.1-200-A.1"></a>Furthermore, if there exists a
                                 supertype <span class="type">X</span> of <span class="type">T</span>, and a supertype <span class="type">Y</span> of <span class="type">S</span>, such that both
                                 <span class="type">X</span> and <span class="type">Y</span> are provably distinct parameterized types
                                 (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>), and that the erasures of <span class="type">X</span> and
                                 <span class="type">Y</span> are the same, a compile-time error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.1-200-B"></a>If
                               <span class="type">T</span> is an interface type:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-5.5.1-200-B-A"></a>If <span class="type">S</span> is not a <code class="literal">final</code> class
                                              (<a class="xref" href="jls-8.html#jls-8.1.1" title="8.1.1.&nbsp;Class Modifiers">&sect;8.1.1</a>), then, if there exists a
                                              supertype <span class="type">X</span> of <span class="type">T</span>, and a supertype <span class="type">Y</span> of <span class="type">S</span>, such that
                                              both <span class="type">X</span> and <span class="type">Y</span> are provably distinct parameterized types,
                                              and that the erasures of <span class="type">X</span> and <span class="type">Y</span> are the same, a
                                              compile-time error occurs.
                                 </p>
                                 <p class="norm-static"><a name="jls-5.5.1-200-B-A.1"></a>Otherwise, the cast is always
                                              legal at compile time (because even if <span class="type">S</span> does not
                                              implement <span class="type">T</span>, a subclass of <span class="type">S</span> might).
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-5.5.1-200-B-B"></a>If <span class="type">S</span> is a <code class="literal">final</code> class
                                              (<a class="xref" href="jls-8.html#jls-8.1.1" title="8.1.1.&nbsp;Class Modifiers">&sect;8.1.1</a>), then <span class="type">S</span> must implement <span class="type">T</span>,
                                              or a compile-time error occurs.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.1-200-C"></a>If
                               <span class="type">T</span> is a type variable, then this algorithm is applied
                               recursively, using the upper bound of <span class="type">T</span> in place of <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.1-200-D"></a>If
                               <span class="type">T</span> is an array type, then <span class="type">S</span> must be the class <code class="literal">Object</code>, or a
                               compile-time error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.1-200-E"></a>If <span class="type">T</span> is an
                                 intersection type, <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span>, then it is a
                                 compile-time error if there exists a <span class="type">T<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                 <span class="emphasis"><em>n</em></span>) such that <span class="type">S</span> cannot be cast to <span class="type">T<sub>i</sub></span> by this
                                 algorithm. That is, the success of the cast is determined by the
                                 most restrictive component of the intersection type.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-5.5.1-300"></a>If <span class="type">S</span> is an interface
                  type:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.1-300-A"></a>
                                 If <span class="type">T</span> is an array type, then <span class="type">S</span> must be the type <code class="literal">java.io.Serializable</code> or
                                 <code class="literal">Cloneable</code> (the only interfaces implemented by
                                 arrays), or a compile-time error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.1-300-B"></a>
                                 If <span class="type">T</span> is a class or interface type that is not <code class="literal">final</code>
                                 (<a class="xref" href="jls-8.html#jls-8.1.1" title="8.1.1.&nbsp;Class Modifiers">&sect;8.1.1</a>), then if there exists a supertype
                                 <span class="type">X</span> of <span class="type">T</span>, and a supertype <span class="type">Y</span> of <span class="type">S</span>, such that both <span class="type">X</span> and
                                 <span class="type">Y</span> are provably distinct parameterized types, and that the
                                 erasures of <span class="type">X</span> and <span class="type">Y</span> are the same, a compile-time error
                                 occurs.
                        </p>
                        <p class="norm-static"><a name="jls-5.5.1-300-B.1"></a>
                                 Otherwise, the cast is always legal at compile time (because
                                 even if <span class="type">T</span> does not implement <span class="type">S</span>, a subclass of <span class="type">T</span>
                                 might).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.1-300-C"></a>
                                 If <span class="type">T</span> is a class type that is <code class="literal">final</code>, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-5.5.1-300-C-A"></a>
                                    	  If <span class="type">S</span> is not a parameterized type or a raw type, then <span class="type">T</span>
                                              must implement <span class="type">S</span>,  or a compile-time error occurs.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-5.5.1-300-C-B"></a>Otherwise, <span class="type">S</span> is either a
                                            parameterized type that is an invocation of some generic type
                                            declaration <span class="type">G</span>, or a raw type corresponding to a generic type
                                            declaration <span class="type">G</span>. Then there must exist a supertype <span class="type">X</span> of <span class="type">T</span>,
                                            such that <span class="type">X</span> is an invocation of <span class="type">G</span>, or a compile-time error
                                            occurs.
                                 </p>
                                 <p class="norm-error"><a name="jls-5.5.1-300-C-B.1"></a>
                                    	  Furthermore, if <span class="type">S</span> and <span class="type">X</span> are provably distinct
                                              parameterized types then a compile-time error occurs.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.1-300-D"></a>
                                 If <span class="type">T</span> is a type variable, then this algorithm is applied
                                 recursively, using the upper bound of <span class="type">T</span> in place of
                                 <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.1-300-E"></a>
                                 If <span class="type">T</span> is an intersection type, <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span>, then
                                 it is a compile-time error if there exists a <span class="type">T<sub>i</sub></span> (1 <span class="symbol">&#8804;</span>
                                 <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) such that <span class="type">S</span> cannot be cast to <span class="type">T<sub>i</sub></span> by
                                 this algorithm.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-5.5.1-400"></a>If <span class="type">S</span> is
                  a type variable, then this algorithm is applied recursively, using the
                  upper bound of <span class="type">S</span> in place of <span class="type">S</span>.
               </p>
               <p class="norm-static"><a name="jls-5.5.1-500"></a>If <span class="type">S</span> is an
                  intersection type <span class="type">A<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">A<sub>n</sub></span>, then it is a compile-time
                  error if there exists an <span class="type">A<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) such that
                  <span class="type">A<sub>i</sub></span> cannot be cast to <span class="type">T</span> by this algorithm. That is, the success of
                  the cast is determined by the most restrictive component of the
                  intersection type.
               </p>
               <p class="norm-static"><a name="jls-5.5.1-600"></a>If <span class="type">S</span> is
                  an array type <span class="type">SC</span><code class="literal">[]</code>, that is, an array of components of type
                  <span class="type">SC</span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.1-600-A"></a>If
                                 <span class="type">T</span> is a class type, then if <span class="type">T</span> is not <code class="literal">Object</code>, then a
                                 compile-time error occurs (because <code class="literal">Object</code> is the only class
                                 type to which arrays can be assigned).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.1-600-B"></a>If
                                 <span class="type">T</span> is an interface type, then a compile-time error occurs
                                 unless <span class="type">T</span> is the type <code class="literal">java.io.Serializable</code> or the type <code class="literal">Cloneable</code>
                                 (the only interfaces implemented by arrays).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.1-600-C"></a>If <span class="type">T</span> is
                                 a type variable, then this algorithm is applied recursively,
                                 using the upper bound of <span class="type">T</span> in place of <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.1-600-D"></a>If
                               <span class="type">T</span> is an array type <span class="type">TC</span><code class="literal">[]</code>, that is, an array of
                               components of type <span class="type">TC</span>, then a compile-time error occurs unless
                               one of the following is true:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-5.5.1-600-D-A"></a><span class="type">TC</span> and <span class="type">SC</span> are the same
                                            primitive type.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-5.5.1-600-D-B"></a><span class="type">TC</span> and <span class="type">SC</span> are reference types
                                            and type <span class="type">SC</span> can undergo casting conversion to <span class="type">TC</span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.1-600-E"></a>If <span class="type">T</span> is an
                                 intersection type, <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span>, then it is a
                                 compile-time error if there exists a <span class="type">T<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                 <span class="emphasis"><em>n</em></span>) such that <span class="type">S</span> cannot be cast to <span class="type">T<sub>i</sub></span> by this
                                 algorithm.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e7526"></a><p class="title"><b>Example&nbsp;5.5.1-1.&nbsp;Casting Conversion for Reference Types</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point { int x, y; }
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}
final class EndPoint extends Point {}

class Test {
    public static void main(String[] args) {
        Point p = new Point();
        ColoredPoint cp = new ColoredPoint();
        Colorable c;
        // The following may cause errors at run time because
        // we cannot be sure they will succeed; this possibility
        // is suggested by the casts:
        cp = (ColoredPoint)p;  // p might not reference an
                               // object which is a ColoredPoint
                               // or a subclass of ColoredPoint
        c = (Colorable)p;      // p might not be Colorable
        // The following are incorrect at compile time because
        // they can never succeed as explained in the text:
        Long l = (Long)p;            // compile-time error #1
        EndPoint e = new EndPoint();
        c = (Colorable)e;            // compile-time error #2
    }
}
</pre><p class="note">Here, the first compile-time error occurs because
                        the class types <code class="literal">Long</code> and <code class="literal">Point</code> are unrelated
                        (that is, they are not the same, and neither is a subclass of the
                        other), so a cast between them will always fail.
                     </p>
                     <p class="note">The second compile-time error occurs because a
                        variable of type <code class="literal">EndPoint</code> can never reference a
                        value that implements the interface <code class="literal">Colorable</code>. This
                        is because <code class="literal">EndPoint</code> is a <code class="literal">final</code> type, and a
                        variable of a <code class="literal">final</code> type always holds a value of the same run-time
                        type as its compile-time type. Therefore, the run-time type of
                        variable <code class="literal">e</code> must be exactly the
                        type <code class="literal">EndPoint</code>, and type <code class="literal">EndPoint</code>
                        does not implement <code class="literal">Colorable</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e7542"></a><p class="title"><b>Example&nbsp;5.5.1-2.&nbsp;Casting Conversion for Array Types</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
    public String toString() { return "("+x+","+y+")"; }
}
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    ColoredPoint(int x, int y, int color) {
        super(x, y); setColor(color);
    }
    public void setColor(int color) { this.color = color; }
    public String toString() {
        return super.toString() + "@" + color;
    }
}

class Test {
    public static void main(String[] args) {
        Point[] pa = new ColoredPoint[4];
        pa[0] = new ColoredPoint(2, 2, 12);
        pa[1] = new ColoredPoint(4, 5, 24);
        ColoredPoint[] cpa = (ColoredPoint[])pa;
        System.out.print("cpa: {");
        for (int i = 0; i &lt; cpa.length; i++)
            System.out.print((i == 0 ? " " : ", ") + cpa[i]);
        System.out.println(" }");
    }
}
</pre><p class="note">This program compiles without errors and produces
                        the output:
                     </p><pre class="screen">
cpa: { (2,2)@12, (4,5)@24, null, null }
</pre></div>
               </div><br class="example-break"></div>
            <div class="section" title="5.5.2.&nbsp;Checked Casts and Unchecked Casts">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.5.2"></a>5.5.2.&nbsp;Checked Casts and Unchecked Casts
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.5.2-100"></a>A cast
                  from a type <span class="type">S</span> to a type <span class="type">T</span> is <span class="emphasis"><em>statically known to be
                        correct</em></span> if and only if <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>
                  (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>).
               </p>
               <p class="norm-static"><a name="jls-5.5.2-200"></a>A cast
                  from a type <span class="type">S</span> to a parameterized type (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>)
                  <span class="type">T</span> is <span class="emphasis"><em>unchecked</em></span> unless at least one of the
                  following is true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.2-200-A"></a>
                                 <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.2-200-B"></a>
                                 All of the type arguments (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>) of <span class="type">T</span>
                                 are unbounded wildcards
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.2-200-C"></a>
                                 <span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">S</span> and <span class="type">S</span> has no subtype <span class="type">X</span> other than
                                 <span class="type">T</span> where the type arguments of <span class="type">X</span> are not contained in the
                                 type arguments of <span class="type">T</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-5.5.2-300"></a>A cast from
                  a type <span class="type">S</span> to a type variable <span class="type">T</span> is unchecked unless <span class="type">S</span>
                  <code class="literal">&lt;:</code> <span class="type">T</span>.
               </p>
               <p class="norm-static"><a name="jls-5.5.2-310"></a>A cast from a type
                  <span class="type">S</span> to an intersection type <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span> is unchecked if
                  there exists a <span class="type">T<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) such that a cast
                  from <span class="type">S</span> to <span class="type">T<sub>i</sub></span> is unchecked.
               </p>
               <p class="norm-static"><a name="jls-5.5.2-400"></a>An unchecked
                  cast from <span class="type">S</span> to a non-intersection type <span class="type">T</span> is <span class="emphasis"><em>completely
                        unchecked</em></span> if the cast from |<span class="type">S</span>| to |<span class="type">T</span>| is statically
                  known to be correct. Otherwise, it is <span class="emphasis"><em>partially
                        unchecked</em></span>.
               </p>
               <p class="norm-static"><a name="jls-5.5.2-410"></a>An unchecked cast
                  from <span class="type">S</span> to an intersection type <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span>
                  is <span class="emphasis"><em>completely unchecked</em></span> if, for all <span class="emphasis"><em>i</em></span> (1
                  <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), a cast from <span class="type">S</span> to <span class="type">T<sub>i</sub></span> is either
                  statically known to be correct or completely unchecked. Otherwise, it
                  is <span class="emphasis"><em>partially unchecked</em></span>.
               </p>
               <p class="norm-warning"><a name="jls-5.5.2-500"></a>An
                  unchecked cast causes a compile-time unchecked warning, unless
                  suppressed by the <code class="literal">SuppressWarnings</code> annotation
                  (<a class="xref" href="jls-9.html#jls-9.6.4.5" title="9.6.4.5.&nbsp;@SuppressWarnings">&sect;9.6.4.5</a>).
               </p>
               <p class="norm-static"><a name="jls-5.5.2-600"></a>A cast is
                  <span class="emphasis"><em>checked</em></span> if it is not statically known to be
                  correct and it is not unchecked.
               </p>
               <p class="norm-static"><a name="jls-5.5.2-700"></a>If a cast
                  to a reference type is not a compile-time error, there are several
                  cases:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.2-700-A"></a>The
                                 cast is statically known to be correct.
                        </p>
                        <p class="norm-dynamic"><a name="jls-5.5.2-700-A.1"></a>No run-time action is performed for
                                 such a cast.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.2-700-B"></a>The
                                 cast is a completely unchecked cast.
                        </p>
                        <p class="norm-dynamic"><a name="jls-5.5.2-700-B.1"></a>No run-time action is performed for
                                 such a cast.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.2-700-C"></a>The cast is
                                 a partially unchecked or checked cast to an intersection
                                 type.
                        </p>
                        <p class="norm-dynamic"><a name="jls-5.5.2-700-C.1"></a>Where the
                                 intersection type is <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span>, then for all
                                 <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), any run-time check
                                 required for a cast from <span class="type">S</span> to <span class="type">T<sub>i</sub></span> is also required for the
                                 cast to the intersection type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.2-700-D"></a>The cast
                                 is a partially unchecked cast to a non-intersection type.
                        </p>
                        <p class="norm-dynamic"><a name="jls-5.5.2-700-D.1"></a>
                                 Such a cast requires a run-time validity check. The check is
                                 performed as if the cast had been a checked cast between |<span class="type">S</span>|
                                 and |<span class="type">T</span>|, as described below.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.5.2-700-E"></a>The cast
                                 is a checked cast to a non-intersection type.
                        </p>
                        <p class="norm-dynamic"><a name="jls-5.5.2-700-E.1"></a>Such a cast requires a run-time
                                 validity check. If the value at run time is <code class="literal">null</code>, then the
                                 cast is allowed. Otherwise, let <span class="type">R</span> be the class of the object
                                 referred to by the run-time reference value, and let <span class="type">T</span> be the
                                 erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the type named in the
                                 cast operator. A cast conversion must check, at run time, that
                                 the class <span class="type">R</span> is assignment compatible with the type <span class="type">T</span>, via
                                 the algorithm in <a class="xref" href="jls-5.html#jls-5.5.3" title="5.5.3.&nbsp;Checked Casts at Run Time">&sect;5.5.3</a>.
                        </p>
                        <p class="norm-static"><a name="jls-5.5.2-700-E.2"></a>Note that <span class="type">R</span> cannot be an interface
                                 when these rules are first applied for any given cast, but <span class="type">R</span>
                                 may be an interface if the rules are applied recursively because
                                 the run-time reference value may refer to an array whose element
                                 type is an interface type.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="5.5.3.&nbsp;Checked Casts at Run Time">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.5.3"></a>5.5.3.&nbsp;Checked Casts at Run Time
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-5.5.3-100"></a>Here is
                  the algorithm to check whether the run-time type <span class="type">R</span> of an object is
                  assignment compatible with the type <span class="type">T</span> which is the erasure
                  (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the type named in the cast operator. If
                  a run-time exception is thrown, it is a <code class="literal">ClassCastException</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-5.5.3-200"></a>If <span class="type">R</span> is
                  an ordinary class (not an array class):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.3-200-A"></a>If
                                 <span class="type">T</span> is a class type, then <span class="type">R</span> must be either the same class
                                 (<a class="xref" href="jls-4.html#jls-4.3.4" title="4.3.4.&nbsp;When Reference Types Are the Same">&sect;4.3.4</a>) as <span class="type">T</span> or a subclass of <span class="type">T</span>, or a
                                 run-time exception is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.3-200-B"></a>If
                                 <span class="type">T</span> is an interface type, then <span class="type">R</span> must implement
                                 (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>) interface <span class="type">T</span>, or a run-time
                                 exception is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.3-200-C"></a>If
                                 <span class="type">T</span> is an array type, then a run-time exception is
                                 thrown.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.5.3-300"></a>If <span class="type">R</span> is
                  an interface:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.3-300-A"></a>If
                                 <span class="type">T</span> is a class type, then <span class="type">T</span> must be <code class="literal">Object</code>
                                 (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>), or a run-time exception is
                                 thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.3-300-B"></a>If
                                 <span class="type">T</span> is an interface type, then <span class="type">R</span> must be either the same
                                 interface as <span class="type">T</span> or a subinterface of <span class="type">T</span>, or a run-time
                                 exception is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.3-300-C"></a>If
                                 <span class="type">T</span> is an array type, then a run-time exception is
                                 thrown.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-5.5.3-400"></a>If <span class="type">R</span> is
                  a class representing an array type <span class="type">RC</span><code class="literal">[]</code>, that is, an array
                  of components of type <span class="type">RC</span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.3-400-A"></a>If
                                 <span class="type">T</span> is a class type, then <span class="type">T</span> must be <code class="literal">Object</code>
                                 (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>), or a run-time exception is
                                 thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.3-400-B"></a>If
                                 <span class="type">T</span> is an interface type, then a run-time exception is thrown
                                 unless <span class="type">T</span> is the type <code class="literal">java.io.Serializable</code> or the type <code class="literal">Cloneable</code>
                                 (the only interfaces implemented by arrays).
                        </p>
                        <p class="note">This case could slip past the compile-time
                                 checking if, for example, a reference to an array were stored in
                                 a variable of type <code class="literal">Object</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-5.5.3-400-C"></a>If
                                 <span class="type">T</span> is an array type <span class="type">TC</span><code class="literal">[]</code>, that is, an array of
                                 components of type <span class="type">TC</span>, then a run-time exception is thrown
                                 unless one of the following is true:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.5.3-400-C-A"></a><span class="type">TC</span> and <span class="type">RC</span> are the same
                                              primitive type.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-5.5.3-400-C-B"></a><span class="type">TC</span> and <span class="type">RC</span> are reference types
                                              and type <span class="type">RC</span> can be cast to <span class="type">TC</span> by a recursive application
                                              of these run-time rules for casting.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e7759"></a><p class="title"><b>Example&nbsp;5.5.3-1.&nbsp;Incompatible Types at Run Time</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point { int x, y; }
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}

class Test {
    public static void main(String[] args) {
        Point[] pa = new Point[100];

        // The following line will throw a ClassCastException:
        ColoredPoint[] cpa = (ColoredPoint[])pa;
        System.out.println(cpa[0]);
        int[] shortvec = new int[2];
        Object o = shortvec;

        // The following line will throw a ClassCastException:
        Colorable c = (Colorable)o;
        c.setColor(0);
    }
}
</pre><p class="note">This program uses casts to compile, but it throws
                        exceptions at run time, because the types are incompatible.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="5.6.&nbsp;Numeric Contexts">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-5.6"></a>5.6.&nbsp;Numeric Contexts
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-5.6-100"></a><span class="emphasis"><em>Numeric contexts</em></span> apply to the
               operands of an arithmetic operator.
            </p>
            <p class="norm-static"><a name="jls-5.6-110"></a>Numeric
               contexts allow the use of:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.6-110-A"></a>an
                              identity conversion (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.6-110-B"></a>a
                              widening primitive conversion (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-5.6-110-C"></a>an
                              unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) optionally
                              followed by a widening primitive conversion
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-5.6-200"></a>A 
               <span class="emphasis"><em>numeric promotion</em></span> is a process by which, given an
               arithmetic operator and its argument expressions, the arguments are
               converted to an inferred target type <span class="type">T</span>. <span class="type">T</span> is chosen during
               promotion such that each argument expression can be converted to <span class="type">T</span>
               and the arithmetic operation is defined for values of type <span class="type">T</span>.
            </p>
            <p class="norm"><a name="jls-5.6-300"></a>The two kinds of numeric
               promotion are unary numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>)
               and binary numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
            </p>
            <div class="section" title="5.6.1.&nbsp;Unary Numeric Promotion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.6.1"></a>5.6.1.&nbsp;Unary Numeric Promotion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.6.1-100"></a>Some
                  operators apply <span class="emphasis"><em>unary numeric promotion</em></span> to a
                  single operand, which must produce a value of a numeric type:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.6.1-100-A"></a>If
                                 the operand is of compile-time type <code class="literal">Byte</code>, <code class="literal">Short</code>,
                                 <code class="literal">Character</code>, or <code class="literal">Integer</code>, it is subjected to unboxing
                                 conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>). The result is then
                                 promoted to a value of type <code class="literal">int</code> by a widening primitive
                                 conversion (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>) or an identity
                                 conversion (<a class="xref" href="jls-5.html#jls-5.1.1" title="5.1.1.&nbsp;Identity Conversion">&sect;5.1.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.6.1-100-B"></a>Otherwise, if the operand is of
                                 compile-time type <code class="literal">Long</code>, <code class="literal">Float</code>, or <code class="literal">Double</code>, it is subjected
                                 to unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.6.1-100-C"></a>Otherwise, if the operand is of
                                 compile-time type <code class="literal">byte</code>, <code class="literal">short</code>, or <code class="literal">char</code>, it is promoted to
                                 a value of type <code class="literal">int</code> by a widening primitive conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.6.1-100-D"></a>Otherwise, a unary numeric operand
                                 remains as is and is not converted.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-5.6.1-200"></a>After the
                  conversion(s), if any, value set conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) is then applied.
               </p>
               <p class="norm"><a name="jls-5.6.1-300"></a>Unary numeric promotion is
                  performed on expressions in the following situations:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.1-300-A"></a>
                                 Each dimension expression in an array creation expression
                                 (<a class="xref" href="jls-15.html#jls-15.10.1" title="15.10.1.&nbsp;Array Creation Expressions">&sect;15.10.1</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.1-300-B"></a>
                                 The index expression in an array access expression
                                 (<a class="xref" href="jls-15.html#jls-15.10.3" title="15.10.3.&nbsp;Array Access Expressions">&sect;15.10.3</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.1-300-C"></a>
                                 The operand of a unary plus operator <code class="literal">+</code>
                                 (<a class="xref" href="jls-15.html#jls-15.15.3" title="15.15.3.&nbsp;Unary Plus Operator +">&sect;15.15.3</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.1-300-D"></a>
                                 The operand of a unary minus operator <code class="literal">-</code>
                               (<a class="xref" href="jls-15.html#jls-15.15.4" title="15.15.4.&nbsp;Unary Minus Operator -">&sect;15.15.4</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.1-300-E"></a>
                                 The operand of a bitwise complement operator <code class="literal">~</code>
                                 (<a class="xref" href="jls-15.html#jls-15.15.5" title="15.15.5.&nbsp;Bitwise Complement Operator ~">&sect;15.15.5</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.1-300-F"></a>Each operand,
                                 separately, of a shift operator <code class="literal">&lt;&lt;</code>, <code class="literal">&gt;&gt;</code>, or
                                 <code class="literal">&gt;&gt;&gt;</code> (<a class="xref" href="jls-15.html#jls-15.19" title="15.19.&nbsp;Shift Operators">&sect;15.19</a>).
                        </p>
                        <p class="norm"><a name="jls-5.6.1-300-F.1"></a>A <code class="literal">long</code> shift
                                 distance (right operand) does not promote the value being
                                 shifted (left operand) to <code class="literal">long</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e7848"></a><p class="title"><b>Example&nbsp;5.6.1-1.&nbsp;Unary Numeric Promotion</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        byte b = 2;
        int a[] = new int[b];  // dimension expression promotion
        char c = '\u0001';
        a[c] = 1;              // index expression promotion
        a[0] = -c;             // unary - promotion
        System.out.println("a: " + a[0] + "," + a[1]);
        b = -1;
        int i = ~b;            // bitwise complement promotion
        System.out.println("~0x" + Integer.toHexString(b)
                           + "==0x" + Integer.toHexString(i));
        i = b &lt;&lt; 4L;           // shift promotion (left operand)
        System.out.println("0x" + Integer.toHexString(b)
                           + "&lt;&lt;4L==0x" + Integer.toHexString(i));
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
a: -1,1
~0xffffffff==0x0
0xffffffff&lt;&lt;4L==0xfffffff0
</pre></div>
               </div><br class="example-break"></div>
            <div class="section" title="5.6.2.&nbsp;Binary Numeric Promotion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-5.6.2"></a>5.6.2.&nbsp;Binary Numeric Promotion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-5.6.2-100"></a>When an
                  operator applies <span class="emphasis"><em>binary numeric promotion</em></span> to a
                  pair of operands, each of which must denote a value that is
                  convertible to a numeric type, the following rules apply, in
                  order:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.6.2-100-A"></a>
                                 If any operand is of a reference type, it is subjected to
                                 unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-5.6.2-100-B"></a>
                                 Widening primitive conversion (<a class="xref" href="jls-5.html#jls-5.1.2" title="5.1.2.&nbsp;Widening Primitive Conversion">&sect;5.1.2</a>) is
                                 applied to convert either or both operands as specified by the
                                 following rules:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="disc">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-5.6.2-100-B-A"></a>
                                    	  If either operand is of type <code class="literal">double</code>, the other is
                                              converted to <code class="literal">double</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-5.6.2-100-B-B"></a>
                                    	  Otherwise, if either operand is of type <code class="literal">float</code>, the other
                                              is converted to <code class="literal">float</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-5.6.2-100-B-C"></a>
                                    	  Otherwise, if either operand is of type <code class="literal">long</code>, the other is
                                              converted to <code class="literal">long</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-5.6.2-100-B-D"></a>
                                    	  Otherwise, both operands are converted to type <code class="literal">int</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ol>
               </div>
               <p class="norm-static"><a name="jls-5.6.2-200"></a>After the
                  conversion(s), if any, value set conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) is then applied to each operand.
               </p>
               <p class="norm"><a name="jls-5.6.2-300"></a>Binary numeric promotion is
                  performed on the operands of certain operators:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.2-300-A"></a>The multiplicative
                               operators <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">%</code>
                               (<a class="xref" href="jls-15.html#jls-15.17" title="15.17.&nbsp;Multiplicative Operators">&sect;15.17</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.2-300-B"></a>The addition and
                               subtraction operators for numeric types <code class="literal">+</code> and <code class="literal">-</code>
                               (<a class="xref" href="jls-15.html#jls-15.18.2" title="15.18.2.&nbsp;Additive Operators (+ and -) for Numeric Types">&sect;15.18.2</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.2-300-C"></a>The numerical
                               comparison operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>,
                               <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code>
                               (<a class="xref" href="jls-15.html#jls-15.20.1" title="15.20.1.&nbsp;Numerical Comparison Operators <, <=, &gt;, and &gt;=">&sect;15.20.1</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.2-300-D"></a>The numerical equality
                               operators <code class="literal">==</code> and <code class="literal">!=</code>
                               (<a class="xref" href="jls-15.html#jls-15.21.1" title="15.21.1.&nbsp;Numerical Equality Operators == and !=">&sect;15.21.1</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.2-300-E"></a>The integer bitwise
                               operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code>
                               (<a class="xref" href="jls-15.html#jls-15.22.1" title="15.22.1.&nbsp;Integer Bitwise Operators &amp;, ^, and |">&sect;15.22.1</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-5.6.2-300-F"></a>In certain cases, the
                               conditional operator <code class="literal">? :</code> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e7917"></a><p class="title"><b>Example&nbsp;5.6.2-1.&nbsp;Binary Numeric Promotion</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        int i    = 0;
        float f  = 1.0f;
        double d = 2.0;
        // First int*float is promoted to float*float, then
        // float==double is promoted to double==double:
        if (i * f == d) System.out.println("oops");
		
        // A char&amp;byte is promoted to int&amp;int:
        byte b = 0x1f;
        char c = 'G';
        int control = c &amp; b;
        System.out.println(Integer.toHexString(control));
		
        // Here int:float is promoted to float:float:
        f = (b==0) ? i : 4.0f;
        System.out.println(1.0/f);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
7
0.25
</pre><p class="note">The example converts the ASCII
                        character <code class="literal">G</code> to the ASCII control-G (BEL), by
                        masking off all but the low 5 bits of the
                        character. The <code class="literal">7</code> is the numeric value of this
                        control character.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-4.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-6.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;Types, Values, and Variables&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;6.&nbsp;Names</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>