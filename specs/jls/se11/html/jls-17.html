
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;17.&nbsp;Threads and Locks</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">
      <link rel="next" href="jls-18.html" title="Chapter&nbsp;18.&nbsp;Type Inference">
      <link rel="copyright" href="spec-frontmatter.html" title="Legal Notice">
   <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="../../../../webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="https://docs.oracle.com/en/java/javase/11/">Java SE</a> &gt; <a href="../../../index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;17.&nbsp;Threads and Locks</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-16.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-18.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;17.&nbsp;Threads and Locks">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-17"></a>Chapter&nbsp;17.&nbsp;Threads and Locks
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-17.html#jls-17.1">17.1. Synchronization</a></span></dt>
               <dt><span class="section"><a href="jls-17.html#jls-17.2">17.2. Wait Sets and Notification</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-17.html#jls-17.2.1">17.2.1. Wait</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.2.2">17.2.2. Notification</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.2.3">17.2.3. Interruptions</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.2.4">17.2.4. Interactions of Waits, Notification, and Interruption</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-17.html#jls-17.3">17.3. Sleep and Yield</a></span></dt>
               <dt><span class="section"><a href="jls-17.html#jls-17.4">17.4. Memory Model</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-17.html#jls-17.4.1">17.4.1. Shared Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.4.2">17.4.2. Actions</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.4.3">17.4.3. Programs and Program Order</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.4.4">17.4.4. Synchronization Order</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.4.5">17.4.5. Happens-before Order</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.4.6">17.4.6. Executions</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.4.7">17.4.7. Well-Formed Executions</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.4.8">17.4.8. Executions and Causality Requirements</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.4.9">17.4.9. Observable Behavior and Nonterminating Executions</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-17.html#jls-17.5">17.5. <code class="literal">final</code> Field Semantics</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-17.html#jls-17.5.1">17.5.1. Semantics of <code class="literal">final</code> Fields</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.5.2">17.5.2. Reading <code class="literal">final</code> Fields During Construction</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.5.3">17.5.3. Subsequent Modification of <code class="literal">final</code> Fields</a></span></dt>
                     <dt><span class="section"><a href="jls-17.html#jls-17.5.4">17.5.4. Write-Protected Fields</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-17.html#jls-17.6">17.6. Word Tearing</a></span></dt>
               <dt><span class="section"><a href="jls-17.html#jls-17.7">17.7. Non-Atomic Treatment of <code class="literal">double</code> and <code class="literal">long</code></a></span></dt>
            </dl>
         </div>
         <p class="norm"><a name="jls-17-100"></a>While most of the discussion in
            the preceding chapters is concerned only with the behavior of code as
            executed a single statement or expression at a time, that is, by a
            single <span class="emphasis"><em>thread</em></span>, the Java Virtual Machine can support many threads
            of execution at once. These threads independently execute code that
            operates on values and objects residing in a shared main
            memory. Threads may be supported by having many hardware processors,
            by time-slicing a single hardware processor, or by time-slicing many
            hardware processors.
         </p>
         <p class="norm"><a name="jls-17-110"></a>Threads are represented by the
            <code class="literal">Thread</code> class. The only way for a user to create a thread is to
            create an object of this class; each thread is associated with such an
            object. A thread will start when the <code class="literal">start()</code> method
            is invoked on the corresponding <code class="literal">Thread</code> object.
         </p>
         <p class="norm"><a name="jls-17-120"></a>The behavior of threads,
            particularly when not correctly synchronized, can be confusing and
            counterintuitive. This chapter describes the semantics of
            multithreaded programs; it includes rules for which values may be seen
            by a read of shared memory that is updated by multiple threads. As the
            specification is similar to the <span class="emphasis"><em>memory models</em></span> for
            different hardware architectures, these semantics are known as
            the <span class="emphasis"><em>Java programming language memory model</em></span>. When no confusion
            can arise, we will simply refer to these rules as "the memory
            model".
         </p>
         <p class="norm"><a name="jls-17-130"></a>These semantics do not prescribe
            how a multithreaded program should be executed. Rather, they describe
            the behaviors that multithreaded programs are allowed to exhibit. Any
            execution strategy that generates only allowed behaviors is an
            acceptable execution strategy. 
         </p>
         <div class="section" title="17.1.&nbsp;Synchronization">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-17.1"></a>17.1.&nbsp;Synchronization
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-17.1-100"></a>The Java programming language provides
               multiple mechanisms for communicating between threads. The most basic
               of these methods is <span class="emphasis"><em>synchronization</em></span>, which is
               implemented using <span class="emphasis"><em>monitors</em></span>. Each object in Java
               is associated with a monitor, which a thread
               can <span class="emphasis"><em>lock</em></span> or <span class="emphasis"><em>unlock</em></span>. Only one
               thread at a time may hold a lock on a monitor. Any other threads
               attempting to lock that monitor are blocked until they can obtain a
               lock on that monitor. A thread <span class="emphasis"><em>t</em></span> may lock a particular monitor
               multiple times; each unlock reverses the effect of one lock
               operation.
            </p>
            <p class="norm"><a name="jls-17.1-110"></a>The <code class="literal">synchronized</code> statement
               (<a class="xref" href="jls-14.html#jls-14.19" title="14.19.&nbsp;The synchronized Statement">&sect;14.19</a>) computes a reference to an object; it
               then attempts to perform a lock action on that object's monitor and
               does not proceed further until the lock action has successfully
               completed. After the lock action has been performed, the body of the
               <code class="literal">synchronized</code> statement is executed. If execution of the body is ever
               completed, either normally or abruptly, an unlock action is
               automatically performed on that same monitor.
            </p>
            <p class="norm"><a name="jls-17.1-120"></a>A <code class="literal">synchronized</code> method
               (<a class="xref" href="jls-8.html#jls-8.4.3.6" title="8.4.3.6.&nbsp;synchronized Methods">&sect;8.4.3.6</a>) automatically performs a lock action
               when it is invoked; its body is not executed until the lock action has
               successfully completed. If the method is an instance method, it locks
               the monitor associated with the instance for which it was invoked
               (that is, the object that will be known as <code class="literal">this</code> during execution of
               the body of the method). If the method is <code class="literal">static</code>, it locks the
               monitor associated with the <code class="literal">Class</code> object that represents the class
               in which the method is defined. If execution of the method's body is
               ever completed, either normally or abruptly, an unlock action is
               automatically performed on that same monitor.
            </p>
            <p class="norm"><a name="jls-17.1-130"></a>The Java programming language neither
               prevents nor requires detection of deadlock conditions. Programs where
               threads hold (directly or indirectly) locks on multiple objects should
               use conventional techniques for deadlock avoidance, creating
               higher-level locking primitives that do not deadlock, if
               necessary.
            </p>
            <p class="norm"><a name="jls-17.1-140"></a>Other mechanisms, such as
               reads and writes of <code class="literal">volatile</code> variables and the use of classes in
               the <code class="literal">java.util.concurrent</code> package, provide
               alternative ways of synchronization.
            </p>
         </div>
         <div class="section" title="17.2.&nbsp;Wait Sets and Notification">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-17.2"></a>17.2.&nbsp;Wait Sets and Notification
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-17.2-100"></a>Every object, in addition to
               having an associated monitor, has an associated <span class="emphasis"><em>wait
                     set</em></span>. A wait set is a set of threads.
            </p>
            <p class="norm"><a name="jls-17.2-110"></a>When an object is first
               created, its wait set is empty. Elementary actions that add threads to
               and remove threads from wait sets are atomic. Wait sets are
               manipulated solely through the methods
               <code class="literal">Object</code><code class="literal">.</code><code class="literal">wait</code>,
               <code class="literal">Object</code><code class="literal">.</code><code class="literal">notify</code>, and
               <code class="literal">Object</code><code class="literal">.</code><code class="literal">notifyAll</code>.
            </p>
            <p class="norm"><a name="jls-17.2-120"></a>Wait set manipulations can
               also be affected by the interruption status of a thread, and by the
               <code class="literal">Thread</code> class's methods dealing with interruption. Additionally, the
               <code class="literal">Thread</code> class's methods for sleeping and joining other threads have
               properties derived from those of wait and notification actions.
            </p>
            <div class="section" title="17.2.1.&nbsp;Wait">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.2.1"></a>17.2.1.&nbsp;Wait
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.2.1-100"></a><span class="emphasis"><em>Wait
                        actions</em></span> occur upon invocation of <code class="literal">wait()</code>,
                  or the timed forms <code class="literal">wait(long millisecs)</code>
                  and <code class="literal">wait(long millisecs, int nanosecs)</code>.
               </p>
               <p class="note">A call of <code class="literal">wait(long millisecs)</code>
                  with a parameter of zero, or a call of <code class="literal">wait(long millisecs,
                     int nanosecs)</code> with two zero parameters, is equivalent to an
                  invocation of <code class="literal">wait()</code>.
               </p>
               <p class="norm"><a name="jls-17.2.1-110"></a>A thread <span class="emphasis"><em>returns
                        normally</em></span> from a wait if it returns without throwing an
                  <code class="literal">InterruptedException</code>.
               </p>
               <p class="norm"><a name="jls-17.2.1-120"></a>Let thread <span class="emphasis"><em>t</em></span> be the thread
                  executing the <code class="literal">wait</code> method on object <span class="emphasis"><em>m</em></span>, and let
                  <span class="emphasis"><em>n</em></span> be the number of lock actions by <span class="emphasis"><em>t</em></span> on <span class="emphasis"><em>m</em></span> that have not been
                  matched by unlock actions. One of the following actions occurs:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.1-120-A"></a>If <span class="emphasis"><em>n</em></span> is zero (i.e.,
                                 thread <span class="emphasis"><em>t</em></span> does not already possess the lock for target <span class="emphasis"><em>m</em></span>),
                                 then an <code class="literal">IllegalMonitorStateException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.1-120-B"></a>If this is a timed
                                 wait and the <code class="literal">nanosecs</code> argument is not in the
                                 range of <code class="literal">0-999999</code> or
                                 the <code class="literal">millisecs</code> argument is negative, then an
                                 <code class="literal">IllegalArgumentException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.1-120-C"></a>If thread <span class="emphasis"><em>t</em></span> is
                                 interrupted, then an <code class="literal">InterruptedException</code> is thrown and <span class="emphasis"><em>t</em></span>'s interruption
                                 status is set to false.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.1-120-D"></a>Otherwise, the
                                 following sequence occurs:
                        </p>
                        <div class="orderedlist">
                           <ol class="orderedlist" type="1">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.2.1-120-D-1"></a>Thread <span class="emphasis"><em>t</em></span> is
                                              added to the wait set of object <span class="emphasis"><em>m</em></span>, and performs <span class="emphasis"><em>n</em></span> unlock
                                              actions on <span class="emphasis"><em>m</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.2.1-120-D-2"></a>Thread <span class="emphasis"><em>t</em></span> does
                                    	  not execute any further instructions until it has been
                                    	  removed from <span class="emphasis"><em>m</em></span>'s wait set. The thread may be removed from
                                    	  the wait set due to any one of the following actions, and
                                    	  will resume sometime afterward:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="circle">
                                       <li class="listitem">
                                          <p class="norm"><a name="jls-17.2.1-120-D-2-A"></a>A <code class="literal">notify</code>
                                                           action being performed on <span class="emphasis"><em>m</em></span> in which <span class="emphasis"><em>t</em></span> is selected
                                                           for removal from the wait set.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm"><a name="jls-17.2.1-120-D-2-B"></a>A <code class="literal">notifyAll</code>
                                             	      action being performed on <span class="emphasis"><em>m</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm"><a name="jls-17.2.1-120-D-2-C"></a>An <code class="literal">interrupt</code>
                                             	      action being performed on <span class="emphasis"><em>t</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm"><a name="jls-17.2.1-120-D-2-D"></a>If this is
                                             	      a timed wait, an internal action removing <span class="emphasis"><em>t</em></span> from <span class="emphasis"><em>m</em></span>'s
                                             	      wait set that occurs after at
                                             	      least <code class="literal">millisecs</code> milliseconds
                                             	      plus <code class="literal">nanosecs</code> nanoseconds elapse
                                             	      since the beginning of this wait action.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm"><a name="jls-17.2.1-130-D-2-E"></a>An
                                             	      internal action by the implementation. Implementations
                                             	      are permitted, although not encouraged, to perform
                                             	      "spurious wake-ups", that is, to remove threads from
                                             	      wait sets and thus enable resumption without explicit
                                             	      instructions to do so.
                                          </p>
                                          <p class="note">Notice that this provision necessitates
                                             	      the Java coding practice of
                                             	      using <code class="literal">wait</code> only within loops that
                                             	      terminate only when some logical condition that the
                                             	      thread is waiting for holds.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                                 <p class="norm"><a name="jls-17.2.1-120-D-2.1"></a>Each thread
                                    	  must determine an order over the events that could cause it
                                    	  to be removed from a wait set. That order does not have to
                                    	  be consistent with other orderings, but the thread must
                                    	  behave as though those events occurred in that order.
                                 </p>
                                 <p class="norm"><a name="jls-17.2.1-120-D-2.2"></a>For example,
                                    	  if a thread <span class="emphasis"><em>t</em></span> is in the wait set for <span class="emphasis"><em>m</em></span>, and then both an
                                    	  interrupt of <span class="emphasis"><em>t</em></span> and a notification of <span class="emphasis"><em>m</em></span> occur, there must
                                    	  be an order over these events. If the interrupt is deemed to
                                    	  have occurred first, then <span class="emphasis"><em>t</em></span> will eventually return
                                    	  from <code class="literal">wait</code> by throwing <code class="literal">InterruptedException</code>, and some
                                    	  other thread in the wait set for <span class="emphasis"><em>m</em></span> (if any exist at the
                                    	  time of the notification) must receive the notification. If
                                    	  the notification is deemed to have occurred first, then <span class="emphasis"><em>t</em></span>
                                    	  will eventually return normally from <code class="literal">wait</code>
                                    	  with an interrupt still pending.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.2.1-120-D-3"></a>Thread <span class="emphasis"><em>t</em></span>
                                    	  performs <span class="emphasis"><em>n</em></span> lock actions on <span class="emphasis"><em>m</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.2.1-120-D-4"></a>If thread <span class="emphasis"><em>t</em></span>
                                    	  was removed from <span class="emphasis"><em>m</em></span>'s wait set in step 2 due to an
                                    	  interrupt, then <span class="emphasis"><em>t</em></span>'s interruption status is set to false
                                    	  and the <code class="literal">wait</code> method throws <code class="literal">InterruptedException</code>.
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="17.2.2.&nbsp;Notification">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.2.2"></a>17.2.2.&nbsp;Notification
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.2.2-100"></a>Notification actions occur
                  upon invocation of methods <code class="literal">notify</code>
                  and <code class="literal">notifyAll</code>.
               </p>
               <p class="norm"><a name="jls-17.2.2-110"></a>Let thread <span class="emphasis"><em>t</em></span> be the thread
                  executing either of these methods on object <span class="emphasis"><em>m</em></span>, and let <span class="emphasis"><em>n</em></span> be the
                  number of lock actions by <span class="emphasis"><em>t</em></span> on <span class="emphasis"><em>m</em></span> that have not been matched by
                  unlock actions. One of the following actions occurs:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.2-110-A"></a>If <span class="emphasis"><em>n</em></span> is zero, then
                               an <code class="literal">IllegalMonitorStateException</code> is thrown.
                        </p>
                        <p class="norm"><a name="jls-17.2.2-110-A.1"></a>This is the case
                               where thread <span class="emphasis"><em>t</em></span> does not already possess the lock for target
                               <span class="emphasis"><em>m</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.2-110-B"></a>If <span class="emphasis"><em>n</em></span> is greater than
                               zero and this is a <code class="literal">notify</code> action, then if <span class="emphasis"><em>m</em></span>'s
                               wait set is not empty, a thread <span class="emphasis"><em>u</em></span> that is a member of <span class="emphasis"><em>m</em></span>'s
                               current wait set is selected and removed from the wait set.
                        </p>
                        <p class="norm"><a name="jls-17.2.2-110-B.1"></a>There is no
                               guarantee about which thread in the wait set is selected. This
                               removal from the wait set enables <span class="emphasis"><em>u</em></span>'s resumption in a wait
                               action. Notice, however, that <span class="emphasis"><em>u</em></span>'s lock actions upon resumption
                               cannot succeed until some time after <span class="emphasis"><em>t</em></span> fully unlocks the monitor
                               for <span class="emphasis"><em>m</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.2-110-C"></a>If <span class="emphasis"><em>n</em></span> is greater than
                               zero and this is a <code class="literal">notifyAll</code> action, then all
                               threads are removed from <span class="emphasis"><em>m</em></span>'s wait set, and thus resume.
                        </p>
                        <p class="norm"><a name="jls-17.2.2-110-C.1"></a>Notice, however,
                               that only one of them at a time will lock the monitor required
                               during the resumption of wait.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="17.2.3.&nbsp;Interruptions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.2.3"></a>17.2.3.&nbsp;Interruptions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.2.3-100"></a>Interruption actions occur
                  upon invocation of <code class="literal">Thread.interrupt</code>, as well as
                  methods defined to invoke it in turn, such as
                  <code class="literal">ThreadGroup.interrupt</code>.
               </p>
               <p class="norm"><a name="jls-17.2.3-110"></a>Let <span class="emphasis"><em>t</em></span> be the thread
                  invoking <span class="emphasis"><em>u</em></span><code class="literal">.interrupt</code>, for some thread <span class="emphasis"><em>u</em></span>, where
                  <span class="emphasis"><em>t</em></span> and <span class="emphasis"><em>u</em></span> may be the same. This action causes <span class="emphasis"><em>u</em></span>'s interruption
                  status to be set to true.
               </p>
               <p class="norm"><a name="jls-17.2.3-120"></a>Additionally, if there
                  exists some object <span class="emphasis"><em>m</em></span> whose wait set contains <span class="emphasis"><em>u</em></span>, then <span class="emphasis"><em>u</em></span> is
                  removed from <span class="emphasis"><em>m</em></span>'s wait set. This enables <span class="emphasis"><em>u</em></span> to resume in a wait
                  action, in which case this wait will, after re-locking <span class="emphasis"><em>m</em></span>'s monitor,
                  throw <code class="literal">InterruptedException</code>.
               </p>
               <p class="norm"><a name="jls-17.2.3-130"></a>Invocations
                  of <code class="literal">Thread.isInterrupted</code> can determine a thread's
                  interruption status. The <code class="literal">static</code>
                  method <code class="literal">Thread.interrupted</code> may be invoked by a
                  thread to observe and clear its own interruption status.
               </p>
            </div>
            <div class="section" title="17.2.4.&nbsp;Interactions of Waits, Notification, and Interruption">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.2.4"></a>17.2.4.&nbsp;Interactions of Waits, Notification, and Interruption
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.2.4-100"></a>The above specifications
                  allow us to determine several properties having to do with the
                  interaction of waits, notification, and interruption.
               </p>
               <p class="norm"><a name="jls-17.2.4-110"></a>If a thread is both notified
                  and interrupted while waiting, it may either:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.4-110-A"></a>return normally
                               from <code class="literal">wait</code>, while still having a pending
                               interrupt (in other words, a call
                               to <code class="literal">Thread.interrupted</code> would return true)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.4-110-B"></a>return
                               from <code class="literal">wait</code> by throwing
                               an <code class="literal">InterruptedException</code></p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.2.4-120"></a>The thread may not reset its
                  interrupt status and return normally from the call
                  to <code class="literal">wait</code>.
               </p>
               <p class="norm"><a name="jls-17.2.4-200"></a>Similarly, notifications
                  cannot be lost due to interrupts. Assume that a set <span class="emphasis"><em>s</em></span> of threads is
                  in the wait set of an object <span class="emphasis"><em>m</em></span>, and another thread performs
                  a <code class="literal">notify</code> on <span class="emphasis"><em>m</em></span>. Then either:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.4-200-A"></a>at least one thread in
                               <span class="emphasis"><em>s</em></span> must return normally from <code class="literal">wait</code>, or
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.2.4-200-B"></a>all of the threads in
                               <span class="emphasis"><em>s</em></span> must exit <code class="literal">wait</code> by
                               throwing <code class="literal">InterruptedException</code></p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.2.4-210"></a>Note that if a thread is
                  both interrupted and woken via <code class="literal">notify</code>, and that
                  thread returns from <code class="literal">wait</code> by throwing
                  an <code class="literal">InterruptedException</code>, then some other thread in
                  the wait set must be notified.
               </p>
            </div>
         </div>
         <div class="section" title="17.3.&nbsp;Sleep and Yield">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-17.3"></a>17.3.&nbsp;Sleep and Yield
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-17.3-100"></a><code class="literal">Thread.sleep</code> causes the
               currently executing thread to sleep (temporarily cease execution) for
               the specified duration, subject to the precision and accuracy of
               system timers and schedulers. The thread does not lose ownership of
               any monitors, and resumption of execution will depend on scheduling
               and the availability of processors on which to execute the
               thread.
            </p>
            <p class="norm"><a name="jls-17.3-110"></a>It is important to note that
               neither <code class="literal">Thread.sleep</code>
               nor <code class="literal">Thread.yield</code> have any synchronization
               semantics. In particular, the compiler does not have to flush writes
               cached in registers out to shared memory before a call
               to <code class="literal">Thread.sleep</code> or <code class="literal">Thread.yield</code>,
               nor does the compiler have to reload values cached in registers after
               a call to <code class="literal">Thread.sleep</code>
               or <code class="literal">Thread.yield</code>.
            </p>
            <div class="informalexample">
               <p class="note">For example, in the following (broken) code
                  fragment, assume that <code class="literal">this.done</code> is a
                  non-<code class="literal">volatile boolean</code> field:
               </p><pre class="screen">
while (!this.done)
    Thread.sleep(1000);
</pre><p class="note">The compiler is free to read the
                  field <code class="literal">this.done</code> just once, and reuse the cached
                  value in each execution of the loop. This would mean that the loop
                  would never terminate, even if another thread changed the value
                  of <code class="literal">this.done</code>.
               </p>
            </div>
         </div>
         <div class="section" title="17.4.&nbsp;Memory Model">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-17.4"></a>17.4.&nbsp;Memory Model
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-17.4-100"></a>A <span class="emphasis"><em>memory
                     model</em></span> describes, given a program and an execution trace of
               that program, whether the execution trace is a legal execution of the
               program. The Java programming language memory model works by examining each read in
               an execution trace and checking that the write observed by that read
               is valid according to certain rules.
            </p>
            <p class="norm"><a name="jls-17.4-110"></a>The memory model describes
               possible behaviors of a program. An implementation is free to produce
               any code it likes, as long as all resulting executions of a program
               produce a result that can be predicted by the memory model.
            </p>
            <p class="note">This provides a great deal of freedom for the
               implementor to perform a myriad of code transformations, including the
               reordering of actions and removal of unnecessary
               synchronization.
            </p>
            <div class="example"><a name="d5e34649"></a><p class="title"><b>Example&nbsp;17.4-1.&nbsp;Incorrectly Synchronized Programs May Exhibit Surprising Behavior</b></p>
               <div class="example-contents">
                  <p class="note">The semantics of the Java programming language allow compilers and
                     microprocessors to perform optimizations that can interact with
                     incorrectly synchronized code in ways that can produce behaviors that
                     seem paradoxical. Here are some examples of how incorrectly
                     synchronized programs may exhibit surprising behaviors.
                  </p>
                  <p class="note">Consider, for example, the example program traces
                     shown in <a class="xref" href="jls-17.html#jls-17.4-A" title="Table&nbsp;17.4-A.&nbsp;Surprising results caused by statement reordering - original code">Table&nbsp;17.4-A</a>. This program uses local
                     variables <code class="literal">r1</code> and <code class="literal">r2</code> and shared
                     variables <code class="literal">A</code>
                     and <code class="literal">B</code>. Initially, <code class="literal">A == B ==
                        0</code>.
                  </p>
                  <div class="table"><a name="jls-17.4-A"></a><p class="title"><b>Table&nbsp;17.4-A.&nbsp;Surprising results caused by statement reordering - original code</b></p>
                     <div class="table-contents">
                        <table summary="Surprising results caused by statement reordering - original code" border="1">
                           <colgroup>
                              <col>
                              <col>
                           </colgroup>
                           <thead>
                              <tr>
                                 <th>Thread 1</th>
                                 <th>Thread 2</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td>1: <code class="literal">r2 = A;</code></td>
                                 <td>3: <code class="literal">r1 = B;</code></td>
                              </tr>
                              <tr>
                                 <td>2: <code class="literal">B = 1;</code></td>
                                 <td>4: <code class="literal">A = 2;</code></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </div><br class="table-break"><p class="note">It may appear that the result <code class="literal">r2 ==
                        2</code> and <code class="literal">r1 == 1</code> is impossible. Intuitively,
                     either instruction 1 or instruction 3 should come first in an
                     execution. If instruction 1 comes first, it should not be able to see
                     the write at instruction 4. If instruction 3 comes first, it should
                     not be able to see the write at instruction 2.
                  </p>
                  <p class="note">If some execution exhibited this behavior, then we
                     would know that instruction 4 came before instruction 1, which came
                     before instruction 2, which came before instruction 3, which came
                     before instruction 4. This is, on the face of it, absurd.
                  </p>
                  <p class="note">However, compilers are allowed to reorder the
                     instructions in either thread, when this does not affect the execution
                     of that thread in isolation. If instruction 1 is reordered with
                     instruction 2, as shown in the trace in <a class="xref" href="jls-17.html#jls-17.4-B" title="Table&nbsp;17.4-B.&nbsp;Surprising results caused by statement reordering - valid compiler transformation">Table&nbsp;17.4-B</a>,
                     then it is easy to see how the result <code class="literal">r2 == 2</code>
                     and <code class="literal">r1 == 1</code> might occur.
                  </p>
                  <div class="table"><a name="jls-17.4-B"></a><p class="title"><b>Table&nbsp;17.4-B.&nbsp;Surprising results caused by statement reordering - valid compiler transformation</b></p>
                     <div class="table-contents">
                        <table summary="Surprising results caused by statement reordering - valid compiler transformation" border="1">
                           <colgroup>
                              <col>
                              <col>
                           </colgroup>
                           <thead>
                              <tr>
                                 <th>Thread 1</th>
                                 <th>Thread 2</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td><code class="literal">B = 1;</code></td>
                                 <td><code class="literal">r1 = B;</code></td>
                              </tr>
                              <tr>
                                 <td><code class="literal">r2 = A;</code></td>
                                 <td><code class="literal">A = 2;</code></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </div><br class="table-break"><p class="note">To some programmers, this behavior may seem
                     "broken". However, it should be noted that this code is improperly
                     synchronized:
                  </p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">there is a write in one thread,</p>
                        </li>
                        <li class="listitem">
                           <p class="note">a read of the same variable by another
                                  thread,
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">and the write and read are not ordered by
                                  synchronization.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">This situation is an example of a <span class="emphasis"><em>data
                           race</em></span> (<a class="xref" href="jls-17.html#jls-17.4.5" title="17.4.5.&nbsp;Happens-before Order">&sect;17.4.5</a>). When code contains a
                     data race, counterintuitive results are often possible.
                  </p>
                  <p class="note">Several mechanisms can produce the reordering in
                     <a class="xref" href="jls-17.html#jls-17.4-B" title="Table&nbsp;17.4-B.&nbsp;Surprising results caused by statement reordering - valid compiler transformation">Table&nbsp;17.4-B</a>. A Just-In-Time compiler in a Java Virtual Machine
                     implementation may rearrange code, or the processor. In addition, the
                     memory hierarchy of the architecture on which a Java Virtual Machine implementation
                     is run may make it appear as if code is being reordered. In this
                     chapter, we shall refer to anything that can reorder code as
                     a <span class="emphasis"><em>compiler</em></span>.
                  </p>
                  <p class="note">Another example of surprising results can be seen in
                     <a class="xref" href="jls-17.html#jls-17.4-C" title="Table&nbsp;17.4-C.&nbsp;Surprising results caused by forward substitution">Table&nbsp;17.4-C</a>. Initially, <code class="literal">p == q</code>
                     and <code class="literal">p.x == 0</code>. This program is also incorrectly
                     synchronized; it writes to shared memory without enforcing any
                     ordering between those writes.
                  </p>
                  <div class="table"><a name="jls-17.4-C"></a><p class="title"><b>Table&nbsp;17.4-C.&nbsp;Surprising results caused by forward substitution</b></p>
                     <div class="table-contents">
                        <table summary="Surprising results caused by forward substitution" border="1">
                           <colgroup>
                              <col>
                              <col>
                           </colgroup>
                           <thead>
                              <tr>
                                 <th>Thread 1</th>
                                 <th>Thread 2</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td><code class="literal">r1 = p;</code></td>
                                 <td><code class="literal">r6 = p;</code></td>
                              </tr>
                              <tr>
                                 <td><code class="literal">r2 = r1.x;</code></td>
                                 <td><code class="literal">r6.x = 3;</code></td>
                              </tr>
                              <tr>
                                 <td><code class="literal">r3 = q;</code></td>
                                 <td>&nbsp;</td>
                              </tr>
                              <tr>
                                 <td><code class="literal">r4 = r3.x;</code></td>
                                 <td>&nbsp;</td>
                              </tr>
                              <tr>
                                 <td><code class="literal">r5 = r1.x;</code></td>
                                 <td>&nbsp;</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </div><br class="table-break"><p class="note">One common compiler optimization involves having the
                     value read for <code class="literal">r2</code> reused for <code class="literal">r5</code>:
                     they are both reads of <code class="literal">r1.x</code> with no intervening
                     write. This situation is shown in <a class="xref" href="jls-17.html#jls-17.4-D" title="Table&nbsp;17.4-D.&nbsp;Surprising results caused by forward substitution">Table&nbsp;17.4-D</a>.
                  </p>
                  <div class="table"><a name="jls-17.4-D"></a><p class="title"><b>Table&nbsp;17.4-D.&nbsp;Surprising results caused by forward substitution</b></p>
                     <div class="table-contents">
                        <table summary="Surprising results caused by forward substitution" border="1">
                           <colgroup>
                              <col>
                              <col>
                           </colgroup>
                           <thead>
                              <tr>
                                 <th>Thread 1</th>
                                 <th>Thread 2</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td><code class="literal">r1 = p;</code></td>
                                 <td><code class="literal">r6 = p;</code></td>
                              </tr>
                              <tr>
                                 <td><code class="literal">r2 = r1.x;</code></td>
                                 <td><code class="literal">r6.x = 3;</code></td>
                              </tr>
                              <tr>
                                 <td><code class="literal">r3 = q;</code></td>
                                 <td>&nbsp;</td>
                              </tr>
                              <tr>
                                 <td><code class="literal">r4 = r3.x;</code></td>
                                 <td>&nbsp;</td>
                              </tr>
                              <tr>
                                 <td><code class="literal">r5 = r2;</code></td>
                                 <td>&nbsp;</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </div><br class="table-break"><p class="note">Now consider the case where the assignment
                     to <code class="literal">r6.x</code> in Thread 2 happens between the first read
                     of <code class="literal">r1.x</code> and the read of <code class="literal">r3.x</code> in
                     Thread 1. If the compiler decides to reuse the value
                     of <code class="literal">r2</code> for the <code class="literal">r5</code>,
                     then <code class="literal">r2</code> and <code class="literal">r5</code> will have the
                     value <code class="literal">0</code>, and <code class="literal">r4</code> will have the
                     value <code class="literal">3</code>. From the perspective of the programmer,
                     the value stored at <code class="literal">p.x</code> has changed
                     from <code class="literal">0</code> to <code class="literal">3</code> and then changed
                     back.
                  </p>
               </div>
            </div><br class="example-break"><p class="norm"><a name="jls-17.4-120"></a>The memory model determines
               what values can be read at every point in the program. The actions of
               each thread in isolation must behave as governed by the semantics of
               that thread, with the exception that the values seen by each read are
               determined by the memory model. When we refer to this, we say that the
               program obeys <span class="emphasis"><em>intra-thread semantics</em></span>.
               Intra-thread semantics are the semantics for single-threaded programs,
               and allow the complete prediction of the behavior of a thread based on
               the values seen by read actions within the thread. To determine if the
               actions of thread <span class="emphasis"><em>t</em></span> in an execution are legal, we simply evaluate
               the implementation of thread <span class="emphasis"><em>t</em></span> as it would be performed in a
               single-threaded context, as defined in the rest of this
               specification.
            </p>
            <p class="norm"><a name="jls-17.4-130"></a>Each time the evaluation of
               thread <span class="emphasis"><em>t</em></span> generates an inter-thread action, it must match the
               inter-thread action <span class="emphasis"><em>a</em></span> of <span class="emphasis"><em>t</em></span> that comes next in program order. If
               <span class="emphasis"><em>a</em></span> is a read, then further evaluation of <span class="emphasis"><em>t</em></span> uses the value seen by
               <span class="emphasis"><em>a</em></span> as determined by the memory model.
            </p>
            <p class="norm"><a name="jls-17.4-140"></a>This section provides the
               specification of the Java programming language memory model except for issues dealing
               with <code class="literal">final</code> fields, which are described in
               <a class="xref" href="jls-17.html#jls-17.5" title="17.5.&nbsp;final Field Semantics">&sect;17.5</a>.
            </p>
            <p class="note">The memory model specified herein is not
               fundamentally based in the object-oriented nature of the
               Java programming language. For conciseness and simplicity in our examples, we often
               exhibit code fragments without class or method definitions, or
               explicit dereferencing. Most examples consist of two or more threads
               containing statements with access to local variables, shared global
               variables, or instance fields of an object. We typically use variables
               names such as <code class="varname">r1</code> or <code class="varname">r2</code> to
               indicate variables local to a method or thread. Such variables are not
               accessible by other threads.
            </p>
            <div class="section" title="17.4.1.&nbsp;Shared Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.4.1"></a>17.4.1.&nbsp;Shared Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.4.1-100"></a>Memory that can be shared
                  between threads is called <span class="emphasis"><em>shared memory</em></span>
                  or <span class="emphasis"><em>heap memory</em></span>.
               </p>
               <p class="norm"><a name="jls-17.4.1-110"></a>All instance fields,
                  <code class="literal">static</code> fields, and array elements are stored in heap memory. In this
                  chapter, we use the term <span class="emphasis"><em>variable</em></span> to refer to
                  both fields and array elements.
               </p>
               <p class="norm"><a name="jls-17.4.1-120"></a>Local variables
                  (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>), formal method parameters
                  (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>), and exception handler parameters
                  (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>) are never shared between threads and are
                  unaffected by the memory model.
               </p>
               <p class="norm"><a name="jls-17.4.1-200"></a>Two accesses to (reads of or
                  writes to) the same variable are said to be 
                  <span class="emphasis"><em>conflicting</em></span> if at least one of the accesses is a
                  write.
               </p>
            </div>
            <div class="section" title="17.4.2.&nbsp;Actions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.4.2"></a>17.4.2.&nbsp;Actions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.4.2-100"></a>An <span class="emphasis"><em>inter-thread
                        action</em></span> is an action performed by one thread that can be
                  detected or directly influenced by another thread. There are several
                  kinds of inter-thread action that a program may perform:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.2-100-A"></a><span class="emphasis"><em>Read</em></span> (normal, or
                               non-volatile). Reading a variable.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.2-100-B"></a><span class="emphasis"><em>Write</em></span> (normal, or
                               non-volatile). Writing a variable.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.2-100-C"></a><span class="emphasis"><em>Synchronization
                                     actions</em></span>, which are:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.2-100-C-1"></a><span class="emphasis"><em>Volatile
                                          	read</em></span>. A volatile read of a variable.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.2-100-C-2"></a><span class="emphasis"><em>Volatile
                                          	write</em></span>. A volatile write of a variable.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.2-100-C-3"></a><span class="emphasis"><em>Lock</em></span>. Locking
                                    	a monitor
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.2-100-C-4"></a><span class="emphasis"><em>Unlock</em></span>. Unlocking
                                    	a monitor.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.2-100-C-5"></a>The (synthetic)
                                    	first and last action of a thread.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.2-100-C-6"></a>Actions that
                                    	start a thread or detect that a thread has terminated
                                    	(<a class="xref" href="jls-17.html#jls-17.4.4" title="17.4.4.&nbsp;Synchronization Order">&sect;17.4.4</a>).
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.2-100-D"></a><span class="emphasis"><em>External
                                     Actions</em></span>. An external action is an action that may be
                               observable outside of an execution, and has a result based on an
                               environment external to the execution.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.2-100-E"></a><span class="emphasis"><em>Thread
                                     divergence actions</em></span> (<a class="xref" href="jls-17.html#jls-17.4.9" title="17.4.9.&nbsp;Observable Behavior and Nonterminating Executions">&sect;17.4.9</a>). A
                               thread divergence action is only performed by a thread that is in
                               an infinite loop in which no memory, synchronization, or external
                               actions are performed. If a thread performs a thread divergence
                               action, it will be followed by an infinite number of thread
                               divergence actions.
                        </p>
                        <p class="note">Thread divergence actions are introduced to
                               model how a thread may cause all other threads to stall and fail
                               to make progress.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.4.2-110"></a>This specification is only
                  concerned with inter-thread actions. We do not need to concern
                  ourselves with intra-thread actions (e.g., adding two local variables
                  and storing the result in a third local variable). As previously
                  mentioned, all threads need to obey the correct intra-thread semantics
                  for Java programs. We will usually refer to inter-thread actions more
                  succinctly as simply <span class="emphasis"><em>actions</em></span>.
               </p>
               <p class="norm"><a name="jls-17.4.2-200"></a>An action <span class="emphasis"><em>a</em></span> is described
                  by a tuple &lt; <span class="emphasis"><em>t</em></span>, <span class="emphasis"><em>k</em></span>, <span class="emphasis"><em>v</em></span>, <span class="emphasis"><em>u</em></span> &gt;, comprising:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.2-200-A"></a><span class="emphasis"><em>t</em></span> - the thread
                               performing the action
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.2-200-B"></a><span class="emphasis"><em>k</em></span> - the kind of
                               action
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.2-200-C"></a><span class="emphasis"><em>v</em></span> - the variable or
                               monitor involved in the action.
                        </p>
                        <p class="norm"><a name="jls-17.4.2-200-C.1"></a>For lock actions,
                               <span class="emphasis"><em>v</em></span> is the monitor being locked; for unlock actions, <span class="emphasis"><em>v</em></span> is the
                               monitor being unlocked.
                        </p>
                        <p class="norm"><a name="jls-17.4.2-200-C.2"></a>If the action is a
                               (volatile or non-volatile) read, <span class="emphasis"><em>v</em></span> is the variable being
                               read.
                        </p>
                        <p class="norm"><a name="jls-17.4.2-200-C.3"></a>If the action is a
                               (volatile or non-volatile) write, <span class="emphasis"><em>v</em></span> is the variable being
                               written.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.2-200-D"></a><span class="emphasis"><em>u</em></span> - an arbitrary
                               unique identifier for the action
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.4.2-300"></a>An external action tuple
                  contains an additional component, which contains the results of the
                  external action as perceived by the thread performing the action. This
                  may be information as to the success or failure of the action, and any
                  values read by the action.
               </p>
               <p class="norm"><a name="jls-17.4.2-310"></a>Parameters to the external
                  action (e.g., which bytes are written to which socket) are not part of
                  the external action tuple. These parameters are set up by other
                  actions within the thread and can be determined by examining the
                  intra-thread semantics. They are not explicitly discussed in the
                  memory model.
               </p>
               <p class="norm"><a name="jls-17.4.2-320"></a>In non-terminating
                  executions, not all external actions are observable. Non-terminating
                  executions and observable actions are discussed in
                  <a class="xref" href="jls-17.html#jls-17.4.9" title="17.4.9.&nbsp;Observable Behavior and Nonterminating Executions">&sect;17.4.9</a>.
               </p>
            </div>
            <div class="section" title="17.4.3.&nbsp;Programs and Program Order">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.4.3"></a>17.4.3.&nbsp;Programs and Program Order
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.4.3-100"></a>Among all the inter-thread
                  actions performed by each thread <span class="emphasis"><em>t</em></span>, the <span class="emphasis"><em>program
                        order</em></span> of <span class="emphasis"><em>t</em></span> is a total order that reflects the order in
                  which these actions would be performed according to the intra-thread
                  semantics of <span class="emphasis"><em>t</em></span>.
               </p>
               <p class="norm"><a name="jls-17.4.3-110"></a>A set of actions
                  is <span class="emphasis"><em>sequentially consistent</em></span> if all actions occur
                  in a total order (the execution order) that is consistent with program
                  order, and furthermore, each read <span class="emphasis"><em>r</em></span> of a variable <span class="emphasis"><em>v</em></span> sees the value
                  written by the write <span class="emphasis"><em>w</em></span> to <span class="emphasis"><em>v</em></span> such that:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.3-110-A"></a><span class="emphasis"><em>w</em></span> comes before <span class="emphasis"><em>r</em></span>
                               in the execution order, and
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.3-110-B"></a>there is no other
                               write <span class="emphasis"><em>w</em></span>' such that <span class="emphasis"><em>w</em></span> comes before <span class="emphasis"><em>w</em></span>' and <span class="emphasis"><em>w</em></span>' comes before
                               <span class="emphasis"><em>r</em></span> in the execution order.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.4.3-120"></a>Sequential consistency is a
                  very strong guarantee that is made about visibility and ordering in an
                  execution of a program. Within a sequentially consistent execution,
                  there is a total order over all individual actions (such as reads and
                  writes) which is consistent with the order of the program, and each
                  individual action is atomic and is immediately visible to every
                  thread.
               </p>
               <p class="norm"><a name="jls-17.4.3-130"></a>If a program has no data
                  races, then all executions of the program will appear to be
                  sequentially consistent.
               </p>
               <p class="norm"><a name="jls-17.4.3-140"></a>Sequential consistency
                  and/or freedom from data races still allows errors arising from groups
                  of operations that need to be perceived atomically and are not.
               </p>
               <p class="note">If we were to use sequential consistency as our
                  memory model, many of the compiler and processor optimizations that we
                  have discussed would be illegal. For example, in the trace in
                  <a class="xref" href="jls-17.html#jls-17.4-C" title="Table&nbsp;17.4-C.&nbsp;Surprising results caused by forward substitution">Table&nbsp;17.4-C</a>, as soon as the write
                  of <code class="literal">3</code> to <code class="literal">p.x</code> occurred, subsequent
                  reads of that location would be required to see that value.
               </p>
            </div>
            <div class="section" title="17.4.4.&nbsp;Synchronization Order">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.4.4"></a>17.4.4.&nbsp;Synchronization Order
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.4.4-100"></a>Every execution has
                  a <span class="emphasis"><em>synchronization order</em></span>. A synchronization order
                  is a total order over all of the synchronization actions of an
                  execution. For each thread <span class="emphasis"><em>t</em></span>, the synchronization order of the
                  synchronization actions (<a class="xref" href="jls-17.html#jls-17.4.2" title="17.4.2.&nbsp;Actions">&sect;17.4.2</a>) in <span class="emphasis"><em>t</em></span> is
                  consistent with the program order (<a class="xref" href="jls-17.html#jls-17.4.3" title="17.4.3.&nbsp;Programs and Program Order">&sect;17.4.3</a>) of
                  <span class="emphasis"><em>t</em></span>.
               </p>
               <p class="norm"><a name="jls-17.4.4-110"></a>Synchronization actions
                  induce the <span class="emphasis"><em>synchronized-with</em></span> relation on actions,
                  defined as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.4-110-A"></a>An unlock action on
                               monitor <span class="emphasis"><em>m</em></span> <span class="emphasis"><em>synchronizes-with</em></span> all subsequent
                               lock actions on <span class="emphasis"><em>m</em></span> (where "subsequent" is defined according to
                               the synchronization order).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.4-110-B"></a>A write to a volatile
                               variable <span class="emphasis"><em>v</em></span>
                               (<a class="xref" href="jls-8.html#jls-8.3.1.4" title="8.3.1.4.&nbsp;volatile Fields">&sect;8.3.1.4</a>) <span class="emphasis"><em>synchronizes-with</em></span>
                               all subsequent reads of <span class="emphasis"><em>v</em></span> by any thread (where "subsequent" is
                               defined according to the synchronization order).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.4-110-C"></a>An action that starts
                               a thread <span class="emphasis"><em>synchronizes-with</em></span> the first action
                               in the thread it starts.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.4-110-D"></a>The write of the
                               default value (zero, <code class="literal">false</code>, or <code class="literal">null</code>) to each
                               variable <span class="emphasis"><em>synchronizes-with</em></span> the first action
                               in every thread.
                        </p>
                        <p class="note">Although it may seem a little strange to write a
                               default value to a variable before the object containing the
                               variable is allocated, conceptually every object is created at the
                               start of the program with its default initialized values.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.4-110-E"></a>The final action in a
                               thread <code class="varname">T1</code>
                               <span class="emphasis"><em>synchronizes-with</em></span> any action in another
                               thread <code class="varname">T2</code> that detects
                               that <code class="varname">T1</code> has terminated.
                        </p>
                        <p class="note"><code class="varname">T2</code> may accomplish this by
                               calling <code class="varname">T1</code><code class="literal">.isAlive()</code>
                               or <code class="varname">T1</code><code class="literal">.join()</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.4-110-F"></a>If
                               thread <code class="varname">T1</code> interrupts
                               thread <code class="varname">T2</code>, the interrupt
                               by <code class="varname">T1</code> <span class="emphasis"><em>synchronizes-with</em></span>
                               any point where any other thread (including <code class="varname">T2</code>)
                               determines that <code class="varname">T2</code> has been interrupted (by
                               having an <code class="literal">InterruptedException</code> thrown or by
                               invoking <code class="literal">Thread.interrupted</code>
                               or <code class="literal">Thread.isInterrupted</code>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.4.4-120"></a>The source of
                  a <span class="emphasis"><em>synchronizes-with</em></span> edge is called
                  a <span class="emphasis"><em>release</em></span>, and the destination is called
                  an <span class="emphasis"><em>acquire</em></span>.
               </p>
            </div>
            <div class="section" title="17.4.5.&nbsp;Happens-before Order">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.4.5"></a>17.4.5.&nbsp;Happens-before Order
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.4.5-100"></a>Two actions can be ordered
                  by a <span class="emphasis"><em>happens-before</em></span> relationship. If one
                  action <span class="emphasis"><em>happens-before</em></span> another, then the first is
                  visible to and ordered before the second.
               </p>
               <p class="norm"><a name="jls-17.4.5-110"></a>If we have two actions <span class="emphasis"><em>x</em></span>
                  and <span class="emphasis"><em>y</em></span>, we write <span class="emphasis"><em>hb(x, y)</em></span> to indicate
                  that <span class="emphasis"><em>x happens-before y</em></span>.
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-110-A"></a>If <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> are
                               actions of the same thread and <span class="emphasis"><em>x</em></span> comes before <span class="emphasis"><em>y</em></span> in program
                               order, then <span class="emphasis"><em>hb(x, y)</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-110-B"></a>There is
                               a <span class="emphasis"><em>happens-before</em></span> edge from the end of a
                               constructor of an object to the start of a finalizer
                               (<a class="xref" href="jls-12.html#jls-12.6" title="12.6.&nbsp;Finalization of Class Instances">&sect;12.6</a>) for that object.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-110-C"></a>If an action
                               <span class="emphasis"><em>x</em></span> <span class="emphasis"><em>synchronizes-with</em></span> a following action <span class="emphasis"><em>y</em></span>,
                               then we also have <span class="emphasis"><em>hb(x, y)</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-110-D"></a>If <span class="emphasis"><em>hb(x,
                                     y)</em></span> and <span class="emphasis"><em>hb(y, z)</em></span>,
                               then <span class="emphasis"><em>hb(x, z)</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.4.5-120"></a>The <code class="literal">wait</code>
                  methods of class <code class="literal">Object</code> (<a class="xref" href="jls-17.html#jls-17.2.1" title="17.2.1.&nbsp;Wait">&sect;17.2.1</a>) have lock and
                  unlock actions associated with them;
                  their <span class="emphasis"><em>happens-before</em></span> relationships are defined by
                  these associated actions.
               </p>
               <p class="norm"><a name="jls-17.4.5-200"></a>It should be noted that the
                  presence of a <span class="emphasis"><em>happens-before</em></span> relationship between
                  two actions does not necessarily imply that they have to take place in
                  that order in an implementation. If the reordering produces results
                  consistent with a legal execution, it is not illegal.
               </p>
               <p class="note">For example, the write of a default value to every
                  field of an object constructed by a thread need not happen before the
                  beginning of that thread, as long as no read ever observes that
                  fact.
               </p>
               <p class="norm"><a name="jls-17.4.5-210"></a>More specifically, if two
                  actions share a <span class="emphasis"><em>happens-before</em></span> relationship, they
                  do not necessarily have to appear to have happened in that order to
                  any code with which they do not share
                  a <span class="emphasis"><em>happens-before</em></span> relationship. Writes in one
                  thread that are in a data race with reads in another thread may, for
                  example, appear to occur out of order to those reads.
               </p>
               <p class="norm"><a name="jls-17.4.5-300"></a>The
                  <span class="emphasis"><em>happens-before</em></span> relation defines when data races
                  take place.
               </p>
               <p class="norm"><a name="jls-17.4.5-310"></a>A set of synchronization
                  edges, <span class="emphasis"><em>S</em></span>, is <span class="emphasis"><em>sufficient</em></span> if
                  it is the minimal set such that the transitive closure
                  of <span class="emphasis"><em>S</em></span> with the program order determines all of
                  the <span class="emphasis"><em>happens-before</em></span> edges in the execution. This
                  set is unique.
               </p>
               <p class="norm"><a name="jls-17.4.5-320"></a>It follows from the above
                  definitions that:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-320-A"></a>An unlock on a
                               monitor <span class="emphasis"><em>happens-before</em></span> every subsequent lock
                               on that monitor.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-320-B"></a>A write to a
                               <code class="literal">volatile</code> field
                               (<a class="xref" href="jls-8.html#jls-8.3.1.4" title="8.3.1.4.&nbsp;volatile Fields">&sect;8.3.1.4</a>) <span class="emphasis"><em>happens-before</em></span>
                               every subsequent read of that field.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-320-C"></a>A call
                               to <code class="literal">start()</code> on a
                               thread <span class="emphasis"><em>happens-before</em></span> any actions in the
                               started thread.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-320-D"></a>All actions in a
                               thread <span class="emphasis"><em>happen-before</em></span> any other thread
                               successfully returns from a <code class="literal">join()</code> on that
                               thread.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-320-E"></a>The default
                               initialization of any object <span class="emphasis"><em>happens-before</em></span>
                               any other actions (other than default-writes) of a program.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.4.5-330"></a>When a program contains two
                  conflicting accesses (<a class="xref" href="jls-17.html#jls-17.4.1" title="17.4.1.&nbsp;Shared Variables">&sect;17.4.1</a>) that are not
                  ordered by a happens-before relationship, it is said to contain
                  a <span class="emphasis"><em>data race</em></span>.
               </p>
               <p class="norm"><a name="jls-17.4.5-340"></a>The semantics of operations
                  other than inter-thread actions, such as reads of array lengths
                  (<a class="xref" href="jls-10.html#jls-10.7" title="10.7.&nbsp;Array Members">&sect;10.7</a>), executions of checked casts
                  (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>, <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>), and
                  invocations of virtual methods (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), are not
                  directly affected by data races.
               </p>
               <p class="note">Therefore, a data race cannot cause incorrect
                  behavior such as returning the wrong length for an array.
               </p>
               <p class="norm"><a name="jls-17.4.5-400"></a>A program
                  is <span class="emphasis"><em>correctly synchronized</em></span> if and only if all
                  sequentially consistent executions are free of data races.
               </p>
               <p class="norm"><a name="jls-17.4.5-410"></a>If a program is correctly
                  synchronized, then all executions of the program will appear to be
                  sequentially consistent (<a class="xref" href="jls-17.html#jls-17.4.3" title="17.4.3.&nbsp;Programs and Program Order">&sect;17.4.3</a>).
               </p>
               <p class="note">This is an extremely strong guarantee for
                  programmers. Programmers do not need to reason about reorderings to
                  determine that their code contains data races. Therefore they do not
                  need to reason about reorderings when determining whether their code
                  is correctly synchronized. Once the determination that the code is
                  correctly synchronized is made, the programmer does not need to worry
                  that reorderings will affect his or her code.
               </p>
               <p class="note">A program must be correctly synchronized to avoid
                  the kinds of counterintuitive behaviors that can be observed when code
                  is reordered. The use of correct synchronization does not ensure that
                  the overall behavior of a program is correct. However, its use does
                  allow a programmer to reason about the possible behaviors of a program
                  in a simple way; the behavior of a correctly synchronized program is
                  much less dependent on possible reorderings. Without correct
                  synchronization, very strange, confusing and counterintuitive
                  behaviors are possible.
               </p>
               <p class="norm"><a name="jls-17.4.5-500"></a>We say that a read <span class="emphasis"><em>r</em></span> of a
                  variable <span class="emphasis"><em>v</em></span> is allowed to observe a write <span class="emphasis"><em>w</em></span> to <span class="emphasis"><em>v</em></span> if, in
                  the <span class="emphasis"><em>happens-before</em></span> partial order of the execution
                  trace:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-500-A"></a><span class="emphasis"><em>r</em></span> is not ordered
                                 before <span class="emphasis"><em>w</em></span> (i.e., it is not the case that <span class="emphasis"><em>hb(r,
                                       w)</em></span>), and
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.5-500-B"></a>there is no
                                 intervening write <span class="emphasis"><em>w</em></span>' to <span class="emphasis"><em>v</em></span> (i.e. no write <span class="emphasis"><em>w</em></span>' to <span class="emphasis"><em>v</em></span> such
                                 that <span class="emphasis"><em>hb(w, w')</em></span> and <span class="emphasis"><em>hb(w',
                                       r)</em></span>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.4.5-510"></a>Informally, a read <span class="emphasis"><em>r</em></span> is
                  allowed to see the result of a write <span class="emphasis"><em>w</em></span> if there is
                  no <span class="emphasis"><em>happens-before</em></span> ordering to prevent that
                  read.
               </p>
               <p class="norm"><a name="jls-17.4.5-600"></a>A set of actions <span class="emphasis"><em>A</em></span>
                  is <span class="emphasis"><em>happens-before consistent</em></span> if for all reads <span class="emphasis"><em>r</em></span>
                  in <span class="emphasis"><em>A</em></span>, where <span class="emphasis"><em>W(r)</em></span> is the write action seen by
                  <span class="emphasis"><em>r</em></span>, it is not the case that either <span class="emphasis"><em>hb(r, W(r))</em></span>
                  or that there exists a write <span class="emphasis"><em>w</em></span> in <span class="emphasis"><em>A</em></span> such
                  that <span class="emphasis"><em>w.v</em></span> = <span class="emphasis"><em>r.v</em></span>
                  and <span class="emphasis"><em>hb(W(r), w)</em></span> and <span class="emphasis"><em>hb(w,
                        r)</em></span>.
               </p>
               <p class="norm"><a name="jls-17.4.5-610"></a>In
                  a <span class="emphasis"><em>happens-before consistent</em></span> set of actions, each
                  read sees a write that it is allowed to see by
                  the <span class="emphasis"><em>happens-before</em></span> ordering.
               </p>
               <div class="example"><a name="d5e35122"></a><p class="title"><b>Example&nbsp;17.4.5-1.&nbsp;Happens-before Consistency</b></p>
                  <div class="example-contents">
                     <p class="note">For the trace in <a class="xref" href="jls-17.html#jls-17.4.5-A" title="Table&nbsp;17.4.5-A.&nbsp;Behavior allowed by happens-before consistency, but not sequential consistency.">Table&nbsp;17.4.5-A</a>,
                        initially <code class="literal">A == B == 0</code>. The trace can
                        observe <code class="literal">r2 == 0</code> and <code class="literal">r1 == 0</code> and
                        still be <span class="emphasis"><em>happens-before consistent</em></span>, since there
                        are execution orders that allow each read to see the appropriate
                        write.
                     </p>
                     <div class="table"><a name="jls-17.4.5-A"></a><p class="title"><b>Table&nbsp;17.4.5-A.&nbsp;Behavior allowed by happens-before consistency, but not sequential consistency.</b></p>
                        <div class="table-contents">
                           <table summary="Behavior allowed by happens-before consistency, but not sequential consistency." border="1">
                              <colgroup>
                                 <col>
                                 <col>
                              </colgroup>
                              <thead>
                                 <tr>
                                    <th>Thread 1</th>
                                    <th>Thread 2</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr>
                                    <td><code class="literal">B = 1;</code></td>
                                    <td><code class="literal">A = 2;</code></td>
                                 </tr>
                                 <tr>
                                    <td><code class="literal">r2 = A;</code></td>
                                    <td><code class="literal">r1 = B;</code></td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </div><br class="table-break"><p class="note">Since there is no synchronization, each read can see
                        either the write of the initial value or the write by the other
                        thread. An execution order that displays this behavior is:
                     </p><pre class="screen">
1: B = 1;
3: A = 2;
2: r2 = A;  // sees initial write of 0
4: r1 = B;  // sees initial write of 0
</pre><p class="note">
                        Another execution order that is happens-before consistent is:
                     </p><pre class="screen">
1: r2 = A;  // sees write of A = 2
3: r1 = B;  // sees write of B = 1
2: B = 1;
4: A = 2;
</pre><p class="note">In this execution, the reads see writes that occur
                        later in the execution order. This may seem counterintuitive, but is
                        allowed by <span class="emphasis"><em>happens-before</em></span> consistency. Allowing
                        reads to see later writes can sometimes produce unacceptable
                        behaviors.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="17.4.6.&nbsp;Executions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.4.6"></a>17.4.6.&nbsp;Executions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.4.6-100"></a>An execution <span class="emphasis"><em>E</em></span> is
                  described by a tuple &lt; <span class="emphasis"><em>P, A, po, so, W, V, sw,
                        hb</em></span> &gt;, comprising:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.6-100-A"></a><span class="emphasis"><em>P</em></span> - a program
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.6-100-B"></a><span class="emphasis"><em>A</em></span> - a set of
                               actions
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.6-100-C"></a><span class="emphasis"><em>po</em></span> - program order,
                               which for each thread <span class="emphasis"><em>t</em></span>, is a total order over all actions
                               performed by <span class="emphasis"><em>t</em></span> in <span class="emphasis"><em>A</em></span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.6-100-D"></a><span class="emphasis"><em>so</em></span> -
                               synchronization order, which is a total order over all
                               synchronization actions in <span class="emphasis"><em>A</em></span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.6-100-E"></a><span class="emphasis"><em>W</em></span>
                               - a write-seen function, which for each read <span class="emphasis"><em>r</em></span> in <span class="emphasis"><em>A</em></span>,
                               gives <span class="emphasis"><em>W(r)</em></span>, the write action seen by <span class="emphasis"><em>r</em></span>
                               in <span class="emphasis"><em>E</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.6-100-F"></a><span class="emphasis"><em>V</em></span>
                               - a value-written function, which for each write <span class="emphasis"><em>w</em></span> in <span class="emphasis"><em>A</em></span>,
                               gives <span class="emphasis"><em>V(w)</em></span>, the value written by <span class="emphasis"><em>w</em></span>
                               in <span class="emphasis"><em>E</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.6-100-G"></a><span class="emphasis"><em>sw</em></span> -
                               synchronizes-with, a partial order over synchronization
                               actions
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.6-100-H"></a><span class="emphasis"><em>hb</em></span> -
                               happens-before, a partial order over actions
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.4.6-110"></a>Note that the
                  synchronizes-with and happens-before elements are uniquely determined
                  by the other components of an execution and the rules for well-formed
                  executions (<a class="xref" href="jls-17.html#jls-17.4.7" title="17.4.7.&nbsp;Well-Formed Executions">&sect;17.4.7</a>).
               </p>
               <p class="norm"><a name="jls-17.4.6-200"></a>An execution
                  is <span class="emphasis"><em>happens-before consistent</em></span> if its set of
                  actions is <span class="emphasis"><em>happens-before consistent</em></span>
                  (<a class="xref" href="jls-17.html#jls-17.4.5" title="17.4.5.&nbsp;Happens-before Order">&sect;17.4.5</a>).
               </p>
            </div>
            <div class="section" title="17.4.7.&nbsp;Well-Formed Executions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.4.7"></a>17.4.7.&nbsp;Well-Formed Executions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.4.7-100"></a>We only consider well-formed
                  executions. An execution <span class="emphasis"><em>E</em></span> = &lt; <span class="emphasis"><em>P, A, po, so, W, V, sw,
                        hb</em></span> &gt; is well formed if the following are true:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.7-100-A"></a>Each read sees a write
                               to the same variable in the execution.
                        </p>
                        <p class="norm"><a name="jls-17.4.7-100-A.1"></a>All reads and writes
                               of volatile variables are volatile actions. For all reads <span class="emphasis"><em>r</em></span> in
                               <span class="emphasis"><em>A</em></span>, we have <span class="emphasis"><em>W(r)</em></span> in <span class="emphasis"><em>A</em></span>
                               and <span class="emphasis"><em>W(r).v</em></span> = <span class="emphasis"><em>r.v</em></span>. The
                               variable <span class="emphasis"><em>r.v</em></span> is volatile if and only if <span class="emphasis"><em>r</em></span>
                               is a volatile read, and the variable <span class="emphasis"><em>w.v</em></span> is
                               volatile if and only if <span class="emphasis"><em>w</em></span> is a volatile write.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.7-100-B"></a>The happens-before
                               order is a partial order.
                        </p>
                        <p class="norm"><a name="jls-17.4.7-100-B.1"></a>The happens-before
                               order is given by the transitive closure of synchronizes-with
                               edges and program order. It must be a valid partial order:
                               reflexive, transitive and antisymmetric.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.7-100-C"></a>The execution obeys
                               intra-thread consistency.
                        </p>
                        <p class="norm"><a name="jls-17.4.7-100-C.1"></a>For each thread <span class="emphasis"><em>t</em></span>,
                               the actions performed by <span class="emphasis"><em>t</em></span> in <span class="emphasis"><em>A</em></span> are the same as would be
                               generated by that thread in program-order in isolation, with each
                               write <span class="emphasis"><em>w</em></span> writing the value <span class="emphasis"><em>V(w)</em></span>, given that
                               each read <span class="emphasis"><em>r</em></span> sees the value <span class="emphasis"><em>V(W(r))</em></span>. Values
                               seen by each read are determined by the memory model. The program
                               order given must reflect the program order in which the actions
                               would be performed according to the intra-thread semantics of
                               <span class="emphasis"><em>P</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.7-100-D"></a>The execution
                               is <span class="emphasis"><em>happens-before consistent</em></span>
                               (<a class="xref" href="jls-17.html#jls-17.4.6" title="17.4.6.&nbsp;Executions">&sect;17.4.6</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.7-100-E"></a>The execution obeys
                               synchronization-order consistency.
                        </p>
                        <p class="norm"><a name="jls-17.4.7-100-E.1"></a>For all volatile
                               reads <span class="emphasis"><em>r</em></span> in <span class="emphasis"><em>A</em></span>, it is not the case that either <span class="emphasis"><em>so(r,
                                     W(r))</em></span> or that there exists a write <span class="emphasis"><em>w</em></span> in <span class="emphasis"><em>A</em></span> such
                               that <span class="emphasis"><em>w.v</em></span> = <span class="emphasis"><em>r.v</em></span>
                               and <span class="emphasis"><em>so(W(r), w)</em></span> and <span class="emphasis"><em>so(w,
                                     r)</em></span>.
                        </p>
                     </li>
                  </ol>
               </div>
            </div>
            <div class="section" title="17.4.8.&nbsp;Executions and Causality Requirements">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.4.8"></a>17.4.8.&nbsp;Executions and Causality Requirements
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="note">We use <span class="emphasis"><em>f</em></span>|<sub><span class="emphasis"><em>d</em></span></sub> to denote the
                  function given by restricting the domain of <span class="emphasis"><em>f</em></span> to <span class="emphasis"><em>d</em></span>. For all <span class="emphasis"><em>x</em></span> in
                  <span class="emphasis"><em>d</em></span>, <span class="emphasis"><em>f</em></span>|<sub><span class="emphasis"><em>d</em></span></sub>(<span class="emphasis"><em>x</em></span>) = <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>x</em></span>), and for all <span class="emphasis"><em>x</em></span>
                  not in <span class="emphasis"><em>d</em></span>, <span class="emphasis"><em>f</em></span>|<sub><span class="emphasis"><em>d</em></span></sub>(<span class="emphasis"><em>x</em></span>) is undefined.
               </p>
               <p class="note">We use <span class="emphasis"><em>p</em></span>|<sub><span class="emphasis"><em>d</em></span></sub> to represent
                  the restriction of the partial order <span class="emphasis"><em>p</em></span> to the elements in <span class="emphasis"><em>d</em></span>. For
                  all <span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span> in <span class="emphasis"><em>d</em></span>, <span class="emphasis"><em>p</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>) if and only if
                  <span class="emphasis"><em>p</em></span>|<sub><span class="emphasis"><em>d</em></span></sub>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>).  If either
                  <span class="emphasis"><em>x</em></span> or <span class="emphasis"><em>y</em></span> are not in <span class="emphasis"><em>d</em></span>, then it is not the case that
                  <span class="emphasis"><em>p</em></span>|<sub><span class="emphasis"><em>d</em></span></sub>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>).
               </p>
               <p class="norm"><a name="jls-17.4.8-100"></a>A well-formed execution <span class="emphasis"><em>E</em></span>
                  = &lt; <span class="emphasis"><em>P, A, po, so, W, V, sw, hb</em></span> &gt; is
                  validated by <span class="emphasis"><em>committing</em></span> actions from <span class="emphasis"><em>A</em></span>. If all
                  of the actions in <span class="emphasis"><em>A</em></span> can be committed, then the execution satisfies
                  the causality requirements of the Java programming language memory model.
               </p>
               <p class="norm"><a name="jls-17.4.8-110"></a>Starting with the empty set
                  as <span class="emphasis"><em>C<sub>0</sub></em></span>, we perform a sequence of steps where we take actions from the
                  set of actions <span class="emphasis"><em>A</em></span> and add them to a set of committed actions <span class="emphasis"><em>C<sub>i</sub></em></span> to
                  get a new set of committed actions <span class="emphasis"><em>C<sub>i+1</sub></em></span>.  To demonstrate that
                  this is reasonable, for each <span class="emphasis"><em>C<sub>i</sub></em></span> we need to demonstrate an execution
                  <span class="emphasis"><em>E</em></span> containing <span class="emphasis"><em>C<sub>i</sub></em></span> that meets certain conditions.
               </p>
               <p class="norm"><a name="jls-17.4.8-200"></a>Formally, an
                  execution <span class="emphasis"><em>E satisfies the causality requirements of the
                        Java programming language memory model</em></span> if and only if there exist:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-200-A"></a>Sets of actions <span class="emphasis"><em>C<sub>0</sub></em></span>,
                               <span class="emphasis"><em>C<sub>1</sub></em></span>, ... such that:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.8-200-A-1"></a><span class="emphasis"><em>C<sub>0</sub></em></span> is the
                                    	empty set
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.8-200-A-2"></a><span class="emphasis"><em>C<sub>i</sub></em></span> is a proper
                                            subset of <span class="emphasis"><em>C<sub>i+1</sub></em></span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.8-200-A-3"></a><span class="emphasis"><em>A</em></span> = <span class="symbol">&#8746;</span>
                                    	(<span class="emphasis"><em>C<sub>0</sub></em></span>, <span class="emphasis"><em>C<sub>1</sub></em></span>, ...)
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p class="norm"><a name="jls-17.4.8-200-A.1"></a>If <span class="emphasis"><em>A</em></span> is finite,
                               then the sequence <span class="emphasis"><em>C<sub>0</sub></em></span>, <span class="emphasis"><em>C<sub>1</sub></em></span>, ... will be finite, ending in a set
                               <span class="emphasis"><em>C<sub>n</sub></em></span> = <span class="emphasis"><em>A</em></span>.
                        </p>
                        <p class="norm"><a name="jls-17.4.8-200-A.2"></a>If <span class="emphasis"><em>A</em></span> is infinite,
                               then the sequence <span class="emphasis"><em>C<sub>0</sub></em></span>, <span class="emphasis"><em>C<sub>1</sub></em></span>, ... may be infinite, and it must be
                               the case that the union of all elements of this infinite sequence
                               is equal to <span class="emphasis"><em>A</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-200-B"></a>Well-formed executions
                               <span class="emphasis"><em>E<sub>1</sub></em></span>, ..., where <span class="emphasis"><em>E<sub>i</sub></em></span> = &lt; <span class="emphasis"><em>P,
                                     A<sub>i</sub>, po<sub>i</sub>,
                                     so<sub>i</sub>, W<sub>i</sub>,
                                     V<sub>i</sub>, sw<sub>i</sub>,
                                     hb<sub>i</sub></em></span> &gt;.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.4.8-300"></a>Given these sets of actions
                  <span class="emphasis"><em>C<sub>0</sub></em></span>, ... and executions <span class="emphasis"><em>E<sub>1</sub></em></span>, ... , every action in <span class="emphasis"><em>C<sub>i</sub></em></span> must be one
                  of the actions in <span class="emphasis"><em>E<sub>i</sub></em></span>. All actions in <span class="emphasis"><em>C<sub>i</sub></em></span> must share the same
                  relative happens-before order and synchronization order in both <span class="emphasis"><em>E<sub>i</sub></em></span>
                  and <span class="emphasis"><em>E</em></span>. Formally:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-300-A"></a><span class="emphasis"><em>C<sub>i</sub></em></span> is a subset of <span class="emphasis"><em>A<sub>i</sub></em></span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-300-B"></a>
                                 <span class="emphasis"><em>hb<sub>i</sub></em></span>|<sub><span class="emphasis"><em>C<sub>i</sub></em></span></sub> = <span class="emphasis"><em>hb</em></span>|<sub><span class="emphasis"><em>C<sub>i</sub></em></span></sub>
                               
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-300-C"></a>
                                 <span class="emphasis"><em>so<sub>i</sub></em></span>|<sub><span class="emphasis"><em>C<sub>i</sub></em></span></sub> = <span class="emphasis"><em>so</em></span>|<sub><span class="emphasis"><em>C<sub>i</sub></em></span></sub>
                               
                        </p>
                     </li>
                  </ol>
               </div>
               <p class="norm"><a name="jls-17.4.8-310"></a>The values written by the
                  writes in <span class="emphasis"><em>C<sub>i</sub></em></span> must be the same in both <span class="emphasis"><em>E<sub>i</sub></em></span> and <span class="emphasis"><em>E</em></span>. Only the reads
                  in <span class="emphasis"><em>C<sub>i-1</sub></em></span> need to see the same writes in <span class="emphasis"><em>E<sub>i</sub></em></span> as in
                  <span class="emphasis"><em>E</em></span>. Formally:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" start="4" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-310-A"></a>
                                 <span class="emphasis"><em>V<sub>i</sub></em></span>|<sub><span class="emphasis"><em>C<sub>i</sub></em></span></sub> = <span class="emphasis"><em>V</em></span>|<sub><span class="emphasis"><em>C<sub>i</sub></em></span></sub>
                               
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-310-B"></a>
                                 <span class="emphasis"><em>W<sub>i</sub></em></span>|<sub><span class="emphasis"><em>C<sub>i-1</sub></em></span></sub> = <span class="emphasis"><em>W</em></span>|<sub><span class="emphasis"><em>C<sub>i-1</sub></em></span></sub>
                               
                        </p>
                     </li>
                  </ol>
               </div>
               <p class="norm"><a name="jls-17.4.8-320"></a>All reads in <span class="emphasis"><em>E<sub>i</sub></em></span> that are
                  not in <span class="emphasis"><em>C<sub>i-1</sub></em></span> must see writes that happen-before them. Each read <span class="emphasis"><em>r</em></span>
                  in <span class="emphasis"><em>C<sub>i</sub></em></span> - <span class="emphasis"><em>C<sub>i-1</sub></em></span> must see writes in <span class="emphasis"><em>C<sub>i-1</sub></em></span> in both <span class="emphasis"><em>E<sub>i</sub></em></span> and <span class="emphasis"><em>E</em></span>, but
                  may see a different write in <span class="emphasis"><em>E<sub>i</sub></em></span> from the one it sees in
                  <span class="emphasis"><em>E</em></span>. Formally:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" start="6" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-320-A"></a>For any read <span class="emphasis"><em>r</em></span> in
                                 <span class="emphasis"><em>A<sub>i</sub></em></span> - <span class="emphasis"><em>C<sub>i-1</sub></em></span>, we
                                 have <span class="emphasis"><em>hb<sub>i</sub>(W<sub>i</sub>(r),
                                       r)</em></span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-320-B"></a>For any read <span class="emphasis"><em>r</em></span> in
                                 (<span class="emphasis"><em>C<sub>i</sub></em></span> - <span class="emphasis"><em>C<sub>i-1</sub></em></span>), we
                                 have <span class="emphasis"><em>W<sub>i</sub>(r)</em></span> in <span class="emphasis"><em>C<sub>i-1</sub></em></span>
                                 and <span class="emphasis"><em>W(r)</em></span> in <span class="emphasis"><em>C<sub>i-1</sub></em></span></p>
                     </li>
                  </ol>
               </div>
               <p class="norm"><a name="jls-17.4.8-330"></a>Given a set of sufficient
                  synchronizes-with edges for <span class="emphasis"><em>E<sub>i</sub></em></span>, if there is a release-acquire pair
                  that happens-before (<a class="xref" href="jls-17.html#jls-17.4.5" title="17.4.5.&nbsp;Happens-before Order">&sect;17.4.5</a>) an action you are
                  committing, then that pair must be present in all <span class="emphasis"><em>E<sub>j</sub></em></span>, where <span class="emphasis"><em>j</em></span>
                  <span class="symbol">&#8805;</span> <span class="emphasis"><em>i</em></span>. Formally:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" start="8" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-330-A"></a>Let <span class="emphasis"><em>ssw<sub>i</sub></em></span>
                                 be the <span class="emphasis"><em>sw<sub>i</sub></em></span> edges
                                 that are also in the transitive reduction
                                 of <span class="emphasis"><em>hb<sub>i</sub></em></span> but not
                                 in <span class="emphasis"><em>po</em></span>. We
                                 call <span class="emphasis"><em>ssw<sub>i</sub></em></span>
                                 the <span class="emphasis"><em>sufficient synchronizes-with edges for
                                       <span class="emphasis"><em>E<sub>i</sub></em></span></em></span>. If <span class="emphasis"><em>ssw<sub>i</sub>(x,
                                       y)</em></span> and <span class="emphasis"><em>hb<sub>i</sub>(y,
                                       z)</em></span> and <span class="emphasis"><em>z</em></span> in <span class="emphasis"><em>C<sub>i</sub></em></span>,
                                 then <span class="emphasis"><em>sw<sub>j</sub>(x, y)</em></span> for
                                 all <span class="emphasis"><em>j</em></span> <span class="symbol">&#8805;</span> <span class="emphasis"><em>i</em></span>.
                        </p>
                        <p class="norm"><a name="jls-17.4.8-330-A.1"></a>If an action <span class="emphasis"><em>y</em></span> is
                                 committed, all external actions that happen-before <span class="emphasis"><em>y</em></span> are also
                                 committed.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.8-330-B"></a>If <span class="emphasis"><em>y</em></span> is in <span class="emphasis"><em>C<sub>i</sub></em></span>, <span class="emphasis"><em>x</em></span>
                                 is an external action
                                 and <span class="emphasis"><em>hb<sub>i</sub>(x, y)</em></span>, then
                                 <span class="emphasis"><em>x</em></span> in <span class="emphasis"><em>C<sub>i</sub></em></span>.
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="example"><a name="d5e35547"></a><p class="title"><b>Example&nbsp;17.4.8-1.&nbsp;Happens-before Consistency Is Not Sufficient</b></p>
                  <div class="example-contents">
                     <p class="note">Happens-before consistency is a necessary, but not
                        sufficient, set of constraints. Merely enforcing happens-before
                        consistency would allow for unacceptable behaviors - those that
                        violate the requirements we have established for programs. For
                        example, happens-before consistency allows values to appear "out of
                        thin air". This can be seen by a detailed examination of the trace in
                        <a class="xref" href="jls-17.html#jls-17.4.8-A" title="Table&nbsp;17.4.8-A.&nbsp;Happens-before consistency is not sufficient">Table&nbsp;17.4.8-A</a>.
                     </p>
                     <div class="table"><a name="jls-17.4.8-A"></a><p class="title"><b>Table&nbsp;17.4.8-A.&nbsp;Happens-before consistency is not sufficient</b></p>
                        <div class="table-contents">
                           <table summary="Happens-before consistency is not sufficient" border="1">
                              <colgroup>
                                 <col>
                                 <col>
                              </colgroup>
                              <thead>
                                 <tr>
                                    <th>Thread 1</th>
                                    <th>Thread 2</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr>
                                    <td><code class="literal">r1 = x;</code></td>
                                    <td><code class="literal">r2 = y;</code></td>
                                 </tr>
                                 <tr>
                                    <td><code class="literal">if (r1 != 0) y = 1;</code></td>
                                    <td><code class="literal">if (r2 != 0) x = 1;</code></td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </div><br class="table-break"><p class="note">The code shown in <a class="xref" href="jls-17.html#jls-17.4.8-A" title="Table&nbsp;17.4.8-A.&nbsp;Happens-before consistency is not sufficient">Table&nbsp;17.4.8-A</a> is
                        correctly synchronized. This may seem surprising, since it does not
                        perform any synchronization actions. Remember, however, that a program
                        is correctly synchronized if, when it is executed in a sequentially
                        consistent manner, there are no data races. If this code is executed
                        in a sequentially consistent way, each action will occur in program
                        order, and neither of the writes will occur. Since no writes occur,
                        there can be no data races: the program is correctly
                        synchronized.
                     </p>
                     <p class="note">Since this program is correctly synchronized, the
                        only behaviors we can allow are sequentially consistent
                        behaviors. However, there is an execution of this program that is
                        happens-before consistent, but not sequentially consistent:
                     </p><pre class="screen">
r1 = x;  // sees write of x = 1
y = 1;
r2 = y;  // sees write of y = 1
x = 1; 
</pre><p class="note">This result is happens-before consistent: there is
                        no happens-before relationship that prevents it from
                        occurring. However, it is clearly not acceptable: there is no
                        sequentially consistent execution that would result in this
                        behavior. The fact that we allow a read to see a write that comes
                        later in the execution order can sometimes thus result in unacceptable
                        behaviors.
                     </p>
                     <p class="note">Although allowing reads to see writes that come
                        later in the execution order is sometimes undesirable, it is also
                        sometimes necessary. As we saw above, the trace in
                        <a class="xref" href="jls-17.html#jls-17.4.5-A" title="Table&nbsp;17.4.5-A.&nbsp;Behavior allowed by happens-before consistency, but not sequential consistency.">Table&nbsp;17.4.5-A</a> requires some reads to see writes that
                        occur later in the execution order. Since the reads come first in each
                        thread, the very first action in the execution order must be a
                        read. If that read cannot see a write that occurs later, then it
                        cannot see any value other than the initial value for the variable it
                        reads. This is clearly not reflective of all behaviors.
                     </p>
                     <p class="note">We refer to the issue of when reads can see future
                        writes as <span class="emphasis"><em>causality</em></span>, because of issues that arise
                        in cases like the one found in <a class="xref" href="jls-17.html#jls-17.4.8-A" title="Table&nbsp;17.4.8-A.&nbsp;Happens-before consistency is not sufficient">Table&nbsp;17.4.8-A</a>. In that
                        case, the reads cause the writes to occur, and the writes cause the
                        reads to occur. There is no "first cause" for the actions. Our memory
                        model therefore needs a consistent way of determining which reads can
                        see writes early.
                     </p>
                     <p class="note">Examples such as the one found in
                        <a class="xref" href="jls-17.html#jls-17.4.8-A" title="Table&nbsp;17.4.8-A.&nbsp;Happens-before consistency is not sufficient">Table&nbsp;17.4.8-A</a> demonstrate that the specification must
                        be careful when stating whether a read can see a write that occurs
                        later in the execution (bearing in mind that if a read sees a write
                        that occurs later in the execution, it represents the fact that the
                        write is actually performed early).
                     </p>
                     <p class="note">The memory model takes as input a given execution,
                        and a program, and determines whether that execution is a legal
                        execution of the program. It does this by gradually building a set of
                        "committed" actions that reflect which actions were executed by the
                        program. Usually, the next action to be committed will reflect the
                        next action that can be performed by a sequentially consistent
                        execution. However, to reflect reads that need to see later writes, we
                        allow some actions to be committed earlier than other actions that
                        happen-before them.
                     </p>
                     <p class="note">Obviously, some actions may be committed early and
                        some may not. If, for example, one of the writes in
                        <a class="xref" href="jls-17.html#jls-17.4.8-A" title="Table&nbsp;17.4.8-A.&nbsp;Happens-before consistency is not sufficient">Table&nbsp;17.4.8-A</a> were committed before the read of that
                        variable, the read could see the write, and the "out-of-thin-air"
                        result could occur. Informally, we allow an action to be committed
                        early if we know that the action can occur without assuming some data
                        race occurs. In <a class="xref" href="jls-17.html#jls-17.4.8-A" title="Table&nbsp;17.4.8-A.&nbsp;Happens-before consistency is not sufficient">Table&nbsp;17.4.8-A</a>, we cannot perform
                        either write early, because the writes cannot occur unless the reads
                        see the result of a data race.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="17.4.9.&nbsp;Observable Behavior and Nonterminating Executions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.4.9"></a>17.4.9.&nbsp;Observable Behavior and Nonterminating Executions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.4.9-100"></a>For programs that always
                  terminate in some bounded finite period of time, their behavior can be
                  understood (informally) simply in terms of their allowable
                  executions. For programs that can fail to terminate in a bounded
                  amount of time, more subtle issues arise.
               </p>
               <p class="norm"><a name="jls-17.4.9-110"></a>The observable behavior of a
                  program is defined by the finite sets of external actions that the
                  program may perform. A program that, for example, simply prints
                  "Hello" forever is described by a set of behaviors that for any
                  non-negative integer <span class="emphasis"><em>i</em></span>, includes the behavior of printing "Hello"
                  <span class="emphasis"><em>i</em></span> times.
               </p>
               <p class="norm"><a name="jls-17.4.9-120"></a>Termination is not
                  explicitly modeled as a behavior, but a program can easily be extended
                  to generate an additional external action 
                  <span class="emphasis"><em>executionTermination</em></span> that occurs when all threads
                  have terminated.
               </p>
               <p class="norm"><a name="jls-17.4.9-130"></a>We also define a
                  special <span class="emphasis"><em>hang</em></span> action. If behavior is described by
                  a set of external actions including a <span class="emphasis"><em>hang</em></span>
                  action, it indicates a behavior where after the external actions are
                  observed, the program can run for an unbounded amount of time without
                  performing any additional external actions or terminating. Programs
                  can hang if all threads are blocked or if the program can perform an
                  unbounded number of actions without performing any external
                  actions.
               </p>
               <p class="norm"><a name="jls-17.4.9-200"></a>A thread can be blocked in a
                  variety of circumstances, such as when it is attempting to acquire a
                  lock or perform an external action (such as a read) that depends on
                  external data. 
               </p>
               <p class="norm"><a name="jls-17.4.9-210"></a>An execution may result in a
                  thread being blocked indefinitely and the execution's not
                  terminating. In such cases, the actions generated by the blocked
                  thread must consist of all actions generated by that thread up to and
                  including the action that caused the thread to be blocked, and no
                  actions that would be generated by the thread after that
                  action.
               </p>
               <p class="norm"><a name="jls-17.4.9-300"></a>To reason about observable
                  behaviors, we need to talk about sets of observable actions.
               </p>
               <p class="norm"><a name="jls-17.4.9-310"></a>If <span class="emphasis"><em>O</em></span> is a set of
                  observable actions for an execution <span class="emphasis"><em>E</em></span>, then set <span class="emphasis"><em>O</em></span> must be a subset
                  of <span class="emphasis"><em>E</em></span>'s actions, <span class="emphasis"><em>A</em></span>, and must contain only a finite number of
                  actions, even if <span class="emphasis"><em>A</em></span> contains an infinite number of
                  actions. Furthermore, if an action <span class="emphasis"><em>y</em></span> is in <span class="emphasis"><em>O</em></span>, and
                  either <span class="emphasis"><em>hb(x, y)</em></span> or <span class="emphasis"><em>so(x, y)</em></span>,
                  then <span class="emphasis"><em>x</em></span> is in <span class="emphasis"><em>O</em></span>.
               </p>
               <p class="norm"><a name="jls-17.4.9-320"></a>Note that a set of
                  observable actions are not restricted to external actions. Rather,
                  only external actions that are in a set of observable actions are
                  deemed to be observable external actions.
               </p>
               <p class="norm"><a name="jls-17.4.9-330"></a>A behavior <span class="emphasis"><em>B</em></span> is an
                  allowable behavior of a program <span class="emphasis"><em>P</em></span> if and only if <span class="emphasis"><em>B</em></span> is a finite set
                  of external actions and either:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.9-330-A"></a>There exists an
                               execution <span class="emphasis"><em>E</em></span> of <span class="emphasis"><em>P</em></span>, and a set <span class="emphasis"><em>O</em></span> of observable actions for <span class="emphasis"><em>E</em></span>,
                               and <span class="emphasis"><em>B</em></span> is the set of external actions in <span class="emphasis"><em>O</em></span> (If any threads in
                               <span class="emphasis"><em>E</em></span> end in a blocked state and <span class="emphasis"><em>O</em></span> contains all actions in <span class="emphasis"><em>E</em></span>,
                               then <span class="emphasis"><em>B</em></span> may also contain a <span class="emphasis"><em>hang</em></span> action);
                               or
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.4.9-330-B"></a>There exists a set <span class="emphasis"><em>O</em></span>
                               of actions such that <span class="emphasis"><em>B</em></span> consists of a <span class="emphasis"><em>hang</em></span>
                               action plus all the external actions in <span class="emphasis"><em>O</em></span> and for all <span class="emphasis"><em>k</em></span> <span class="symbol">&#8805;</span>
                               | <span class="emphasis"><em>O</em></span> |, there exists an execution <span class="emphasis"><em>E</em></span> of <span class="emphasis"><em>P</em></span> with actions <span class="emphasis"><em>A</em></span>,
                               and there exists a set of actions <span class="emphasis"><em>O</em></span>' such that:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.9-330-B-1"></a>Both <span class="emphasis"><em>O</em></span> and
                                    	<span class="emphasis"><em>O</em></span>' are subsets of <span class="emphasis"><em>A</em></span> that fulfill the requirements for sets
                                    	of observable actions.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.9-330-B-2"></a><span class="emphasis"><em>O</em></span> <span class="symbol">&#8838;</span> <span class="emphasis"><em>O</em></span>' <span class="symbol">&#8838;</span> <span class="emphasis"><em>A</em></span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.9-330-B-3"></a>| <span class="emphasis"><em>O</em></span>' | <span class="symbol">&#8805;</span> <span class="emphasis"><em>k</em></span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.4.9-330-B-4"></a><span class="emphasis"><em>O</em></span>' - <span class="emphasis"><em>O</em></span> contains no external actions
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">Note that a behavior <span class="emphasis"><em>B</em></span> does not describe the order
                  in which the external actions in <span class="emphasis"><em>B</em></span> are observed, but other
                  (internal) constraints on how the external actions are generated and
                  performed may impose such constraints.
               </p>
            </div>
         </div>
         <div class="section" title="17.5.&nbsp;final Field Semantics">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-17.5"></a>17.5.&nbsp;<code class="literal">final</code> Field Semantics
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-17.5-100"></a>Fields declared final are
               initialized once, but never changed under normal circumstances. The
               detailed semantics of <code class="literal">final</code> fields are somewhat different from those
               of normal fields. In particular, compilers have a great deal of
               freedom to move reads of <code class="literal">final</code> fields across synchronization
               barriers and calls to arbitrary or unknown methods. Correspondingly,
               compilers are allowed to keep the value of a <code class="literal">final</code> field cached in a
               register and not reload it from memory in situations where a
               non-<code class="literal">final</code> field would have to be reloaded.
            </p>
            <p class="norm"><a name="jls-17.5-110"></a><code class="literal">final</code> fields also allow
               programmers to implement thread-safe immutable objects without
               synchronization. A thread-safe immutable object is seen as immutable
               by all threads, even if a data race is used to pass references to the
               immutable object between threads. This can provide safety guarantees
               against misuse of an immutable class by incorrect or malicious
               code. <code class="literal">final</code> fields must be used correctly to provide a guarantee of
               immutability.
            </p>
            <p class="norm"><a name="jls-17.5-120"></a>An object is considered to
               be <span class="emphasis"><em>completely initialized</em></span> when its constructor
               finishes. A thread that can only see a reference to an object after
               that object has been completely initialized is guaranteed to see the
               correctly initialized values for that object's <code class="literal">final</code> fields.
            </p>
            <p class="norm"><a name="jls-17.5-200"></a>The usage model for <code class="literal">final</code>
               fields is a simple one: Set the <code class="literal">final</code> fields for an object in that
               object's constructor; and do not write a reference to the object being
               constructed in a place where another thread can see it before the
               object's constructor is finished. If this is followed, then when the
               object is seen by another thread, that thread will always see the
               correctly constructed version of that object's <code class="literal">final</code> fields. It will
               also see versions of any object or array referenced by those <code class="literal">final</code>
               fields that are at least as up-to-date as the <code class="literal">final</code> fields
               are.
            </p>
            <div class="example"><a name="d5e35689"></a><p class="title"><b>Example&nbsp;17.5-1.&nbsp;<code class="literal">final</code> Fields In The Java Memory Model</b></p>
               <div class="example-contents">
                  <p class="note">The program below illustrates how <code class="literal">final</code> fields
                     compare to normal fields.
                  </p><pre class="programlisting">
class FinalFieldExample { 
    final int x;
    int y; 
    static FinalFieldExample f;

    public FinalFieldExample() {
        x = 3; 
        y = 4; 
    } 

    static void writer() {
        f = new FinalFieldExample();
    } 

    static void reader() {
        if (f != null) {
            int i = f.x;  // guaranteed to see 3  
            int j = f.y;  // could see 0
        } 
    } 
}
</pre><p class="note">The class <code class="literal">FinalFieldExample</code> has a
                     <code class="literal">final</code> <code class="literal">int</code> field <code class="literal">x</code> and a non-<code class="literal">final</code> <code class="literal">int</code>
                     field <code class="literal">y</code>. One thread might execute the
                     method <code class="literal">writer</code> and another might execute the
                     method <code class="literal">reader</code>.
                  </p>
                  <p class="note">Because the <code class="literal">writer</code> method
                     writes <code class="literal">f</code> <span class="emphasis"><em>after</em></span> the object's
                     constructor finishes, the <code class="literal">reader</code> method will be
                     guaranteed to see the properly initialized value
                     for <code class="literal">f.x</code>: it will read the
                     value <code class="literal">3</code>. However, <code class="literal">f.y</code> is not
                     <code class="literal">final</code>; the <code class="literal">reader</code> method is therefore not
                     guaranteed to see the value <code class="literal">4</code> for it.
                  </p>
               </div>
            </div><br class="example-break"><div class="example"><a name="d5e35716"></a><p class="title"><b>Example&nbsp;17.5-2.&nbsp;<code class="literal">final</code> Fields For Security</b></p>
               <div class="example-contents">
                  <p class="note"><code class="literal">final</code> fields are designed to allow for necessary
                     security guarantees. Consider the following program. One thread (which
                     we shall refer to as thread 1) executes:
                  </p><pre class="screen">
Global.s = "/tmp/usr".substring(4);
</pre><p class="note">while another thread (thread 2) executes</p><pre class="screen">
String myS = Global.s; 
if (myS.equals("/tmp"))System.out.println(myS);
</pre><p class="note"><code class="literal">String</code> objects are intended to be immutable and
                     string operations do not perform synchronization. While the <code class="literal">String</code>
                     implementation does not have any data races, other code could have
                     data races involving the use of <code class="literal">String</code> objects, and the memory model
                     makes weak guarantees for programs that have data races. In
                     particular, if the fields of the <code class="literal">String</code> class were not <code class="literal">final</code>, then
                     it would be possible (although unlikely) that thread 2 could initially
                     see the default value of <code class="literal">0</code> for the offset of the
                     string object, allowing it to compare as equal to
                     "<code class="literal">/tmp</code>". A later operation on the <code class="literal">String</code> object
                     might see the correct offset of <code class="literal">4</code>, so that the
                     <code class="literal">String</code> object is perceived as being "<code class="literal">/usr</code>". Many
                     security features of the Java programming language depend upon <code class="literal">String</code> objects being
                     perceived as truly immutable, even if malicious code is using data
                     races to pass <code class="literal">String</code> references between threads.
                  </p>
               </div>
            </div><br class="example-break"><div class="section" title="17.5.1.&nbsp;Semantics of final Fields">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.5.1"></a>17.5.1.&nbsp;Semantics of <code class="literal">final</code> Fields
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.5.1-100"></a>Let <span class="emphasis"><em>o</em></span> be an object, and
                  <span class="emphasis"><em>c</em></span> be a constructor for <span class="emphasis"><em>o</em></span> in which a <code class="literal">final</code> field <span class="emphasis"><em>f</em></span> is
                  written. A <span class="emphasis"><em>freeze</em></span> action on <code class="literal">final</code> field <span class="emphasis"><em>f</em></span> of
                  <span class="emphasis"><em>o</em></span> takes place when <span class="emphasis"><em>c</em></span> exits, either normally or abruptly.
               </p>
               <p class="norm"><a name="jls-17.5.1-110"></a>Note that if one constructor
                  invokes another constructor, and the invoked constructor sets a
                  <code class="literal">final</code> field, the freeze for the <code class="literal">final</code> field takes place at the end
                  of the invoked constructor.
               </p>
               <p class="norm"><a name="jls-17.5.1-200"></a>For each execution, the
                  behavior of reads is influenced by two additional partial orders, the
                  dereference chain <span class="emphasis"><em>dereferences()</em></span> and the memory
                  chain <span class="emphasis"><em>mc()</em></span>, which are considered to be part of
                  the execution (and thus, fixed for any particular execution). These
                  partial orders must satisfy the following constraints (which need not
                  have a unique solution):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.5.1-200-A"></a>Dereference Chain: If
                               an action <span class="emphasis"><em>a</em></span> is a read or write of a field or element of an
                               object <span class="emphasis"><em>o</em></span> by a thread <span class="emphasis"><em>t</em></span> that did not initialize <span class="emphasis"><em>o</em></span>, then there
                               must exist some read <span class="emphasis"><em>r</em></span> by thread <span class="emphasis"><em>t</em></span> that sees the address of
                               <span class="emphasis"><em>o</em></span> such that <span class="emphasis"><em>r</em></span> <span class="emphasis"><em>dereferences(r, a)</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-17.5.1-200-B"></a>Memory Chain: There
                               are several constraints on the memory chain ordering:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.5.1-200-B-1"></a>If <span class="emphasis"><em>r</em></span> is a read
                                    	that sees a write <span class="emphasis"><em>w</em></span>, then it must be the case
                                    	that <span class="emphasis"><em>mc(w, r)</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.5.1-200-B-2"></a>If <span class="emphasis"><em>r</em></span> and <span class="emphasis"><em>a</em></span>
                                    	are actions such that <span class="emphasis"><em>dereferences(r, a)</em></span>,
                                    	then it must be the case that <span class="emphasis"><em>mc(r,
                                          	a)</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-17.5.1-200-B-3"></a>If <span class="emphasis"><em>w</em></span> is a
                                    	write of the address of an object <span class="emphasis"><em>o</em></span> by a thread <span class="emphasis"><em>t</em></span> that did
                                    	not initialize <span class="emphasis"><em>o</em></span>, then there must exist some read <span class="emphasis"><em>r</em></span> by
                                    	thread <span class="emphasis"><em>t</em></span> that sees the address of <span class="emphasis"><em>o</em></span> such
                                    	that <span class="emphasis"><em>mc(r, w)</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-17.5.1-300"></a>Given a write <span class="emphasis"><em>w</em></span>, a freeze
                  <span class="emphasis"><em>f</em></span>, an action <span class="emphasis"><em>a</em></span> (that is not a read of a <code class="literal">final</code> field), a
                  read <span class="emphasis"><em>r<sub>1</sub></em></span> of the <code class="literal">final</code>
                  field frozen by <span class="emphasis"><em>f</em></span>, and a
                  read <span class="emphasis"><em>r<sub>2</sub></em></span> such
                  that <span class="emphasis"><em>hb(w, f)</em></span>, <span class="emphasis"><em>hb(f,
                        a)</em></span>, <span class="emphasis"><em>mc(a, r<sub>1</sub>)</em></span>,
                  and <span class="emphasis"><em>dereferences(r<sub>1</sub>,
                        r<sub>2</sub>)</em></span>, then when determining which
                  values can be seen by <span class="emphasis"><em>r<sub>2</sub></em></span>,
                  we consider <span class="emphasis"><em>hb(w,
                        r<sub>2</sub>)</em></span>. (This <span class="emphasis"><em>happens-before</em></span>
                  ordering does not transitively close with
                  other <span class="emphasis"><em>happens-before</em></span> orderings.)
               </p>
               <p class="norm"><a name="jls-17.5.1-310"></a>Note that
                  the <span class="emphasis"><em>dereferences</em></span> order is reflexive,
                  and <span class="emphasis"><em>r<sub>1</sub></em></span> can be the same
                  as <span class="emphasis"><em>r<sub>2</sub></em></span>.
               </p>
               <p class="norm"><a name="jls-17.5.1-320"></a>For reads of <code class="literal">final</code> fields,
                  the only writes that are deemed to come before the read of the <code class="literal">final</code>
                  field are the ones derived through the <code class="literal">final</code> field semantics.
               </p>
            </div>
            <div class="section" title="17.5.2.&nbsp;Reading final Fields During Construction">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.5.2"></a>17.5.2.&nbsp;Reading <code class="literal">final</code> Fields During Construction
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.5.2-100"></a>A read of a <code class="literal">final</code> field of
                  an object within the thread that constructs that object is ordered
                  with respect to the initialization of that field within the
                  constructor by the usual <span class="emphasis"><em>happens-before</em></span> rules. If
                  the read occurs after the field is set in the constructor, it sees the
                  value the <code class="literal">final</code> field is assigned, otherwise it sees the default
                  value.
               </p>
            </div>
            <div class="section" title="17.5.3.&nbsp;Subsequent Modification of final Fields">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.5.3"></a>17.5.3.&nbsp;Subsequent Modification of <code class="literal">final</code> Fields
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.5.3-100"></a>In some cases, such as
                  deserialization, the system will need to change the <code class="literal">final</code> fields of
                  an object after construction. <code class="literal">final</code> fields can be changed via
                  reflection and other implementation-dependent means. The only pattern
                  in which this has reasonable semantics is one in which an object is
                  constructed and then the <code class="literal">final</code> fields of the object are updated. The
                  object should not be made visible to other threads, nor should the
                  <code class="literal">final</code> fields be read, until all updates to the <code class="literal">final</code> fields of the
                  object are complete. Freezes of a <code class="literal">final</code> field occur both at the end
                  of the constructor in which the <code class="literal">final</code> field is set, and immediately
                  after each modification of a <code class="literal">final</code> field via reflection or other
                  special mechanism.
               </p>
               <p class="norm"><a name="jls-17.5.3-110"></a>Even then, there are a
                  number of complications. If a <code class="literal">final</code> field is initialized to a
                  constant expression (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>) in the field
                  declaration, changes to the <code class="literal">final</code> field may not be observed, since
                  uses of that <code class="literal">final</code> field are replaced at compile time with the value
                  of the constant expression.
               </p>
               <p class="norm"><a name="jls-17.5.3-120"></a>Another problem is that the
                  specification allows aggressive optimization of <code class="literal">final</code> fields. Within
                  a thread, it is permissible to reorder reads of a <code class="literal">final</code> field with
                  those modifications of a <code class="literal">final</code> field that do not take place in the
                  constructor.
               </p>
               <div class="example"><a name="d5e35856"></a><p class="title"><b>Example&nbsp;17.5.3-1.&nbsp;Aggressive Optimization of <code class="literal">final</code> Fields</b></p>
                  <div class="example-contents"><pre class="programlisting">
class A {
    final int x;
    A() { 
        x = 1; 
    } 

    int f() { 
        return d(this,this); 
    } 

    int d(A a1, A a2) { 
        int i = a1.x; 
        g(a1); 
        int j = a2.x; 
        return j - i; 
    }

    static void g(A a) { 
        // uses reflection to change a.x to 2 
    } 
}
</pre><p class="note">In the <code class="literal">d</code> method, the compiler is
                        allowed to reorder the reads of <code class="literal">x</code> and the call
                        to <code class="literal">g</code> freely. Thus, <code class="literal">new A().f()</code>
                        could return <code class="literal">-1</code>, <code class="literal">0</code>, or <code class="literal">1</code>.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-17.5.3-200"></a>An implementation may
                  provide a way to execute a block of code in
                  a <span class="emphasis"><em><code class="literal">final</code>-field-safe context</em></span>. If an object is
                  constructed within a <code class="literal">final</code>-field-safe context, the reads of a
                  <code class="literal">final</code> field of that object will not be reordered with modifications
                  of that <code class="literal">final</code> field that occur within that <code class="literal">final</code>-field-safe
                  context.
               </p>
               <p class="norm"><a name="jls-17.5.3-210"></a>A <code class="literal">final</code>-field-safe context
                  has additional protections. If a thread has seen an incorrectly
                  published reference to an object that allows the thread to see the
                  default value of a <code class="literal">final</code> field, and then, within a
                  <code class="literal">final</code>-field-safe context, reads a properly published reference to
                  the object, it will be guaranteed to see the correct value of the
                  <code class="literal">final</code> field. In the formalism, code executed within a
                  <code class="literal">final</code>-field-safe context is treated as a separate thread (for the
                  purposes of <code class="literal">final</code> field semantics only).
               </p>
               <p class="norm"><a name="jls-17.5.3-220"></a>In an implementation, a
                  compiler should not move an access to a <code class="literal">final</code> field into or out of a
                  <code class="literal">final</code>-field-safe context (although it can be moved around the
                  execution of such a context, so long as the object is not constructed
                  within that context).
               </p>
               <p class="note">One place where use of a <code class="literal">final</code>-field-safe context
                  would be appropriate is in an executor or thread pool. By executing
                  each <code class="literal">Runnable</code> in a separate <code class="literal">final</code>-field-safe
                  context, the executor could guarantee that incorrect access by
                  one <code class="literal">Runnable</code> to a object <span class="emphasis"><em>o</em></span> will not remove
                  <code class="literal">final</code> field guarantees for other <code class="literal">Runnable</code>s
                  handled by the same executor.
               </p>
            </div>
            <div class="section" title="17.5.4.&nbsp;Write-Protected Fields">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-17.5.4"></a>17.5.4.&nbsp;Write-Protected Fields
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-17.5.4-100"></a>Normally, a field that is
                  <code class="literal">final</code> and <code class="literal">static</code> may not be
                  modified. However, <code class="literal">System.in</code>, <code class="literal">System.out</code>,
                  and <code class="literal">System.err</code> are <code class="literal">static</code> <code class="literal">final</code> fields that,
                  for legacy reasons, must be allowed to be changed by the
                  methods <code class="literal">System.setIn</code>, <code class="literal">System.setOut</code>,
                  and <code class="literal">System.setErr</code>. We refer to these fields as
                  being <span class="emphasis"><em>write-protected</em></span> to distinguish them from
                  ordinary <code class="literal">final</code> fields.
               </p>
               <p class="norm"><a name="jls-17.5.4-110"></a>The compiler needs to treat
                  these fields differently from other <code class="literal">final</code> fields. For example, a
                  read of an ordinary <code class="literal">final</code> field is "immune" to synchronization: the
                  barrier involved in a lock or volatile read does not have to affect
                  what value is read from a <code class="literal">final</code> field. Since the value of
                  write-protected fields may be seen to change, synchronization events
                  should have an effect on them. Therefore, the semantics dictate that
                  these fields be treated as normal fields that cannot be changed by
                  user code, unless that user code is in the <code class="literal">System</code>
                  class.
               </p>
            </div>
         </div>
         <div class="section" title="17.6.&nbsp;Word Tearing">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-17.6"></a>17.6.&nbsp;Word Tearing
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-17.6-100"></a>One consideration for
               implementations of the Java Virtual Machine is that every field and array element is
               considered distinct; updates to one field or element must not interact
               with reads or updates of any other field or element. In particular,
               two threads that update adjacent elements of a byte array separately
               must not interfere or interact and do not need synchronization to
               ensure sequential consistency.
            </p>
            <p class="norm"><a name="jls-17.6-110"></a>Some processors do not provide
               the ability to write to a single byte. It would be illegal to
               implement byte array updates on such a processor by simply reading an
               entire word, updating the appropriate byte, and then writing the
               entire word back to memory. This problem is sometimes known
               as <span class="emphasis"><em>word tearing</em></span>, and on processors that cannot
               easily update a single byte in isolation some other approach will be
               required.
            </p>
            <div class="example"><a name="d5e35918"></a><p class="title"><b>Example&nbsp;17.6-1.&nbsp;Detection of Word Tearing</b></p>
               <div class="example-contents">
                  <p class="note">The following program is a test case to detect word
                     tearing:
                  </p><pre class="programlisting">
public class WordTearing extends Thread { 
    static final int LENGTH = 8;
    static final int ITERS  = 1000000; 
    static byte[] counts    = new byte[LENGTH]; 
    static Thread[] threads = new Thread[LENGTH]; 

    final int id; 
    WordTearing(int i) { 
        id = i; 
    }

    public void run() { 
        byte v = 0; 
        for (int i = 0; i &lt; ITERS; i++) { 
            byte v2 = counts[id]; 
            if (v != v2) { 
                System.err.println("Word-Tearing found: " + 
                              "counts[" + id + "] = "+ v2 +
                              ", should be " + v); 
                return; 
            } 
            v++; 
            counts[id] = v; 
        } 
    }

    public static void main(String[] args) { 
        for (int i = 0; i &lt; LENGTH; ++i) 
            (threads[i] = new WordTearing(i)).start(); 
    } 
}
</pre><p class="note">This makes the point that bytes must not be
                     overwritten by writes to adjacent bytes.
                  </p>
               </div>
            </div><br class="example-break"></div>
         <div class="section" title="17.7.&nbsp;Non-Atomic Treatment of double and long">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-17.7"></a>17.7.&nbsp;Non-Atomic Treatment of <code class="literal">double</code> and <code class="literal">long</code></h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-17.7-100"></a>For the purposes of the
               Java programming language memory model, a single write to a non-volatile <code class="literal">long</code> or
               <code class="literal">double</code> value is treated as two separate writes: one to each 32-bit
               half. This can result in a situation where a thread sees the first 32
               bits of a 64-bit value from one write, and the second 32 bits from
               another write.
            </p>
            <p class="norm"><a name="jls-17.7-110"></a>Writes and reads of volatile
               <code class="literal">long</code> and <code class="literal">double</code> values are always atomic.
            </p>
            <p class="norm"><a name="jls-17.7-120"></a>Writes to and reads of
               references are always atomic, regardless of whether they are
               implemented as 32-bit or 64-bit values.
            </p>
            <p class="note">Some implementations may find it convenient to
               divide a single write action on a 64-bit <code class="literal">long</code> or <code class="literal">double</code> value into
               two write actions on adjacent 32-bit values. For efficiency's sake,
               this behavior is implementation-specific; an implementation of the
               Java Virtual Machine is free to perform writes to <code class="literal">long</code> and <code class="literal">double</code> values
               atomically or in two parts.
            </p>
            <p class="note">Implementations of the Java Virtual Machine are encouraged to avoid
               splitting 64-bit values where possible. Programmers are encouraged to
               declare shared 64-bit values as <code class="literal">volatile</code> or synchronize their
               programs correctly to avoid possible complications.
            </p>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-16.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-18.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;16.&nbsp;Definite Assignment&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;18.&nbsp;Type Inference</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="spec-frontmatter.html">
                Legal Notice
              </a></div>
   </body>
</html>