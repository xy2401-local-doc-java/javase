<html>
<head>
<title> Packages</title>
<meta name="collection" content="community">
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="names.html">Prev</a> | <a href="classes.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>
 
<a name="34412"></a>
<p><strong>
CHAPTER
 7 </strong></p>
<a name="60384"></a>
<h1>Packages</h1>
<hr><p>
<a name="61541"></a>
Programs are organized as sets of packages. Each package has its own set of names for types, which helps to prevent name conflicts. A top level type is accessible <a href="names.html#104285">(&#167;6.6)</a> outside the package that declares it only if the type is declared <code>public</code>.<p>
<a name="26517"></a>
The naming structure for packages is hierarchical <a href="packages.html#26535">(&#167;7.1)</a>. The members of a package are class and interface types <a href="packages.html#26783">(&#167;7.6)</a>, which are declared in compilation units of the package, and subpackages, which may contain compilation units and subpackages of their own.<p>
<a name="93733"></a>
A package can be stored in a file system <a href="packages.html#37546">(&#167;7.2.1)</a> or in a database <a href="packages.html#37739">(&#167;7.2.2)</a>. Packages that are stored in a file system may have certain constraints on the organization of their compilation units to allow a simple implementation to find classes easily.<p>
<a name="26522"></a>
A package consists of a number of compilation units <a href="packages.html#40031">(&#167;7.3)</a>. A compilation unit automatically has access to all types declared in its package and also automatically imports<em> </em>all of the public types declared in the predefined package <code>java.lang</code>.<p>
<a name="26526"></a>
<p>For small programs and casual development, a package can be unnamed <a href="packages.html#103097">(&#167;7.4.2)</a> or have a simple name, but if code is to be widely distributed, unique package names should be chosen <a href="packages.html#40169">(&#167;7.7)</a>. This can prevent the conflicts that would otherwise occur if two development groups happened to pick the same package name and these packages were later to be used in a single program.</p>
<a name="26535"></a>
<a name="7.1"></a>
<h2>7.1    Package Members</h2>
<a name="103587"></a>
The members of a package are its subpackages and all the top level <a href="packages.html#26783">(&#167;7.6)</a> class types <a href="classes.html#29542">(&#167;8)</a> and top level interface types <a href="interfaces.html#29542">(&#167;9)</a> declared in all the compilation units <a href="packages.html#40031">(&#167;7.3)</a> of the package.<p>
<a name="85252"></a>
For example, in the Java Application Programming Interface:<p>
<ul><a name="37559"></a>
<li>The package <code>java</code> has subpackages <code>awt</code>, <code>applet</code>, <code>io</code>, <code>lang</code>, <code>net</code>, and <code>util</code>, but no compilation units.
<a name="37560"></a>
<li>The package <code>java.awt</code> has a subpackage named <code>image</code>, as well as a number of compilation units containing declarations of class and interface types.
</ul><a name="13127"></a>
If the fully qualified name <a href="names.html#25430">(&#167;6.7)</a> of a package is <i>P</i>, and <i>Q</i> is a subpackage of <i>P</i>, then <i>P</i>.<i>Q</i> is the fully qualified name of the subpackage.<p>
<a name="77109"></a>
A package may not contain two members of the same name, or a compile-time error results. <p>
<a name="77111"></a>
<p>Here are some examples:</p>
<ul><a name="37575"></a>
<li>Because the package <code>java.awt</code> has a subpackage <code>image</code>, it cannot (and does not) contain a declaration of a class or interface type named <code>image</code>.
<a name="73657"></a>
<li>If there is a package named <code>mouse</code> and a member type <code>Button</code> in that package (which then might be referred to as <code>mouse.Button</code>), then there cannot be any package with the fully qualified name <code>mouse.Button</code> or <code>mouse.Button.Click</code>.
<a name="103056"></a>
<li>If <code>com.sun.java.jag</code> is the fully qualified name of a type, then there cannot be any package whose fully qualified name is either <code>com.sun.java.jag</code> or <code>com.sun.java.jag.scrabble</code>.
</ul>
<a name="73659"></a>
<p>The hierarchical naming structure for packages is intended to be convenient for organizing related packages in a conventional manner, but has no significance in itself other than the prohibition against a package having a subpackage with the same simple name as a top level type <a href="packages.html#26783">(&#167;7.6)</a> declared in that package. There is no special access relationship between a package named <code>oliver</code> and another package named <code>oliver.twist</code>, or between packages named <code>evelyn.wood</code> and <code>evelyn.waugh</code>. For example, the code in a package named <code>oliver.twist</code> has no better access to the types declared within package <code>oliver</code> than code in any other package.</p>
<a name="37758"></a>
<a name="7.2"></a>
<h2>7.2    Host Support for Packages</h2>
<a name="37780"></a>
Each host determines how packages, compilation units, and subpackages are created and stored, and which compilation units are observable <a href="packages.html#40031">(&#167;7.3)</a> in a particular compilation. <p>
<a name="89673"></a>
<p>The observability of compilation units in turn determines which packages are observable, and which packages are in scope.</p>
<a name="73467"></a>
<p>The packages may be stored in a local file system in simple implementations of the Java platform. Other implementations may use a distributed file system or some form of database to store source and/or binary code.</p>
<a name="37546"></a>
<a name="7.2.1"></a>
<h3>7.2.1    Storing Packages in a File System</h3>
<a name="37463"></a>
As an extremely simple example, all the packages and source and binary code on a system might be stored in a single directory and its subdirectories. Each immediate subdirectory of this directory would represent a top level package, that is, one whose fully qualified name consists of a single simple name. The directory might contain the following immediate subdirectories:<p>
<blockquote><pre>com
gls
jag
java
wnj
</pre></blockquote><a name="37477"></a>
where directory <code>java</code> would contain the Java Application Programming Interface packages; the directories <code>jag</code>, <code>gls</code>, and <code>wnj</code> might contain packages that three of the authors of this specification created for their personal use and to share with each other within this small group; and the directory <code>com</code> would contain packages procured from companies that used the conventions described in <a href="packages.html#40169">&#167;7.7</a> to generate unique names for their packages.<p>
<a name="37480"></a>
<p>Continuing the example, the directory <code>java</code> would contain, among others, the following subdirectories:</p>
<blockquote><pre>applet 
awt
io
lang
net
util
</pre></blockquote><a name="37490"></a>
corresponding to the packages <code>java.applet</code>, <code>java.awt</code>, <code>java.io</code>, <code>java.lang</code>, <code>java.net</code>, and <code>java.util</code> that are defined as part of the Java Application Programming Interface.<p>
<a name="37491"></a>
<p>Still continuing the example, if we were to look inside the directory <code>util</code>, we might see the following files:</p>
<blockquote><pre>
BitSet.java                             Observable.java
BitSet.class                            Observable.class
Date.java                               Observer.java
Date.class                              Observer.class
...
</pre></blockquote><a name="37466"></a>
where each of the <code>.java</code> files contains the source for a compilation unit <a href="packages.html#40031">(&#167;7.3)</a> that contains the definition of a class or interface whose binary compiled form is contained in the corresponding <code>.class</code> file.<p>
<a name="37599"></a>
<p>Under this simple organization of packages, an implementation of the Java platform would transform a package name into a pathname by concatenating the components of the package name, placing a file name separator (directory indicator) between adjacent components. </p>
<a name="91586"></a>
<p>For example, if this simple organization were used on a UNIX system, where the file name separator is <code>/</code>, the package name:</p>
<blockquote><pre>jag.scrabble.board
</pre></blockquote><a name="37601"></a>
would be transformed into the directory name:<p>
<blockquote><pre>jag/scrabble/board
</pre></blockquote><a name="37603"></a>
and:<p>
<blockquote><pre>com.sun.sunsoft.DOE
</pre></blockquote><a name="37605"></a>
would be transformed to the directory name:<p>
<blockquote><pre><code>com/sun/sunsoft/DOE
</code></pre></blockquote><a name="77903"></a>
<p>A package name component or class name might contain a character that cannot correctly appear in a host file system's ordinary directory name, such as a Unicode character on a system that allows only ASCII characters in file names. As a convention, the character can be escaped by using, say, the <code>@</code> character followed by four hexadecimal digits giving the numeric value of the character, as in the <code>\u</code><i>xxxx</i> escape <a href="lexical.html#100850">(&#167;3.3)</a>, so that the package name:</p>
<blockquote><pre>
children.activities.crafts.papierM\u00e2ch\u00e9
</pre></blockquote><a name="77910"></a>
which can also be written using full Unicode as:<p>
<blockquote><pre>children.activities.crafts.papierM&acirc;ch&eacute;
</pre></blockquote><a name="37616"></a>
might be mapped to the directory name:<p>
<blockquote><pre>children/activities/crafts/papierM@00e2ch@00e9
</pre></blockquote><a name="37618"></a>
If the <code>@</code> character is not a valid character in a file name for some given host file system, then some other character that is not valid in a identifier could be used instead.<p>
<a name="37739"></a>
<a name="7.2.2"></a>
<h3>7.2.2    Storing Packages in a Database</h3>
<a name="37740"></a>
A host system may store packages and their compilation units and subpackages in a database.<p>
<a name="85462"></a>
<p>Such a database must not impose the optional restrictions <a href="packages.html#26783">(&#167;7.6)</a> on compilation units in file-based implementations. For example, a system that uses a database to store packages may not enforce a maximum of one <code>public</code> class or interface per compilation unit.</p>
<a name="74243"></a>
Systems that use a database must, however, provide an option to convert a program to a form that obeys the restrictions, for purposes of export to file-based implementations.<p>
<a name="40031"></a>
<a name="7.3"></a>
<h2>7.3    Compilation Units</h2>
<a name="26594"></a>
<em>CompilationUnit </em>is the goal symbol <a href="grammars.html#40415">(&#167;2.1)</a> for the syntactic grammar <a href="grammars.html#151185">(&#167;2.3)</a> of Java programs. It is defined by the following productions:<p>
<blockquote><pre>
<em>CompilationUnit:
        PackageDeclaration<sub>opt</sub> ImportDeclarations<sub>opt</sub> TypeDeclarations<sub>opt</sub>
ImportDeclarations:
        ImportDeclaration
        ImportDeclarations ImportDeclaration

TypeDeclarations:
        TypeDeclaration
        TypeDeclarations TypeDeclaration
        </em>
</pre></blockquote><a name="24124"></a>
Types declared in different compilation units can depend on each other, circularly. A Java compiler must arrange to compile all such types at the same time.<p>
<a name="35022"></a>
A <em>compilation unit</em> consists of three parts, each of which is optional:<p>
<ul><a name="35029"></a>
<li>A <code>package</code> declaration <a href="packages.html#26619">(&#167;7.4)</a>, giving the fully qualified name <a href="names.html#25430">(&#167;6.7)</a> of the package to which the compilation unit belongs. A compilation unit that has no package declaration is part of an unnamed package <a href="packages.html#103097">(&#167;7.4.2)</a>.
<a name="35033"></a>
<li><code>import</code> declarations <a href="packages.html#70209">(&#167;7.5)</a> that allow types from other packages and static members of types to be referred to using their simple names
<a name="35037"></a>
<li>Top level type declarations <a href="packages.html#26783">(&#167;7.6)</a> of class and interface types
</ul><a name="70276"></a>
Which compilation units are <em>observable</em> is determined by the host system. However, all the compilation units of the package <code>java</code> and its subpackages <code>lang</code> and <code>io</code> must always be observable. The observability of a compilation unit influences the observability of its package <a href="packages.html#13180">(&#167;7.4.3)</a>.<p>
<a name="26614"></a>
Every compilation unit automatically and implicitly imports every <code>public</code> type name declared by the predefined package <code>java.lang</code>, so that the names of all those types are available as simple names, as described in <a href="packages.html#93721">&#167;7.5.5</a>.<p>
<a name="26619"></a>
<a name="7.4"></a>
<h2>7.4    Package Declarations</h2>
<a name="35052"></a>
A package declaration appears within a compilation unit to indicate the package to which the compilation unit belongs.<p>
<a name="26621"></a>
<a name="7.4.1"></a>
<h3>7.4.1    Named Packages</h3>
<a name="26626"></a>
A <em>package declaration</em> in a compilation unit specifies the name <a href="names.html#31692">(&#167;6.2)</a> of the package to which the compilation unit belongs.<p>
<blockquote><pre>
<em>PackageDeclaration:
        Annotations<sub>opt</sub> </em><code>package</code><em> PackageName ;</em>
</pre></blockquote><a name="26629"></a>
The keyword <code>package</code> may optionally be preceded by annotation modifiers <a href="interfaces.html#253695">(&#167;9.7)</a>. If an annotation <i>a</i> on a package declaration corresponds to an annotation type<i> T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.PACKAGE</code>, or a compile-time error occurs.<p>
<a name="97206"></a>
The package name mentioned in a package declaration must be the fully qualified name <a href="names.html#25430">(&#167;6.7)</a> of the package.<p>
<a name="97186"></a>
<a name="7.4.1.1"></a>
<h4>7.4.1.1    Package Annotations</h4>
<a name="97192"></a>
Annotations may be used on package declarations, with the restriction that at most one annotated package declaration is permitted for a given package. <p>
<hr>
<a name="97373"></a>
 <p>
 <b>Discussion</b>
 </p>
<a name="97374"></a>
 The manner in which this restriction is enforced must, of necessity, vary from implementation to implementation. The following scheme is strongly recommended for file-system-based implementations: The sole annotated package declaration, if it exists, is placed in a source file called <code>package-info.java</code> in the directory containing the source files for the package. This file does not contain the source for a class called package-info.java; indeed it would be illegal for it to do so, as package-info is not a legal identifier. Typically <code>package-info.java</code> contains only a package declaration, preceded immediately by the annotations on the package. While the file could technically contain the source code for one or more package-private classes, it would be very bad form. <p>
<a name="97193"></a>
It is recommended that <code>package-info.java</code>, if it is present, take the place of <code>package.html</code> for javadoc and other similar documentation generation systems. If this file is present, the documentation generation tool should look for the package documentation comment immediately preceding the (possibly annotated) package declaration in <code>package-info.java</code>. In this way, package-info.java becomes the sole repository for package level annotations and documentation. If, in future, it becomes desirable to add any other package-level information, this file should prove a convenient home for this information. <p>
<hr>
<a name="97187"></a>
 <p>
<a name="103100"></a>
<p>
<a name="103097"></a>
<a name="7.4.2"></a>
<h3>7.4.2    Unnamed Packages</h3>
<a name="70410"></a>
A compilation unit that has no package declaration is part of an unnamed package. <p>
<a name="73463"></a>
<p>Note that an unnamed package cannot have subpackages, since the syntax of a package declaration always includes a reference to a named top level package.</p>
<a name="73468"></a>
As an example, the compilation unit:<p>
<blockquote><pre>class FirstCall {
        public static void main(String[] args) {
                System.out.println("Mr. Watson, come here. "
                                        + "I want you.");
        }
}
</pre></blockquote><a name="35114"></a>
defines a very simple compilation unit as part of an unnamed package.<p>
<a name="73470"></a>
An implementation of the Java platform must support at least one unnamed package; it may support more than one unnamed package but is not required to do so. Which compilation units are in each unnamed package is determined by the host system.<p>
<a name="73469"></a>
<p>In implementations of the Java platform that use a hierarchical file system for storing packages, one typical strategy is to associate an unnamed package with each directory; only one unnamed package is observable at a time, namely the one that is associated with the "current working directory." The precise meaning of "current working directory" depends on the host system.</p>
<a name="73471"></a>
<p>Unnamed packages are provided by the Java platform principally for convenience when developing small or temporary applications or when just beginning development.</p>
<a name="13180"></a>
<a name="7.4.3"></a>
<h3>7.4.3    Observability of a Package</h3>
<a name="70173"></a>
A package is <em>observable</em> if and only if either:<p>
<ul><a name="70174"></a>
<li>A compilation unit containing a declaration of the package is observable.
<a name="70175"></a>
<li>A subpackage of the package is observable.
<a name="89676"></a>
</ul>
<p>One can conclude from the rule above and from the requirements on observable compilation units, that the packages <code>java</code>, <code>java.lang</code>, and <code>java.io</code> are always observable.</p>
<a name="70172"></a>
<a name="7.4.4"></a>
<h3>7.4.4    Scope of a Package Declaration</h3>
<a name="103604"></a>
The scope of the declaration of an observable <a href="packages.html#13180">(&#167;7.4.3)</a> top level package is all observable compilation units <a href="packages.html#40031">(&#167;7.3)</a>. The declaration of a package that is not observable is never in scope. Subpackage declarations are never in scope.<p>
<a name="87388"></a>
<p>It follows that the package <code>java</code> is always in scope <a href="names.html#103228">(&#167;6.3)</a>.</p>
<a name="103625"></a>
Package declarations never shadow other declarations.<p>
<a name="70209"></a>
<a name="7.5"></a>
<h2>7.5    Import Declarations</h2>
<a name="92728"></a>
An <em>import declaration</em> allows a static member or a named type to be referred to by a simple name <a href="names.html#31692">(&#167;6.2)</a> that consists of a single identifier. Without the use of an appropriate <code>import</code> declaration, the only way to refer to a type declared in another package, or a static member of another type, is to use a fully qualified name <a href="names.html#25430">(&#167;6.7)</a>.<p>
<blockquote><pre>
<em>ImportDeclaration:
        SingleTypeImportDeclaration
        TypeImportOnDemandDeclaration   
        SingleStaticImportDeclaration   
        StaticImportOnDemandDeclaration
        </em>
</pre></blockquote><a name="99931"></a>
A single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> imports a single named type, by mentioning its canonical name <a href="names.html#25430">(&#167;6.7)</a>. <p>
<a name="96277"></a>
A type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> imports all the accessible <a href="names.html#104285">(&#167;6.6)</a> types of a named type or package as needed. It is a compile time error to import a type from the unnamed package. <p>
<a name="94659"></a>
A single static import declaration <a href="packages.html#26741">(&#167;7.5.3)</a> imports all accessible static members with a given name from a type, by giving its canonical name.<p>
<a name="94662"></a>
A static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a> imports all accessible static members of a named type as needed.<p>
<a name="103634"></a>
The scope of a type imported by a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> or a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> is all the class and interface type declarations <a href="packages.html#26783">(&#167;7.6)</a> in the compilation unit in which the import declaration appears.<p>
<a name="103647"></a>
The scope of a member imported by a single-static-import declaration <a href="packages.html#26741">(&#167;7.5.3)</a> or a static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a> is all the class and interface type declarations <a href="packages.html#26783">(&#167;7.6)</a> in the compilation unit in which the import declaration appears.<p>
<a name="69951"></a>
An <code>import</code> declaration makes types available by their simple names only within the compilation unit that actually contains the <code>import</code> declaration. The scope of the entities(s) it introduces specifically does not include the <code>package</code> statement, other <code>import</code> declarations in the current compilation unit, or other compilation units in the same package. See <a href="packages.html#24151">&#167;7.5.6</a> for an illustrative example.<p>
<a name="26699"></a>
<a name="7.5.1"></a>
<h3>7.5.1    Single-Type-Import Declaration</h3>
<a name="13275"></a>
A <em>single-type-import declaration </em>imports a single type by giving its canonical name, making it available under a simple name in the class and interface declarations of the compilation unit in which the single-type import declaration appears.<p>
<blockquote><pre>
<em>SingleTypeImportDeclaration:
</em>   import<em> TypeName ;</em>
</pre></blockquote><a name="29086"></a>
The <em>TypeName</em> must be the canonical name of a class or interface type; a compile-time error occurs if the named type does not exist. The named type must be accessible <a href="names.html#104285">(&#167;6.6)</a> or a compile-time error occurs.<p>
<a name="103573"></a>
A single-type-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a type named <i>n</i> shadows the declarations of:<p>
<ul><a name="103575"></a>
<li>any top level type named <i>n</i> declared in another compilation unit of <i>p</i>.
<a name="103576"></a>
<li>any type named <i>n</i> imported by a type-import-on-demand declaration in <i>c.</i>
<a name="103577"></a>
<li>any type named <i>n</i> imported by a static-import-on-demand declaration in <i>c</i>.
</ul><a name="103578"></a>
throughout <i>c.</i><p>
<a name="37971"></a>
<p>The example:</p>
<blockquote><pre>import java.util.Vector;
</pre></blockquote><a name="98784"></a>
causes the simple name <code>Vector</code> to be available within the class and interface declarations in a compilation unit. Thus, the simple name <code>Vector</code> refers to the type declaration <code>Vector</code> in the package <code>java.util</code> in all places where it is not shadowed <a href="names.html#34133">(&#167;6.3.1)</a> or obscured <a href="names.html#104058">(&#167;6.3.2)</a> by a declaration of a field, parameter, local variable, or nested type declaration with the same name.<p>
<a name="98792"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="98793"></a>
 Note that <code>Vector</code> is declared as a generic type. Once imported, the name <code>Vector</code> can be used without qualification in a parameterized type such as <code>Vector&lt;String&gt;,</code> or as the raw type <code>Vector.</code><p>
<a name="98794"></a>
This highlights a limitation of the <code>import</code> declaration. A type nested inside a generic type declaration can be imported, but its outer type is always erased.<p>
<hr>
<a name="98766"></a>
 <p>
<a name="103720"></a>
If two single-type-import declarations in the same compilation unit attempt to import types with the same simple name, then a compile-time error occurs, unless the two types are the same type, in which case the duplicate declaration is ignored. If the type imported by the the single-type-import declaration is declared in the compilation unit that contains the import declaration, the import declaration is ignored. If a compilation unit contains both a single-static-import <a href="packages.html#26741">(&#167;7.5.3)</a> declaration that imports a type whose simple name is <i>n</i>, and a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> that imports a type whose simple name is <i>n</i>, a compile-time error occurs. <p>
<a name="103501"></a>
If another top level type with the same simple name is otherwise declared in the current compilation unit except by a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> or a static-import-on-demand declaration <a href="packages.html#94114">(&#167;7.5.4)</a>, then a compile-time error occurs.<p>
<a name="97378"></a>
So the sample program:<p>
<blockquote><pre>import java.util.Vector;
class Vector { Object[] vec; }
</pre></blockquote><a name="29137"></a>
causes a compile-time error because of the duplicate declaration of <code>Vector</code>, as does:<p>
<blockquote><pre>import java.util.Vector;
import myVector.Vector;
</pre></blockquote><a name="29140"></a>
where <code>myVector</code> is a package containing the compilation unit:<p>
<blockquote><pre>package myVector;
public class Vector { Object[] vec; }
</pre></blockquote><a name="73475"></a>
The compiler keeps track of types by their binary names <a href="binaryComp.html#44909">(&#167;13.1)</a>.<p>
<a name="60471"></a>
<p>Note that an import statement cannot import a subpackage, only a type. For example, it does not work to try to import <code>java.util</code> and then use the name <code>util.Random</code> to refer to the type <code>java.util.Random</code>:</p>
<blockquote><pre>import java.util;              // incorrect: compile-time error
class Test { util.Random generator; }
</pre></blockquote><a name="26725"></a>
<a name="7.5.2"></a>
<h3>7.5.2    Type-Import-on-Demand Declaration</h3>
<a name="26727"></a>
A <em>type-import-on-demand declaration</em> allows all accessible <a href="names.html#104285">(&#167;6.6)</a> types declared in the type or package named by a canonical name to be imported as needed.<p>
<blockquote><pre>
<em>TypeImportOnDemandDeclaration:
        </em>import<em> PackageOrTypeName . * ;</em>
</pre></blockquote><a name="99324"></a>
It is a compile-time error for a type-import-on-demand declaration to name a type or package that is not accessible. Two or more type-import-on-demand declarations in the same compilation unit may name the same type or package. All but one of these declarations are considered <i>redundant</i>; the effect is as if that type was imported only once.<p>
<a name="103752"></a>
If a compilation unit contains both a static-import-on-demand declaration and a type-import-on-demand <a href="packages.html#26725">(&#167;7.5.2)</a> declaration that name the same type, the effect is as if the static member types of that type were imported only once.<p>
<a name="103759"></a>
<p>
<a name="94574"></a>
It is not a compile-time error to name the current package or <code>java.lang</code> in a type-import-on-demand declaration. The type-import-on-demand declaration is ignored in such cases.<p>
<a name="103680"></a>
A type-import-on-demand declaration never causes any other declaration to be shadowed.<p>
<a name="91265"></a>
The example:<p>
<blockquote><pre>import java.util.*;
</pre></blockquote><a name="35216"></a>
causes the simple names of all <code>public</code> types declared in the package <code>java.util</code> to be available within the class and interface declarations of the compilation unit. Thus, the simple name <code>Vector</code> refers to the type <code>Vector</code> in the package <code>java.util</code> in all places in the compilation unit where that type declaration is not shadowed <a href="names.html#34133">(&#167;6.3.1)</a> or obscured <a href="names.html#104058">(&#167;6.3.2)</a>. The declaration might be shadowed by a single-type-import declaration of a type whose simple name is <code>Vector</code>; by a type named <code>Vector</code> and declared in the package to which the compilation unit belongs; or any nested classes or interfaces. The declaration might be obscured by a declaration of a field, parameter, or local variable named <code>Vector </code>(It would be unusual for any of these conditions to occur.)<p>
<a name="26741"></a>
<a name="7.5.3"></a>
<h3>7.5.3    Single Static Import Declaration</h3>
<a name="94141"></a>
A <em>single-static-import declaration </em>imports all accessible <a href="names.html#104285">(&#167;6.6)</a> static members with a given simple name from a type. This makes these static members available under their simple name in the class and interface declarations of the compilation unit in which the single-static import declaration appears.<p>
<blockquote><pre>
<em>SingleStaticImportDeclaration:
        </em>import static<em> TypeName . Identifier;</em>
</pre></blockquote><a name="93862"></a>
The <em>TypeName</em> must be the canonical name of a class or interface type; a compile-time error occurs if the named type does not exist. The named type must be accessible <a href="names.html#104285">(&#167;6.6)</a> or a compile-time error occurs. The Identifier must name at least one static member of the named type; a compile-time error occurs if there is no member of that name or if all of the named members are not accessible.<p>
<a name="103685"></a>
A single-static-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a field named <i>n</i> shadows the declaration of any static field named <i>n</i> imported by a static-import-on-demand declaration in <i>c</i>, throughout <i>c.</i><p>
<a name="103688"></a>
A single-static-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a method named <i>n</i> with signature s shadows the declaration of any static method named <i>n</i> with signature <i>s </i>imported by a static-import-on-demand declaration in <i>c</i>, throughout <i>c.</i><p>
<a name="103691"></a>
A single-static-import declaration <i>d</i> in a compilation unit <i>c</i> of package <i>p</i> that imports a type named <i>n</i> shadows the declarations of:<p>
<ul><a name="103693"></a>
<li>any static type named <i>n</i> imported by a static-import-on-demand declaration in <i>c.</i>
<a name="103700"></a>
<li>any top level type <a href="packages.html#26783">(&#167;7.6)</a> named <i>n</i> declared in another compilation unit <a href="packages.html#40031">(&#167;7.3)</a> of <i>p</i>.
<a name="103704"></a>
<li>any type named <i>n</i> imported by a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> in <i>c</i>.
</ul><a name="103705"></a>
throughout <i>c.</i><p>
<a name="94681"></a>
Note that it is permissable for one single-static-import declaration to import several fields or types with the same name, or several methods with the same name and signature.<p>
<a name="103711"></a>
If a compilation unit contains both a single-static-import <a href="packages.html#26741">(&#167;7.5.3)</a> declaration that imports a type whose simple name is <i>n</i>, and a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> that imports a type whose simple name is <i>n</i>, a compile-time error occurs. <p>
<a name="93986"></a>
If a single-static-import declaration imports a type whose simple name is <i>n</i>, and the compilation unit also declares a top level type <a href="packages.html#26783">(&#167;7.6)</a> whose simple name is <i>n</i>, a compile-time error occurs.<p>
<a name="94114"></a>
<a name="7.5.4"></a>
<h3>7.5.4    Static-Import-on-Demand Declaration</h3>
<a name="94122"></a>
A <em>static-import-on-demand declaration</em> allows all accessible <a href="names.html#104285">(&#167;6.6)</a> static members declared in the type named by a canonical name to be imported as needed.<p>
<blockquote><pre>
<em>StaticImportOnDemandDeclaration:
        </em> import static<em> TypeName . * ;</em>
</pre></blockquote><a name="93770"></a>
It is a compile-time error for a static-import-on-demand declaration to name a type that does not exist or a type that is not accessible. Two or more static-import-on-demand declarations in the same compilation unit may name the same type or package; the effect is as if there was exactly one such declaration. Two or more static-import-on-demand declarations in the same compilation unit may name the same member; the effect is as if the member was imported exactly once.<p>
<a name="94775"></a>
Note that it is permissable for one static-import-on-demand declaration to import several fields or types with the same name, or several methods with the same name and signature.<p>
<a name="103726"></a>
If a compilation unit contains both a static-import-on-demand declaration and a type-import-on-demand <a href="packages.html#26725">(&#167;7.5.2)</a> declaration that name the same type, the effect is as if the static member types of that type were imported only once.<p>
<a name="103733"></a>
<p>
<a name="103568"></a>
A static-import-on-demand declaration never causes any other declaration to be shadowed.<p>
<a name="103349"></a>
<p>
<a name="93757"></a>
<p>
<a name="93721"></a>
<a name="7.5.5"></a>
<h3>7.5.5    Automatic Imports</h3>
<a name="26743"></a>
Each compilation unit automatically imports all of the<em> </em>public type names declared in the predefined package<em> </em>java.lang, as if the declaration:<p>
<blockquote><pre>import java.lang.*;
</pre></blockquote><a name="26745"></a>
appeared at the beginning of each compilation unit, immediately following any <code>package</code> statement.<p>
<a name="103101"></a>
<p>
<a name="24151"></a>
<a name="7.5.6"></a>
<h3>7.5.6    A Strange Example</h3>
<a name="24152"></a>
Package names and type names are usually different under the naming conventions described in <a href="names.html#73307">&#167;6.8</a>. Nevertheless, in a contrived example where there is an unconventionally-named package <code>Vector</code>, which declares a <code>public</code> class whose <p>
<a name="103175"></a>
<p>
<a name="103176"></a>
name is <code>Mosquito</code>:<p>
<blockquote><pre>package Vector;
public class Mosquito { int capacity; }
</pre></blockquote><a name="24158"></a>
and then the compilation unit:<p>
<blockquote><pre>package strange.example;
import java.util.Vector;
import Vector.Mosquito;
class Test {
        public static void main(String[] args) {
                System.out.println(new Vector().getClass());
                System.out.println(new Mosquito().getClass());
        }
}
</pre></blockquote><a name="24170"></a>
the single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> importing class <code>Vector</code> from package <code>java.util</code> does not prevent the package name <code>Vector</code> from appearing and being correctly recognized in subsequent <code>import</code> declarations. The example compiles and produces the output:<p>
<blockquote><pre>class java.util.Vector
class Vector.Mosquito
</pre></blockquote><a name="26783"></a>
<a name="7.6"></a>
<h2>7.6    Top Level Type Declarations</h2>
<a name="26790"></a>
A <em>top level type declaration</em> declares a top level class type <a href="classes.html#29542">(&#167;8)</a> or a top level interface type <a href="interfaces.html#238678">(&#167;9)</a>: <p>
<blockquote><pre>
<em>TypeDeclaration:
        ClassDeclaration
        InterfaceDeclaration
        ;</em>
</pre></blockquote><a name="70047"></a>
By default, the top level types declared in a package are accessible only within the compilation units of that package, but a type may be declared to be <code>public</code> to grant access to the type from code in other packages (<a href="names.html#104285">&#167;6.6</a>, <a href="classes.html#21613">&#167;8.1.1</a>, <a href="interfaces.html#235947">&#167;9.1.1</a>).<p>
<a name="103666"></a>
The scope of a top level type is all type declarations in the package in which the top level type is declared.<p>
<a name="103671"></a>
If a top level type named <i>T</i> is declared in a compilation unit of a package whose fully qualified name is <i>P</i>, then the fully qualified name of the type is <i>P</i>.<i>T</i>.<i> </i>If the type is declared in an unnamed package <a href="packages.html#103097">(&#167;7.4.2)</a>, then the type has the fully qualified name <i>T</i>.<p>
<a name="103452"></a>
<p>
<a name="103128"></a>
<p>
<a name="103129"></a>
Thus in the example:<p>
<blockquote><pre>package wnj.points;
class Point { int x, y; }
</pre></blockquote><a name="70050"></a>
the fully qualified name of class <code>Point</code> is <code>wnj.points.Point</code>. <p>
<a name="26802"></a>
An implementation of the Java platform must keep track of types within packages by their binary names <a href="binaryComp.html#44909">(&#167;13.1)</a>. Multiple ways of naming a type must be expanded to binary names to make sure that such names are understood as referring to the same type. <p>
<a name="73490"></a>
<p>For example, if a compilation unit contains the single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a>:</p>
<a name="103107"></a>
<p></p>
<blockquote><pre>import java.util.Vector;
</pre></blockquote><a name="26807"></a>
<p>
<a name="103106"></a>
then within that compilation unit the simple name <code>Vector</code> and the fully qualified name <code>java.util.Vector</code> refer to the same type.<p>
<a name="73491"></a>
When packages are stored in a file system <a href="packages.html#37546">(&#167;7.2.1)</a>, the host system may choose to enforce the restriction that it is a compile-time error if a type is not found in a file under a name composed of the type name plus an extension (such as <code>.java</code> or <code>.jav</code>) if either of the following is true:<p>
<ul><a name="40155"></a>
<li>The type is referred to by code in other compilation units of the package in which the type is declared.
<a name="40159"></a>
<li>The type is declared <code>public</code> (and therefore is potentially accessible from code in other packages).
</ul><a name="40156"></a>
<p>
<a name="103105"></a>
This restriction implies that there must be at most one such type per compilation unit. This restriction makes it easy for a compiler for the Java programming language or an implementation of the Java virtual machine to find a named class within a package; for example, the source code for a <code>public</code> type <code>wet.sprocket.Toad</code> would be found in a file <code>Toad.java</code> in the directory <code>wet/sprocket</code>, and the corresponding object code would be found in the file <code>Toad.class</code> in the same directory.<p>
<a name="97383"></a>
<p>When packages are stored in a database <a href="packages.html#37739">(&#167;7.2.2)</a>, the host system must not impose such restrictions. In practice, many programmers choose to put each class or interface type in its own compilation unit, whether or not it is public or is referred to by code in other compilation units.</p>
<a name="103291"></a>
A compile-time error occurs if the name of a top level type appears as the name of any other top level class or interface type declared in the same package <a href="packages.html#26783">(&#167;7.6)</a>.<p>
<a name="103295"></a>
A compile-time error occurs if the name of a top level type is also declared as a type by a single-type-import declaration <a href="packages.html#26699">(&#167;7.5.1)</a> in the compilation unit <a href="packages.html#40031">(&#167;7.3)</a> containing the type declaration.<p>
<a name="103304"></a>
<p>
<a name="103305"></a>
<p>
<a name="103306"></a>
<p>In the example:</p>
<blockquote><pre>class Point { int x, y; }
</pre></blockquote><a name="103308"></a>
the class Point is declared in a compilation unit with no package statement, and thus Point is its fully qualified name, whereas in the example:<p>
<blockquote><pre>package vista;
class Point { int x, y; }
</pre></blockquote><a name="103311"></a>
the fully qualified name of the class Point is <code>vista.Point</code>. (The package name vista is suitable for local or personal use; if the package were intended to be widely distributed, it would be better to give it a unique package name <a href="packages.html#40169">(&#167;7.7)</a>.)<p>
<a name="103316"></a>
<p>In the example:</p>
<blockquote><pre>package test;
import java.util.Vector;
class Point {
</pre></blockquote><pre><a name="103320"></a>   int x, y;
</pre><blockquote><pre>}
interface Point {                                                                                       // compile-time error #1
        int getR();
        int getTheta();
}
class Vector { Point[] pts; }                                                                                   // compile-time error #2
</pre></blockquote><a name="103327"></a>
<p>
<a name="103328"></a>
the first compile-time error is caused by the duplicate declaration of the name Point as both a class and an <code>interface</code> in the same package. A second error detected at compile time is the attempt to declare the name Vector both by a class type declaration and by a single-type-import declaration.<p>
<a name="103329"></a>
<p>Note, however, that it is not an error for the name of a class to also to name a type that otherwise might be imported by a type-import-on-demand declaration <a href="packages.html#26725">(&#167;7.5.2)</a> in the compilation unit <a href="packages.html#40031">(&#167;7.3)</a> containing the class declaration. In the example:</p>
<a name="103336"></a>
<p></p>
<blockquote><pre>package test;
import java.util.*;
class Vector { Point[] pts; }                                                                                   // not a compile-time error
</pre></blockquote><a name="103340"></a>
the declaration of the class <code>Vector</code> is permitted even though there is also a class <code>java.util.Vector</code>. Within this compilation unit, the simple name <code>Vector</code> refers to the class <code>test.Vector</code>, not to <code>java.util.Vector</code> (which can still be referred to by code within the compilation unit, but only by its fully qualified name).<p>
<a name="103116"></a>
<a name="103117"></a>
<p>
<a name="69810"></a>
<p>As another example, the compilation unit:</p>
<blockquote><pre>package points;
class Point {
        int x, y;               // coordinates
        PointColor color;       // color of this point
        Point next;             // next point with this color
        static int nPoints;
}
class PointColor {
        Point first;            // first point with this color
        PointColor(int color) {
                this.color = color;
        }
        private int color;      // color components
}
</pre></blockquote><a name="103120"></a>
defines two classes that use each other in the declarations of their class members. Because the class types <code>Point</code> and <code>PointColor</code> have all the type declarations in package points, including all those in the current compilation unit, as their scope, this example compiles correctly-that is, forward reference is not a problem.<p>
<a name="69901"></a>
It is a compile-time error if a top level type declaration contains any one of the following access modifiers: <code>protected</code>, <code>private</code> or <code>static</code>.<p>
<a name="103130"></a>
<p>
<a name="40169"></a>
<a name="7.7"></a>
<h2>7.7    Unique Package Names</h2>
<a name="37792"></a>
Developers should take steps to avoid the possibility of two published packages having the same name by choosing <em>unique package names</em> for packages that are widely distributed. This allows packages to be easily and automatically installed and catalogued. This section specifies a suggested convention for generating such unique package names. Implementations of the Java platform are encouraged to provide automatic support for converting a set of packages from local and casual package names to the unique name format described here.<p>
<a name="37825"></a>
<p>If unique package names are not used, then package name conflicts may arise far from the point of creation of either of the conflicting packages. This may create &#32;a situation that is difficult or impossible for the user or programmer to resolve. The class <code>ClassLoader</code> can be used to isolate packages with the same name from each other in those cases where the packages will have constrained interactions, but not in a way that is transparent to a na&iuml;ve program.</p>
<a name="26818"></a>
<p>You form a unique package name by first having (or belonging to an organization that has) an Internet domain name, such as <code>sun.com</code>. You then reverse this name, component by component, to obtain, in this example, <code>com.sun</code>, and use this as a prefix for your package names, using a convention developed within your organization to further administer package names.</p>
<a name="77945"></a>
<p>In some cases, the internet domain name may not be a valid package name. Here are some suggested conventions for dealing with these situations:</p>
<ul><a name="77954"></a>
<li>If the domain name contains a hyphen, or any other special character not allowed in an identifier <a href="lexical.html#40625">(&#167;3.8)</a>, convert it into an underscore.
<a name="77968"></a>
<li>If any of the resulting package name components are keywords <a href="lexical.html#229308">(&#167;3.9)</a> then append underscore to them.
<a name="103096"></a>
<li>If any of the resulting package name components start with a digit, or any other character that is not allowed as an initial character of an identifier, have an underscore prefixed to the component.
<a name="26819"></a>
</ul>
<p>Such a convention might specify that certain directory name components be division, department, project, machine, or login names. Some possible examples:</p>
<blockquote><pre>com.sun.sunsoft.DOE
com.sun.java.jag.scrabble
com.apple.quicktime.v2
edu.cmu.cs.bovik.cheese
gov.whitehouse.socks.mousefinder
</pre></blockquote><a name="91495"></a>
The first component of a unique package name is always written in all-lowercase ASCII letters and should be one of the top level domain names, currently <code>com</code>, <code>edu</code>, <code>gov</code>, <code>mil</code>, <code>net</code>, <code>org</code>, or one of the English two-letter codes identifying countries as specified in ISO Standard 3166, 1981. For more information, refer to the documents stored at <code>ftp://rs.internic.net/rfc</code>, for example, <code>rfc920.txt</code> and <code>rfc1032.txt</code>.<p>
<a name="91496"></a>
<p>The name of a package is not meant to imply where the package is stored within the Internet; for example, a package named <code>edu.cmu.cs.bovik.cheese</code> is not necessarily obtainable from Internet address <code>cmu.edu</code> or from <code>cs.cmu.edu</code> or from <code>bovik.cs.cmu.edu</code>. The suggested convention for generating unique package names is merely a way to piggyback a package naming convention on top of an existing, widely known unique name registry instead of having to create a separate registry for package names.</p>
<a name="60426"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="names.html">Prev</a> | <a href="classes.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
</body></html>

