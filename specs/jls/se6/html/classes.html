<html>
<head>
<title> Classes</title>
<meta name="collection" content="community">
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="packages.html">Prev</a> | <a href="interfaces.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<hr><br>
 
<a name="328796"></a>
<p><strong>
CHAPTER
 8 </strong></p>
<a name="328799"></a>
<h1>Classes</h1>
<hr><p>
<a name="228205"></a>
Class declarations define new reference types and describe how they are implemented <a href="classes.html#15372">(&#167;8.1)</a>.<p>
<a name="246201"></a>
A <i>nested class</i> is any class whose declaration occurs within the body of another class or interface. A <i>top level class</i> is a class that is not a nested class.<p>
<a name="246214"></a>
This chapter discusses the common semantics of all classes-top level <a href="packages.html#26783">(&#167;7.6)</a> and nested (including member classes (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>), local classes <a href="statements.html#247766">(&#167;14.3)</a> and anonymous classes <a href="expressions.html#252986">(&#167;15.9.5)</a>). Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs. <p>
<a name="35674"></a>
A named class may be declared <code>abstract</code> <a href="classes.html#34944">(&#167;8.1.1.1)</a> and must be declared <code>abstract</code> if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. A class may be declared <code>final</code> <a href="classes.html#54727">(&#167;8.1.1.2)</a>, in which case it cannot have subclasses. If a class is declared <code>public</code>, then it can be referred to from other packages. Each class except <code>Object</code> is an extension of (that is, a subclass of) a single existing class <a href="classes.html#262560">(&#167;8.1.4)</a> and may implement interfaces <a href="classes.html#34031">(&#167;8.1.5)</a>. Classes may be generic, that is, they may declare type variables <a href="typesValues.html#108850">(&#167;4.4)</a> whose bindings may differ among different instances of the class.<p>
<a name="303544"></a>
Classes may be decorated with annotations <a href="interfaces.html#253695">(&#167;9.7)</a> just like any other kind of declaration.<p>
<a name="273974"></a>
The body of a class declares members (fields and methods and nested classes and interfaces), instance and static initializers, and constructors <a href="classes.html#18988">(&#167;8.1.6)</a>. The scope <a href="names.html#103228">(&#167;6.3)</a> of a member <a href="classes.html#21831">(&#167;8.2)</a> is the entire body of the declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers <a href="names.html#104285">(&#167;6.6)</a> <code>public</code>, <code>protected</code>, or <code>private</code>. The members of a class include both declared and inherited members <a href="classes.html#21831">(&#167;8.2)</a>. Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared class members and interface members can hide class or interface members declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.<p>
<a name="15807"></a>
Field declarations <a href="classes.html#40898">(&#167;8.3)</a> describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared <code>final</code> <a href="classes.html#35962">(&#167;8.3.1.2)</a>, in which case it can be assigned to only once. Any field declaration may include an initializer.<p>
<a name="245981"></a>
Member class declarations <a href="classes.html#246026">(&#167;8.5)</a> describe nested classes that are members of the surrounding class. Member classes may be static, in which case they have no access to the instance variables of the surrounding class; or they may be inner classes <a href="classes.html#295574">(&#167;8.1.3)</a>.<p>
<a name="245982"></a>
Member interface declarations <a href="classes.html#246026">(&#167;8.5)</a> describe nested interfaces that are members of the surrounding class.<p>
<a name="35821"></a>
Method declarations <a href="classes.html#40420">(&#167;8.4)</a> describe code that may be invoked by method invocation expressions <a href="expressions.html#20448">(&#167;15.12)</a>. A class method is invoked relative to the class type; an instance method is invoked with respect to some particular object that is an instance of a class type. A method whose declaration does not indicate how it is implemented must be declared <code>abstract</code>. A method may be declared <code>final</code> <a href="classes.html#11246">(&#167;8.4.3.3)</a>, in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent <code>native</code> code <a href="classes.html#31125">(&#167;8.4.3.4)</a>. A <code>synchronized</code> method <a href="classes.html#260369">(&#167;8.4.3.6)</a> automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a <code>synchronized</code> statement <a href="statements.html#255769">(&#167;14.19)</a>, thus allowing its activities to be synchronized with those of other threads <a href="memory.html#61803">(&#167;17)</a>.<p>
<a name="227762"></a>
Method names may be overloaded <a href="classes.html#227768">(&#167;8.4.9)</a>.<p>
<a name="246235"></a>
Instance initializers <a href="classes.html#246032">(&#167;8.6)</a> are blocks of executable code that may be used to help initialize an instance when it is created <a href="expressions.html#41147">(&#167;15.9)</a>.<p>
<a name="35837"></a>
Static initializers <a href="classes.html#39245">(&#167;8.7)</a> are blocks of executable code that may be used to help initialize a class.<p>
<a name="259034"></a>
Constructors <a href="classes.html#41652">(&#167;8.8)</a> are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded <a href="classes.html#229266">(&#167;8.8.8)</a>.<p>
<a name="15372"></a>
<a name="8.1"></a>
<h2>8.1    Class Declaration</h2>
<a name="23643"></a>
A <em>class declaration</em> specifies a new named reference type. There are two kinds of class declarations - <i>normal class declarations</i> and <i>enum declarations</i>:<p>
<a name="301637"></a>
<blockquote><pre>
<em>ClassDeclaration:
		NormalClassDeclaration	
		EnumDeclaration

NormalClassDeclaration:
	ClassModifiers<sub>opt</sub> class Identifier TypeParameters<sub>opt</sub> Super<sub>opt</sub> Interfaces<sub>opt</sub> 
ClassBody
</em>
</pre></blockquote><a name="299212"></a>
The rules in this section apply to all class declarations unless this specification explicitly states otherwise. In many cases, special restrictions apply to enum declarations. Enum declarations are described in detail in <a href="classes.html#301020">&#167;8.9</a>.<p>
<a name="287266"></a>
The <em>Identifier</em> in a class declaration specifies the name of the class. A compile-time error occurs if a class has the same simple name as any of its enclosing classes or interfaces. <p>
<a name="21613"></a>
<a name="8.1.1"></a>
<h3>8.1.1    Class Modifiers</h3>
<a name="54718"></a>
A class declaration may include <em>class modifiers</em>.<p>
<blockquote><pre>
<em>ClassModifiers:
	ClassModifier
	ClassModifiers ClassModifier

ClassModifier: one of
	Annotation </em>public&#32;protected&#32;private
	abstract&#32;static&#32;final&#32;strictfp 
</pre></blockquote><a name="258803"></a>
Not all modifiers are applicable to all kinds of class declarations. The access modifier <code>public</code> pertains only to top level classes <a href="packages.html#26783">(&#167;7.6)</a> and to member classes (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>), and is discussed in <a href="names.html#104285">&#167;6.6</a>, <a href="classes.html#246026">&#167;8.5</a> and <a href="interfaces.html#252566">&#167;9.5</a>. The access modifiers <code>protected</code> and <code>private</code> pertain only to member classes within a directly enclosing class declaration <a href="classes.html#246026">(&#167;8.5)</a> and are discussed in <a href="classes.html#247581">&#167;8.5.1</a>. The access modifier <code>static</code> pertains only to member classes (<a href="classes.html#246026">&#167;8.5</a>, <a href="interfaces.html#252566">&#167;9.5</a>). A compile-time error occurs if the same modifier appears more than once in a class declaration. <p>
<a name="302590"></a>
If an annotation <i>a</i> on a class declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.TYPE</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="259039"></a>
<p>If two or more class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>ClassModifier</em>.</p>
<a name="34944"></a>
<a name="8.1.1.1"></a>
<h4>8.1.1.1    abstract Classes</h4>
<a name="301954"></a>
An <code>abstract</code> class is a class that is incomplete, or to be considered incomplete. Normal classes may have <code>abstract</code> methods (<a href="classes.html#34484">&#167;8.4.3.1</a>, <a href="interfaces.html#78651">&#167;9.4</a>), that is methods that are declared but not yet implemented, only if they are <code>abstract</code> classes. If a normal class that is not <code>abstract</code> contains an <code>abstract</code> method, then a compile-time error occurs. <p>
<a name="329450"></a>
Enum types <a href="classes.html#301020">(&#167;8.9)</a> must not be declared abstract; doing so will result in a compile-time error. It is a compile-time error for an enum type <i>E</i> to have an abstract method <i>m</i> as a member unless <i>E</i> has one or more enum constants, and all of <i>E</i>'s enum constants have class bodies that provide concrete implementations of <i>m</i>. It is a compile-time error for the class body of an enum constant to declare an abstract method. <p>
<a name="329130"></a>
<p>
<a name="301945"></a>
A class <i>C</i> has <code>abstract</code> methods if any of the following is true:<p>
<ul><a name="36417"></a>
<li><i>C</i> explicitly contains a declaration of an <code>abstract</code> method <a href="classes.html#78188">(&#167;8.4.3)</a>.
<a name="250484"></a>
<li>Any of <i>C</i>'s superclasses has an <code>abstract</code> method and <i>C</i> neither declares nor inherits a method that implements <a href="classes.html#227927">(&#167;8.4.8.1)</a> it. 
<a name="14247"></a>
<li>A direct superinterface (<a href="classes.html#34031">&#167;8.1.5</a>) of <i>C</i> declares or inherits a method (which is therefore necessarily <code>abstract</code>) and <i>C</i> neither declares nor inherits a method that implements it.
<a name="259043"></a>
</ul>
<p>In the example:</p>
<a name="324064"></a>
<blockquote><pre>abstract class Point {
	int x = 1, y = 1;
	void move(int dx, int dy) {
		x += dx;
		y += dy;
		alert();
	}
	abstract void alert();
}
abstract class ColoredPoint extends Point {
	int color;
}

class SimplePoint extends Point {
	void alert() { }
}
</pre></blockquote><a name="259046"></a>
a class <code>Point</code> is declared that must be declared <code>abstract</code>, because it contains a declaration of an <code>abstract</code> method named <code>alert</code>. The subclass of <code>Point</code> named<code> ColoredPoint</code> inherits the <code>abstract</code> method <code>alert</code>, so it must also be declared <code>abstract</code>. On the other hand, the subclass of <code>Point</code> named <code>SimplePoint</code> provides an implementation of <code>alert</code>, so it need not be <code>abstract</code>.<p>
<a name="259051"></a>
A compile-time error occurs if an attempt is made to create an instance of an <code>abstract</code> class using a class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>. <p>
<a name="259044"></a>
<p>Thus, continuing the example just shown, the statement:</p>
<blockquote><pre>	Point p = new Point();
</pre></blockquote><a name="54883"></a>
would result in a compile-time error; the class <code>Point</code> cannot be instantiated because it is <code>abstract</code>. However, a <code>Point</code> variable could correctly be initialized with a reference to any subclass of <code>Point</code>, and the class <code>SimplePoint</code> is not <code>abstract</code>, so the statement:<p>
<blockquote><pre>	Point p = new SimplePoint();
</pre></blockquote><a name="227782"></a>
would be correct.<p>
<a name="259056"></a>
<p>A subclass of an <code>abstract</code> class that is not itself <code>abstract</code> may be instantiated, resulting in the execution of a constructor for the <code>abstract</code> class and, therefore, the execution of the field initializers for instance variables of that class. Thus, in the example just given, instantiation of a <code>SimplePoint</code> causes the default constructor and field initializers for <code>x</code> and <code>y</code> of <code>Point</code> to be executed.</p>
<a name="292198"></a>
It is a compile-time error to declare an <code>abstract</code> class type such that it is not possible to create a subclass that implements all of its <code>abstract</code> methods. This situation can occur if the class would have as members two <code>abstract</code> methods that have the same method signature <a href="classes.html#38649">(&#167;8.4.2)</a> but incompatible return types. <p>
<a name="292194"></a>
<p>As an example, the declarations:</p>
<blockquote><pre>interface Colorable { void setColor(int color); }
abstract class Colored implements Colorable {
	abstract int setColor(int color);
}
</pre></blockquote><a name="25369"></a>
result in a compile-time error: it would be impossible for any subclass of class <code>Colored</code> to provide an implementation of a method named <code>setColor</code>, taking one argument of type <code>int</code>, that can satisfy both <code>abstract</code> method specifications, because the one in interface <code>Colorable</code> requires the same method to return no value, while the one in class <code>Colored</code> requires the same method to return a value of type <code>int</code> <a href="classes.html#40420">(&#167;8.4)</a>.<p>
<a name="36521"></a>
<p>A class type should be declared <code>abstract</code> only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor <a href="classes.html#16830">(&#167;8.8.10)</a> of no arguments, make it <code>private</code>, never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class <code>Math</code> is an example of a class that cannot be instantiated; its declaration looks like this:</p>
<blockquote><pre>public final class Math {
	private Math() { }		// never instantiate this class
<em>	. . . declarations of class variables and methods . . .
</em><a name="259064"></a>
<p>}</p>
</pre></blockquote><a name="54727"></a>
<a name="8.1.1.2"></a>
<h4>8.1.1.2    final Classes</h4>
<a name="54729"></a>
A class can be declared <code>final</code> if its definition is complete and no subclasses are desired or required. A compile-time error occurs if the name of a <code>final</code> class appears in the <code>extends</code> clause <a href="classes.html#262560">(&#167;8.1.4)</a> of another <code>class</code> declaration; this implies that a <code>final</code> class cannot have any subclasses. A compile-time error occurs if a class is declared both <code>final</code> and <code>abstract</code>, because the implementation of such a class could never be completed <a href="classes.html#34944">(&#167;8.1.1.1)</a>.<p>
<a name="259069"></a>
<p>Because a <code>final</code> class never has any subclasses, the methods of a <code>final</code> class are never overridden <a href="classes.html#227927">(&#167;8.4.8.1)</a>.</p>
<a name="251946"></a>
<a name="8.1.1.3"></a>
<h4>8.1.1.3    strictfp Classes</h4>
<a name="251947"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double </code>expressions within the class declaration be explicitly FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>. This implies that all methods declared in the class, and all nested types declared in the class, are implicitly strictfp. <p>
<a name="270918"></a>
<p>Note also that all <code>float</code> or <code>double </code>expressions within all variable initializers, instance initializers, static initializers and constructors of the class will also be explicitly FP-strict.</p>
<a name="299360"></a>
<a name="8.1.2"></a>
<h3>8.1.2    Generic Classes and Type Parameters</h3>
<a name="299365"></a>
A class is <i>generic</i> if it declares one or more type variables <a href="typesValues.html#108850">(&#167;4.4)</a>. These type variables are known as the <i>type parameters</i> of the class. The type parameter section follows the class name and is delimited by angle brackets. It defines one or more type variables that act as parameters. A generic class declaration defines a set of parameterized types, one for each possible invocation of the type parameter section. All of these parameterized types share the same class at runtime.  <p>
<a name="302719"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="299366"></a>
 For instance, executing the code <p>
<blockquote><pre>Vector&lt;String&gt; x = new Vector&lt;String&gt;(); 
Vector&lt;Integer&gt; y = new Vector&lt;Integer&gt;(); 
boolean b = x.getClass() == y.getClass();
</pre></blockquote><a name="299374"></a>
will result in the variable <code>b</code> holding the value <code>true</code>. <p>
<hr>
<a name="302720"></a>
 <p>
<blockquote><pre>
<em>TypeParameters ::= &lt; TypeParameterList &gt;
</em>
<em>TypeParameterList    ::= TypeParameterList , TypeParameter
</em>
                      |<em>  TypeParameter
</em></pre></blockquote><a name="303584"></a>
It is a compile-time error if a generic class is a direct or indirect subclass of <code>Throwable</code>.<p>
<a name="303591"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="303588"></a>
 This restriction is needed since the <code>catch</code> mechanism of the Java virtual machine works only with non-generic classes. <p>
<a name="300549"></a>
 <p>
<a name="329478"></a>
The scope of a class' type parameter is the entire declaration of the class including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="307296"></a>
It is a compile-time error to refer to a type parameter of a class <i>C</i> anywhere in the declaration of a static member of <i>C</i> or the declaration of a static member of any type declaration nested within <i>C</i>. It is a compile-time error to refer to a type parameter of a class <i>C</i> within a static initializer of <i>C</i> or any class nested within <i>C</i>.<p>
<a name="307842"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="299385"></a>
 Example: Mutually recursive type variable bounds.<p>
<blockquote><pre>interface ConvertibleTo&lt;T&gt; { 
   T convert(); 
} 
class ReprChange&lt;T implements ConvertibleTo&lt;S&gt;, 
                 S implements ConvertibleTo&lt;T&gt;&gt; { 
   T t; 
   void set(S s) { t = s.convert(); } 
   S get() { return t.convert(); } 
}
</pre></blockquote><a name="299400"></a>
<hr>
<p>
Parameterized class declarations can be nested inside other declarations.<p>
<hr>
<a name="302723"></a>
 <p>
 <b>Discussion</b>
 </p>
<a name="299401"></a>
 This is illustrated in the following example: <p>
<blockquote><pre>class Seq&lt;T&gt; { 
   T head; 
   Seq&lt;T&gt; tail; 
   Seq() { this(null, null); } 
   boolean isEmpty() { return tail == null; }
   Seq(T head, Seq&lt;T&gt; tail) { this.head = head; this.tail = tail; }
   class Zipper&lt;S&gt; { 
		Seq&lt;Pair&lt;T,S&gt;&gt; zip(Seq&lt;S&gt; that) { 
     			if (this.isEmpty() || that.isEmpty())
				return new Seq&lt;Pair&lt;T,S&gt;&gt;(); 
     			else 
				return new Seq&lt;Pair&lt;T,S&gt;&gt;( 
					new Pair&lt;T,S&gt;(this.head, that.head), 
					this.tail.zip(that.tail));
		}
   }
}
class Pair&lt;T, S&gt; {
	T fst; S Snd;
	Pair(T f, S s) {fst = f; snd = s;}
}

class Client {
	{
		Seq&lt;String&gt; strs = 
		new Seq&lt;String&gt;("a", new Seq&lt;String&gt;("b", 
					new Seq&lt;String&gt;()));
   		Seq&lt;Number&gt; nums = 
			new Seq&lt;Number&gt;(new Integer(1), 
					 new Seq&lt;Number&gt;(new Double(1.5), 
													new Seq&lt;Number&gt;()));
		Seq&lt;String&gt;.Zipper&lt;Number&gt; zipper = 
					strs.new Zipper&lt;Number&gt;();
		Seq&lt;Pair&lt;String,Number&gt;&gt; combined = zipper.zip(nums);
	}
}
<a name="302724"></a>
</pre></blockquote><a name="295574"></a>
<hr>
<a name="8.1.3"></a>
<h3>8.1.3    Inner Classes and Enclosing Instances</h3>
<a name="246255"></a>
An <i>inner class</i> is a nested class that is not explicitly or implicitly declared <code>static</code>. Inner classes may not declare static initializers <a href="classes.html#39245">(&#167;8.7)</a> or member interfaces. Inner classes may not declare static members, unless they are compile-time constant fields <a href="expressions.html#5313">(&#167;15.28)</a>.<p>
<a name="263434"></a>
<p>To illustrate these rules, consider the example below:</p>
<blockquote><pre>class HasStatic{
	static int j = 100;
}
class Outer{
	class Inner extends HasStatic{
		static final int x = 3;			// ok - compile-time constant
		static int y = 4; 			// compile-time error, an inner class
	}
	static class NestedButNotInner{
		static int z = 5; 			// ok, not an inner class
	}
	interface NeverInner{}				// interfaces are never inner
}
</pre></blockquote><a name="270924"></a>
Inner classes may inherit static members that are not compile-time constants even though they may not declare them. Nested classes that are not inner classes may declare static members freely, in accordance with the usual rules of the Java programming language. Member interfaces <a href="classes.html#246026">(&#167;8.5)</a> are always implicitly static so they are never considered to be inner classes. <p>
<a name="296300"></a>
A statement or expression <i>occurs in a static context</i> if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement <a href="classes.html#78435">(&#167;8.8.7)</a>.<p>
<a name="247506"></a>
An inner class C is a <i>direct inner class of a class O</i> if <i>O</i> is the immediately lexically enclosing class of <i>C</i> and the declaration of <i>C</i> does not occur in a static context. A class <i>C</i> is an <i>inner class of class O</i> if it is either a direct inner class of <i>O</i> or an inner class of an inner class of <i>O</i>.<p>
<a name="255368"></a>
A class <i>O</i> is the <i>zeroth lexically enclosing class of itself</i>. A class <i>O</i> is the <i>nth lexically enclosing class of a class C</i> if it is the immediately enclosing class of the <i>n</i>-1st lexically enclosing class of <i>C</i>.<p>
<a name="246965"></a>
An instance <i>i</i> of a direct inner class <i>C</i> of a class <i>O</i> is associated with an instance of <i>O</i>, known as the <i>immediately enclosing instance of i</i>. The immediately enclosing instance of an object, if any, is determined when the object is created <a href="expressions.html#253028">(&#167;15.9.2)</a>.<p>
<a name="255371"></a>
An object <i>o</i> is the <i>zeroth lexically enclosing instance of itself</i>. An object <i>o</i> is the <i>nth lexically enclosing instance of an instance i</i> if it is the immediately enclosing instance of the <i>n</i>-1st lexically enclosing instance of <i>i</i>.
<p> 
<a name="247026"></a> When an inner class refers to an instance variable that is a member of a lexically enclosing class, the variable of the corresponding lexically enclosing instance is used. A blank final <a href="typesValues.html#10931">(&#167;4.12.4)</a> field of a lexically enclosing class may not be assigned within an inner class.<p>
<a name="250538"></a>
An instance of an inner class <i>I </i>whose declaration occurs in a static context has no lexically enclosing instances. However, if <i>I</i> is immediately declared within a static method or static initializer then <i>I</i> does have an <i>enclosing block</i>, which is the innermost block statement lexically enclosing the declaration of <i>I</i>.<p>
<a name="254910"></a>
Furthermore, for every superclass <i>S</i> of <i>C</i> which is itself a direct inner class of a class <i>SO</i>, there is an instance of <i>SO</i> associated with <i>i</i>, known as the <i>immediately enclosing instance of i with respect to S</i>. The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement.<p>
<a name="247496"></a>
Any local variable, formal method parameter or exception handler parameter used but not declared in an inner class must be declared final. Any local variable, used but not declared in an inner class must be definitely assigned <a href="defAssign.html#25979">(&#167;16)</a> before the body of the inner class.<p>
<a name="247494"></a>
<p>Inner classes include local <a href="statements.html#247766">(&#167;14.3)</a>, anonymous <a href="expressions.html#252986">(&#167;15.9.5)</a> and non-static member classes <a href="classes.html#246026">(&#167;8.5)</a>. Here are some examples:</p>
<blockquote><pre>class Outer {
	int i = 100;
	static void classMethod() {
		final int l = 200;
		class LocalInStaticContext{
			int k = i; // compile-time error
			int m = l; // ok
		}
	}
	
void foo() {
	class Local { // a local class
		int j = i;
		}
	}
}
</pre></blockquote>
<a name="262528"></a>
<p>The declaration of class <code>LocalInStaticContext</code> occurs in a static context-within the static method <code>classMethod</code>. Instance variables of class <code>Outer</code> are not available within the body of a static method. In particular, instance variables of <code>Outer</code> are not available inside the body of <code>LocalInStaticContext</code>. However, local variables from the surrounding method may be referred to without error (provided they are marked <code>final</code>).</p>
<a name="262541"></a>
<p>Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class, the instance variable must be defined with respect to an enclosing instance of that class. So, for example, the class <code>Local</code> above has an enclosing instance of class <code>Outer</code>. As a further example:</p>
<a name="324210"></a>
<blockquote><pre>
class WithDeepNesting{
	boolean toBe;
	WithDeepNesting(boolean b) { toBe = b;}
	class Nested {
		boolean theQuestion;
		class DeeplyNested {
			DeeplyNested(){
				theQuestion = toBe || !toBe;
			}
		}
	}
}
</pre></blockquote><a name="270930"></a>
Here, every instance of <code>WithDeepNesting.Nested.DeeplyNested</code> has an enclosing instance of class <code>WithDeepNesting.Nested</code> (its immediately enclosing instance) and an enclosing instance of class <code>WithDeepNesting</code> (its 2nd lexically enclosing instance).<p>
<a name="324211"></a>
<p>
<a name="324212"></a>
<p>
<a name="324213"></a>
<p>
<a name="262560"></a>
<a name="8.1.4"></a>
<h3>8.1.4    Superclasses and Subclasses</h3>
<a name="303827"></a>
The optional <code>extends</code> clause in a normal class declaration specifies the <em>direct superclass</em> of the current class.<p>
<blockquote><pre>
<em>Super:
	</em>extends <em>ClassType
	</em>
</pre></blockquote><a name="229540"></a>
The following is repeated from <a href="typesValues.html#9317">&#167;4.3</a> to make the presentation here clearer:<p>
<blockquote><pre>
<em>
ClassType:
	TypeDeclSpecifier TypeArguments<sub>opt</sub></em>
</pre></blockquote><a name="29813"></a>
A class is said to be a <em>direct subclass</em> of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived. The direct superclass of an enum type <code>E</code> is <code>Enum&lt;E&gt;</code>. The <code>extends</code> clause must not appear in the definition of the class <code>Object</code>, because it is the primordial class and has no direct superclass.<p>
<a name="303860"></a>
Given a (possibly generic) class declaration for <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i><img src="chars/gtequal.gif">0, <i>C</i><img src="chars/notequal.gif"><i>Object</i>, the direct superclass of the class type <a href="typesValues.html#112898">(&#167;4.5)</a> <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i> is the type given in the extends clause of the declaration of <i>C</i> if an extends clause is present, or <code>Object</code> otherwise.<p>
<a name="324340"></a>
Let <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i>&gt;0, be a generic class declaration. The direct superclass of the parameterized class type <i>C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i> , where <i>T<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, is a type, is <i>D&lt;U<sub>1</sub> theta , ..., U<sub>k</sub> theta&gt;</i>, where <i>D&lt;U<sub>1</sub>,...,U<sub>k</sub>&gt;</i> is the direct superclass of <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, and <i>theta</i> is the substitution [<i>F<sub>1</sub></i> := <i>T<sub>1</sub>, ..., F<sub>n</sub></i> := <i>T<sub>n</sub></i>].<p>
<a name="303851"></a>
The <em>ClassType</em> must name an accessible <a href="names.html#104285">(&#167;6.6)</a> class type, or a compile-time error occurs. If the specified <em>ClassType </em>names a class that is <code>final</code> <a href="classes.html#54727">(&#167;8.1.1.2)</a>, then a compile-time error occurs; <code>final</code> classes are not allowed to have subclasses. It is a compile-time error if the <em>ClassType </em>names the class <code>Enum</code> or any invocation of it. If the TypeName is followed by any type arguments, it must be a correct invocation of the type declaration denoted by TypeName, and none of the type arguments may be wildcard type arguments, or a compile-time error occurs.<p>
<a name="34088"></a>
<p>In the example:</p>
<blockquote><pre>class Point { int x, y; }
final class ColoredPoint extends Point { int color; }
class Colored3DPoint extends ColoredPoint { int z; } // error
</pre></blockquote><a name="29322"></a>
the relationships are as follows:<p>
<ul><a name="29323"></a>
<li>The class <code>Point</code> is a direct subclass of <code>Object</code>.
<a name="29324"></a>
<li>The class <code>Object</code> is the direct superclass of the class <code>Point</code>.
<a name="35258"></a>
<li>The class <code>ColoredPoint</code> is a direct subclass of class <code>Point</code>.
<a name="35261"></a>
<li>The class <code>Point</code> is the direct superclass of class <code>ColoredPoint</code>.
</ul><a name="270940"></a>
The declaration of class <code>Colored3dPoint</code> causes a compile-time error because it attempts to extend the <code>final</code> class <code>ColoredPoint</code>.<p>
<a name="303777"></a>
<p>
<a name="303780"></a>
The <em>subclass </em>relationship is the transitive closure of the direct subclass relationship. A class <i>A</i> is a subclass of class <i>C</i> if either of the following is true:<p>
<ul><a name="34080"></a>
<li><i>A</i> is the direct subclass of <i>C</i>.
<a name="34081"></a>
<li>There exists a class <i>B</i> such that <i>A</i> is a subclass of <i>B</i>, and <i>B</i> is a subclass of <i>C</i>, applying this definition recursively.
</ul><a name="34082"></a>
Class <i>C</i> is said to be a <em>superclass </em>of class <i>A</i> whenever <i>A</i> is a subclass of <i>C</i>.<p>
<a name="36594"></a>
<p>In the example:</p>
<blockquote><pre>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
final class Colored3dPoint extends ColoredPoint { int z; }
</pre></blockquote><a name="35276"></a>
the relationships are as follows:<p>
<ul><a name="36602"></a>
<li>The class <code>Point</code> is a superclass of class <code>ColoredPoint</code>.
<a name="36604"></a>
<li>The class <code>Point</code> is a superclass of class <code>Colored3dPoint</code>.
<a name="36611"></a>
<li>The class <code>ColoredPoint</code> is a subclass of class <code>Point</code>.
<a name="36613"></a>
<li>The class <code>ColoredPoint</code> is a superclass of class <code>Colored3dPoint</code>.
<a name="271013"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>ColoredPoint</code>.
<a name="303579"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>Point</code>.
</ul><a name="271016"></a>
A class <i>C</i> <i>directly depends</i> on a type <i>T</i> if <i>T </i>is mentioned in the <code>extends</code> or <code>implements</code> clause of <i>C</i> either as a superclass or superinterface, or as a qualifier of a superclass or superinterface name. A class <i>C</i> depends on a reference type <i>T</i> if any of the following conditions hold:<p>
<ul><a name="251985"></a>
<li><i>C</i> directly depends on <i>T</i>.
<a name="251987"></a>
<li><i>C</i> directly depends on an interface <i>I</i> that depends <a href="interfaces.html#253307">(&#167;9.1.3)</a> on <i>T</i>.
<a name="251993"></a>
<li><i>C</i> directly depends on a class <i>D</i> that depends on <i>T</i> (using this definition recursively).
</ul><a name="251995"></a>
It is a compile-time error if a class depends on itself.<p>
<a name="250505"></a>
<p>For example:</p>
<blockquote><pre>class Point extends ColoredPoint { int x, y; }
class ColoredPoint extends Point { int color; }
</pre></blockquote><a name="270956"></a>
causes a compile-time error.<p>
<a name="259094"></a>
If circularly declared classes are detected at run time, as classes are loaded <a href="execution.html#44459">(&#167;12.2)</a>, then a <code>ClassCircularityError</code> is thrown.<p>
<a name="34031"></a>
<a name="8.1.5"></a>
<h3>8.1.5    Superinterfaces</h3>
<a name="18953"></a>
The optional <code>implements</code> clause in a class declaration lists the names of interfaces that are <em>direct superinterfaces</em> of the class being declared:<p>
<blockquote><pre>
<em>Interfaces:</em>
	implements <em>InterfaceTypeList

InterfaceTypeList:
	InterfaceType
	InterfaceTypeList , InterfaceType
	</em>
</pre></blockquote><a name="229546"></a>
The following is repeated from <a href="typesValues.html#9317">&#167;4.3</a> to make the presentation here clearer:<p>
<blockquote><pre><em>
InterfaceType:
	TypeDeclSpecifier TypeArguments<sub>opt</sub></em>
</pre></blockquote><a name="303892"></a>
Given a (possibly generic) class declaration for <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i><img src="chars/gtequal.gif">0, <i>C</i><img src="chars/notequal.gif"><i>Object</i>, the direct superinterfaces of the class type <a href="typesValues.html#112898">(&#167;4.5)</a> <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i> are the types given in the implements clause of the declaration of <i>C</i> if an implements clause is present.<p>
<a name="303903"></a>
Let <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, <i>n</i>&gt;0, be a generic class declaration. The direct superinterfaces of the parameterized class type <i>C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;</i>, where <i>T<sub>i</sub></i>, 1<img src="chars/lt_equal.gif"><i>i</i><img src="chars/lt_equal.gif"><i>n</i>, is a type, are all types <i>I&lt;U<sub>1</sub> theta , ..., U<sub>k</sub> theta&gt;</i>, where <i>I&lt;U<sub>1</sub>,...,U<sub>k</sub>&gt;</i> is a direct superinterface of <i>C&lt;F<sub>1</sub>,...,F<sub>n</sub>&gt;</i>, and <i>theta</i> is the substitution [<i>F<sub>1</sub></i> := <i>T<sub>1</sub>, ..., F<sub>n</sub></i> := <i>T<sub>n</sub></i>].<p>
<a name="328872"></a>
Each <em>InterfaceType</em> must name an accessible <a href="names.html#104285">(&#167;6.6)</a> interface type, or a compile-time error occurs. If the <i>TypeName</i> is followed by any type arguments, it must be a correct invocation of the type declaration denoted by <i>TypeName</i>, and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. <p>
<a name="328874"></a>
A compile-time error occurs if the same interface is mentioned as a direct superinterface two or more times in a single <code>implements</code> clause names.<p>
<a name="258838"></a>
<p>This is true even if the interface is named in different ways; for example, the code:</p>
<a name="328879"></a>
<p></p>
<blockquote><pre>class Redundant implements java.lang.Cloneable, Cloneable {
	int x;
}
</pre></blockquote><a name="259097"></a>
results in a compile-time error because the names java.lang.<code>Cloneable</code> and <code>Cloneable</code> refer to the same interface.<p>
<a name="31147"></a>
An interface type <i>I</i> is a <em>superinterface</em> of class type <i>C</i> if any of the following is true:<p>
<ul><a name="34118"></a>
<li><i>I</i> is a direct superinterface of <i>C</i>.
<a name="29862"></a>
<li><i>C</i> has some direct superinterface <i>J</i> for which <i>I</i> is a superinterface, using the definition of "superinterface of an interface" given in <a href="interfaces.html#253307">&#167;9.1.3</a>.
<a name="34121"></a>
<li><i>I</i> is a superinterface of the direct superclass of <i>C</i>.
</ul><a name="29918"></a>
A class is said to <em>implement</em> all its superinterfaces.<p>
<a name="229105"></a>
<p>In the example:</p>
<blockquote><pre>public interface Colorable {
	void setColor(int color);
	int getColor();
}
public enum Finish {MATTE, GLOSSY}
public interface Paintable extends Colorable {
	void setFinish(Finish finish);
	Finish getFinish();
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	int color;
	public void setColor(int color) { this.color = color; }
	public int getColor() { return color; }
}
class PaintedPoint extends ColoredPoint implements Paintable
{
	Finish finish;
	public void setFinish(Finish finish) {
		this.finish = finish;
	}
	public Finish getFinish() { return finish; }
}
</pre></blockquote><a name="29896"></a>
the relationships are as follows:<p>
<ul><a name="29897"></a>
<li>The interface <code>Paintable</code> is a superinterface of class <code>PaintedPoint</code>.
<a name="29898"></a>
<li>The interface <code>Colorable</code> is a superinterface of class <code>ColoredPoint</code> and of class <code>PaintedPoint</code>.
<a name="29899"></a>
<li>The interface <code>Paintable</code> is a subinterface of the interface <code>Colorable</code>, and <code>Colorable</code> is a superinterface of <code>Paintable</code>, <code>a</code>s defined in <a href="interfaces.html#253307">&#167;9.1.3</a>.
</ul><a name="29870"></a>
A class can have a superinterface in more than one way. In this example, the class <code>PaintedPoint</code> has <code>Colorable</code> as a superinterface both because it is a superinterface of <code>ColoredPoint</code> and because it is a superinterface of <code>Paintable</code>. Unless the class being declared is <code>abstract</code>, the declarations of all the method members of each direct superinterface must be implemented either by a declaration in this class or by an existing method declaration inherited from the direct superclass, because a class that is not <code>abstract</code> is not permitted to have <code>abstract</code> methods <a href="classes.html#34944">(&#167;8.1.1.1)</a>.<p>
<a name="230327"></a>
<p>Thus, the example:</p>
<blockquote><pre>interface Colorable {
	void setColor(int color);
	int getColor();
}
class Point { int x, y; };
class ColoredPoint extends Point implements Colorable {
	int color;
}
</pre></blockquote><a name="36705"></a>
causes a compile-time error, because <code>ColoredPoint</code> is not an <code>abstract</code> class but it fails to provide an implementation of methods <code>setColor</code> and <code>getColor</code> of the interface <code>Colorable</code>.<p>
<a name="228059"></a>
<p>It is permitted for a single method declaration in a class to implement methods of more than one superinterface. For example, in the code:</p>
<blockquote><pre>interface Fish { int getNumberOfScales(); }
interface Piano { int getNumberOfScales(); }
class Tuna implements Fish, Piano {
	// You can tune a piano, but can you tuna fish?
	int getNumberOfScales() { return 91; }
}
</pre></blockquote><a name="228071"></a>
the method <code>getNumberOfScales</code> in class <code>Tuna</code> has a name, signature, and return type that matches the method declared in interface <code>Fish</code> and also matches the method declared in interface <code>Piano</code>; it is considered to implement both.<p>
<a name="228080"></a>
<p>On the other hand, in a situation such as this:</p>
<blockquote><pre>interface Fish { int getNumberOfScales(); }
interface StringBass { double getNumberOfScales(); }
class Bass implements Fish, StringBass {
	// This declaration cannot be correct, no matter what type is used.
	public ??? getNumberOfScales() { return 91; }
}
</pre></blockquote><a name="270984"></a>
It is impossible to declare a method named <code>getNumberOfScales</code> whose signature and return type are compatible with those of both the methods declared in interface <code>Fish</code> and in interface <code>StringBass</code>, because a class cannot have multiple methods with the same signature and different primitive return types <a href="classes.html#40420">(&#167;8.4)</a>. Therefore, it is impossible for a single class to implement both interface <code>Fish</code> and interface <code>StringBass</code> <a href="classes.html#228745">(&#167;8.4.8)</a>.<p>
<a name="299564"></a>
A class may not at the same time be a subtype of two interface types which are different invocations of the same generic interface <a href="interfaces.html#78598">(&#167;9.1.2)</a>, or an invocation of a generic interface and a raw type naming that same generic interface.<p>
<hr>
<a name="299568"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="302710"></a>
 Here is an example of an illegal multiple inheritance of an interface:<p>
<blockquote><pre>class B implements I&lt;Integer&gt;
class C extends B implements I&lt;String&gt;
</pre></blockquote>
<p>
<a name="299572"></a>
 This requirement was introduced in order to support translation by type erasure <a href="typesValues.html#108979">(&#167;4.6)</a>.<p>
<a name="302711"></a>
<hr>
 <p>
<a name="18988"></a>
<a name="8.1.6"></a>
<h3>8.1.6    Class Body and Member Declarations</h3>
<a name="77979"></a>
A <em>class body</em> may contain declarations of members of the class, that is, fields <a href="classes.html#40898">(&#167;8.3)</a>, classes <a href="classes.html#246026">(&#167;8.5)</a>, interfaces <a href="classes.html#246026">(&#167;8.5)</a> and methods <a href="classes.html#40420">(&#167;8.4)</a>. A class body may also contain instance initializers <a href="classes.html#246032">(&#167;8.6)</a>, static initializers <a href="classes.html#39245">(&#167;8.7)</a>, and declarations of constructors <a href="classes.html#41652">(&#167;8.8)</a> for the class.<p>
<blockquote><pre>
<em>
ClassBody:
</em>	{ <em>ClassBodyDeclarations<sub>opt</sub></em> }<em>

ClassBodyDeclarations:
	ClassBodyDeclaration
	ClassBodyDeclarations ClassBodyDeclaration

ClassBodyDeclaration:
	ClassMemberDeclaration
	InstanceInitializer
	StaticInitializer
	ConstructorDeclaration

ClassMemberDeclaration:
	FieldDeclaration
	MethodDeclaration
	ClassDeclaration						
	InterfaceDeclaration
	;		</em> 
</pre></blockquote><a name="329405"></a>
The scope of a declaration of a member <i>m</i> declared in or inherited by a class type <i>C</i> is the entire body of <i>C</i>, including any nested type declarations.<p>
<a name="250255"></a>
If <i>C</i> itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as <i>m</i> in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member <i>m</i> declared or inherited in C shadows <a href="names.html#34133">(&#167;6.3.1)</a> the other definitions of the same kind and name. <p>
<a name="21831"></a>
<a name="8.2"></a>
<h2>8.2    Class Members</h2>
<a name="40942"></a>
The members of a class type are all of the following:<p>
<ul><a name="40946"></a>
<li>Members inherited from its direct superclass <a href="classes.html#262560">(&#167;8.1.4)</a>, except in class <code>Object</code>, which has no direct superclass
<a name="45862"></a>
<li>Members inherited from any direct superinterfaces <a href="classes.html#34031">(&#167;8.1.5)</a>
<a name="45866"></a>
<li>Members declared in the body of the class <a href="classes.html#18988">(&#167;8.1.6)</a>
</ul><a name="30394"></a>
Members of a class that are declared <code>private</code> are not inherited by subclasses of that class. Only members of a class that are declared <code>protected</code> or <code>public</code> are inherited by subclasses declared in a package other than the one in which the class is declared.<p>
<a name="306567"></a>
We use the phrase <i>the type of a member</i> to denote:<p>
<ul><a name="306568"></a>
<li>For a field, its type.
<a name="306572"></a>
<li>For a method, an ordered 3-tuple consisting of:
<ul>
<a name="306592"></a>
<li><b>argument types</b>: a list of the types of the arguments to the method member. 
<a name="306594"></a>
<li><b>return type</b>: the return type of the method member and the 
<a name="306595"></a>
<li><b>throws clause</b>: exception types declared in the throws clause of the method member.
</ul>
</ul><a name="302404"></a>
Constructors, static initializers, and instance initializers are not members and therefore are not inherited.<p>
<a name="36731"></a>
<p>The example:</p>
<a name="324219"></a>
<p></p>
<blockquote><pre>class Point {
	int x, y;
	private Point() { reset(); }
	Point(int x, int y) { this.x = x; this.y = y; }
	private void reset() { this.x = 0; this.y = 0; }
}
class ColoredPoint extends Point {
	int color;
	void clear() { reset(); }				// error
}
class Test {
	public static void main(String[] args) {
		ColoredPoint c = new ColoredPoint(0, 0);	// error
		c.reset();					// error
	}
}
</pre></blockquote><a name="14620"></a>
causes four compile-time errors:<p>
<ul><a name="16328"></a>
<li>An error occurs because <code>ColoredPoint</code> has no constructor declared with two integer parameters, as requested by the use in <code>main</code>. This illustrates the fact that <code>ColoredPoint</code> does not inherit the constructors of its superclass <code>Point</code>.
<a name="16329"></a>
<li>Another error occurs because <code>ColoredPoint</code> declares no constructors, and therefore a default constructor for it is automatically created <a href="classes.html#16823">(&#167;8.8.9)</a>, and this default constructor is equivalent to:
<blockquote><pre>	ColoredPoint() { super(); }
</pre></blockquote>
<a name="14625"></a>
<p>which invokes the constructor, with no arguments, for the direct superclass of the class <code>ColoredPoint</code>. The error is that the constructor for <code>Point</code> that takes no arguments is <code>private</code>, and therefore is not accessible outside the class <code>Point</code>, even through a superclass constructor invocation <a href="classes.html#78435">(&#167;8.8.7)</a>.</p>
</ul><a name="270990"></a>
<p>
Two more errors occur because the method <code>reset</code> of class <code>Point</code> is <code>private</code>, and therefore is not inherited by class <code>ColoredPoint</code>. The method invocations in method <code>clear</code> of class <code>ColoredPoint</code> and in method <code>main</code> of class <code>Test</code> are therefore not correct.<p>
<a name="30229"></a>
<a name="8.2.1"></a>
<h3>8.2.1    Examples of Inheritance</h3>
<a name="36776"></a>
This section illustrates inheritance of class members through several examples.<p>
<a name="40830"></a>
<a name="8.2.1.1"></a>
<h4>8.2.1.1    Example: Inheritance with Default Access</h4>
<a name="40831"></a>
Consider the example where the <code>points</code> package declares two compilation units:<p>
<blockquote><pre>package points;
public class Point {
	int x, y;
	public void move(int dx, int dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="40836"></a>
and:<p>
<blockquote><pre>package points;
public class Point3d extends Point {
	int z;
	public void move(int dx, int dy, int dz) {
		x += dx; y += dy; z += dz;
	}
}
</pre></blockquote><a name="40844"></a>
and a third compilation unit, in another package, is:<p>
<blockquote><pre>import points.Point3d;
class Point4d extends Point3d {
	int w;
	public void move(int dx, int dy, int dz, int dw) {
		x += dx; y += dy; z += dz; w += dw; // compile-time errors
	}
}
</pre></blockquote><a name="40852"></a>
Here both classes in the <code>points</code> package compile. The class <code>Point3d</code> inherits the fields <code>x</code> and <code>y</code> of class <code>Point</code>, because it is in the same package as <code>Point</code>. The class <code>Point4d</code>, which is in a different package, does not inherit the fields <code>x</code> and <code>y</code> of class <code>Point</code> or the field <code>z</code> of class <code>Point3d</code>, and so fails to compile.<p>
<a name="40853"></a>
<p>A better way to write the third compilation unit would be:</p>
<blockquote><pre>import points.Point3d;
class Point4d extends Point3d {
	int w;
	public void move(int dx, int dy, int dz, int dw) {
		super.move(dx, dy, dz); w += dw;
	}
}
</pre></blockquote><a name="40861"></a>
using the <code>move</code> method of the superclass <code>Point3d</code> to process <code>dx</code>, <code>dy</code>, and <code>dz</code>. If <code>Point4d</code> is written in this way it will compile without errors.<p>
<a name="40862"></a>
<a name="8.2.1.2"></a>
<h4>8.2.1.2    Inheritance with public and protected</h4>
<a name="40863"></a>
Given the class <code>Point</code>:<p>
<blockquote><pre>package points;
public class Point {
	public int x, y;
	protected int useCount = 0;
	static protected int totalUseCount = 0;
	public void move(int dx, int dy) {
		x += dx; y += dy; useCount++; totalUseCount++;
	}
}
</pre></blockquote><a name="40872"></a>
the <code>public</code> and <code>protected</code> fields <code>x</code>, <code>y</code>, <code>useCount</code> and <code>totalUseCount</code> are inherited in all subclasses of <code>Point</code>. <p>
<a name="292212"></a>
<p>Therefore, this test program, in another package, can be compiled successfully:</p>
<blockquote><pre>class Test extends points.Point {
	public void moveBack(int dx, int dy) {
		x -= dx; y -= dy; useCount++; totalUseCount++;
	}
}
</pre></blockquote><a name="40879"></a>
<a name="8.2.1.3"></a>
<h4>8.2.1.3    Inheritance with private</h4>
<a name="40880"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x, y;
	void move(int dx, int dy) {
		x += dx; y += dy; totalMoves++;
	}
	private static int totalMoves;
	void printMoves() { System.out.println(totalMoves); }
}
</pre></blockquote><a name="324221"></a>
<p>
<a name="324222"></a>
<p>
<blockquote><pre>class Point3d extends Point {
	int z;
	void move(int dx, int dy, int dz) {
		super.move(dx, dy); z += dz; totalMoves++;
	}
}
</pre></blockquote><a name="40822"></a>
the class variable <code>totalMoves</code> can be used only within the class <code>Point</code>; it is not inherited by the subclass <code>Point3d</code>. A compile-time error occurs because method <code>move</code> of class <code>Point3d</code> tries to increment <code>totalMoves</code>.<p>
<a name="23530"></a>
<a name="8.2.1.4"></a>
<h4>8.2.1.4    Accessing Members of Inaccessible Classes</h4>
<a name="23515"></a>
Even though a class might not be declared <code>public</code>, instances of the class might be available at run time to code outside the package in which it is declared by means a <code>public</code> superclass or superinterface. An instance of the class can be assigned to a variable of such a <code>public</code> type. An invocation of a <code>public</code> method of the object referred to by such a variable may invoke a method of the class if it implements or overrides a method of the <code>public</code> superclass or superinterface. (In this situation, the method is necessarily declared <code>public</code>, even though it is declared in a class that is not <code>public</code>.)<p>
<a name="23519"></a>
<p>Consider the compilation unit:</p>
<blockquote><pre>package points;
public class Point {
	public int x, y;
	public void move(int dx, int dy) {
		x += dx; y += dy;
	}
}
</pre></blockquote><a name="36865"></a>
and another compilation unit of another package:<p>
<blockquote><pre>package morePoints;
class Point3d extends points.Point {
	public int z;
	public void move(int dx, int dy, int dz) {
		super.move(dx, dy); z += dz;
	}
	public void move(int dx, int dy) {
		move(dx, dy, 0);
	}
}
</pre></blockquote><a name="324223"></a>
<p>
<blockquote><pre>public class OnePoint {
	public static points.Point getOne() { 
		return new Point3d(); 
	}
}
</pre></blockquote><a name="324231"></a>
<p>
<a name="324227"></a>
An invocation <code>morePoints.OnePoint.getOne()</code> in yet a third package would return a <code>Point3d</code> that can be used as a <code>Point</code>, even though the type <code>Point3d</code> is not available outside the package <code>morePoints</code>. The two argument version of method <code>move</code> could then be invoked for that object, which is permissible because method <code>move</code> of <code>Point3d</code> is <code>public</code> (as it must be, for any method that overrides a <code>public</code> method must itself be <code>public</code>, precisely so that situations such as this will work out correctly). The fields <code>x</code> and <code>y</code> of that object could also be accessed from such a third package.<p>
<a name="36884"></a>
<p>While the field <code>z</code> of class <code>Point3d</code> is <code>public</code>, it is not possible to access this field from code outside the package <code>morePoints</code>, given only a reference to an instance of class <code>Point3d</code> in a variable <code>p</code> of type <code>Point</code>. This is because the expression <code>p.z</code> is not correct, as <code>p</code> has type <code>Point</code> and class <code>Point</code> has no field named <code>z</code>; also, the expression <code>((Point3d)p).z</code> is not correct, because the class type <code>Point3d</code> cannot be referred to outside package <code>morePoints</code>. </p>
<a name="292218"></a>
<p>The declaration of the field <code>z</code> as <code>public</code> is not useless, however. If there were to be, in package <code>morePoints</code>, a <code>public</code> subclass <code>Point4d</code> of the class <code>Point3d</code>:</p>
<blockquote><pre>package morePoints;
public class Point4d extends Point3d {
	public int w;
	public void move(int dx, int dy, int dz, int dw) {
		super.move(dx, dy, dz); w += dw;
	}
}
</pre></blockquote><a name="324232"></a>
<p>
<a name="270996"></a>
then class <code>Point4d</code> would inherit the field <code>z</code>, which, being <code>public</code>, could then be accessed by code in packages other than <code>morePoints</code>, through variables and expressions of the <code>public</code> type <code>Point4d</code>.<p>
<a name="324233"></a>
<p>
<a name="324234"></a>
<p>
<a name="324235"></a>
<p>
<a name="40898"></a>
<a name="8.3"></a>
<h2>8.3    Field Declarations</h2>
<a name="40823"></a>
The variables of a class type are introduced by <em>field declarations</em>:<p>
<blockquote><pre>
<em>
FieldDeclaration:
	FieldModifiers<sub>opt</sub> Type VariableDeclarators </em>;<em>

VariableDeclarators:
	VariableDeclarator
	VariableDeclarators , VariableDeclarator

VariableDeclarator:
	VariableDeclaratorId
	VariableDeclaratorId </em>=<em> VariableInitializer

VariableDeclaratorId:
	Identifier
	VariableDeclaratorId </em>[ ]<em>

VariableInitializer:
	Expression
	ArrayInitializer
</em>
</pre></blockquote><a name="78087"></a>
The <em>FieldModifiers</em> are described in <a href="classes.html#78091">&#167;8.3.1</a>. The <em>Identifier</em> in a <em>FieldDeclarator</em> may be used in a name to refer to the field. Fields are members; the scope <a href="names.html#103228">(&#167;6.3)</a> of a field declaration is specified in <a href="classes.html#18988">&#167;8.1.6</a>. More than one field may be declared in a single field declaration by using more than one declarator; the <em>FieldModifiers</em> and <em>Type</em> apply to all the declarators in the declaration. Variable declarations involving array types are discussed in <a href="arrays.html#25891">&#167;10.2</a>.<p>
<a name="29989"></a>
It is a compile-time error for the body of a class declaration to declare two fields with the same name. Methods, types, and fields may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures <a href="names.html#106941">(&#167;6.5)</a>.<p>
<a name="36999"></a>
If the class declares a field with a certain name, then the declaration of that field is said to <em>hide</em> any and all accessible declarations of fields with the same name in superclasses, and superinterfaces of the class. The field declaration also shadows <a href="names.html#34133">(&#167;6.3.1)</a> declarations of any accessible fields in enclosing classes or interfaces, and any local variables, formal method parameters, and exception handler parameters with the same name in any enclosing blocks.<p>
<a name="38152"></a>
If a field declaration hides the declaration of another field, the two fields need not have the same type.<p>
<a name="38148"></a>
A class inherits from its direct superclass and direct superinterfaces all the non-private fields of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.<p>
<a name="247092"></a>
<p>Note that a private field of a superclass might be accessible to a subclass (for example, if both classes are members of the same class). Nevertheless, a private field is never inherited by a subclass.</p>
<a name="37087"></a>
<p>It is possible for a class to inherit more than one field with the same name <a href="classes.html#40491">(&#167;8.3.3.3)</a>. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.</p>
<a name="37038"></a>
<p>There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.</p>
<a name="37037"></a>
<p>A hidden field can be accessed by using a qualified name (if it is <code>static</code>) or by using a field access expression <a href="expressions.html#41267">(&#167;15.11)</a> that contains the keyword <code>super</code> or a cast to a superclass type. See <a href="expressions.html#20860">&#167;15.11.2</a> for discussion and an example.</p>
<a name="259125"></a>
<p>A value stored in a field of type <code>float</code> is always an element of the float value set <a href="typesValues.html#9208">(&#167;4.2.3)</a>; similarly, a value stored in a field of type <code>double</code> is always an element of the double value set. It is not permitted for a field of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a field of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.</p>
<a name="78091"></a>
<a name="8.3.1"></a>
<h3>8.3.1    Field Modifiers</h3>
<blockquote><pre>
<em>FieldModifiers:
	FieldModifier
	FieldModifiers FieldModifier

FieldModifier: one of
	</em>Annotation public&#32;protected&#32;private
	static&#32;final&#32;transient&#32;volatile
</pre></blockquote><a name="35964"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.html#104285">&#167;6.6</a>. A compile-time error occurs if the same modifier appears more than once in a field declaration, or if a field declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. <p>
<a name="302614"></a>
If an annotation <i>a</i> on a field declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.FIELD</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="259130"></a>
<p>If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>FieldModifier</em>.</p>
<a name="37544"></a>
<a name="8.3.1.1"></a>
<h4>8.3.1.1    static Fields</h4>
<a name="230789"></a>
If a field is declared <code>static</code>, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created. A <code>static</code> field, sometimes called a <em>class variable</em>, is incarnated when the class is initialized <a href="execution.html#44557">(&#167;12.4)</a>.<p>
<a name="230793"></a>
A field that is not declared <code>static</code> (sometimes called a non-<code>static</code> field) is called an <em>instance variable</em>. Whenever a new instance of a class is created, a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses. The example program:<p>
<blockquote><pre>class Point {
	int x, y, useCount;
	Point(int x, int y) { this.x = x; this.y = y; }
	final static Point origin = new Point(0, 0);
}
class Test {
	public static void main(String[] args) {
		Point p = new Point(1,1);
		Point q = new Point(2,2);
		p.x = 3; p.y = 3; p.useCount++; p.origin.useCount++;
		System.out.println("(" + q.x + "," + q.y + ")");
		System.out.println(q.useCount);
		System.out.println(q.origin == Point.origin);
		System.out.println(q.origin.useCount);
	}
}
</pre></blockquote><a name="37584"></a>
prints:<p>
<blockquote><pre>(2,2)
0
true
1
</pre></blockquote><a name="37588"></a>
showing that changing the fields <code>x</code>, <code>y</code>, and <code>useCount</code> of <code>p</code> does not affect the fields of <code>q</code>, because these fields are instance variables in distinct objects. In this example, the class variable <code>origin</code> of the class <code>Point</code> is referenced both using the class name as a qualifier, in <code>Point.origin</code>, and using variables of the class type in field access expressions <a href="expressions.html#41267">(&#167;15.11)</a>, as in <code>p.origin</code> and <code>q.origin</code>. These two ways of accessing the <code>origin</code> class variable access the same object, evidenced by the fact that the value of the reference equality expression <a href="expressions.html#236163">(&#167;15.21.3)</a>:<p>
<blockquote><pre><code>q.origin==Point.origin
</code></pre></blockquote><a name="227825"></a>
is <code>true</code>. Further evidence is that the incrementation:<p>
<blockquote><pre>p.origin.useCount++;
</pre></blockquote><a name="259135"></a>
causes the value of <code>q.origin.useCount</code> to be <code>1</code>; this is so because <code>p.origin</code> and <code>q.origin</code> refer to the same variable.<p>
<a name="35962"></a>
<a name="8.3.1.2"></a>
<h4>8.3.1.2    final Fields</h4>
<a name="246472"></a>
A field can be declared <code>final</code> <a href="typesValues.html#10931">(&#167;4.12.4)</a>. Both class and instance variables (<code>static</code> and non-<code>static</code> fields) may be declared <code>final</code>.<p>
<a name="246476"></a>
It is a compile-time error if a blank final <a href="typesValues.html#10931">(&#167;4.12.4)</a> class variable is not definitely assigned <a href="defAssign.html#63310">(&#167;16.8)</a> by a static initializer <a href="classes.html#39245">(&#167;8.7)</a> of the class in which it is declared.<p>
<a name="246496"></a>
A blank final instance variable must be definitely assigned <a href="defAssign.html#56210">(&#167;16.9)</a> at the end of every constructor <a href="classes.html#41652">(&#167;8.8)</a> of the class in which it is declared; otherwise a compile-time error occurs. <p>
<a name="78119"></a>
<a name="8.3.1.3"></a>
<h4>8.3.1.3    transient Fields</h4>
<a name="37020"></a>
Variables may be marked <code>transient</code> to indicate that they are not part of the persistent state of an object. <p>
<a name="258868"></a>
<p>If an instance of the class <code>Point</code>:</p>
<blockquote><pre>class Point {
	int x, y;
	transient float rho, theta;
}
</pre></blockquote><a name="259140"></a>
were saved to persistent storage by a system service, then only the fields <code>x</code> and <code>y</code> would be saved. This specification does not specify details of such services; see the specification of <code>java.io.Serializable</code> for an example of such a service.<p>
<a name="36930"></a>
<a name="8.3.1.4"></a>
<h4>8.3.1.4    volatile Fields</h4>
<a name="37715"></a>
As described in <a href="memory.html#61803">&#167;17</a>, the Java programming language allows threads to access shared variables.  As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.<p>
<a name="259149"></a>
<p>The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes.</p>
<a name="259153"></a>
A field may be declared <code>volatile</code>, in which case the Java memory model <a href="memory.html#61803">(&#167;17)</a> ensures that all threads see a consistent value for the variable.<p>
<a name="14790"></a>
<p>If, in the following example, one thread repeatedly calls the method <code>one</code> (but no more than <code>Integer.MAX_VALUE</code> times in all), and another thread repeatedly calls the method <code>two</code>:</p>
<blockquote><pre>class Test {
	static int i = 0, j = 0;
	static void one() { i++; j++; }
	static void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote><a name="14803"></a>
then method <code>two</code> could occasionally print a value for <code>j</code> that is greater than the value of <code>i</code>, because the example includes no synchronization and, under the rules explained in <a href="memory.html#61803">&#167;17</a>, the shared values of <code>i</code> and <code>j</code> might be updated out of order.<p>
<a name="37738"></a>
<p>One way to prevent this out-or-order behavior would be to declare methods <code>one</code> and <code>two</code> to be <code>synchronized</code> <a href="classes.html#260369">(&#167;8.4.3.6)</a>:</p>
<blockquote><pre>class Test {
	static int i = 0, j = 0;
	static synchronized void one() { i++; j++; }
	static synchronized void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote><a name="37777"></a>
This prevents method <code>one</code> and method <code>two</code> from being executed concurrently, and furthermore guarantees that the shared values of <code>i</code> and <code>j</code> are both updated before method <code>one</code> returns. Therefore method <code>two</code> never observes a value for <code>j</code> greater than that for <code>i</code>; indeed, it always observes the same value for <code>i</code> and <code>j</code>.<p>
<a name="37789"></a>
<p>Another approach would be to declare <code>i</code> and <code>j</code> to be <code>volatile</code>:</p>
<blockquote><pre>class Test {
	static volatile int i = 0, j = 0;
	static void one() { i++; j++; }
	static void two() {
		System.out.println("i=" + i + " j=" + j);
	}
}
</pre></blockquote>
<a name="259157"></a>
<p>This allows method <code>one</code> and method <code>two</code> to be executed concurrently, but guarantees that accesses to the shared values for <code>i</code> and <code>j</code> occur exactly as many times, and in exactly the same order, as they appear to occur during execution of the program text by each thread. Therefore, the shared value for <code>j</code> is never greater than that for <code>i</code>, because each update to <code>i</code> must be reflected in the shared value for <code>i</code> before the update to <code>j</code> occurs. It is possible, however, that any given invocation of method <code>two</code> might observe a value for <code>j</code> that is much greater than the value observed for <code>i</code>, because method <code>one</code> might be executed many times between the moment when method <code>two</code> fetches the value of <code>i</code> and the moment when method <code>two</code> fetches the value of <code>j</code>.</p>
<p><a name="14791"></a>
See <a href="memory.html#61803">&#167;17</a> for more discussion and examples.<p>
<a name="24509"></a>
A compile-time error occurs if a <code>final</code> variable is also declared <code>volatile</code>.<p>
<a name="24510"></a>
<a name="8.3.2"></a>
<h3>8.3.2    Initialization of Fields</h3>
<a name="41082"></a>
If a field declarator contains a <em>variable initializer</em>, then it has the semantics of an assignment <a href="expressions.html#5281">(&#167;15.26)</a> to the declared variable, and:<p>
<ul><a name="37635"></a>
<li>If the declarator is for a class variable (that is, a <code>static</code> field), then the variable initializer is evaluated and the assignment performed exactly once, when the class is initialized <a href="execution.html#44557">(&#167;12.4)</a>.
<a name="37639"></a>
<li>If the declarator is for an instance variable (that is, a field that is not <code>static</code>), then the variable initializer is evaluated and the assignment performed each time an instance of the class is created <a href="execution.html#44670">(&#167;12.5)</a>. 
<a name="38002"></a>
<p>The example:</p>
</ul><blockquote><pre>class Point {
	int x = 1, y = 5;
}
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		System.out.println(p.x + ", " + p.y);
	}
}
</pre></blockquote><a name="30363"></a>
produces the output:<p>
<blockquote><pre>1, 5
</pre></blockquote><a name="30378"></a>
because the assignments to <code>x</code> and <code>y</code> occur whenever a new <code>Point</code> is created.<p>
<a name="259166"></a>
Variable initializers are also used in local variable declaration statements <a href="statements.html#5920">(&#167;14.4)</a>, where the initializer is evaluated and the assignment performed each time the local variable declaration statement is executed.<p>
<a name="38006"></a>
It is a compile-time error if the evaluation of a variable initializer for a <code>static</code> field of a named class (or of an interface) can complete abruptly with a checked exception <a href="exceptions.html#44121">(&#167;11.2)</a>.<p>
<a name="329518"></a>
It is compile-time error if an instance variable initializer of a named class can throw a checked exception unless that exception or one of its supertypes is explicitly declared in the throws clause of each constructor of its class and the class has at least one explicitly declared constructor. An instance variable initializer in an anonymous class <a href="expressions.html#252986">(&#167;15.9.5)</a> can throw any exceptions. <p>
<a name="329198"></a>
<p>
<a name="38010"></a>
<a name="8.3.2.1"></a>
<h4>8.3.2.1    Initializers for Class Variables</h4>
<a name="37971"></a>
If a reference by simple name to any instance variable occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="37934"></a>
If the keyword <code>this</code> <a href="expressions.html#251519">(&#167;15.8.3)</a> or the keyword <code>super</code> (<a href="expressions.html#20860">&#167;15.11.2</a>, <a href="expressions.html#20448">&#167;15.12</a>) occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="259173"></a>
<p>One subtlety here is that, at run time, <code>static</code> variables that are <code>final</code> and that are initialized with compile-time constant values are initialized first. This also applies to such fields in interfaces <a href="interfaces.html#40720">(&#167;9.3.1)</a>. These variables are "constants" that will never be observed to have their default initial values <a href="typesValues.html#96595">(&#167;4.12.5)</a>, even by devious programs. See <a href="execution.html#44630">&#167;12.4.2</a> and <a href="binaryComp.html#45139">&#167;13.4.9</a> for more discussion.</p>
<a name="329328"></a>
Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See <a href="classes.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to class variables.<p>
<a name="38013"></a>
<a name="8.3.2.2"></a>
<h4>8.3.2.2    Initializers for Instance Variables</h4>
<a name="37982"></a>
Initialization expressions for instance variables may use the simple name of any <code>static</code> variable declared in or inherited by the class, even one whose declaration occurs textually later. <p>
<a name="258899"></a>
<p>Thus the example:</p>
<blockquote><pre>class Test {
	float f = j;
	static int j = 1;
}
</pre></blockquote><a name="259183"></a>
compiles without error; it initializes <code>j</code> to <code>1</code> when class <code>Test</code> is initialized, and initializes <code>f</code> to the current value of <code>j</code> every time an instance of class <code>Test</code> is created.<p>
<a name="40409"></a>
Initialization expressions for instance variables are permitted to refer to the current object <code>this</code> <a href="expressions.html#251519">(&#167;15.8.3)</a> and to use the keyword <code>super</code> (<a href="expressions.html#20860">&#167;15.11.2</a>, <a href="expressions.html#20448">&#167;15.12</a>).<p>
<a name="329422"></a>
Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See <a href="classes.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to instance variables.<p>
<a name="287406"></a>
<a name="8.3.2.3"></a>
<h4>8.3.2.3    Restrictions on the use of Fields during Initialization</h4>
<a name="287409"></a>
The declaration of a member needs to appear textually before it is used only if the member is an instance (respectively <code>static</code>) field of a class or interface <i>C</i> and all of the following conditions hold:<p>
<ul><a name="287410"></a>
<li>The usage occurs in an instance (respectively <code>static</code>) variable initializer of <i>C</i> or in an instance (respectively <code>static</code>) initializer of <i>C</i>.
<a name="310502"></a>
<li>The usage is not on the left hand side of an assignment. 
<a name="320043"></a>
<li>The usage is via a simple name.
<a name="287412"></a>
<li><i>C</i> is the innermost class or interface enclosing the usage.
</ul><a name="287413"></a>
A compile-time error occurs if any of the four requirements above are not met.<p>
<a name="287447"></a>
<p>This means that a compile-time error results from the test program:</p>
<blockquote><pre>	class Test {
		int i = j;	// compile-time error: incorrect forward reference
		int j = 1;
	}
</pre></blockquote><a name="287452"></a>
whereas the following example compiles without error:<p>
<blockquote><pre>	class Test {
		Test() { k = 2; }
		int j = 1;
		int i = j;
		int k;
	}
</pre></blockquote><a name="287462"></a>
even though the constructor <a href="classes.html#41652">(&#167;8.8)</a> for <code>Test</code> refers to the field <code>k</code> that is declared three lines later. <p>
<a name="288775"></a>
<p>These restrictions are designed to catch, at compile time, circular or otherwise malformed initializations. Thus, both:</p>
<blockquote><pre>class Z {
	static int i = j + 2; 
	static int j = 4;
}
</pre></blockquote><a name="288780"></a>
and:<p>
<blockquote><pre>class Z {
	static { i = j + 2; }
	static int i, j;
	static { j = 4; }
}
</pre></blockquote><a name="288786"></a>
result in compile-time errors. Accesses by methods are not checked in this way, so:<p>
<blockquote><pre>class Z {
	static int peek() { return j; }
	static int i = peek();
	static int j = 1;
}
class Test {
	public static void main(String[] args) {
		System.out.println(Z.i);
	}
}
</pre></blockquote><a name="288795"></a>
produces the output:<p>
<blockquote><pre>0
</pre></blockquote><a name="288797"></a>
because the variable initializer for <code>i</code> uses the class method <code>peek</code> to access the value of the variable <code>j</code> before <code>j</code> has been initialized by its variable initializer, at which point it still has its default value <a href="typesValues.html#96595">(&#167;4.12.5)</a>.<p>
<a name="288772"></a>
<p>A more elaborate example is:</p>
<blockquote><pre>class UseBeforeDeclaration {
	static {
		x = 100; // ok - assignment
		int y = x + 1; // error - read before declaration
		int v = x = 3; // ok - x at left hand side of assignment
		int z = UseBeforeDeclaration.x * 2; 
	// ok - not accessed via simple name
		Object o = new Object(){ 
			void foo(){x++;} // ok - occurs in a different class
			{x++;} // ok - occurs in a different class
    		};
  }
	{
		j = 200; // ok - assignment
		j = j + 1; // error - right hand side reads before declaration
		int k = j = j + 1; 
		int n = j = 300; // ok - j at left hand side of assignment
		int h = j++; // error - read before declaration
		int l = this.j * 3; // ok - not accessed via simple name
		Object o = new Object(){ 
			void foo(){j++;} // ok - occurs in a different class
			{ j = j + 1;} // ok - occurs in a different class
		};
	}
	int w = x = 3; // ok - x at left hand side of assignment
	int p = x; // ok - instance initializers may access static fields
	static int u = (new Object(){int bar(){return x;}}).bar();
	// ok - occurs in a different class
	static int x;
	int m = j = 4; // ok - j at left hand side of assignment
	int o = (new Object(){int bar(){return j;}}).bar(); 
	// ok - occurs in a different class
	int j;
}
</pre></blockquote><a name="40425"></a>
<a name="8.3.3"></a>
<h3>8.3.3    Examples of Field Declarations</h3>
<a name="259192"></a>
The following examples illustrate some (possibly subtle) points about field declarations.<p>
<a name="40428"></a>
<a name="8.3.3.1"></a>
<h4>8.3.3.1    Example: Hiding of Class Variables</h4>
<a name="40429"></a>
The example:<p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	static double x = 4.7;
	public static void main(String[] args) {
		new Test().printX();
	}
	void printX() {
		System.out.println(x + " " + super.x);
	}
}
</pre></blockquote><a name="40439"></a>
produces the output:<p>
<blockquote><pre>4.7 2
</pre></blockquote><a name="40441"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. Within the declaration of class <code>Test</code>, the simple name <code>x</code> refers to the field declared within class <code>Test</code>. Code in class <code>Test</code> may refer to the field <code>x</code> of class <code>Point</code> as <code>super.x</code> (or, because <code>x</code> is <code>static</code>, as <code>Point.x</code>). If the declaration of <code>Test.x</code> is deleted:<p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	public static void main(String[] args) {
		new Test().printX();
	}
	void printX() {
		System.out.println(x + " " + super.x);
	}
}
</pre></blockquote><a name="40450"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>; instead, the simple name <code>x</code> now refers to the field <code>Point.x</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. Therefore, the output from this variant program is:<p>
<blockquote><pre>2 2
</pre></blockquote><a name="229119"></a>
<a name="8.3.3.2"></a>
<h4>8.3.3.2    Example: Hiding of Instance Variables</h4>
<a name="40453"></a>
This example is similar to that in the previous section, but uses instance variables rather than static variables. The code:<p>
<blockquote><pre>class Point {
	int x = 2;
}
class Test extends Point {
	double x = 4.7;
	void printBoth() {
		System.out.println(x + " " + super.x);
	}
	public static void main(String[] args) {
		Test sample = new Test();
		sample.printBoth();
		System.out.println(sample.x + " " + 
												((Point)sample).x);
	}
}
</pre></blockquote><a name="40468"></a>
produces the output:<p>
<blockquote><pre>4.7 2
4.7 2
</pre></blockquote><a name="40471"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. It must be noted, however, that while the field <code>x</code> of class <code>Point</code> is not <em>inherited</em> by class <code>Test</code>, it is nevertheless <em>implemented</em> by instances of class <code>Test</code>. In other words, every instance of class <code>Test</code> contains two fields, one of type <code>int</code> and one of type <code>double</code>. Both fields bear the name <code>x</code>, but within the declaration of class <code>Test</code>, the simple name <code>x</code> always refers to the field declared within class <code>Test</code>. Code in instance methods of class <code>Test</code> may refer to the instance variable <code>x</code> of class <code>Point</code> as <code>super.x</code>.<p>
<a name="40472"></a>
<p>Code that uses a field access expression to access field <code>x</code> will access the field named <code>x</code> in the class indicated by the type of reference expression. Thus, the expression <code>sample.x</code> accesses a <code>double</code> value, the instance variable declared in class <code>Test</code>, because the type of the variable sample is <code>Test</code>, but the expression <code>((Point)sample).x</code> accesses an <code>int</code> value, the instance variable declared in class <code>Point</code>, because of the cast to type <code>Point</code>.</p>
<a name="40473"></a>
<p>If the declaration of <code>x</code> is deleted from class <code>Test</code>, as in the program:</p>
<blockquote><pre>class Point {
	static int x = 2;
}
class Test extends Point {
	void printBoth() {
		System.out.println(x + " " + super.x);
	}
	public static void main(String[] args) {
		Test sample = new Test();
		sample.printBoth();
		System.out.println(sample.x + " " +
												((Point)sample).x);
	}
}
</pre></blockquote><a name="40487"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>. Within instance methods in the declaration of class <code>Test</code>, the simple name <code>x</code> now refers to the field declared within class <code>Point</code>. Code in class <code>Test</code> may still refer to that same field as <code>super.x</code>. The expression <code>sample.x</code> still refers to the field <code>x</code> within type <code>Test</code>, but that field is now an inherited field, and so refers to the field <code>x</code> declared in class <code>Point</code>. The output from this variant program is:<p>
<blockquote><pre>2 2
2 2
</pre></blockquote><a name="40491"></a>
<a name="8.3.3.3"></a>
<h4>8.3.3.3    Example: Multiply Inherited Fields</h4>
<a name="40492"></a>
A class may inherit two or more fields with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited field by its simple name. A qualified name or a field access expression that contains the keyword <code>super</code> <a href="expressions.html#20860">(&#167;15.11.2)</a> may be used to access such fields unambiguously. In the example:<p>
<blockquote><pre>interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {
	public static void main(String[] args) {
		new Test().printV();
	}
	void printV() { System.out.println(v); }
}
</pre></blockquote><a name="40504"></a>
the class <code>Test</code> inherits two fields named <code>v</code>, one from its superclass <code>SuperTest</code> and one from its superinterface <code>Frob</code>. This in itself is permitted, but a compile-time error occurs because of the use of the simple name <code>v</code> in method <code>printV</code>: it cannot be determined which <code>v</code> is intended.<p>
<a name="41191"></a>
<p>The following variation uses the field access expression <code>super.v</code> to refer to the field named <code>v</code> declared in class <code>SuperTest</code> and uses the qualified name <code>Frob.v</code> to refer to the field named <code>v</code> declared in interface <code>Frob</code>:</p>
<blockquote><pre>interface Frob { float v = 2.0f; }
class SuperTest { int v = 3; }
class Test extends SuperTest implements Frob {
	public static void main(String[] args) {
		new Test().printV();
	}
	void printV() {
		System.out.println((super.v + Frob.v)/2);
	}
}
</pre></blockquote><a name="40515"></a>
It compiles and prints:<p>
<blockquote><pre>2.5
</pre></blockquote>
<a name="40518"></a>
<p>Even if two distinct inherited fields have the same type, the same value, and are both <code>final</code>, any reference to either field by simple name is considered ambiguous and results in a compile-time error. In the example:</p>
<blockquote><pre>
interface Color { int RED=0, GREEN=1, BLUE=2; }
interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; }
class Test implements Color, TrafficLight {
	public static void main(String[] args) {
		System.out.println(GREEN);	// compile-time error
		System.out.println(RED);	// compile-time error
	}
}
</pre></blockquote><a name="40527"></a>
it is not astonishing that the reference to <code>GREEN</code> should be considered ambiguous, because class <code>Test</code> inherits two different declarations for <code>GREEN</code> with different values. The point of this example is that the reference to <code>RED</code> is also considered ambiguous, because two distinct declarations are inherited. The fact that the two fields named <code>RED</code> happen to have the same type and the same unchanging value does not affect this judgment.<p>
<a name="40528"></a>
<a name="8.3.3.4"></a>
<h4>8.3.3.4    Example: Re-inheritance of Fields</h4>
<a name="40529"></a>
If the same field declaration is inherited from an interface by multiple paths, the field is considered to be inherited only once. It may be referred to by its simple name without ambiguity. For example, in the code:<p>
<blockquote><pre>public interface Colorable {
	int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff;
}
public interface Paintable extends Colorable {
	int MATTE = 0, GLOSSY = 1;
}
class Point { int x, y; }
class ColoredPoint extends Point implements Colorable {
	. . .
}
class PaintedPoint extends ColoredPoint implements Paintable
{
	. . .  &#32; &#32; &#32;<code>RED</code> &#32; &#32; &#32; . . .
}
</pre></blockquote><a name="259196"></a>
the fields <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> are inherited by the class <code>PaintedPoint</code> both through its direct superclass <code>ColoredPoint</code> and through its direct superinterface <code>Paintable</code>. The simple names <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> may nevertheless be used without ambiguity within the class <code>PaintedPoint</code> to refer to the fields declared in interface <code>Colorable</code>.<p>
<a name="324240"></a>
<p>
<a name="40420"></a>
<a name="8.4"></a>
<h2>8.4    Method Declarations</h2>
<a name="40422"></a>
A <em>method</em> declares executable code that can be invoked, passing a fixed number of values as arguments.<p>
<a name="324241"></a>
<p>
<blockquote><pre>
<em>
MethodDeclaration:
	MethodHeader MethodBody

MethodHeader:
	MethodModifiers<sub>opt</sub> TypeParameters<sub>opt</sub> ResultType MethodDeclarator 
Throws<sub>opt</sub>
ResultType:
	Type
	</em>void<em>

MethodDeclarator:
	Identifier ( FormalParameterList<sub>opt</sub> )
	</em>
</pre></blockquote><a name="37508"></a>
The <em>MethodModifiers</em> are described in <a href="classes.html#78188">&#167;8.4.3</a>, the <em>TypeParameters</em> clause of a method in <a href="classes.html#323928">&#167;8.4.4</a>, the <em>Throws</em> clause in <a href="classes.html#308526">&#167;8.4.6</a>, and the <em>MethodBody</em> in <a href="classes.html#37316">&#167;8.4.7</a>. A method declaration either specifies the type of value that the method returns or uses the keyword <code>void</code> to indicate that the method does not return a value.<p>
<a name="30386"></a>
The <em>Identifier</em> in a <em>MethodDeclarator</em> may be used in a name to refer to the method. A class can declare a method with the same name as the class or a field, member class or member interface of the class, but this is discouraged as a matter of syle.<p>
<a name="38703"></a>
For compatibility with older versions of the Java platform, a declaration form for a method that returns an array is allowed to place (some or all of) the empty bracket pairs that form the declaration of the array type after the parameter list. This is supported by the obsolescent production:<p>
<blockquote><pre>
<em>
MethodDeclarator:
	MethodDeclarator </em>[ ]
</pre></blockquote><a name="38705"></a>
but should not be used in new code.<p>
<a name="38056"></a>
It is a compile-time error for the body of a class to declare as members two methods with override-equivalent signatures <a href="classes.html#38649">(&#167;8.4.2)</a> (name, number of parameters, and types of any parameters). Methods and fields may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures <a href="names.html#106941">(&#167;6.5)</a>.<p>
<a name="38698"></a>
<a name="8.4.1"></a>
<h3>8.4.1    Formal Parameters</h3>
<a name="37472"></a>
The <em>formal parameters</em> of a method or constructor, if any, are specified by a list of comma-separated parameter specifiers. Each parameter specifier consists of a type (optionally preceded by the <code>final</code> modifier and/or one or more annotations <a href="interfaces.html#253695">(&#167;9.7)</a>) and an identifier (optionally followed by brackets) that specifies the name of the parameter. The last formal parameter in a list is special; it may be a <i>variable arity parameter</i>, indicated by an elipsis following the type:<p>
<blockquote><pre>
<em>
FormalParameterList:
	LastFormalParameter
	FormalParameters , LastFormalParameter

FormalParameters:
	FormalParameter
	FormalParameters , FormalParameter

FormalParameter:
	VariableModifiers Type VariableDeclaratorId

VariableModifiers:
	VariableModifier
	VariableModifiers VariableModifier

VariableModifier: one of</em>
	final <em>Annotation

LastFormalParameter:
	VariableModifiers Type...<sub>opt</sub> VariableDeclaratorId
	FormalParameter
	</em>
</pre></blockquote><a name="291867"></a>
The following is repeated from <a href="classes.html#40898">&#167;8.3</a> to make the presentation here clearer:<p>
<blockquote><pre>
<em>
VariableDeclaratorId:
	Identifier
	VariableDeclaratorId </em>[ ]
</pre></blockquote><a name="55499"></a>
If a method or constructor has no parameters, only an empty pair of parentheses appears in the declaration of the method or constructor.<p>
<a name="246504"></a>
If two formal parameters of the same method or constructor are declared to have the same name (that is, their declarations mention the same <em>Identifier</em>), then a compile-time error occurs.<p>
<a name="302827"></a>
If an annotation <i>a</i> on a formal parameter corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.PARAMETER</code>, or a compile-time error occurs. Annotation modifiers are described further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="246509"></a>
It is a compile-time error if a method or constructor parameter that is declared final is assigned to within the body of the method or constructor.<p>
<a name="37477"></a>
When the method or constructor is invoked <a href="expressions.html#20448">(&#167;15.12)</a>, the values of the actual argument expressions initialize newly created parameter variables, each of the declared <em>Type,</em> before execution of the body of the method or constructor. The <em>Identifier</em> that appears<em> </em>in the <em>DeclaratorId</em> may be used as a simple name in the body of the method or constructor to refer to the formal parameter.<p>
<a name="300870"></a>
If the last formal parameter is a variable arity parameter of type <i>T</i>, it is considered to define a formal parameter of type <i>T[]</i>. The method is then a <i>variable arity method</i>. Otherwise, it is a <i>fixed arity method</i>. Invocations of a variable arity method may contain more actual argument expressions than formal parameters. All the actual argument expressions that do not correspond to the formal parameters preceding the variable arity parameter will be evaluated and the results stored into an array that will be passed to the method invocation <a href="expressions.html#45449">(&#167;15.12.4.2)</a>.<p>
<a name="329396"></a>
The scope of a parameter of a method <a href="classes.html#38698">(&#167;8.4.1)</a> or constructor <a href="classes.html#29488">(&#167;8.8.1)</a> is the entire body of the method or constructor.<p>
<a name="38643"></a>
These parameter names may not be redeclared as local variables of the method, or as exception parameters of catch clauses in a try statement of the method or constructor. However, a parameter of a method or constructor may be shadowed anywhere inside a class declaration nested within that method or constructor. Such a nested class declaration could declare either a local class <a href="statements.html#247766">(&#167;14.3)</a> or an anonymous class <a href="expressions.html#41147">(&#167;15.9)</a>. <p>
<a name="38647"></a>
Formal parameters are referred to only using simple names, never by using qualified names <a href="names.html#104285">(&#167;6.6)</a>.<p>
<a name="246529"></a>
A method or constructor parameter of type <code>float</code> always contains an element of the float value set <a href="typesValues.html#9208">(&#167;4.2.3)</a>; similarly, a method or constructor parameter of type <code>double</code> always contains an element of the double value set. It is not permitted for a method or constructor parameter of type <code>float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a method parameter of type <code>double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set. <p>
<a name="246530"></a>
Where an actual argument expression corresponding to a parameter variable is not FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>, evaluation of that actual argument expression is permitted to use intermediate values drawn from the appropriate extended-exponent value sets. Prior to being stored in the parameter variable the result of such an expression is mapped to the nearest value in the corresponding standard value set by method invocation conversion <a href="conversions.html#12687">(&#167;5.3)</a>.<p>
<a name="38649"></a>
<a name="8.4.2"></a>
<h3>8.4.2    Method Signature</h3>
<a name="302559"></a>
It is a compile-time error to declare two methods with override-equivalent signatures (defined below) in a class. <p>
<a name="310521"></a>
Two methods have the <i>same signature</i> if they have the same name and argument types. <p>
<a name="324242"></a>
Two method or constructor declarations <i>M</i> and <i>N</i> have the <i>same argument types</i> if all of the following conditions hold:<p>
<ul><a name="299803"></a>
<li>They have the same number of formal parameters (possibly zero) 
<a name="299804"></a>
<li>They have the same number of type parameters (possibly zero) 
<a name="324473"></a>
<li>Let <i>&lt;A<sub>1</sub>,...,A<sub>n</sub>&gt;</i> be the formal type parameters of <i>M</i> and let <i>&lt;B<sub>1</sub>,...,B<sub>n</sub>&gt;</i> be the formal type parameters of <i>N</i>. After renaming each occurrence of a <i>B<sub>i</sub></i> in <i>N</i>'s type to <i>A<sub>i</sub></i> the bounds of corresponding type variables and the argument types of <i>M</i> and <i>N</i> are the same.
</ul><a name="324474"></a>
The signature of a method <i>m1</i> is a <i>subsignature</i> of the signature of a method <i>m2</i> if either <p>
<ul>
<a name="308836"></a>
<li><i>m</i>2 has the same signature as <i>m1</i>, or
<a name="308837"></a>
<li>the signature of <i>m1</i> is the same as the erasure of the signature of <i>m</i>2.
</ul>
<a name="308833"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="309081"></a>
 The notion of subsignature defined here is designed to express a relationship between two methods whose signatures are not identical, but in which one may override the other.<p>
<a name="309082"></a>
Specifically, it allows a method whose signature does not use generic types to override any generified version of that method. This is important so that library designers may freely generify methods independently of clients that define subclasses or subinterfaces of the library.<p>
<a name="309094"></a>
Consider the example:<p>
<blockquote><pre>class CollectionConverter {
    List toList(Collection c) {...}
}
class Overrider extends CollectionConverter{
    List toList(Collection c) {...}
}
</pre></blockquote><a name="309101"></a>
Now, assume this code was written before the introduction of genericity, and now the author of class <code>CollectionConverter</code> decides to generify the code, thus:<p>
<blockquote><pre>class CollectionConverter {
	&lt;T&gt; List&lt;T&gt; toList(Collection&lt;T&gt; c) {...}
}
</pre></blockquote><a name="309105"></a>
Without special dispensation, <code>Overrider.toList()</code> would no longer override <code>CollectionConverter.toList()</code>. Instead, the code would be illegal. This would significantly inhibit the use of genericity, since library writers would hesitate to migrate existing code.<p>
<hr>
<a name="309083"></a>
 <p>
<a name="309142"></a>
Two method signatures <i>m1</i> and <i>m2</i> are <i>override-equivalent</i> iff either <i>m1</i> is a subsignature of <i>m2</i> or <i>m2</i> is a subsignature of <i>m1</i>.<p>
<a name="321243"></a>
<p>The example:</p>
<blockquote><pre>class Point implements Move {
	int x, y;
	abstract void move(int dx, int dy);
	void move(int dx, int dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="321249"></a>
causes a compile-time error because it declares two <code>move</code> methods with the same (and hence, override-equivalent) signature. This is an error even though one of the declarations is <code>abstract</code>.<p>
<a name="78188"></a>
<a name="8.4.3"></a>
<h3>8.4.3    Method Modifiers</h3>
<blockquote><pre>
<em>MethodModifiers:
	MethodModifier
	MethodModifiers MethodModifier

MethodModifier: one of
	Annotation</em> public&#32;protected&#32;private&#32;abstract&#32;static
	final&#32;synchronized&#32;native&#32;strictfp
</pre></blockquote><a name="320610"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if the same modifier appears more than once in a method declaration, or if a method declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. A compile-time error occurs if a method declaration that contains the keyword <code>abstract</code> also contains any one of the keywords <code>private</code>, <code>static</code>, <code>final</code>, <code>native</code>, <code>strictfp</code>, or <code>synchronized</code>. A compile-time error occurs if a method declaration that contains the keyword <code>native</code> also contains <code>strictfp</code>.<p>
<a name="302554"></a>
If an annotation <i>a</i> on a method declaration corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.METHOD</code>, or a compile-time error occurs. Annotations are discussed further in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="259206"></a>
<p>If two or more method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>MethodModifier</em>.</p>
<a name="34484"></a>
<a name="8.4.3.1"></a>
<h4>8.4.3.1    abstract Methods</h4>
<a name="227750"></a>
An <code>abstract</code> method declaration introduces the method as a member, providing its signature <a href="classes.html#38649">(&#167;8.4.2)</a>, return type, and <code>throws</code> clause (if any), but does not provide an implementation. The declaration of an <code>abstract</code> method <i>m</i> must appear directly within an <code>abstract</code> class (call it <i>A</i>) unless it occurs within an enum <a href="classes.html#301020">(&#167;8.9)</a>; otherwise a compile-time error results. Every subclass of <i>A</i> that is not <code>abstract</code> must provide an implementation for <i>m</i>, or a compile-time error occurs as specified in <a href="classes.html#34944">&#167;8.1.1.1</a>. <p>
<a name="230064"></a>
It is a compile-time error for a <code>private</code> method to be declared <code>abstract</code>.<p>
<a name="259211"></a>
<p>It would be impossible for a subclass to implement a <code>private</code> <code>abstract</code> method, because <code>private</code> methods are not inherited by subclasses; therefore such a method could never be used.</p>
<a name="230065"></a>
It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="230073"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="36710"></a>
An <code>abstract</code> class can override an <code>abstract</code> method by providing another <code>abstract</code> method declaration. <p>
<a name="258918"></a>
<p>This can provide a place to put a documentation comment, to refine the return type, or to declare that the set of checked exceptions <a href="exceptions.html#44121">(&#167;11.2)</a> that can be thrown by that method, when it is implemented by its subclasses, is to be more limited. For example, consider this code:</p>
<a name="324243"></a>
<p></p>
<blockquote><pre>class BufferEmpty extends Exception {
	BufferEmpty() { super(); }
	BufferEmpty(String s) { super(s); }
}
class BufferError extends Exception {
	BufferError() { super(); }
	BufferError(String s) { super(s); }
}
public interface Buffer {
	char get() throws BufferEmpty, BufferError;
}
public abstract class InfiniteBuffer implements Buffer {
	public abstract char get() throws BufferError;
}
</pre></blockquote><a name="324244"></a>
<p>
<a name="259216"></a>
<p>The overriding declaration of method <code>get</code> in class <code>InfiniteBuffer</code> states that method <code>get</code> in any subclass of <code>InfiniteBuffer</code> never throws a <code>BufferEmpty</code> exception, putatively because it generates the data in the buffer, and thus can never run out of data.</p>
<a name="14765"></a>
An instance method that is not <code>abstract</code> can be overridden by an <code>abstract</code> method. <p>
<a name="258923"></a>
<p></p>
<a name="324245"></a>
<p>For example, we can declare an <code>abstract</code> class <code>Point</code> that requires its subclasses to implement <code>toString</code> if they are to be complete, instantiable classes:</p>
<blockquote><pre>abstract class Point {
	int x, y;
	public abstract String toString();
}
</pre></blockquote><a name="14912"></a>
This <code>abstract</code> declaration of <code>toString</code> overrides the non-<code>abstract</code> <code>toString</code> method of class <code>Object</code>. (Class <code>Object</code> is the implicit direct superclass of class <code>Point</code>.) Adding the code:<p>
<blockquote><pre>class ColoredPoint extends Point {
	int color;
	public String toString() {
		return super.toString() + ": color " + color; // error
	}
}
</pre></blockquote><a name="38923"></a>
results in a compile-time error because the invocation <code>super.toString()</code> refers to method <code>toString</code> in class <code>Point</code>, which is <code>abstract</code> and therefore cannot be invoked. Method <code>toString</code> of class <code>Object</code> can be made available to class <code>ColoredPoint</code> &#32;only if class <code>Point</code> explicitly makes it available through some other method, as in:<p>
<blockquote><pre>abstract class Point {
	int x, y;
	public abstract String toString();
	protected String objString() { return super.toString(); }
}
class ColoredPoint extends Point {
	int color;
	public String toString() {
		return objString() + ": color " + color;														// correct
	}
}
</pre></blockquote><a name="229128"></a>
<a name="8.4.3.2"></a>
<h4>8.4.3.2    static Methods</h4>
<a name="39431"></a>
A method that is declared <code>static</code> is called a <em>class method</em>. A class method is always invoked without reference to a particular object. An attempt to reference the current object using the keyword <code>this</code> or the keyword <code>super</code> or to reference the type parameters of any surrounding declaration in the body of a class method results in a compile-time error. It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="39033"></a>
A method that is not declared <code>static</code> is called an <em>instance method,</em> and sometimes called a non-<code>static</code> method. An instance method is always invoked with respect to an object, which becomes the current object to which the keywords <code>this</code> and <code>super</code> refer during execution of the method body.<p>
<a name="11246"></a>
<a name="8.4.3.3"></a>
<h4>8.4.3.3    final Methods</h4>
<a name="30456"></a>
A method can be declared <code>final</code> to prevent subclasses from overriding or hiding it. It is a compile-time error to attempt to override or hide a <code>final</code> method.<p>
<a name="38958"></a>
A <code>private</code> method and all methods declared immediately within a <code>final</code> class <a href="classes.html#54727">(&#167;8.1.1.2)</a> behave as if they are <code>final</code>, since it is impossible to override them.  <p>
<a name="38950"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="14844"></a>
At run time, a machine-code generator or optimizer can "inline" the body of a <code>final</code> method, replacing an invocation of the method with the code in its body. The inlining process must preserve the semantics of the method invocation. In particular, if the target of an instance method invocation is <code>null</code>, then a <code>NullPointerException</code> must be thrown even if the method is inlined. The compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation.<p>
<a name="258931"></a>
<p>Consider the example:</p>
<blockquote><pre>final class Point {
	int x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class Test {
	public static void main(String[] args) {
		Point[] p = new Point[100];
		for (int i = 0; i &lt; p.length; i++) {
			p[i] = new Point();
			p[i].move(i, p.length-1-i);
		}
	}
}
</pre></blockquote><a name="36666"></a>
Here, inlining the method <code>move</code> of class <code>Point</code> in method <code>main</code> would transform the <code>for</code> loop to the form:<p>
<blockquote><pre>		for (int i = 0; i &lt; p.length; i++) {
			p[i] = new Point();
			Point pi = p[i];
			int j = p.length-1-i;
			pi.x += i;
			pi.y += j;
		}
</pre></blockquote><a name="31122"></a>
The loop might then be subject to further optimizations.<p>
<a name="259226"></a>
<p>Such inlining cannot be done at compile time unless it can be guaranteed that <code>Test</code> and <code>Point</code> will always be recompiled together, so that whenever <code>Point</code>-and specifically its <code>move</code> method-changes, the code for <code>Test.main</code> will also be updated.</p>
<a name="31125"></a>
<a name="8.4.3.4"></a>
<h4>8.4.3.4    native Methods</h4>
<a name="30468"></a>
A method that is <code>native</code> is implemented in platform-dependent code, typically written in another programming language such as C, C++, FORTRAN,or assembly language. The body of a <code>native</code> method is given as a semicolon only, indicating that the implementation is omitted, instead of a block.<p>
<a name="38981"></a>
A compile-time error occurs if a <code>native</code> method is declared <code>abstract</code>.<p>
<a name="38035"></a>
<p>For example, the class <code>RandomAccessFile</code> of the package <code>java.io</code> might declare the following <code>native</code> methods:</p>
<blockquote><pre>package java.io;
public class RandomAccessFile
	implements DataOutput, DataInput
{	. . .
	public native void open(String name, boolean writeable)
		throws IOException;
	public native int readBytes(byte[] b, int off, int len)
		throws IOException;
	public native void writeBytes(byte[] b, int off, int len)
		throws IOException;
	public native long getFilePointer() throws IOException;
	public native void seek(long pos) throws IOException;
	public native long length() throws IOException;
	public native void close() throws IOException;
<a name="259231"></a>
<p>}</p>
</pre></blockquote><a name="55408"></a>
<a name="8.4.3.5"></a>
<h4>8.4.3.5    strictfp Methods</h4>
<a name="260393"></a>
The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double </code>expressions within the method body be explicitly FP-strict <a href="expressions.html#249198">(&#167;15.4)</a>.<p>
<a name="260369"></a>
<a name="8.4.3.6"></a>
<h4>8.4.3.6    synchronized Methods</h4>
<a name="30531"></a>
A <code>synchronized</code> method acquires a monitor <a href="memory.html#56318">(&#167;17.1)</a> before it executes. For a class (<code>static)</code> method, the monitor associated with the <code>Class</code> object for the method's class is used. For an instance method, the monitor associated with <code>this</code> (the object for which the method was invoked) is used. <p>
<a name="258940"></a>
<p>These are the same locks that can be used by the <code>synchronized</code> statement <a href="statements.html#255769">(&#167;14.19)</a>; thus, the code:</p>
<blockquote><pre>class Test {
	int count;
	synchronized void bump() { count++; }
	static int classCount;
	static synchronized void classBump() {
		classCount++;
	}
}
</pre></blockquote><a name="39096"></a>
has exactly the same effect as:<p>
<blockquote><pre>class BumpTest {
	int count;
	void bump() {
		synchronized (this) {
			count++;
		}
	}
	static int classCount;
	static void classBump() {
		try {
			synchronized (Class.forName("BumpTest")) {
				classCount++;
			}
		} catch (ClassNotFoundException e) {
				...
		}
	}
}
</pre></blockquote><a name="39078"></a>
The more elaborate example:<p>
<blockquote><pre>public class Box {
	private Object boxContents;
	public synchronized Object get() {
		Object contents = boxContents;
		boxContents = null;
		return contents;
	}
	public synchronized boolean put(Object contents) {
		if (boxContents != null)
			return false;
		boxContents = contents;
		return true;
	}
}
</pre></blockquote><a name="324957"></a>
defines a class which is designed for concurrent use. Each instance of the class <code>Box</code> has an instance variable <code>boxContents</code> that can hold a reference to any object. You can put an object in a <code>Box</code> by invoking <code>put</code>, which returns <code>false</code> if the box is already full. You can get something out of a <code>Box</code> by invoking <code>get</code>, which returns a null reference if the box is empty.<p>
<a name="39151"></a>
<p>If <code>put</code> and <code>get</code> were not <code>synchronized</code>, and two threads were executing methods for the same instance of <code>Box</code> at the same time, then the code could misbehave. It might, for example, lose track of an object because two invocations to <code>put</code> occurred at the same time.</p>
<a name="299963"></a>
See <a href="memory.html#61803">&#167;17</a> for more discussion of threads and locks.<p>
<a name="323927"></a>
<p>
<a name="323928"></a>
<a name="8.4.4"></a>
<h3>8.4.4    Generic Methods</h3>
<a name="299964"></a>
A method is <i>generic</i> if it declares one or more type variables <a href="typesValues.html#108850">(&#167;4.4)</a>. These type variables are known as the <i>formal type parameters</i> of the method. The form of the formal type parameter list is identical to a type parameter list of a class or interface, as described in <a href="classes.html#299360">&#167;8.1.2</a>. <p>
<a name="329504"></a>
The scope of a method's type parameter is the entire declaration of the method, including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="300615"></a>
Type parameters of generic methods need not be provided explicitly when a generic method is invoked. Instead, they are almost always inferred as specified in <a href="expressions.html#341287">&#167;15.12.2.7</a><p>
<a name="296201"></a>
<a name="8.4.5"></a>
<h3>8.4.5    Method Return Type</h3>
<a name="308529"></a>
The return type of a method declares the type of value a method returns, if it returns a value, or states that the method is <code>void</code>. <p>
<a name="308544"></a>
A method declaration <i>d<sub>1</sub></i> with return type <i>R<sub>1</sub></i> is return-type-substitutable for another method <i>d<sub>2</sub></i> with return type <i>R<sub>2</sub></i>, if and only if the following conditions hold: <p>
<ul><a name="308530"></a>
<li>If <i>R<sub>1</sub></i> is a primitive type, then <i>R<sub>2</sub></i> is identical to <i>R<sub>1</sub></i>.
<a name="308531"></a>
<li>If <i>R<sub>1</sub></i> is a reference type then: 
<ul>
<a name="308532"></a>
<li><i>R<sub>1</sub></i> is either a subtype of <i>R<sub>2</sub></i> or <i>R<sub>1</sub></i> can be converted to a subtype of <i>R<sub>2</sub></i> by unchecked conversion <a href="conversions.html#190772">(&#167;5.1.9)</a>, or
<a name="308536"></a>
<li><i>R<sub>1</sub></i> = | <i>R<sub>2</sub></i> |. 
</ul>
<a name="308537"></a>
<li>If <i>R<sub>1</sub></i> is <code>void</code> then <i>R<sub>2</sub></i> is <code>void</code>.
</ul>
<a name="308527"></a>
 <p>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="309108"></a>
 The notion of return-type substitutability summarizes the ways in which return types may vary among methods that override each other. <p>
<P><a name="309109"></a>
Note that this definition supports <i>covariant returns</i> - that is, the specialization of the return type to a subtype (but only for reference types). <p>
<a name="309119"></a>
Also note that unchecked conversions are allowed as well. This is unsound, and requires an unchecked warning whenever it is used; it is a special allowance is made to allow smooth migration from non-generic to generic code. <p>
<hr>
<a name="309110"></a>
 <p>
<a name="308526"></a>
<a name="8.4.6"></a>
<h3>8.4.6    Method Throws</h3>
<a name="41401"></a>
A <em>throws clause</em> is used to declare any checked exceptions <a href="exceptions.html#44121">(&#167;11.2)</a> that can result from the execution of a method or constructor:<p>
<blockquote><pre>
<em>
Throws:</em>
	throws <em>ExceptionTypeList

ExceptionTypeList:
	ExceptionType
	ExceptionTypeList , ExceptionType

ExceptionType:
	ClassType
	TypeVariable
	</em>
</pre></blockquote><a name="302537"></a>
A compile-time error occurs if any <em>ExceptionType</em> mentioned in a <code>throws</code> clause is not a subtype <a href="typesValues.html#120403">(&#167;4.10)</a> of <code>Throwable</code>. It is permitted but not required to mention other (unchecked) exceptions in a <code>throws</code> clause.<p>
<a name="39177"></a>
For each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless that exception type or a supertype of that exception type is mentioned in a <code>throws</code> clause in the declaration of the method or constructor.<p>
<a name="259241"></a>
<p>The requirement to declare checked exceptions allows the compiler to ensure that code for handling such error conditions has been included. Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions will normally result in a compile-time error because of the lack of a proper exception type in a <code>throws</code> clause. The Java programming language thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.</p>
<a name="55271"></a>
The predefined exceptions that are not checked in this way are those for which declaring every possible occurrence would be unimaginably inconvenient:<p>
<ul><a name="41434"></a>
<li>Exceptions that are represented by the subclasses of class <code>Error</code>, for example <code>OutOfMemoryError</code>, are thrown due to a failure in or of the virtual machine. Many of these are the result of linkage failures and can occur at unpredictable points in the execution of a program. Sophisticated programs may yet wish to catch and attempt to recover from some of these conditions.
<a name="41435"></a>
<li>The exceptions that are represented by the subclasses of the class <code>RuntimeException</code>, &#32;for example <code>NullPointerException</code>, result from run--time &#32;integrity checks and are thrown either directly from the program or in library routines. It is beyond the scope of the Java programming language, and perhaps beyond the state of the art, to include sufficient information in the program to reduce to a manageable number the places where these can be proven not to occur.
</ul><a name="230101"></a>
A method that overrides or hides another method <a href="classes.html#228745">(&#167;8.4.8)</a>, including methods that implement <code>abstract</code> methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.<p>
<a name="230102"></a>
More precisely, suppose that <i>B</i> is a class or interface, and <i>A</i> is a superclass or superinterface of <i>B</i>, and a method declaration <i>n</i> in <i>B</i> overrides or hides a method declaration <i>m</i> in <i>A</i>. If <i>n</i> has a <code>throws</code> clause that mentions any checked exception types, then <i>m</i> must have a <code>throws</code> clause, and for every checked exception type listed in the <code>throws</code> clause of <i>n</i>, that same exception class or one of its supertypes must occur in the erasure of the <code>throws</code> clause of <i>m</i>; otherwise, a compile-time error occurs.<p>
<a name="308280"></a>
If the unerased <code>throws</code> clause of <i>m</i> does not contain a supertype of each exception type in the <code>throws</code> clause of <i>n</i>, an unchecked warning must be issued.<p>
<a name="302748"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 See <a href="exceptions.html#44043">&#167;11</a> for more information about exceptions and a large example.<p>
<a name="303630"></a>
 Type variables are allowed in throws lists even though they are not allowed in catch clauses. <p>
<blockquote><pre>interface PrivilegedExceptionAction&lt;E extends Exception&gt; { 
  void run() throws E;
} 
class AccessController {
  public static &lt;E extends Exception&gt; 
  Object doPrivileged(PrivilegedExceptionAction&lt;E&gt; action) throws E 
  { ... }
}
class Test {
  public static void main(String[] args) {
    try { 
      AccessController.doPrivileged(
        new PrivilegedExceptionAction&lt;FileNotFoundException&gt;() { 
          public void run() throws FileNotFoundException 
          {... delete a file  ...} 
        }); 
    } catch (FileNotFoundException f) {...} // do something 
  }
}
<a name="24563"></a>
</pre></blockquote><a name="37316"></a>
<hr>
<p>
<a name="8.4.7"></a>
<h3>8.4.7    Method Body</h3>
<a name="32175"></a>
A <em>method body</em> is either a block of code that implements the method or simply a semicolon, indicating the lack of an implementation. The body of a method must be a semicolon if and only if the method is either <code>abstract</code> <a href="classes.html#34484">(&#167;8.4.3.1)</a> or <code>native</code> <a href="classes.html#31125">(&#167;8.4.3.4)</a>.<p>
<blockquote><pre>
<em>MethodBody</em>:
<em>	Block</em> 
	;
</pre></blockquote><a name="38770"></a>
A compile-time error occurs if a method declaration is either <code>abstract</code> or <code>native</code> and has a block for its body. A compile-time error occurs if a method declaration is neither <code>abstract</code> nor <code>native</code> and has a semicolon for its body.<p>
<a name="39311"></a>
<p>If an implementation is to be provided for a method declared <code>void</code>, but the implementation requires no executable code, the method body should be written as a block that contains no statements: "<code>{ }</code>".</p>
<a name="228178"></a>
If a method is declared <code>void</code>, then its body must not contain any <code>return</code> statement <a href="statements.html#6767">(&#167;14.17)</a> that has an <em>Expression</em>.<p>
<a name="244552"></a>
If a method is declared to have a return type, then every <code>return</code> statement <a href="statements.html#6767">(&#167;14.17)</a> in its body must have an <em>Expression</em>. A compile-time error occurs if the body of the method can complete normally <a href="statements.html#5894">(&#167;14.1)</a>. <p>
<a name="258957"></a>
<p>In other words, a method with a return type must return only by using a return statement that provides a value return; it is not allowed to "drop off the end of its body."</p>
<a name="228370"></a>
<p>Note that it is possible for a method to have a declared return type and yet contain no return statements. Here is one example:</p>
<blockquote><pre>class DizzyDean {
	int pitch() { throw new RuntimeException("90 mph?!"); }
}
</pre></blockquote><a name="228745"></a>
<a name="8.4.8"></a>
<h3>8.4.8    Inheritance, Overriding, and Hiding</h3>
<a name="227926"></a>
A class <i>C</i> <em>inherits</em> from its direct superclass and direct superinterfaces all  non-private methods (whether <code>abstract</code> or not) of the superclass and superinterfaces that are public, protected or declared with default access in the same package as <i>C</i> and are neither overridden <a href="classes.html#227927">(&#167;8.4.8.1)</a> nor hidden <a href="classes.html#227928">(&#167;8.4.8.2)</a> by a declaration in the class.<p>
<a name="227927"></a>
<a name="8.4.8.1"></a>
<h4>8.4.8.1    Overriding (by Instance Methods)</h4>
<a name="39521"></a>
An instance method <i>m1</i> declared in a class <i>C</i> <em>overrides</em> another instance method, <i>m2</i>, declared in class <i>A</i> iff all of the following are true:<p>
<ol>
<a name="247097"></a>
<li>C is a subclass of <i>A</i>.
<a name="307410"></a>
<li>The signature of <i>m1</i> is a subsignature <a href="classes.html#38649">(&#167;8.4.2)</a> of the signature of <i>m2</i>.
<a name="247099"></a>
<li>Either
<ul>
<a name="247100"></a>
<li><i>m2</i> is public, protected or declared with default access in the same package as <i>C</i>, or 
<a name="247101"></a>
<li><i>m1</i> overrides a method <i>m3</i>, <i>m3</i> distinct from <i>m1</i>, <i>m3</i> distinct from <i>m2</i>, such that <i>m3</i> overrides <i>m2</i>.
</ul>
</ol>
<a name="323974"></a>
Moreover, if <i>m1</i> is not <code>abstract</code>, then <i>m1</i> is said to <em>implement</em> any and all declarations of <code>abstract</code> methods that it overrides.<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="323975"></a>
 <p>
<a name="323983"></a>
 The signature of an overriding method may differ from the overridden one if a formal parameter in one of the methods has raw type, while the corresponding parameter in the other has a parameterized type.<p>
<a name="323976"></a>
The rules allow the signature of the overriding method to differ from the overridden one, to accommodate migration of pre-existing code to take advantage of genericity. See section <a href="classes.html#38649">&#167;8.4.2</a> for further analysis.<p>
<hr>
<a name="307478"></a>
 <p>
<a name="227929"></a>
A compile-time error occurs if an instance method overrides a <code>static</code> method. <p>
<a name="258962"></a>
<p>In this respect, overriding of methods differs from hiding of fields <a href="classes.html#40898">(&#167;8.3)</a>, for it is permissible for an instance variable to hide a <code>static</code> variable.</p>
<a name="259251"></a>
<p>An overridden method can be accessed by using a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a> that contains the keyword <code>super</code>. Note that a qualified name or a cast to a superclass type is not effective in attempting to access an overridden method; in this respect, overriding of methods differs from hiding of fields. See <a href="expressions.html#239751">&#167;15.12.4.9</a> for discussion and examples of this point.</p>
<a name="246534"></a>
The presence or absence of the <code>strictfp</code> modifier has absolutely no effect on the rules for overriding methods and implementing abstract methods. For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.<p>
<a name="324257"></a>
<p>
<a name="227928"></a>
<a name="8.4.8.2"></a>
<h4>8.4.8.2    Hiding (by Class Methods)</h4>
<a name="300965"></a>
If a class declares a <code>static</code> method <i>m,</i> then the declaration <i>m</i> is said to <em>hide</em> any method <i>m',</i> where the signature of <i>m</i> is a subsignature <a href="classes.html#38649">(&#167;8.4.2)</a> of the signature of <i>m',</i> in the superclasses and superinterfaces of the class that would otherwise be accessible to code in the class. A compile-time error occurs if a <code>static</code> method hides an instance method.<p>
<a name="258967"></a>
<p>In this respect, hiding of methods differs from hiding of fields <a href="classes.html#40898">(&#167;8.3)</a>, for it is permissible for a <code>static</code> variable to hide an instance variable. Hiding is also distinct from shadowing <a href="names.html#34133">(&#167;6.3.1)</a> and obscuring <a href="names.html#104058">(&#167;6.3.2)</a>.</p>
<a name="259256"></a>
<p>A hidden method can be accessed by using a qualified name or by using a method invocation expression <a href="expressions.html#20448">(&#167;15.12)</a> that contains the keyword <code>super</code> or a cast to a superclass type. In this respect, hiding of methods is similar to hiding of fields.</p>
<a name="324258"></a>
<p></p>
<a name="227965"></a>
<a name="8.4.8.3"></a>
<h4>8.4.8.3    Requirements in Overriding and Hiding</h4>
<a name="227966"></a>
If a method declaration <i>d<sub>1</sub></i> with return type <i>R<sub>1</sub></i> overrides or hides the declaration of another method <i>d<sub>2</sub></i> with return type <i>R<sub>2</sub></i>, then <i>d<sub>1</sub></i> must be return-type substitutable for <i>d<sub>2</sub></i>, or a compile-time error occurs. Furthermore, if <i>R<sub>1</sub></i> is not a subtype of <i>R<sub>2</sub></i>, an unchecked warning must be issued (unless suppressed <a href="interfaces.html#255603">(&#167;9.6.1.5)</a>).<p>
<a name="307722"></a>
A method declaration must not have a <code>throws</code> clause that conflicts <a href="classes.html#308526">(&#167;8.4.6)</a> with that of any method that it overrides or hides; otherwise, &#32;a compile-time error occurs.<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="307750"></a>
 <p>
<a name="307751"></a>
 The rules above allow for <i>covariant return types</i> - refining the return type of a method when overriding it.<p>
<a name="307763"></a>
For example, the following declarations are legal although they were illegal in prior versions of the Java programming language:<p>
<blockquote><pre>class C implements Cloneable { 
   C copy() { return (C)clone(); } 
}
class D extends C implements Cloneable { 
   D copy() { return (D)clone(); } 
}
</pre></blockquote><a name="307758"></a>
The relaxed rule for overriding also allows one to relax the conditions on abstract classes implementing interfaces. <p>
<hr>
<a name="307759"></a>
 <p>
<a name="307463"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="307773"></a>
<p>
 Consider<p>
<blockquote><pre>class StringSorter {
// takes a collection of strings and converts it to a sortedlist
    List toList(Collection c) {...} 
}
</pre></blockquote>
<a name="323955"></a>
 and assume that someone subclasses <code>StringCollector</code><p>
 <blockquote><pre>
class Overrider extends StringSorter{
    List toList(Collection c) {...}
}
</pre></blockquote><a name="323930"></a>
Now, at some point the author of <code>StringSorter</code> decides to generify the code<p>
<blockquote><pre>class StringSorter {
// takes a collection of strings and converts it to a list
    List&lt;String&gt; toList(Collection&lt;String&gt; c) {...}
}
</pre></blockquote><a name="323956"></a>
An unchecked warning would be given when compiling <code>Overrider</code> against the new definition of <code>StringSorter</code> because the return type of <code>Overrider.toList()</code> is <code>List</code>, which is not a subtype of the return type of the overridden method, <code>List&lt;String</code>. <p>
<hr>
<a name="307470"></a>
 <p>
<a name="259261"></a>
<p>In these respects, overriding of methods differs from hiding of fields <a href="classes.html#40898">(&#167;8.3)</a>, for it is permissible for a field to hide a field of another type.</p>
<a name="329241"></a>
It is a compile time error if a type declaration <i>T</i> has a member method <i>m<sub>1</sub></i> and there exists a method <i>m<sub>2</sub></i> declared in <i>T</i> or a supertype of <i>T</i> such that all of the following conditions hold:<p>
<ul><a name="329242"></a>
<li><i>m<sub>1</sub></i> and <i>m<sub>2</sub></i> have the same name.
<a name="329243"></a>
<li><i>m<sub>2</sub></i> is accessible from <i>T</i>.
<a name="329247"></a>
<li>The signature of <i>m<sub>1</sub></i> is not a subsignature <a href="classes.html#38649">(&#167;8.4.2)</a> of the signature of <i>m<sub>2</sub></i>.
<a name="329266"></a>
<li><i>m<sub>1</sub></i> or some method <i>m<sub>1</sub></i> overrides (directly or indirectly) has the same erasure as <i>m<sub>2</sub></i> or some method <i>m<sub>2</sub></i> overrides (directly or indirectly).
</ul><a name="328921"></a>
<p>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="308935"></a>
 <p>
<a name="303530"></a>
 These restrictions are necessary because generics are implemented via erasure. The rule above implies that methods declared in the same class with the same name must have different erasures. It also implies that a type declaration cannot implement or extend two distinct invocations of the same generic interface. Here are some further examples.<p>
<a name="303527"></a>
A class cannot have two member methods with the same name and type erasure.<p>
<blockquote><pre>class C&lt;T&gt; { T id (T x) {...} }
class D extends C&lt;String&gt; {
   Object id(Object x) {...}
}
</pre></blockquote><a name="303481"></a>
This is illegal since <code>D.id(Object)</code> is a member of <code>D</code>, <code>C&lt;String&gt;.id(String)</code> is declared in a supertype of <code>D</code> and:<p>
<ul><a name="303482"></a>
<li>The two methods have the same name, <code>id</code>
<a name="303483"></a>
<li><code>C&lt;String&gt;.id(String</code>) is accessible to <code>D</code>
<a name="303484"></a>
<li>The signature of <code>D.id(Object)</code> is not a subsignature of that of <code>C&lt;String&gt;.id(String)</code>
<a name="303485"></a>
<li>The two methods have the same erasure
</ul>
<a name="303486"></a>
 <p>
 <hr>
<a name="303487"></a>
 <p>
<a name="303488"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
 Two different methods of a class may not override methods with the same erasure.<p>
<blockquote><pre>class C&lt;T&gt; { T id (T x) {...} }
interface I&lt;T&gt; { Tid(T x); }
class D extends C&lt;String&gt; implements I&lt;Integer&gt; {
   String id(String x) {...}
   Integer id(Integer x) {...}
}
</pre></blockquote><a name="303496"></a>
This is also illegal, since <code>D.id(String)</code> is a member of <code>D</code>, <code>D.id(Integer)</code> is declared in <code>D</code> and:<p>
<ul><a name="303497"></a>
<li>the two methods have the same name, <code>id</code>
<a name="303498"></a>
<li>the two methods have different signatures.
<a name="303499"></a>
<li><code>D.id(Integer)</code> is accessible to <code>D</code>
<a name="303500"></a>
<li><code>D.id(String)</code> overrides <code>C&lt;String&gt;.id(String)</code> and <code>D.id(Integer)</code> overrides <code>I.id(Integer)</code> yet the two overridden methods have the same erasure
</ul>
<a name="303501"></a>
 <p>
 <hr>
<a name="300668"></a>
The access modifier <a href="names.html#104285">(&#167;6.6)</a> of an overriding or hiding method must provide at least as much access as the overridden or hidden method, or a compile-time error occurs. In more detail:<p>
<ul><a name="39549"></a>
<li>If the overridden or hidden method is <code>public</code>, then the overriding or hiding method must be <code>public</code>; otherwise, a compile-time error occurs.
<a name="39550"></a>
<li>If the overridden or hidden method is <code>protected</code>, then the overriding or hiding method must be <code>protected</code> or <code>public</code>; otherwise, a compile-time error occurs.
<a name="39551"></a>
<li>If the overridden or hidden method has default (package) access, then the overriding or hiding method must not be <code>private</code>; otherwise, a compile-time error occurs.
</ul>
<a name="259266"></a>
<p>Note that a <code>private</code> method cannot be hidden or overridden in the technical sense of those terms. This means that a subclass can declare a method with the same signature as a <code>private</code> method in one of its superclasses, and there is no requirement that the return type or <code>throws</code> clause of such a method bear any relationship to those of the <code>private</code> method in the superclass.</p>
<a name="227941"></a>
<a name="8.4.8.4"></a>
<h4>8.4.8.4    Inheriting Methods with Override-Equivalent Signatures</h4>
<a name="39557"></a>
It is possible for a class to inherit multiple methods with override-equivalent <a href="classes.html#38649">(&#167;8.4.2)</a> signatures.<p>
<a name="300634"></a>
It is a compile time error if a class <i>C</i> inherits a concrete method whose signatures is a subsignature of another concrete method inherited by <i>C.</i> <p>
<a name="309136"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
<a name="309137"></a>
 <p>
 This can happen, if a superclass is parametric, and it has two methods that were distinct in the generic declaration, but have the same signature in the particular invocation used.<p>
<hr>
<a name="300667"></a>
 <p>
<a name="300644"></a>
Otherwise, there are two possible cases:<p>
<ul><a name="39561"></a>
<li>If one of the inherited methods is not <code>abstract</code>, then there are two subcases:
<ul>
<a name="39562"></a>
<li>If the method that is not <code>abstract</code> is <code>static</code>, a compile-time error occurs.
<a name="39563"></a>
<li>Otherwise, the method that is not <code>abstract</code> is considered to override, and therefore to implement, all the other methods on behalf of the class that inherits it. If the signature of the non-abstract method is not a subsignature of each of the other inherited methods  an unchecked warning must be issued (unless suppressed <a href="interfaces.html#255603">(&#167;9.6.1.5)</a>). A compile-time error also occurs if the return type of the non-abstract method is not return type substitutable <a href="classes.html#296201">(&#167;8.4.5)</a> for each of the other inherited methods. If the return type of the non-abstract method is not a subtype of the return type of any of the other inherited methods, an unchecked warning must be issued. Moreover, a compile-time error occurs if the inherited method that is not <code>abstract</code> has a <code>throws</code> clause that conflicts <a href="classes.html#308526">(&#167;8.4.6)</a> with that of any other of the inherited methods.
</ul>
<a name="308681"></a>
<li>If all the inherited methods are <code>abstract</code>, then the class is necessarily an <code>abstract</code> class and is considered to inherit all the <code>abstract</code> methods. A compile-time error occurs if, for any two such inherited methods, one of the methods  is not return type substitutable for the other (The <code>throws</code> clauses do not cause errors in this case.)
</ul><a name="39569"></a>
There might be several paths by which the same method declaration might be inherited from an interface. This fact causes no difficulty and never, of itself, results in a compile-time error.<p>
<a name="227768"></a>
<a name="8.4.9"></a>
<h3>8.4.9    Overloading</h3>
<a name="39587"></a>
If two methods of a class (whether both declared in the same class, or both inherited by a class, or one declared and one inherited) have the same name but signatures that are not override-equivalent, then the method name is said to be <em>overloaded</em>. This fact causes no difficulty and never of itself results in a compile-time error. There is no required relationship between the return types or between the <code>throws</code> clauses of two methods with the same name, unless their signatures are override-equivalent.<p>
<a name="39909"></a>
Methods are overridden on a signature-by-signature basis. <p>
<a name="258985"></a>
<p>If, for example, a class declares two <code>public</code> methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. </p>
<a name="39591"></a>
<p>When a method is invoked <a href="expressions.html#20448">(&#167;15.12)</a>, the number of actual arguments (and any explicit type arguments) and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked <a href="expressions.html#292575">(&#167;15.12.2)</a>. If the method that is to be invoked is an instance method, the actual method to be invoked will be determined at run time, using dynamic method lookup <a href="expressions.html#45677">(&#167;15.12.4)</a>.</p>
<a name="39598"></a>
<a name="8.4.10"></a>
<h3>8.4.10    Examples of Method Declarations</h3>
<a name="39599"></a>
The following examples illustrate some (possibly subtle) points about method declarations.<p>
<a name="39600"></a>
<a name="8.4.10.1"></a>
<h4>8.4.10.1    Example: Overriding</h4>
<a name="39601"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class SlowPoint extends Point {
	int xLimit, yLimit;
	void move(int dx, int dy) {
		super.move(limit(dx, xLimit), limit(dy, yLimit));
	}
	static int limit(int d, int limit) {
		return d &gt; limit ? limit : d &lt; -limit ? -limit : d;
	}
}
</pre></blockquote><a name="39615"></a>
the class <code>SlowPoint</code> overrides the declarations of method <code>move</code> of class <code>Point</code> with its own <code>move</code> method, which limits the distance that the point can move on each invocation of the method. When the <code>move</code> method is invoked for an instance of class <code>SlowPoint</code>, the overriding definition in class <code>SlowPoint</code> will always be called, even if the reference to the <code>SlowPoint</code> object is taken from a variable whose type is <code>Point</code>.<p>
<a name="39617"></a>
<a name="8.4.10.2"></a>
<h4>8.4.10.2    Example: Overloading, Overriding, and Hiding</h4>
<a name="39618"></a>
In the example:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
	int color;
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
}
</pre></blockquote><a name="39629"></a>
the class <code>RealPoint</code> hides the declarations of the <code>int</code> instance variables <code>x</code> and <code>y</code> of class <code>Point</code> with its own <code>float</code> instance variables <code>x</code> and <code>y</code>, and overrides the method <code>move</code> of class <code>Point</code> with its own <code>move</code> method. It also overloads the name <code>move</code> with another method with a different signature <a href="classes.html#38649">(&#167;8.4.2)</a>.<p>
<a name="39633"></a>
<p>In this example, the members of the class <code>RealPoint</code> include the instance variable <code>color</code> inherited from the class <code>Point</code>, the <code>float</code> instance variables <code>x</code> and <code>y</code> declared in <code>RealPoint</code>, and the two <code>move</code> methods declared in <code>RealPoint</code>.</p>
<a name="39634"></a>
<p>Which of these overloaded <code>move</code> methods of class <code>RealPoint</code> will be chosen for any particular method invocation will be determined at compile time by the overloading resolution procedure described in <a href="expressions.html#20448">&#167;15.12</a>.</p>
<a name="39638"></a>
<a name="8.4.10.3"></a>
<h4>8.4.10.3    Example: Incorrect Overriding</h4>
<a name="39639"></a>
This example is an extended variation of that in the preceding section:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0, color;
	void move(int dx, int dy) { x += dx; y += dy; }
	int getX() { return x; }
	int getY() { return y; }
}
</pre></blockquote><a name="324259"></a>
<p>
<blockquote><pre>class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
	float getX() { return x; }
	float getY() { return y; }
}
</pre></blockquote><a name="39654"></a>
Here the class <code>Point</code> provides methods <code>getX</code> and <code>getY</code> that return the values of its fields <code>x</code> and <code>y</code>; the class <code>RealPoint</code> then overrides these methods by declaring methods with the same signature. The result is two errors at compile time, one for each method, because the return types do not match; the methods in class <code>Point</code> return values of type <code>int</code>, but the wanna-be overriding methods in class <code>RealPoint</code> return values of type <code>float</code>.<p>
<a name="39655"></a>
<a name="8.4.10.4"></a>
<h4>8.4.10.4    Example: Overriding versus Hiding</h4>
<a name="39656"></a>
This example corrects the errors of the example in the preceding section:<p>
<blockquote><pre>class Point {
	int x = 0, y = 0;
	void move(int dx, int dy) { x += dx; y += dy; }
	int getX() { return x; }
	int getY() { return y; }
	int color;
}
class RealPoint extends Point {
	float x = 0.0f, y = 0.0f;
	void move(int dx, int dy) { move((float)dx, (float)dy); }
	void move(float dx, float dy) { x += dx; y += dy; }
	int getX() { return (int)Math.floor(x); }
	int getY() { return (int)Math.floor(y); }
}
</pre></blockquote><a name="39671"></a>
Here the overriding methods <code>getX</code> and <code>getY</code> in class <code>RealPoint</code> have the same return types as the methods of class <code>Point</code> that they override, so this code can be successfully compiled.<p>
<a name="324260"></a>
<p>
<a name="324261"></a>
<p>
<a name="39672"></a>
<p>Consider, then, this test program:</p>
<blockquote><pre>class Test {
	public static void main(String[] args) {
		RealPoint rp = new RealPoint();
		Point p = rp;
		rp.move(1.71828f, 4.14159f);
		p.move(1, -1);
		show(p.x, p.y);
		show(rp.x, rp.y);
		show(p.getX(), p.getY());
		show(rp.getX(), rp.getY());
	}
	static void show(int x, int y) {
		System.out.println("(" + x + ", " + y + ")");
	}
	static void show(float x, float y) {
		System.out.println("(" + x + ", " + y + ")");
	}
}
</pre></blockquote><a name="39691"></a>
The output from this program is:<p>
<blockquote><pre>(0, 0)
(2.7182798, 3.14159)
(2, 3)
(2, 3)
</pre></blockquote>
<a name="39696"></a>
<p>The first line of output illustrates the fact that an instance of <code>RealPoint</code> actually contains the two integer fields declared in class <code>Point</code>; it is just that their names are hidden from code that occurs within the declaration of class <code>RealPoint</code> (and those of any subclasses it might have). When a reference to an instance of class <code>RealPoint</code> in a variable of type <code>Point</code> is used to access the field <code>x</code>, the integer field <code>x</code> declared in class <code>Point</code> is accessed. The fact that its value is zero indicates that the method invocation <code>p.move(1,</code> <code>-1)</code> did not invoke the method <code>move</code> of class <code>Point</code>; instead, it invoked the overriding method <code>move</code> of class <code>RealPoint</code>.</p>
<a name="39697"></a>
<p>The second line of output shows that the field access <code>rp.x</code> refers to the field <code>x</code> declared in class <code>RealPoint</code>. This field is of type <code>float</code>, and this second line of output accordingly displays floating-point values. Incidentally, this also illustrates the fact that the method name <code>show</code> is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.</p>
<a name="230120"></a>
<p>The last two lines of output show that the method invocations <code>p.getX()</code> and <code>rp.getX()</code> each invoke the <code>getX</code> method declared in class <code>RealPoint</code>. Indeed, there is no way to invoke the <code>getX</code> method of class <code>Point</code> for an instance of class <code>RealPoint</code> from outside the body of <code>RealPoint</code>, no matter what the type of the variable we may use to hold the reference to the object. Thus, we see that fields and methods behave differently: hiding is different from overriding.</p>
<a name="229207"></a>
<a name="8.4.10.5"></a>
<h4>8.4.10.5    Example: Invocation of Hidden Class Methods</h4>
<a name="229208"></a>
A hidden class (<code>static</code>) method can be invoked by using a reference whose type is the class that actually contains the declaration of the method. In this respect, hiding of static methods is different from overriding of instance methods. The example:<p>
<blockquote><pre>class Super {
	static String greeting() { return "Goodnight"; }
	String name() { return "Richard"; }
}
class Sub extends Super {
	static String greeting() { return "Hello"; }
	String name() { return "Dick"; }
}
class Test {
	public static void main(String[] args) {
		Super s = new Sub();
		System.out.println(s.greeting() + ", " + s.name());
	}
}
</pre></blockquote><a name="229223"></a>
produces the output:<p>
<blockquote><pre>Goodnight, Dick
</pre></blockquote><a name="229225"></a>
because the invocation of <code>greeting</code> uses the type of <code>s</code>, namely <code>Super</code>, to figure out, at compile time, which class method to invoke, whereas the invocation of <code>name</code> uses the class of <code>s</code>, namely <code>Sub</code>, to figure out, at run time, which instance method to invoke.<p>
<a name="229149"></a>
<a name="8.4.10.6"></a>
<h4>8.4.10.6    Large Example of Overriding</h4>
<a name="229150"></a>
Overriding makes it easy for subclasses to extend the behavior of an existing class, as shown in this example:<p>
<blockquote><pre>import java.io.OutputStream;
import java.io.IOException;
class BufferOutput {
	private OutputStream o;
	BufferOutput(OutputStream o) { this.o = o; }
	protected byte[] buf = new byte[512];
	protected int pos = 0;
	public void putchar(char c) throws IOException {
		if (pos == buf.length)
			flush();
		buf[pos++] = (byte)c;
	}
	public void putstr(String s) throws IOException {
		for (int i = 0; i &lt; s.length(); i++)
			putchar(s.charAt(i));
	}
	public void flush() throws IOException {
		o.write(buf, 0, pos);
		pos = 0;
	}
}
class LineBufferOutput extends BufferOutput {
	LineBufferOutput(OutputStream o) { super(o); }
	public void putchar(char c) throws IOException {
		super.putchar(c);
		if (c == '\n')
			flush();
	}
}
class Test {
	public static void main(String[] args)
		throws IOException
	{
		LineBufferOutput lbo =
			new LineBufferOutput(System.out);
		lbo.putstr("lbo\nlbo");
		System.out.print("print\n");
		lbo.putstr("\n");
	}
}
</pre></blockquote><a name="229188"></a>
This example produces the output:<p>
<blockquote><pre>lbo
print
lbo
</pre></blockquote>
<a name="229192"></a>
<p>The class <code>BufferOutput</code> implements a very simple buffered version of an <code>OutputStream</code>, flushing the output when the buffer is full or <code>flush</code> is invoked. The subclass <code>LineBufferOutput</code> declares only a constructor and a single method <code>putchar</code>, which overrides the method <code>putchar</code> of <code>BufferOutput</code>. It inherits the methods <code>putstr</code> and <code>flush</code> from class <code>BufferOutput</code>.</p>
<a name="229193"></a>
<p>In the <code>putchar</code> method of a <code>LineBufferOutput</code> object, if the character argument is a newline, then it invokes the <code>flush</code> method. The critical point about overriding in this example is that the method <code>putstr</code>, which is declared in class <code>BufferOutput</code>, invokes the <code>putchar</code> method defined by the current object <code>this</code>, which is not necessarily the <code>putchar</code> method declared in class <code>BufferOutput</code>.</p>
<a name="229194"></a>
<p>Thus, when <code>putstr</code> is invoked in <code>main</code> using the <code>LineBufferOutput</code> object <code>lbo</code>, the invocation of <code>putchar</code> in the body of the <code>putstr</code> method is an invocation of the <code>putchar</code> of the object <code>lbo</code>, the overriding declaration of <code>putchar</code> that checks for a newline. This allows a subclass of <code>BufferOutput</code> to change the behavior of the <code>putstr</code> method without redefining it.</p>
<a name="229195"></a>
<p>Documentation for a class such as <code>BufferOutput</code>, which is designed to be extended, should clearly indicate what is the contract between the class and its subclasses, and should clearly indicate that subclasses may override the <code>putchar</code> method in this way. The implementor of the <code>BufferOutput</code> class would not, therefore, want to change the implementation of <code>putstr</code> in a future implementation of <code>BufferOutput</code> not to use the method <code>putchar</code>, because this would break the preexisting contract with subclasses. See the further discussion of binary compatibility in <a href="binaryComp.html#44871">&#167;13</a>, especially <a href="binaryComp.html#44952">&#167;13.2</a>.</p>
</pre></blockquote><a name="229203"></a>
<a name="8.4.10.7"></a>
<h4>8.4.10.7    Example: Incorrect Overriding because of Throws</h4>
<a name="39701"></a>
This example uses the usual and conventional form for declaring a new exception type, in its declaration of the class <code>BadPointException</code>:<p>
<blockquote><pre>class BadPointException extends Exception {
	BadPointException() { super(); }
	BadPointException(String s) { super(s); }
}
class Point {
	int x, y;
	void move(int dx, int dy) { x += dx; y += dy; }
}
class CheckedPoint extends Point {
	void move(int dx, int dy) throws BadPointException {
		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
			throw new BadPointException();
		x += dx; y += dy;
	}
}
</pre></blockquote><a name="39718"></a>
This example results in a compile-time error, because the override of method <code>move</code> in class <code>CheckedPoint</code> declares that it will throw a checked exception that the <code>move</code> in class <code>Point</code> has not declared. If this were not considered an error, an invoker of the method <code>move</code> on a reference of type <code>Point</code> could find the contract between it and <code>Point</code> broken if this exception were thrown.<p>
<a name="39725"></a>
<p>Removing the <code>throws</code> clause does not help:</p>
<blockquote><pre>class CheckedPoint extends Point {
	void move(int dx, int dy) {
		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
			throw new BadPointException();
		x += dx; y += dy;
	}
}
</pre></blockquote>
<a name="259271"></a>
<p>A different compile-time error now occurs, because the body of the method <code>move</code> cannot throw a checked exception, namely <code>BadPointException</code>, that does not appear in the <code>throws</code> clause for <code>move</code>.</p>
<a name="246026"></a>
<a name="8.5"></a>
<h2>8.5    Member Type Declarations</h2>
<a name="247539"></a>
A <i>member class</i> is a class whose declaration is directly enclosed in another class or interface declaration. Similarly, a <i>member interface</i> is an interface whose declaration is directly enclosed in another class or interface declaration. The scope <a href="names.html#103228">(&#167;6.3)</a> of a member class or interface is specified in <a href="classes.html#18988">&#167;8.1.6</a>. <p>
<a name="289016"></a>
If the class declares a member type with a certain name, then the declaration of that type is said to <em>hide</em> any and all accessible declarations of member types with the same name in superclasses and superinterfaces of the class. <p>
<a name="260651"></a>
Within a class <i>C</i>, a declaration <i>d</i> of a member type named <i>n</i> shadows the declarations of any other types named <i>n</i> that are in scope at the point where <i>d</i> occurs.<p>
<a name="300431"></a>
If a member class or interface declared with simple name <i>C</i> is directly enclosed within the declaration of a class with fully qualified name <i>N</i>, then the member class or interface has the fully qualified name <i>N.C</i>. A class inherits from its direct superclass and direct superinterfaces all the non-private member types of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.<p>
<a name="247722"></a>
A class may inherit two or more type declarations with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited class or interface by its simple name<p>
<a name="247732"></a>
If the same type declaration is inherited from an interface by multiple paths, the class or interface is considered to be inherited only once. It may be referred to by its simple name without ambiguity.<p>
<a name="247581"></a>
<a name="8.5.1"></a>
<h3>8.5.1    Modifiers</h3>
<a name="246857"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if a member type declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. <p>
<a name="302512"></a>
Member type declarations may have annotation modifers just like any type or member declaration.<p>
<a name="246853"></a>
<a name="8.5.2"></a>
<h3>8.5.2    Static Member Type Declarations</h3>
<a name="246645"></a>
The <code>static</code> keyword may modify the declaration of a member type <i>C</i> within the body of a non-inner class <i>T</i>. Its effect is to declare that <i>C</i> is not an inner class. Just as a static method of <i>T</i> has no current instance of <i>T</i> in its body, <i>C</i> also has no current instance of <i>T</i>, nor does it have any lexically enclosing instances.<p>
<a name="250215"></a>
It is a compile-time error if a <code>static</code> class contains a usage of a non-<code>static</code> member of an enclosing class.<p>
<a name="247136"></a>
Member interfaces are always implicitly <code>static</code>. It is permitted but not required for the declaration of a member interface to explicitly list the <code>static</code> modifier.<p>
<a name="246032"></a>
<a name="8.6"></a>
<h2>8.6    Instance Initializers</h2>
<a name="246072"></a>
An <i>instance initializer</i> declared in a class is executed when an instance of the class is created <a href="expressions.html#41147">(&#167;15.9)</a>, as specified in <a href="classes.html#229267">&#167;8.8.7.1</a>. <p>
<blockquote><pre>
<em>InstanceInitializer:
	Block
</em></pre></blockquote><a name="329432"></a>
It is compile-time error if an instance initializer of a named class can throw a checked exception unless that exception or one of its supertypes is explicitly declared in the <code>throws</code> clause of each constructor of its class and the class has at least one explicitly declared constructor. An instance initializer in an anonymous class <a href="expressions.html#252986">(&#167;15.9.5)</a> can throw any exceptions. <p>
<a name="329440"></a>
<p>
<a name="273818"></a>
<p>The rules above distinguish between instance initializers in named and anonymous classes. This distinction is deliberate. A given anonymous class is only instantiated at a single point in a program. It is therefore possible to directly propagate information about what exceptions might be raised by an anonymous class' instance initializer to the surrounding expression. Named classes, on the other hand, can be instantiated in many places. Therefore the only way to propagate information about what exceptions might be raised by an instance initializer of a named class is through the throws clauses of its constructors. It follows that a more liberal rule can be used in the case of anonymous classes. Similar comments apply to instance variable initializers.</p>
<a name="273817"></a>
It is a compile-time error if an instance initializer cannot complete normally <a href="statements.html#236365">(&#167;14.21)</a>. If a return statement <a href="statements.html#6767">(&#167;14.17)</a> appears anywhere within an instance initializer, then a compile-time error occurs.<p>
<a name="329413"></a>
Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See <a href="classes.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to instance variables.<p>
<a name="247361"></a>
Instance initializers are permitted to refer to the current object this <a href="expressions.html#251519">(&#167;15.8.3)</a>, to any type variables <a href="typesValues.html#108850">(&#167;4.4)</a> in scope and to use the keyword <code>super</code> (<a href="expressions.html#20860">&#167;15.11.2</a>, <a href="expressions.html#20448">&#167;15.12</a>).<p>
<a name="39245"></a>
<a name="8.7"></a>
<h2>8.7    Static Initializers</h2>
<a name="39251"></a>
Any <em>static initializers </em>declared in a class are executed when the class is initialized and, together with any field initializers <a href="classes.html#24510">(&#167;8.3.2)</a> for class variables, may be used to initialize the class variables of the class <a href="execution.html#44557">(&#167;12.4)</a>.<p>
<blockquote><pre>
<em>StaticInitializer</em>:
	static <em>Block</em>
</pre></blockquote><a name="41620"></a>
It is a compile-time error for a static initializer to be able to complete abruptly (<a href="statements.html#5894">&#167;14.1</a>, <a href="expressions.html#79448">&#167;15.6</a>) with a checked exception <a href="exceptions.html#44121">(&#167;11.2)</a>. It is a compile-time error if a static initializer cannot complete normally <a href="statements.html#236365">(&#167;14.21)</a>.<p>
<a name="260750"></a>
The static initializers and class variable initializers are executed in textual order. <p>
<a name="329365"></a>
Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See <a href="classes.html#287406">&#167;8.3.2.3</a> for the precise rules governing forward reference to class variables.<p>
<a name="41700"></a>
If a <code>return</code> statement <a href="statements.html#6767">(&#167;14.17)</a> appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="39966"></a>
If the keyword <code>this</code> <a href="expressions.html#251519">(&#167;15.8.3)</a> or any type variable <a href="typesValues.html#108850">(&#167;4.4)</a> defined outside the initializer or the keyword <code>super</code> (<a href="expressions.html#41267">&#167;15.11</a>, <a href="expressions.html#20448">&#167;15.12</a>) appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="41652"></a>
<a name="8.8"></a>
<h2>8.8    Constructor Declarations</h2>
<a name="78391"></a>
A <em>constructor</em> is used in the creation of an object that is an instance of a class:<p>
<blockquote><pre>
<em>ConstructorDeclaration:
	ConstructorModifiers<sub>opt</sub>&#32;ConstructorDeclarator
		Throws<sub><i>opt</i></sub>&#32;ConstructorBody

ConstructorDeclarator:
	TypeParameters<sub><i>opt</i></sub> SimpleTypeName ( FormalParameterList<sub><i>opt</i></sub> )
	</em>
</pre></blockquote><a name="30689"></a>
The <em>SimpleTypeName </em>in the <em>ConstructorDeclarator</em> must be the simple name of the class that contains the constructor declaration; otherwise a compile-time error occurs. In all other respects, the constructor declaration looks just like a method declaration that has no result type.<p>
<a name="229252"></a>
<p>
<a name="229249"></a>
<p>Here is a simple example:</p>
<blockquote><pre>class Point {
	int x, y;
	Point(int x, int y) { this.x = x; this.y = y; }
}
</pre></blockquote><a name="41721"></a>
Constructors are invoked by class instance creation expressions <a href="expressions.html#41147">(&#167;15.9)</a>, by the conversions and concatenations caused by the string concatenation operator + <a href="expressions.html#39990">(&#167;15.18.1)</a>, and by explicit constructor invocations from other constructors <a href="classes.html#78435">(&#167;8.8.7)</a>. Constructors are never invoked by method invocation expressions <a href="expressions.html#20448">(&#167;15.12)</a>.<p>
<a name="29483"></a>
Access to constructors is governed by access modifiers <a href="names.html#104285">(&#167;6.6)</a>. <p>
<a name="258999"></a>
<p>This is useful, for example, in preventing instantiation by declaring an inaccessible constructor <a href="classes.html#16830">(&#167;8.8.10)</a>.</p>
<a name="39897"></a>
Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding.<p>
<a name="29488"></a>
<a name="8.8.1"></a>
<h3>8.8.1    Formal Parameters and Formal Type Parameter</h3>
<a name="41970"></a>
The formal parameters and formal type parameters of a constructor are identical in structure and behavior to the formal parameters of a method <a href="classes.html#38698">(&#167;8.4.1)</a>.<p>
<a name="41990"></a>
<a name="8.8.2"></a>
<h3>8.8.2    Constructor Signature</h3>
<a name="303664"></a>
It is a compile-time error to declare two constructors with override-equivalent <a href="classes.html#38649">(&#167;8.4.2)</a> <em>signatures</em> in a class. It is a compile-time error to declare two constructors whose signature has the same erasure <a href="typesValues.html#108979">(&#167;4.6)</a> in a class.<p>
<a name="42018"></a>
<a name="8.8.3"></a>
<h3>8.8.3    Constructor Modifiers</h3>
<blockquote><pre>
<em>ConstructorModifiers:
	ConstructorModifier
	ConstructorModifiers</em> ConstructorModifier

<em>ConstructorModifier: one of
	</em> <em>Annotation</em> public&#32;protected&#32;private
</pre></blockquote><a name="36010"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="names.html#104285">&#167;6.6</a>. A &#32;compile-time error occurs if the same modifier appears more than once in a constructor declaration, or if a constructor declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. <p>
<a name="302183"></a>
If no access modifier is specified for the constructor of a normal class, the constructor has default access. If no access modifier is specified for the constructor of an enum type, the constructor is <code>private</code>. It is a compile-time error if the constructor of an enum type <a href="classes.html#301020">(&#167;8.9)</a> is declared <code>public</code> or <code>protected</code>.<p>
<a name="302508"></a>
If an annotation <i>a</i> on a constructor corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.CONSTRUCTOR</code>, or a compile-time error occurs. Annotations are further discussed in <a href="interfaces.html#253695">&#167;9.7</a>.<p>
<a name="259286"></a>
<p>Unlike methods, a constructor cannot be <code>abstract</code>, <code>static</code>, <code>final</code>, <code>native</code>, <code>strictfp</code>, or <code>synchronized</code>. A constructor is not inherited, so there is no need to declare it <code>final</code> and an <code>abstract</code> constructor could never be implemented. A constructor is always invoked with respect to an object, so it makes no sense for a constructor to be <code>static</code>. There is no practical need for a constructor to be <code>synchronized</code>, because it would lock the object under construction, which is normally not made available to other threads until all constructors for the object have completed their work. The lack of <code>native</code> constructors is an arbitrary language design choice that makes it easy for an implementation of the Java virtual machine to verify that superclass constructors are always properly invoked during object creation.</p>
<a name="246538"></a>
<p>Note that a <em>ConstructorModifier</em> cannot be declared <code>strictfp</code>. This difference in the definitions for <em>ConstructorModifier</em> and <em>MethodModifier</em> <a href="classes.html#78188">(&#167;8.4.3)</a> is an intentional language design choice; it effectively ensures that a constructor is FP-strict <a href="expressions.html#249198">(&#167;15.4)</a> if and only if its class is FP-strict.</p>
<a name="244611"></a>
<a name="8.8.4"></a>
<h3>8.8.4    Generic Constructors</h3>
<a name="300912"></a>
It is possible for a constructor to be declared generic, independently of whether the class the constructor is declared in is itself generic. A constructor is <i>generic</i> if it declares one or more type variables <a href="typesValues.html#108850">(&#167;4.4)</a>. These type variables are known as the <i>formal type parameters</i> of the constructor. The form of the formal type parameter list is identical to a type parameter list of a generic class or interface, as described in <a href="classes.html#299360">&#167;8.1.2</a>. <p>
<a name="329511"></a>
The scope of a constructor's type parameter is the entire declaration of the constructor, including the type parameter section itself. Therefore, type parameters can appear as parts of their own bounds, or as bounds of other type parameters declared in the same section.<p>
<a name="300918"></a>
Type parameters of generic constructor need not be provided explicitly when a generic constructor is invoked. When they are not provided, they are inferred as specified in <a href="expressions.html#341287">&#167;15.12.2.7</a>.<p>
<a name="300906"></a>
<p>
<a name="300902"></a>
<a name="8.8.5"></a>
<h3>8.8.5    Constructor Throws</h3>
<a name="244612"></a>
The <code>throws</code> clause for a constructor is identical in structure and behavior to the <code>throws</code> clause for a method <a href="classes.html#308526">(&#167;8.4.6)</a>.<p>
<a name="306589"></a>
<a name="8.8.6"></a>
<h3>8.8.6    The Type of a Constructor</h3>
<a name="306590"></a>
The type of a constructor consists of its signature and the exception types given its throws clause.<p>
<a name="78435"></a>
<a name="8.8.7"></a>
<h3>8.8.7    Constructor Body</h3>
<a name="42051"></a>
The first statement of a constructor body may be an explicit invocation of another constructor of the same class or of the direct superclass <a href="classes.html#229267">(&#167;8.8.7.1)</a>.<p>
<blockquote><pre>
<em>ConstructorBody:
</em>	{<em> ExplicitConstructorInvocation<sub>opt</sub> BlockStatements<sub><i>opt</i></sub> </em>}
</pre></blockquote><a name="230283"></a>
It is a compile-time error for a constructor to directly or indirectly invoke itself through a series of one or more explicit constructor invocations involving <code>this</code>.  If the constructor is a constructor for an enum type <a href="classes.html#301020">(&#167;8.9)</a>, it is a compile-time error for it to invoke the superclass constructor explicitly.<p>
<a name="229836"></a>
If a constructor body does not begin with an explicit constructor invocation and the constructor being declared is not part of the primordial class <code>Object</code>, then the constructor body is implicitly assumed by the compiler to begin with a superclass constructor invocation "<code>super();</code>", an invocation of the constructor of its direct superclass that takes no arguments.<p>
<a name="30734"></a>
Except for the possibility of explicit constructor invocations, the body of a constructor is like the body of a method <a href="classes.html#37316">(&#167;8.4.7)</a>. A <code>return</code> statement <a href="statements.html#6767">(&#167;14.17)</a> may be used in the body of a constructor if it does not include an expression.<p>
<a name="42056"></a>
<p>In the example:</p>
<blockquote><pre>class Point {
	int x, y;
	Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
	static final int WHITE = 0, BLACK = 1;
	int color;
	ColoredPoint(int x, int y) {
		this(x, y, WHITE);
	}
	ColoredPoint(int x, int y, int color) {
		super(x, y);
		this.color = color;
	}
}
</pre></blockquote><a name="271283"></a>
the first constructor of <code>ColoredPoint</code> invokes the second, providing an additional argument; the second constructor of <code>ColoredPoint</code> invokes the constructor of its superclass <code>Point</code>, passing along the coordinates.<p>
<a name="229264"></a>
<a href="execution.html#44670">&#167;12.5</a> and <a href="expressions.html#41147">&#167;15.9</a> describe the creation and initialization of new class instances.<p>
<a name="229267"></a>
<a name="8.8.7.1"></a>
<h4>8.8.7.1    Explicit Constructor Invocations</h4>
<blockquote><pre>
<em>ExplicitConstructorInvocation:
	NonWildTypeArguments<sub>opt</sub> </em>this ( <em>ArgumentList<sub><i>opt</i></sub></em> ) ;
<em>	NonWildTypeArguments<sub>opt</sub></em> super ( <em>ArgumentList<sub><i>opt</i></sub></em> ) ;<em>
	Primary. NonWildTypeArguments<sub>opt</sub></em> super ( <em>ArgumentList<sub><i>opt</i></sub></em> ) ; 

<em>NonWildTypeArguments:
	&lt; ReferenceTypeList &gt;

ReferenceTypeList: 
	ReferenceType
	ReferenceTypeList , ReferenceType
</em></pre></blockquote><a name="255762"></a>
<p>
<a name="324262"></a>
Explicit constructor invocation statements can be divided into two kinds:<p>
<ul><a name="255763"></a>
<li><i>Alternate constructor invocations</i> begin with the keyword this (possibly prefaced with explicit type arguments). They are used to invoke an alternate constructor of the same class.
<a name="255764"></a>
<li><i>Superclass constructor invocations</i> begin with either the keyword super (possibly prefaced with explicit type arguments) or a <i>Primary</i> expression. They are used to invoke a constructor of the direct superclass. Superclass constructor invocations may be further subdivided:
<ul>
<a name="255765"></a>
<li><i>Unqualified superclass constructor invocations</i> begin with the keyword <code>super</code> (possibly prefaced with explicit type arguments).
<a name="255766"></a>
<li><i>Qualified superclass constructor invocations</i> begin with a <i>Primary</i> expression . They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the direct superclass <a href="classes.html#295574">(&#167;8.1.3)</a>. This may be necessary when the superclass is an inner class.
</ul>
</ul>
<a name="255697"></a>
<p>Here is an example of a qualified superclass constructor invocation:</p>
</ul>
</ul><blockquote><pre>class Outer {
	class Inner{}
}
class ChildOfInner extends Outer.Inner {
	ChildOfInner(){(new Outer()).super();}
}
</pre></blockquote><a name="287141"></a>
An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods declared in this class or any superclass, or use <code>this</code> or <code>super</code> in any expression; otherwise, a compile-time error occurs. <p>
<a name="291517"></a>
<p>For example, if the first constructor of <code>ColoredPoint</code> in the example above were changed to:</p>
<blockquote><pre>ColoredPoint(int x, int y) {
	this(x, y, color);
}
</pre></blockquote><a name="259296"></a>
then a compile-time error would occur, because an instance variable cannot be used within a superclass constructor invocation.<p>
<a name="329301"></a>
An explicit constructor invocation statement can throw an exception type <i>E</i> iff either:<p>
<ul><a name="329302"></a>
<li>Some subexpression of the constructor invocation's parameter list can throw <i>E</i>; or
<a name="329303"></a>
<li><i>E</i> is declared in the throws clause of the constructor that is invoked.
</ul><a name="328981"></a>
<p>
<a name="255702"></a>
If an anonymous class instance creation expression appears within an explicit constructor invocation statement, then the anonymous class may not refer to any of the enclosing instances of the class whose constructor is being invoked.<p>
<a name="255703"></a>
<p>For example:</p>
<blockquote><pre>class Top {
	int x;
	class Dummy {
		Dummy(Object o) {}
	}
	class Inside extends Dummy {
		Inside() {
			super(new Object() { int r = x; }); // error
		}		
		Inside(final int y) {
			super(new Object() { int r = y; }); // correct
		}
	}
}
</pre></blockquote><a name="255722"></a>
Let <i>C</i> be the class being instantiated, let <i>S</i> be the direct superclass of <i>C</i>, and let <i>i</i> be the instance being created. The evaluation of an explicit constructor invocation proceeds as follows:<p>
<ul><a name="255921"></a>
<li>First, if the constructor invocation statement is a superclass constructor invocation, then the immediately enclosing instance of <i>i</i> with respect to <i>S</i> (if any) must be determined. Whether or not <i>i</i> has an immediately enclosing instance with respect to <i>S</i> is determined by the superclass constructor invocation as follows:
<ul>
<a name="255723"></a>
<li>If <i>S</i> is not an inner class, or if the declaration of <i>S</i> occurs in a static context, no immediately enclosing instance of <i>i</i> with respect to <i>S</i> exists. A compile-time error occurs if the superclass constructor invocation is a qualified superclass constructor invocation.
<a name="255724"></a>
<li>Otherwise:
<ul>
<a name="255725"></a>
<li>If the superclass constructor invocation is qualified, then the <i>Primary</i> expression <i>p</i> immediately preceding "<code>.super</code>" is evaluated. If the primary expression evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the superclass constructor invocation completes abruptly. Otherwise, the result of this evaluation is the immediately enclosing instance of <i>i</i> with respect to <i>S</i>. Let <i>O</i> be the immediately lexically enclosing class of <i>S</i>; it is a compile-time error if the type of <i>p</i> is not <i>O</i> or a subclass of <i>O</i>.
<a name="255726"></a>
<li>Otherwise:
<ul>
<a name="255730"></a>
<li>If <i>S</i> is a local class <a href="statements.html#247766">(&#167;14.3)</a>, then let <i>O</i> be the innermost lexically enclosing class of <i>S</i>. Let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of <i>C</i>. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <i>n</i>th lexically enclosing instance of <code>this</code>.
<a name="255734"></a>
<li>Otherwise, <i>S</i> is an inner member class <a href="classes.html#246026">(&#167;8.5)</a>. It is a compile-time error if <i>S</i> is not a member of a lexically enclosing class, or of a superclass or superinterface thereof. Let <i>O</i> be the innermost lexically enclosing class of which <i>S</i> is a member, and let <i>n</i> be an integer such that <i>O</i> is the <i>n</i>th lexically enclosing class of <i>C</i>. The immediately enclosing instance of <i>i</i> with respect to <i>S</i> is the <i>n</i>th lexically enclosing instance of <code>this</code>.
</ul>
</ul>
</ul>
<a name="255735"></a>
<li>Second, the arguments to the constructor are evaluated, left-to-right, as in an ordinary method invocation.
<a name="255924"></a>
<li>Next, the constructor is invoked.
<a name="255859"></a>
<li>Finally, if the constructor invocation statement is a superclass constructor invocation and the constructor invocation statement completes normally, then all instance variable initializers of <i>C</i> and all instance initializers of <i>C</i> are executed. If an instance initializer or instance variable initializer <i>I</i> textually precedes another instance initializer or instance variable initializer <i>J</i>, then <i>I</i> is executed before <i>J</i>. This action is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided automatically. An alternate constructor invocation does not perform this additional implicit action.
</ul><a name="324263"></a>
<p>
<a name="229266"></a>
<a name="8.8.8"></a>
<h3>8.8.8    Constructor Overloading</h3>
<a name="16815"></a>
Overloading of constructors is identical in behavior to overloading of methods. The overloading is resolved at compile time by each class instance creation expression <a href="expressions.html#41147">(&#167;15.9)</a>.<p>
<a name="16823"></a>
<a name="8.8.9"></a>
<h3>8.8.9    Default Constructor</h3>
<a name="229830"></a>
If a class contains no constructor declarations, then a <em>default constructor</em> that takes no parameters is automatically provided:<p>
<ul><a name="229831"></a>
<li>If the class being declared is the primordial class <code>Object</code>, then the default constructor has an empty body.
<a name="229832"></a>
<li>Otherwise, the default constructor takes no parameters and simply invokes the superclass constructor with no arguments.
</ul><a name="16772"></a>
A compile-time error occurs if a default constructor is provided by the compiler but the superclass does not have an accessible constructor that takes no arguments.<p>
<a name="257593"></a>
A default constructor has no <code>throws</code> clause.<p>
<a name="260449"></a>
<p>It follows that if the nullary constructor of the superclass has a <code>throws</code> clause, then a compile-time error will occur.</p>
<a name="16773"></a>
In an enum type <a href="classes.html#301020">(&#167;8.9)</a>, the default constructor is implicitly <code>private</code>. Otherwise, if the class is declared <code>public</code>, then the default constructor is implicitly given the access modifier <code>public</code> <a href="names.html#104285">(&#167;6.6)</a>; if the class is declared <code>protected</code>, then the default constructor is implicitly given the access modifier <code>protected</code> <a href="names.html#104285">(&#167;6.6)</a>; if the class is declared <code>private</code>, then the default constructor is implicitly given the access modifier <code>private</code> <a href="names.html#104285">(&#167;6.6)</a>; otherwise, the default constructor has the default access implied by no access modifier. <p>
<a name="259026"></a>
<p>Thus, the example:</p>
<blockquote><pre>public class Point {
	int x, y;
}
</pre></blockquote><a name="16781"></a>
is equivalent to the declaration:<p>
<blockquote><pre>public class Point {
	int x, y;
	public Point() { super(); }
}
</pre></blockquote><a name="16786"></a>
where the default constructor is <code>public</code> because the class <code>Point</code> is <code>public</code>.<p>
<a name="260516"></a>
<p>The rule that the default constructor of a class has the same access modifier as the class itself is simple and intuitive. Note, however, that this does not imply that the constructor is accessible whenever the class is accessible. Consider</p>
<blockquote><pre>package p1;
public class Outer {
 	protected class Inner{}
}

package p2;
class SonOfOuter extends p1.Outer {
	void foo() {
 		new Inner(); // compile-time access error
	}
}

</pre></blockquote><a name="259796"></a>
The constructor for <code>Inner</code> is protected. However, the constructor is protected relative to <code>Inner</code>, while <code>Inner</code> is protected relative to <code>Outer</code>. So, <code>Inner</code> is accessible in <code>SonOfOuter</code>, since it is a subclass of <code>Outer</code>. <code>Inner</code>'s constructor is not accessible in <code>SonOfOuter</code>, because the class <code>SonOfOuter</code> is not a subclass of <code>Inner</code>! Hence, even though <code>Inner</code> is accessible, its default constructor is not.<p>
<a name="16830"></a>
<a name="8.8.10"></a>
<h3>8.8.10    Preventing Instantiation of a Class</h3>
<a name="16831"></a>
A class can be designed to prevent code outside the class declaration from creating instances of the class by declaring at least one constructor, to prevent the creation of an implicit constructor, and declaring all constructors to be <code>private</code>. A <code>public</code> class can likewise prevent the creation of instances outside its package by declaring at least one constructor, to prevent creation of a default constructor with <code>public</code> access, and declaring no constructor that is <code>public</code>.<p>
<a name="16833"></a>
<p>Thus, in the example:</p>
<blockquote><pre>class ClassOnly {
	private ClassOnly() { }
	static String just = "only the lonely";
}
</pre></blockquote><a name="16838"></a>
the class <code>ClassOnly</code> cannot be instantiated, while in the example:<p>
<blockquote><pre>package just;
public class PackageOnly {
	PackageOnly() { }
	String[] justDesserts = { "cheesecake", "ice cream" };
}
</pre></blockquote><a name="259306"></a>
the class <code>PackageOnly</code> can be instantiated only within the package <code>just</code>, in which it is declared.<p>
<a name="301020"></a>
<a name="8.9"></a>
<h2>8.9    Enums</h2>
<a name="301628"></a>
An enum declaration has the form: <p>
<blockquote><pre>
<em>
EnumDeclaration:
	ClassModifiers<sub>opt</sub></em> enum<em> Identifier Interfaces<sub>opt</sub> EnumBody

EnumBody:
	{ EnumConstants<sub>opt ,opt</sub> EnumBodyDeclarations<sub>opt</sub> }</em>
</pre></blockquote><a name="301035"></a>
The body of an enum type may contain <i>enum constants</i>. An enum constant defines an instance of the enum type. An enum type has no instances other than those defined by its enum constants.<p>
<hr>
<a name="302015"></a>
 <p>
 <b>Discussion</b>
 </p>
<a name="302020"></a>
<p>
 It is a compile-time error to attempt to explicitly instantiate an enum type <a href="expressions.html#386053">(&#167;15.9.1)</a>. The final clone method in Enum ensures that enum constants can never be cloned, and the special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization. Reflective instantiation of enum types is prohibited. Together, these four things ensure that no instances of an enum type exist beyond those defined by the enum constants. <p>
<a name="302097"></a>
Because there is only one instance of each enum constant, it is permissible to use the == operator in place of the <code>equals</code> method when comparing two object references if it is known that at least one of them refers to an enum constant. (The <code>equals</code> method in <code>Enum</code> is a final method that merely invokes <code>super.equals</code> on its argument and returns the result, thus performing an identity comparison.) <p>
<hr>
<a name="302021"></a>
 <p>
<blockquote><pre>
<em>
EnumConstants:
	EnumConstant
	EnumConstants , EnumConstant

EnumConstant:
	Annotations Identifier Arguments<sub>opt</sub> ClassBody<sub>opt</sub>

Arguments:
	( ArgumentList<sub>opt</sub> )

EnumBodyDeclarations:
	; ClassBodyDeclarations<sub>opt</sub>
	</em>
</pre></blockquote><a name="302226"></a>
An enum constant may be preceded by annotation <a href="interfaces.html#253695">(&#167;9.7)</a> modifiers. If an annotation <i>a</i> on an enum constant corresponds to an annotation type <i>T,</i> and <i>T</i> has a (meta-)annotation <i>m</i> that corresponds to <code>annotation.Target</code>, then <i>m</i> must have an element whose value is <code>annotation.ElementType.FIELD</code>, or a compile-time error occurs.<p>
<a name="302777"></a>
An enum constant may be followed by arguments, which are passed to the constructor of the enum type when the constant is created during class initialization as described later in this section. The constructor to be invoked is chosen using the normal overloading rules <a href="expressions.html#292575">(&#167;15.12.2)</a>. If the arguments are omitted, an empty argument list is assumed. If the enum type has no constructor declarations, a parameterless default constructor is provided (which matches the implicit empty argument list). This default constructor is <code>private</code>.<p>
<a name="302235"></a>
The optional class body of an enum constant implicitly defines an anonymous class declaration <a href="expressions.html#252986">(&#167;15.9.5)</a> that extends the immediately enclosing enum type. The class body is governed by the usual rules of anonymous classes; in particular it cannot contain any constructors.<p>
<a name="302240"></a>
 <hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="302241"></a>
 Instance methods declared in these class bodies are may be invoked outside the enclosing enum type only if they override accessible methods in the enclosing enum type. <p>
<hr>
<a name="302244"></a>
 <p>
<a name="329467"></a>
Enum types <a href="classes.html#301020">(&#167;8.9)</a> must not be declared abstract; doing so will result in a compile-time error. It is a compile-time error for an enum type <i>E</i> to have an abstract method <i>m</i> as a member unless <i>E</i> has one or more enum constants, and all of <i>E</i>'s enum constants have class bodies that provide concrete implementations of <i>m.</i> It is a compile-time error for the class body of an enum constant to declare an abstract method. <p>
<a name="329147"></a>
<p>
<a name="301974"></a>
An enum type is implicitly <code>final</code> unless it contains at least one enum constant that has a class body. In any case, it is a compile-time error to explicitly declare an enum type to be <code>final</code>.<p>
<a name="301973"></a>
Nested enum types are implicitly <code>static</code>. It is permissable to explicitly declare a nested enum type to be <code>static</code>. <p>
<a name="308753"></a>
<hr>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="308754"></a>
 This implies that it is impossible to define a local <a href="statements.html#247766">(&#167;14.3)</a> enum, or to define an enum in an inner class <a href="classes.html#295574">(&#167;8.1.3)</a>.<p>
 <hr>
<a name="308756"></a>
 <p>
<a name="301055"></a>
Any constructor or member declarations within an enum declaration apply to the enum type exactly as if they had been present in the class body of a normal class declaration unless explicitly stated otherwise. <p>
<a name="301082"></a>
The direct superclass of an enum type named <i>E</i> is <code>Enum&lt;E&gt;</code>. In addition to the members it inherits from <code>Enum&lt;E&gt;</code>, for each declared enum constant with the name <i>n</i> the enum type has an implicitly declared public <code>static</code> <code>final</code> field named <i>n</i> of type <i>E.</i> These fields are considered to be declared in the same order as the corresponding enum constants, before any static fields explicitly declared in the enum type. Each such field is initialized to the enum constant that corresponds to it. Each such field is also considered to be annotated by the same annotations as the corresponding enum constant. The enum constant is said to be created when the corresponding field is initialized.<p>
<a name="313975"></a>
It is a compile-time error for an enum to declare a finalizer. An instance of an enum may never be finalized.<p>
<a name="302265"></a>
In addition, if <i>E</i> is the name of an enum type, then that type has the following implicitly declared static methods: <p>
<blockquote><pre><a name="301708"></a>
/**
</pre><pre><a name="301709"></a>* Returns an array containing the constants of this enum 
<a name="301748"></a>* type, in the order they're declared.  This method may be
<a name="301749"></a>* used to iterate over the constants as follows:
<a name="301753"></a>*
<a name="301745"></a>*    for(E c : E.values())
<a name="301092"></a>*        System.out.println(c);
<a name="301093"></a>*
<a name="301094"></a>* @return an array containing the constants of this enum 
<a name="301758"></a>* type, in the order they're declared
<a name="301096"></a>*/
<a name="301097"></a>public static E[] values();
<a name="301098"></a>
<a name="301099"></a>/**
<a name="301100"></a>* Returns the enum constant of this type with the specified
<a name="301788"></a>* name.
<a name="301101"></a>* The string must match exactly an identifier used to declare
<a name="301795"></a>* an enum constant in this type.  (Extraneous whitespace 
<a name="301804"></a>* characters are not permitted.)
<a name="301104"></a>* 
<a name="301105"></a>* @return the enum constant with the specified name
<a name="301106"></a>* @throws IllegalArgumentException if this enum type has no
<a name="301824"></a>* constant with the specified name
<a name="301108"></a>*/
<a name="301849"></a>public static E valueOf(String name);
<a name="301110"></a>
</pre></blockquote>
 <p>
<hr>
<p>
<b>Discussion</b>
</p>
<p>
<a name="302063"></a>
 It follows that enum type declarations cannot contain fields that conflict with the enum constants, and cannot contain methods that conflict with the automatically generated methods (<code>values()</code> and <code>valueOf(String)</code>) or methods that override the final methods in <code>Enum</code>: (<code>equals(Object)</code>, <code>hashCode()</code>, <code>clone()</code>,<code> compareTo(Object)</code>, <code>name()</code>, <code>ordinal()</code>, and <code>getDeclaringClass()</code>). <p>
 <hr>
<a name="301111"></a>
<a name="302255"></a>
<p>
<a name="324268"></a>
It is a compile-time error to reference a static field of an enum type that is not a compile-time constant <a href="expressions.html#5313">(&#167;15.28)</a> from constructors, instance initializer blocks, or instance variable initializer expressions of that type. It is a compile-time error for the constructors, instance initializer blocks, or instance variable initializer expressions of an enum constant <i>e</i> to refer to itself or to an enum constant of the same type that is declared to the right of <i>e</i>. <p>
<a name="324269"></a>
<hr>
<p>
<b>Discussion</b>
</p>
<a name="302080"></a>
 <p>
<a name="302079"></a>
 Without this rule, apparently reasonable code would fail at run time due to the initialization circularity inherent in enum types. (A circularity exists in any class with a "self-typed" static field.) Here is an example of the sort of code that would fail: <p>
<blockquote><pre>enum Color {
        RED, GREEN, BLUE;
        static final Map&lt;String,Color&gt; colorMap = 
		new HashMap&lt;String,Color&gt;();
        Color() {
            colorMap.put(toString(), this);
        }
    } 
	</pre></blockquote>
<a name="301135"></a>
 Static initialization of this enum type would throw a NullPointerException because the static variable colorMap is uninitialized when the constructors for the enum constants run. The restriction above ensures that such code won't compile. <p>
<a name="324425"></a>
<p>
<a name="324426"></a>
Note that the example can easily be refactored to work properly: <p>
<blockquote><pre>enum Color {
        RED, GREEN, BLUE;
        static final Map&lt;String,Color&gt; colorMap = 
		new HashMap&lt;String,Color&gt;();
        static {
            for (Color c : Color.values())
                colorMap.put(c.toString(), c);
        }
    } 
	</pre></blockquote>
<a name="301148"></a>
<p>
 The refactored version is clearly correct, as static initialization occurs top to bottom. <p>
 <hr>
<a name="301170"></a>
 <p>
 <hr>
<a name="301176"></a>
 <p>
 <b>Discussion</b>
 </p>
 <p>
<a name="301177"></a>
 Here is program with a nested enum declaration that uses an enhanced for loop to iterate over the constants in the enum: <p>
 <blockquote><pre>
public class Example1 {
    public enum Season { WINTER, SPRING, SUMMER, FALL }

    public static void main(String[] args) {
        for (Season s : Season.values())
            System.out.println(s);
    }
}
</pre></blockquote>
<p>
<a name="301188"></a>
 Running this program produces the following output: <p>
 <blockquote><pre>
WINTER
SPRING
SUMMER
FALL
</pre></blockquote>
<p>
<a name="301195"></a>
 Here is a program illustrating the use of <code>EnumSet</code> to work with subranges: <p>
 <blockquote><pre>
import java.util.*;

public class Example2 {
    enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

    public static void main(String[] args) {
        System.out.print("Weekdays: ");
        for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY))
            System.out.print(d + " ");
        System.out.println();
    }
}
</pre></blockquote>
<a name="301210"></a>
 <p>
<a name="324427"></a>
 Running this program produces the following output: <p>
 <blockquote><pre>
Weekdays: MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY
</pre></blockquote>
<a name="301214"></a>
<code> EnumSet</code> contains a rich family of static factories, so this technique can be generalized to work non-contiguous subsets as well as subranges. At first glance, it might appear wasteful to generate an <code>EnumSet</code> for a single iteration, but they are so cheap that this is the recommended idiom for iteration over a subrange. Internally, an <code>EnumSet</code> is represented with a single long assuming the enum type has 64 or fewer elements. <p>
</pre></blockquote><a name="301218"></a>
Here is a slightly more complex enum declaration for an enum type with an explicit instance field and an accessor for this field. Each member has a different value in the field, and the values are passed in via a constructor. In this example, the field represents the value, in cents, of an American coin. Note, however, that their are no restrictions on the type or number of parameters that may be passed to an enum constructor. <p>
<blockquote><pre>public enum Coin {
    PENNY(1), NICKEL(5), DIME(10), QUARTER(25);

    Coin(int value) { this.value = value; }

    private final int value;

    public int value() { return value; }
}
</pre></blockquote>
<a name="301232"></a>
 Switch statements are useful for simulating the addition of a method to an enum type from outside the type. This example "adds" a color method to the <code>Coin</code> type, and prints a table of coins, their values, and their colors. <p>
 <blockquote><pre>
public class CoinTest {
    public static void main(String[] args) {
        for (Coin c : Coin.values())
            System.out.println(c + ":   	"+ c.value() +"&#162; 	" + color(c));
    }
    private enum CoinColor { COPPER, NICKEL, SILVER }
    private static CoinColor color(Coin c) {
        switch(c) {
          case PENNY:
            return CoinColor.COPPER;
          case NICKEL:
            return CoinColor.NICKEL;
          case DIME: case QUARTER:
            return CoinColor.SILVER;
          default:
            throw new AssertionError("Unknown coin: " + c);
        }
    }
}
</pre></blockquote>
<a name="301257"></a>
 Running the program prints: <p>
 <blockquote><pre>
PENNY:          1&#162;      COPPER
NICKEL:         5&#162;      NICKEL
DIME:           10&#162;     SILVER
QUARTER:        25&#162;     SILVER
</pre></blockquote>
<a name="301264"></a>
<a name="324270"></a>
<a name="324271"></a>
 <p>
<a name="324272"></a>
 In the following example, a playing card class is built atop two simple enum types. Note that each enum type would be as long as the entire example in the absence of the enum facility: <p>
<blockquote><pre>
import java.util.*;
public class Card implements Comparable&lt;Card&gt;, java.io.Serializable {
    public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,JACK, 
QUEEN, KING, ACE }
    public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES }
    private final Rank rank;
    private final Suit suit;
    private Card(Rank rank, Suit suit) {
        if (rank == null || suit == null)
            throw new NullPointerException(rank + ", " + suit);
        this.rank = rank;
        this.suit = suit;
    }
    public Rank rank() { return rank; }
    public Suit suit() { return suit; }
    public String toString() { return rank + " of " + suit; }
    // Primary sort on suit, secondary sort on rank
    public int compareTo(Card c) {
        int suitCompare = suit.compareTo(c.suit);
        return (suitCompare != 0 ? suitCompare : rank.compareTo(c.rank));
    }
    private static final List&lt;Card&gt; prototypeDeck = new ArrayList&lt;Card&gt;(52);
    static {
        for (Suit suit : Suit.values())
            for (Rank rank : Rank.values())
                prototypeDeck.add(new Card(rank, suit));
    }
    // Returns a new deck
    public static List&lt;Card&gt; newDeck() {
        return new ArrayList&lt;Card&gt;(prototypeDeck);
    }
}
</pre></blockquote>
<a name="301307"></a>
 Here's a little program that exercises the <code>Card</code> class. It takes two integer parameters on the command line, representing the number of hands to deal and the number of cards in each hand: <p>
<blockquote><pre>
import java.util.*;
class Deal {
    public static void main(String args[]) {
		int numHands     = Integer.parseInt(args[0]);
		int cardsPerHand = Integer.parseInt(args[1]);
		List&lt;Card&gt; deck  = Card.newDeck();
		Collections.shuffle(deck);
		for (int i=0; i &lt; numHands; i++)
            System.out.println(dealHand(deck, cardsPerHand));
    	}
    /**
	 * Returns a new ArrayList consisting of the last n elements of 
	 * deck, which are removed from deck.  The returned list is
	 * sorted using the elements' natural ordering.
	*/
    public static &lt;E extends Comparable&lt;E&gt;&gt; ArrayList&lt;E&gt;
            dealHand(List&lt;E&gt; deck, int n) {
        int deckSize = deck.size();
        List&lt;E&gt; handView = deck.subList(deckSize - n, deckSize);
        ArrayList&lt;E&gt; hand = new ArrayList&lt;E&gt;(handView);
        handView.clear();
        Collections.sort(hand);
        return hand;
    }
}
</pre></blockquote>
<a name="301338"></a>
 Running the program produces results like this: <p>
<blockquote><pre>
java Deal 4 5
[FOUR of SPADES, NINE of CLUBS, NINE of SPADES, QUEEN of SPADES, KING of SPADES]
[THREE of DIAMONDS, FIVE of HEARTS, SIX of SPADES, SEVEN of DIAMONDS, KING of 
DIAMONDS]
[FOUR of DIAMONDS, FIVE of SPADES, JACK of CLUBS, ACE of DIAMONDS, ACE of 
HEARTS]
[THREE of HEARTS, FIVE of DIAMONDS, TEN of HEARTS, JACK of HEARTS, QUEEN of 
HEARTS]
</pre></blockquote>
<a name="301346"></a>
 The next example demonstrates the use of constant-specific class bodies to attach behaviors to the constants. (It is anticipated that the need for this will be rare.): <p>
 <blockquote><pre>
import java.util.*;
public enum Operation {
    PLUS {
        double eval(double x, double y) { return x + y; }
    },
    MINUS {
        double eval(double x, double y) { return x - y; }
    },
    TIMES {
        double eval(double x, double y) { return x * y; }
    },
    DIVIDED_BY {
        double eval(double x, double y) { return x / y; }
    };
    // Perform the arithmetic operation represented by this constant
   // abstract double eval(double x, double y);
    public static void main(String args[]) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);

        for (Operation op : Operation.values())
            System.out.println(x + " " + op + " " + y + " = " + op.eval(x, y));
    }
}
</pre></blockquote>
<a name="301379"></a>
 Running this program produces the following output: <p>
 <blockquote><pre>
java Operation 2.0 4.0
2.0 PLUS 4.0 = 6.0
2.0 MINUS 4.0 = -2.0
2.0 TIMES 4.0 = 8.0
2.0 DIVIDED_BY 4.0 = 0.5
</pre></blockquote>
<a name="301388"></a>
 The above pattern is suitable for moderately sophisticated programmers. It is admittedly a bit tricky, but it is much safer than using a case statement in the base type (Operation), as the pattern precludes the possibility of forgetting to add a behavior for a new constant (you'd get a compile-time error). <p>
<a name="302081"></a>
<hr>
 <p>
<a name="239730"></a>


<hr>
<!-- This inserts footnotes--><p>
<table border="0" width="100%">
<tr>
<td><a href="j3TOC.html">Contents</a> | <a href="packages.html">Prev</a> | <a href="interfaces.html">Next</a> | <a href="j3IX.html">Index</a></td>
<td align=right><i>Java Language Specification</i><br>
<font size="-1">Third Edition</font></td></tr></table>
<p>
<font size=-1>
<i><a href="jcopyright.html">Copyright</a> &#169 1996-2005 Sun Microsystems, Inc.
All rights reserved</i>
<br>
Please send any comments or corrections via our <a href="http://developers.sun.com/contact/feedback.jsp?&category=doc&mailsubject=Java%20Language%20Specification%20Feedback">feedback form</a>
</font>
</body></html>
