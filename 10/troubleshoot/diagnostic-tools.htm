<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Diagnostic Tools</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="description" content="This chapter introduces diagnostic and other monitoring tools that can be used with the Java Development Kit (JDK). Then, it describes in detail the diagnostic tools in JDK 9 and troubleshooting tools specific to various operating systems. Finally, this chapter explains how to develop custom diagnostic tools using the application programing interfaces (APIs) provided by JDK." />
<meta name="dcterms.created" content="2018-03-12T22:27:13Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Java Platform, Standard Edition Troubleshooting Guide" />
<meta name="dcterms.identifier" content="E91156-01" />
<meta name="dcterms.isVersionOf" content="JSTGD" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1995, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="http://docs.oracle.com/javase/10/index.html" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="prepare-java-troubleshooting.htm" title="Previous" type="text/html" />
<link rel="Next" href="troubleshoot-memory-leaks.htm" title="Next" type="text/html" />
<link rel="alternate" href="JSTGD.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-CBC97A20-7379-4762-BA17-FB1A560D02E4"></a> <span id="PAGE" style="display:none;">6/31</span> <!-- End Header -->
<a id="JSTGD115"></a><a id="JSTGD114"></a>
<h1 id="JSTGD-GUID-CBC97A20-7379-4762-BA17-FB1A560D02E4" class="sect1"><span class="enumeration_chapter">2</span> Diagnostic Tools</h1>
<div>
<div><span>This chapter introduces diagnostic and other monitoring tools that can be used with the Java Development Kit (JDK). Then, it describes in detail the diagnostic tools in JDK 9 and troubleshooting tools specific to various operating systems. Finally, this chapter explains how to develop custom diagnostic tools using the application programing interfaces (APIs) provided by JDK.</span></div>
<p>This chapter contains the following sections:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E" title="Most of the command-line utilities described in this section are either included in the JDK or native operating system tools and utilities.">Diagnostic Tools Overview</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-89C133E9-9E49-40F5-AD61-7A2FE89B1F78" title="The Java Flight Recorder (JFR) is a commercial feature. You can use it for free on developer desktops and laptops, and for evaluation purposes in test, development, and production environments.">What Are Java Flight Recordings</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-14DD9297-94CE-4B03-B6B9-4D5B6A7774DC" title="Use Java Mission Control (JMC) to easily manage flight recordings.Use startup flags at the command line to produce profiling recording, continuous recording, and using diagnostic commands.You can set up Java Mission Control to automatically start or dump a flight recording if a condition is met. This is done from the JMX console. To start the JMX console, find your application in the JVM Browser, right-click it, and select Start JMX Browser.">How to Produce a Flight Recording</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-7E8058D0-249E-44DB-8714-3AA9DA6A4DB8" title="Information about how to get a sample JFR to inspect a flight recording and various tabs in Java Mission Control for you to analyze the flight recordings.">Inspect a Flight Recording</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" title="The jcmd utility is used to send diagnostic command requests to the JVM, where these requests are useful for controlling Java Flight Recordings, troubleshoot, and diagnose JVM and Java applications.">The jcmd Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-1F53A50E-86FF-491D-A023-8EC4F1D1AC77" title="The Native Memory Tracking (NMT) is a Java HotSpot VM feature that tracks internal memory usage for a Java HotSpot VM.">Native Memory Tracking</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-92074912-77E2-46B4-9A2F-A27F10331576" title="Another useful tool included in the JDK download is the JConsole monitoring tool. This tool is compliant with JMX. The tool uses the built-in JMX instrumentation in the JVM to provide information about the performance and resource consumption of running applications.">JConsole</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" title="The jdb utility is included in the JDK as an example command-line debugger. The jdb utility uses the Java Debug Interface (JDI) to launch or connect to the target JVM.">The jdb Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE" title="The jinfo command-line utility gets configuration information from a running Java process or crash dump, and prints the system properties or the command-line flags that were used to start the JVM.">The jinfo Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" title="The jmap command-line utility prints memory-related statistics for a running VM or core file.">The jmap Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-FC269C18-470F-441E-9564-7EEA182F8125" title="The jps utility lists every instrumented Java HotSpot VM for the current user on the target system.">The jps Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-93AEFF21-55CC-4F4A-8810-E9F554623CF7" title="The jrunscript utility is a command-line script shell.">The jrunscript Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="Use the jcmd utility, instead of jcmd utility to diagnose problems with JVM and Java applications.">The jstack Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-370616DE-AB80-49EB-9802-C278AF75AAE8" title="The jstat utility uses the built-in instrumentation in the Java HotSpot VM to provide information about performance and resource consumption of running applications.">The jstat Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25" title="The visualgc tool provides a graphical view of the garbage collection (GC) system.">The visualgc Tool</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" title="The result of pressing the Control key and the backslash (\) key at the application console on operating systems such as Oracle Solaris or Linux, or Windows.">Control+Break Handler</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="List of native tools available on Windows, Linux, and Oracle Solaris operating systems that are useful for troubleshooting or monitoring purposes.">Native Operating System Tools</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-55FDAAC0-8FA8-4F12-AE28-1E768FB49901" title="The JDK has extensive APIs to develop custom tools to observe, monitor, profile, debug, and diagnose issues in applications that are deployed in the JRE.">Custom Diagnostic Tools</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-D3BBA20A-4777-44D2-BF04-05568AD49977" title="The Java Serviceability Agent Debug Daemon (jsadebugd) attaches to a Java process or to a core file and acts as a debug server.">The jsadebugd Daemon</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67" title="The jstatd daemon is an RMI server application that monitors the creation and termination of each instrumented Java HotSpot, and provides an interface to allow remote monitoring tools to attach to JVMs running on the local host.">The jstatd Daemon</a></p>
</li>
</ul>
</div>
<a id="JSTGD116"></a>
<div class="props_rev_3"><a id="GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E"></a>
<h2 id="JSTGD-GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E" class="sect2">Diagnostic Tools Overview</h2>
<div>
<p>Most of the command-line utilities described in this section are either included in the JDK or native operating system tools and utilities.</p>
<p>Although the JDK command-line utilities are included in the JDK download, it is important to consider that they can be used to diagnose issues and monitor applications that are deployed with the Java Runtime Environment (JRE).</p>
<p>In general, the diagnostic tools and options use various mechanisms to get the information they report. The mechanisms are specific to the virtual machine (VM) implementation, operating systems, and release. Frequently, only a subset of the tools is applicable to a given issue at a particular time. Command-line options that are prefixed with <code class="codeph">-XX</code> are specific to Java HotSpot VM. See <a href="command-line-options1.htm#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6" title="Command-line options that are prefixed with -XX are specific to the Java HotSpot Virtual Machine. Many of these options are important for performance tuning and diagnostic purposes, and are therefore described in this appendix.">Java HotSpot VM Command-Line Options</a>.</p>
<div class="infobox-note" id="GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E__GUID-71023838-D959-4D82-B1F2-8AF31D528184">
<p class="notep1">Note:</p>
<p>The <code>-XX</code> options are not part of the Java API and can vary from one release to the next.</p>
</div>
<p>The tools and options are divided into several categories, depending on the type of problem that you are troubleshooting. Certain tools and options might fall into more than one category.</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Postmortem diagnostics</span> These tools and options can be used to diagnose a problem after an application crashes. See <a href="diagnostic-tools.htm#GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3" title="List of tools and options available for post-mortem diagnostics of problems between the application and the Java HotSpot VM.">Postmortem Diagnostic Tools</a>.</p>
</li>
<li>
<p><span class="bold">Hung processes</span> These tools can be used to investigate a hung or deadlocked process. See <a href="diagnostic-tools.htm#GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B" title="List of tools and options for diagnosing problems between the application and the Java HotSpot VM in a hung process.">Hung Processes Tools</a>.</p>
</li>
<li>
<p><span class="bold">Monitoring</span> These tools can be used to monitor a running application. See <a href="diagnostic-tools.htm#GUID-90B85B8D-DCFA-4094-9A85-218D467222B0" title="List of tools and options for monitoring running applications and detecting problems.">Monitoring Tools</a>.</p>
</li>
<li>
<p><span class="bold">Other</span> These tools and options can be used to help diagnose other issues. See <a href="diagnostic-tools.htm#GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC" title="List of general troubleshooting tools, options, variables, and properties that can help to diagnose issues.">Other Tools, Options, Variables, and Properties</a>.</p>
</li>
</ul>
<div class="infobox-note" id="GUID-5A7DAE25-3BFC-4E20-BDE2-7B5298FCA23E__GUID-4FF37A47-5AFF-41C6-9B3E-D7A45100A58D">
<p class="notep1">Note:</p>
<p>Some command-line utilities described in this section are experimental. The <code class="codeph">jstack</code>, <code class="codeph">jinfo</code>, and <code class="codeph">jmap</code> utilities are examples of utilities that are experimental. It is suggested to use the latest diagnostic utility, <code class="codeph">jcmd</code> instead of the earlier <code class="codeph">jstack</code>, <code class="codeph">jinfo,</code> and <code class="codeph">jmap</code> utilities.</p>
</div>
</div>
</div>
<a id="JSTGD117"></a>
<div class="props_rev_3"><a id="GUID-58CC8913-4144-42C3-B5AA-61A73C0EC7FC"></a>
<h2 id="JSTGD-GUID-58CC8913-4144-42C3-B5AA-61A73C0EC7FC" class="sect2">Java Mission Control</h2>
<div>
<p>The Java Mission Control (JMC) is a new JDK profiling and diagnostics tools platform for HotSpot JVM.</p>
<p>It is a tool suite for basic monitoring, managing, and production-time profiling, and diagnostics with high performance. Java Mission Control minimizes the performance overhead that's usually an issue with profiling tools. This tool is a commercial feature built into the JVM and available at runtime.</p>
<p>The Java Flight Recorder (JFR) is a commercial feature. You can use it for free on developer desktops and laptops, and for evaluation purposes in test, development, and production environments. However, to enable JFR <span class="bold">on a production server, you must have a commercial license</span>. Using JMC UI for other purposes on the JDK <span class="bold">does not require a commercial license</span>.</p>
<p>The Java Mission Control (JMC) consists of Java Management Console (JMX), Java Flight Recorder (JFR), and several other plug-ins downloadable from the tool. The JMX is a tool for monitoring and managing Java applications, and the JFR is a profiling tool. Java Mission Control is also available as a set of plug-ins for the Eclipse IDE.</p>
<p>The following topic describes how to troubleshoot with Java Mission Control.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-6786AA0B-B474-4E28-A9D6-75C31D37CCB7" title="Troubleshooting activities that you can perform with Java Mission Control.">Troubleshoot with Java Mission Control</a></p>
</li>
</ul>
</div>
<a id="JSTGD118"></a>
<div class="props_rev_3"><a id="GUID-6786AA0B-B474-4E28-A9D6-75C31D37CCB7"></a>
<h3 id="JSTGD-GUID-6786AA0B-B474-4E28-A9D6-75C31D37CCB7" class="sect3">Troubleshoot with Java Mission Control</h3>
<div>
<p>Troubleshooting activities that you can perform with Java Mission Control.</p>
<div class="section">
<p>Java Mission Control allows you to perform the following troubleshooting activities:</p>
</div>
<!-- class="section" -->
<ul>
<li class="stepexpand"><span>Java Management console (JMX) connects to a running JVM, and collects and displays key characteristics in real time.</span></li>
<li class="stepexpand"><span>Triggers user-provided custom actions and rules for JVM.</span></li>
<li class="stepexpand"><span>Experimental plug-ins like - <code class="codeph">WLS</code>, <code class="codeph">DTrace</code>, <code class="codeph">JOverflow</code>, and others from the JMC tool provide troubleshooting activities.</span>
<ul>
<li><code class="codeph">DTrace</code> plug-in is an extended <code class="codeph">DScript</code> language to produce self-describing events. It provides visualization similar to Java Flight Recorder.</li>
<li><code class="codeph">JOverflow</code> is another plug-in tool for analyzing heap waste (empty/sparse collections). It is recommended to use JDK 8 release and later for optimal use of the <code class="codeph">JOverflow</code> plug-in.</li>
</ul>
</li>
<li class="stepexpand"><span>The Java Flight Recording (JFR) in Java Mission Control is available to analyze events. The preconfigured tabs enable you to easily to drill down in various areas of common interest, such as, code, memory and gc, threads, and I/O. The General Events tab and Operative Events tab together allow drilling down further and rapidly honing in on a set of events with certain properties. The Events tab usually has check boxes to only show events in the Operative set.</span>
<ul>
<li>JFR, when used as a plug-in for the JMC client, presents diagnostic information in logically grouped tables, charts, and dials. It enables you to select the range of time and level of detail necessary to focus on the problem. See <a href="http://docs.oracle.com/javacomponents/jmc.htm" target="_blank">Java Flight Recorder</a>.</li>
</ul>
</li>
<li class="stepexpand"><span>The Java Mission Control plug-ins connect to JVM using the Java Management Extensions (JMX) agent. The JMX is a standard API for the management and monitoring of resources such as applications, devices, services, and the Java Virtual Machine.</span>
<div>
<p>To know more about JMC, see <a href="http://docs.oracle.com/javacomponents/jmc.htm" target="_blank">JMC documentation</a>.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<a id="JSTGD119"></a>
<div class="props_rev_3"><a id="GUID-89C133E9-9E49-40F5-AD61-7A2FE89B1F78"></a>
<h2 id="JSTGD-GUID-89C133E9-9E49-40F5-AD61-7A2FE89B1F78" class="sect2">What Are Java Flight Recordings</h2>
<div>
<p>The Java Flight Recorder (JFR) is a commercial feature. You can use it for free on developer desktops and laptops, and for evaluation purposes in test, development, and production environments.</p>
<p>However, to enable JFR <span class="bold">on a production server, you must have a commercial license</span>. Using the JMC UI for other purposes on the JDK <span class="bold">does not require a commercial license</span>.</p>
<p>To know more about JFR commercial features and availability, see the <a href="http://www.oracle.com/technetwork/java/javase/terms/products/index.html" target="_blank">product documentation</a>.</p>
<p>To know more about JFR commercial license, see the <a href="http://www.oracle.com/technetwork/java/javase/terms/license/index.html" target="_blank">license agreement</a>.</p>
<p>The Java Flight Recorder records detailed information about the java runtime and the Java application running in the java runtime. The recording process is done with little overhead. The data is recorded as time stamped data points called events. Typical events can be threads waiting for locks, garbage collections, periodic CPU usage data, etc.</p>
<p>When creating a flight recording, you select which events should be saved. This is called a <span class="bold">recording template</span>. Some templates only save very basic events and have virtually no impact on performance. Other templates may come with slight performance overhead, and may also trigger GCs in order to gather additional information. In general, it is rare to see more than a few percentage of overhead.</p>
<p>Flight Recordings can be used to debug a wide range of issues from performance problems to memory leaks or heavy lock contention.</p>
<p>The following topic describes types of recording to produce a Java flight recording.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-7BE9B3A7-40DC-405B-9285-A3B3740C1C0E" title="The two types of flight recordings are continuous recordings and profiling recordings.">Types of Recordings</a></p>
</li>
</ul>
</div>
<a id="JSTGD120"></a>
<div class="props_rev_3"><a id="GUID-7BE9B3A7-40DC-405B-9285-A3B3740C1C0E"></a>
<h3 id="JSTGD-GUID-7BE9B3A7-40DC-405B-9285-A3B3740C1C0E" class="sect3">Types of Recordings</h3>
<div>
<p>The two types of flight recordings are continuous recordings and profiling recordings.</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Continuous recordings:</span> A continuous recording is a recording that is always on and saves, for example, the last 6 hours of data. If your application runs into any issues, then you can dump the data from, for example, the last hour and see what happened at the time of the problem.</p>
<p>The default setting for a continuous recordings is to use a recording profile with low overhead. This profile will not get heap statistics or allocation profiling, but will still gather a lot of useful data.</p>
<p>A continuous recording is great to always have running, and is very helpful when debugging issues that happen rarely. The recording can be dumped manually using either jcmd or JMC. You can also set a trigger in JMC to dump the flight recording when specific criteria is fulfilled.</p>
</li>
<li>
<p><span class="bold">Profiling recordings:</span> A profiling recording is a recording that is turned on, runs for a set amount of time, and then stops. Usually, a profiling recording has more events enabled and may have a slightly bigger performance effect. The events that are turned on can be modified depending on your use of profiling recording.</p>
<p>Typical use cases for profiling recordings are as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>Profile which methods are run the most and where most objects are created.</p>
</li>
<li>
<p>Look for classes that use more and more heap, which indicates a memory leak.</p>
</li>
<li>
<p>Look for bottlenecks due to synchronization and many more such use cases.</p>
</li>
</ul>
<p>A profiling recording will give a lot of information even though you are not troubleshooting a specific issue. A profiling recording will give you a good view of the application and can help you find any bottlenecks or areas that need improvement.</p>
</li>
</ul>
<div class="infobox-note" id="GUID-7BE9B3A7-40DC-405B-9285-A3B3740C1C0E__GUID-8DAFAD5B-8B0A-4A19-87C2-9E4B2D2DCF2D">
<p class="notep1">Note:</p>
<p>The typical overhead is around 2%, so you can run a profiling recording on your production environment (which is one of the main use cases for JFR), unless you are extremely sensitive for performance or latencies.</p>
</div>
</div>
</div>
</div>
<a id="JSTGD121"></a>
<div class="props_rev_3"><a id="GUID-14DD9297-94CE-4B03-B6B9-4D5B6A7774DC"></a>
<h2 id="JSTGD-GUID-14DD9297-94CE-4B03-B6B9-4D5B6A7774DC" class="sect2">How to Produce a Flight Recording</h2>
<div>
<p>The following sections describe three ways to produce a flight recording.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2" title="Use Java Mission Control (JMC) to easily manage flight recordings.">Use Java Mission Control to Produce a Flight Recording</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-551AED1E-3316-4150-AE20-C6D4F41127B7" title="Use startup flags at the command line to produce profiling recording, continuous recording, and using diagnostic commands.">Use Startup Flags at the Command Line to Produce a Flight Recording</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493" title="You can set up Java Mission Control to automatically start or dump a flight recording if a condition is met. This is done from the JMX console. To start the JMX console, find your application in the JVM Browser, right-click it, and select Start JMX Browser.">Use Triggers for Automatic Recordings</a></p>
</li>
</ul>
</div>
<a id="JSTGD123"></a><a id="JSTGD124"></a><a id="JSTGD125"></a><a id="JSTGD126"></a><a id="JSTGD127"></a><a id="JSTGD122"></a>
<div class="props_rev_3"><a id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2"></a>
<h3 id="JSTGD-GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2" class="sect3">Use Java Mission Control to Produce a Flight Recording</h3>
<div>
<p>Use Java Mission Control (JMC) to easily manage flight recordings.</p>
<div class="p"><span class="bold">Prerequisites:</span>
<p>To start, find your server in the JVM Browser in the leftmost frame, as shown in <a href="diagnostic-tools.htm#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABFEGBD">Figure 2-1</a>.</p>
<div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABFEGBD">
<p class="titleinfigure">Figure 2-1 Java Mission Control - Find Server</p>
<img width="330" height="286" src="img/jmc-event.png" alt="Description of Figure 2-1 follows" title="Description of Figure 2-1 follows" /><br />
<a href="img_text/jmc-event.htm">Description of "Figure 2-1 Java Mission Control - Find Server"</a></div>
<!-- class="figure" -->
<p>By default, any local running JVMs will be listed. Remote JVMs (running as the same effective user as the user running JMC) must be set up to use a remote JMX agent. Then, click the <span class="bold">New JVM Connection</span> button, and enter the network details.</p>
<p>Before the JDK 8u40 release, the JVM must have been started with the flag: <code>-XX:+UnlockCommercialFeatures -XX:FlightRecorder</code>.</p>
<p>Since the JDK 8u40 release, the Java Flight Recorder can be enabled during runtime.</p>
</div>
<!-- class="section" -->
<div class="section">
<p>The following are three ways to use Java Mission Control to produce a flight recording:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span><span class="bold">Inspect running recordings:</span> Expand the node in the JVM Browser to the recordings that are running. <a href="diagnostic-tools.htm#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJJIJC">Figure 2-2</a> shows both a running continuous recording (with the infinity sign) and a timed profiling recording.</span>
<div>
<div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJJIJC">
<p class="titleinfigure">Figure 2-2 Java Mission Control - Running Recordings</p>
<img width="304" height="308" src="img/jmc-expand-node.png" alt="Description of Figure 2-2 follows" title="Description of Figure 2-2 follows" /><br />
<a href="img_text/jmc-expand-node.htm">Description of "Figure 2-2 Java Mission Control - Running Recordings"</a></div>
<!-- class="figure" -->
<p>Right-click any of the recordings to dump, edit, or stop the recording. Stopping a profiling recording will still produce a recording file and closing a profiling recording will discard the recording.</p>
</div>
</li>
<li class="stepexpand"><span><span class="bold">Dump continuous recordings:</span> Right-click a continuous recording in the JVM Browser and then select to dump it to a file. In the dialog box that comes up, select to dump all available data or only the last part of the recording, as shown in <a href="diagnostic-tools.htm#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABEHFAC">Figure 2-3</a>.</span>
<div>
<div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABEHFAC">
<p class="titleinfigure">Figure 2-3 Java Mission Control - Dump Continuous Recordings</p>
<img width="609" height="447" src="img/jmc-continue-record.png" alt="Description of Figure 2-3 follows" title="Description of Figure 2-3 follows" /><br />
<a href="img_text/jmc-continue-record.htm">Description of "Figure 2-3 Java Mission Control - Dump Continuous Recordings"</a></div>
<!-- class="figure" --></div>
</li>
<li class="stepexpand"><span><span class="bold">Start a new recording:</span> To start a new recording, right click the JVM you want to record on and select <span class="bold">Start Flight Recording</span>. Then, a window displays, as shown in <a href="diagnostic-tools.htm#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJGJFC">Figure 2-4</a>.</span>
<div>
<div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJGJFC">
<p class="titleinfigure">Figure 2-4 Java Mission Control - Start Flight Recordings</p>
<img width="609" height="389" src="img/jmc-start-record.png" alt="Description of Figure 2-4 follows" title="Description of Figure 2-4 follows" /><br />
<a href="img_text/jmc-start-record.htm">Description of "Figure 2-4 Java Mission Control - Start Flight Recordings"</a></div>
<!-- class="figure" -->
<p>Select either <span class="bold">Time fixed recording</span> (profiling recording), or <span class="bold">Continuous recording</span> as shown in <a href="diagnostic-tools.htm#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABJGJFC">Figure 2-4</a>. For continuous recordings, you also specify the maximum size or age of events you want to save.</p>
<p>You can also select <span class="bold">Event settings</span>. There is an option to create your own templates, but for 99 percent of all use cases you want to select either the Continuous template (for very low overhead recordings) or the Profiling template (for more data and slightly more overhead). <span class="italic">Note:</span> The typical overhead for a profiling recording is about 2 percent.</p>
<p>When done, click <span class="bold">Next</span>. The next screen, as shown in <a href="diagnostic-tools.htm#GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABBFHEC">Figure 2-5</a>, gives you a chance to modify the template for different use cases.</p>
<div class="figure" id="GUID-88CC453C-0CED-45D6-9E93-28A03F3752F2__BABBFHEC">
<p class="titleinfigure">Figure 2-5 Java Mission Control - Event Options for Profiling</p>
<img width="609" height="541" src="img/jmc-event-profile.png" alt="Description of Figure 2-5 follows" title="Description of Figure 2-5 follows" /><br />
<a href="img_text/jmc-event-profile.htm">Description of "Figure 2-5 Java Mission Control - Event Options for Profiling"</a></div>
<!-- class="figure" -->
<p>The default settings give a good balance between data and performance. In some cases, you may want to add extra events. For example, if you are investigating a memory leak or want to see the objects that take up the most Java heap, enable <span class="bold">Heap Statistics</span>. This will trigger two Old Collections at the start and end of the recording, so this will give some extra latency. You can also select to show all exceptions being thrown, even the ones that are caught. For some applications, this will generate a lot of events.</p>
<p>The <span class="bold">Threshold</span> value is the length of event recording. For example, by default, synchronization events above 10 ms are gathered. This means, if a thread waits for a lock for more than 10 ms, an event is saved. You can lower this value to get more detailed data for short contentions.</p>
<p>The <span class="bold">Thread Dump</span> setting gives you an option to do periodic thread dumps. These will be normal textual thread dumps, like the ones you would get using the diagnostic command <code class="codeph">Thread.print</code>, or by using the <code class="codeph">jstack</code> tool. The thread dumps complement the events.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="JSTGD128"></a>
<div class="props_rev_3"><a id="GUID-551AED1E-3316-4150-AE20-C6D4F41127B7"></a>
<h3 id="JSTGD-GUID-551AED1E-3316-4150-AE20-C6D4F41127B7" class="sect3">Use Startup Flags at the Command Line to Produce a Flight Recording</h3>
<div>
<p>Use startup flags at the command line to produce profiling recording, continuous recording, and using diagnostic commands.</p>
<div class="section">
<p>For a complete description of JFR flags, see <a class="olink JSWOR624" target="_blank" href="../tools/java.htm#JSWOR624">Advanced Runtime Options</a> in the <span><cite>Java Platform, Standard Edition Tools Reference</cite></span>.</p>
<p>The following are three ways to startup flags at the command line to produce a flight recording.</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span><span class="bold">Start a profiling recording:</span> You can configure a time fixed recording at the start of the application using the <code>-XX:StartFlightRecording</code> option. Because the JFR is a commercial feature, you must specify the <code>-XX:+UnlockCommercialFeatures</code> option. The following example illustrates how to run the <code class="codeph">MyApp</code> application and start a 60-second recording 20 seconds after starting the JVM, which will be saved to a file named <code class="codeph">myrecording.jfr</code>:</span>
<div>
<p><code class="codeph">java <code>-XX:+UnlockCommercialFeatures</code> <code>-XX:+FlightRecorder</code> -XX:StartFlightRecording=delay=20s,duration=60s,name=myrecording,filename=C:\TEMP\myrecording.jfr,settings=profile MyApp</code></p>
<p>The settings parameter takes either the path to or the name of a template. Default templates are located in the <code class="codeph">jre/lib/jfr</code> folder. The two standard profiles are: <span class="italic"><span class="bold">default</span></span> - a low overhead setting made primarily for continuous recordings and <span class="italic"><span class="bold">profile</span></span> - gathers more data and is primarily for profiling recordings.</p>
</div>
</li>
<li class="stepexpand"><span><span class="bold">Start a continuous recording:</span> You can also start a continuous recording from the command line using <code>-XX:FlightRecorderOptions</code>. These flags will start a continuous recording that can later be dumped if needed. The following example illustrates a continuous recording. The temporary data will be saved to disk, to the <code class="codeph">/tmp</code> folder, and 6 hours of data will be stored.</span>
<div>
<p><code class="codeph">java -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:FlightRecorderOptions=defaultrecording=true,disk=true,repository=/tmp,maxage=6h,settings=default MyApp</code></p>
<div class="p">
<div class="infobox-note" id="GUID-551AED1E-3316-4150-AE20-C6D4F41127B7__GUID-4F7A4937-FD41-4005-A794-E24AEB24EB57">
<p class="notep1">Note:</p>
When you actually dump the recording, you specify a new location for the dumped file, so the files in the repository are only temporary.</div>
</div>
<p>To know more about configuring and managing Java Flight Recordings, see <a href="http://www.oracle.com/pls/topic/lookup?ctx=javacomponents&amp;id=JFRRT164" target="_blank">Java Flight Recorder Runtime Guide</a>.</p>
</div>
</li>
<li class="stepexpand"><span><span class="bold">Use diagnostic commands:</span></span>
<div>
<p>You can also control recordings by using Java command-line diagnostic commands. The simplest way to execute a diagnostic command is to use the <code class="codeph">jcmd</code> tool located in the Java installation directory. For more details see, <a href="diagnostic-tools.htm#GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" title="The jcmd utility is used to send diagnostic command requests to the JVM, where these requests are useful for controlling Java Flight Recordings, troubleshoot, and diagnose JVM and Java applications.">The jcmd Utility</a>.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="JSTGD130"></a><a id="JSTGD131"></a><a id="JSTGD129"></a>
<div class="props_rev_3"><a id="GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493"></a>
<h3 id="JSTGD-GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493" class="sect3">Use Triggers for Automatic Recordings</h3>
<div>
<p>You can set up Java Mission Control to automatically start or dump a flight recording if a condition is met. This is done from the JMX console. To start the JMX console, find your application in the JVM Browser, right-click it, and select <span class="bold">Start JMX Browser</span>.</p>
<div class="section">
<p>Select the <span class="bold">Triggers</span> tab at the bottom of the screen, as shown in <a href="diagnostic-tools.htm#GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493__BABCJFCD">Figure 2-6</a>.</p>
<div class="figure" id="GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493__BABCJFCD">
<p class="titleinfigure">Figure 2-6 Java Mission Control - Automatic Recordings</p>
<img width="835" height="527" src="img/jmc-autorecording.png" alt="Description of Figure 2-6 follows" title="Description of Figure 2-6 follows" /><br />
<a href="img_text/jmc-autorecording.htm">Description of "Figure 2-6 Java Mission Control - Automatic Recordings"</a></div>
<!-- class="figure" -->
<p>You can choose to create a trigger on any <code class="codeph">MBean</code> in the application. There are several default triggers set up for common conditions such as high CPU usage, deadlocked threads, or too large of a live set. Select <span class="bold">Add</span> to choose any <code class="codeph">MBean</code> in the application, including your own application-specific ones. When you select your trigger, you can also select the conditions that must be met. For more information, click the question mark in the top right corner to see the built-in help.</p>
<p>Click the boxes next to the triggers to have several triggers running.</p>
<p>Once you have selected your condition, click the <span class="italic"><span class="bold">Action</span></span> tab. Then, select what to do when the condition is met. Finally, choose to either dump a continuous recording or to start a time-limited flight recording as shown in <a href="diagnostic-tools.htm#GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493__BABEIDAH">Figure 2-7</a>.</p>
<div class="figure" id="GUID-DA569617-7185-4E50-BB6B-9F8B83C9A493__BABEIDAH">
<p class="titleinfigure">Figure 2-7 Java Mission Control - Use Triggers</p>
<br />
<div class="imagecenter"><img class="imagecenter" width="932" height="476" src="img/jmc-triggers.png" alt="Description of Figure 2-7 follows" title="Description of Figure 2-7 follows" /><br />
<a href="img_text/jmc-triggers.htm">Description of "Figure 2-7 Java Mission Control - Use Triggers"</a></div>
<br /></div>
<!-- class="figure" --></div>
<!-- class="section" --></div>
</div>
</div>
<a id="JSTGD132"></a>
<div class="props_rev_3"><a id="GUID-7E8058D0-249E-44DB-8714-3AA9DA6A4DB8"></a>
<h2 id="JSTGD-GUID-7E8058D0-249E-44DB-8714-3AA9DA6A4DB8" class="sect2">Inspect a Flight Recording</h2>
<div>
<p>Information about how to get a sample JFR to inspect a flight recording and various tabs in Java Mission Control for you to analyze the flight recordings.</p>
<p>The following sections are described:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-660AA16E-84CD-4427-9A70-FC0F236DFC62" title="Create a Flight Recording, you can open it in Mission Control.">How to Get a Sample JFR to Inspect</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9" title="Inspect the flight recordings using the range navigator.">Range Navigator</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE" title="Inspect flight recordings in the General tab.">General Tab</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-01E1A944-1918-4B46-927A-FB194E680BA6" title="Inspect the flight recordings in the Memory tab.">Memory Tab</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE" title="Inspect flight recordings in the Code tab.">Code Tab</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870" title="Inspect flight recordings in the Threads tab.">Threads Tab</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-BD6117F3-BDC2-4E16-B3C9-A78E18AE7B2C" title="The I/O tab shows information on file reads, file writes, socket reads, and socket writes.">I/O Tab</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-D1453594-A80C-4304-981C-BFD7CE572808" title="The System tab gives detailed information about the CPU, Memory and OS of the machine running the application.">System Tab</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-A0A26A19-44CC-4D4E-B391-C6079FA1B910" title="The Events tab shows all the events in the recording.">Events Tab</a></p>
</li>
</ul>
</div>
<a id="JSTGD133"></a>
<div class="props_rev_3"><a id="GUID-660AA16E-84CD-4427-9A70-FC0F236DFC62"></a>
<h3 id="JSTGD-GUID-660AA16E-84CD-4427-9A70-FC0F236DFC62" class="sect3">How to Get a Sample JFR to Inspect</h3>
<div>
<p>Create a Flight Recording, you can open it in Mission Control.</p>
<div class="section">
<p>After you create a Flight Recording, you can open it in Mission Control. An easy way to look at a flight recording is:</p>
</div>
<!-- class="section" -->
<ul>
<li class="stepexpand"><span>Open Mission Control and select the <span class="bold">JVM Browser</span> tab.</span></li>
<li class="stepexpand"><span>Select <span class="bold">The JVM Running Mission Control</span> option to create a short recording.</span>
<div>
<p>Open a flight recording to see several main tabs such as <span class="bold">General, Memory, Code, Threads, I/O, System, and Events</span>. You can also have other main tabs if any plug-ins are installed. Each of these main tabs have sub tabs. Click the question mark to view the built-in help section for the main tabs and subtabs.</p>
</div>
</li>
</ul>
</div>
</div>
<a id="JSTGD135"></a><a id="JSTGD134"></a>
<div class="props_rev_3"><a id="GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9"></a>
<h3 id="JSTGD-GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9" class="sect3">Range Navigator</h3>
<div>
<p>Inspect the flight recordings using the range navigator.</p>
<p>Each tab has a range navigator at the top view.</p>
<div class="figure" id="GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9__BABDAJJH">
<p class="titleinfigure">Figure 2-8 Inspect Flight Recordings - Range Navigator</p>
<br />
<div class="imagecenter"><img class="imagecenter" width="1055" height="137" src="img/jfr-range-navigator.png" alt="Description of Figure 2-8 follows" title="Description of Figure 2-8 follows" /><br />
<a href="img_text/jfr-range-navigator.htm">Description of "Figure 2-8 Inspect Flight Recordings - Range Navigator"</a></div>
<br /></div>
<!-- class="figure" -->
<p>The vertical bars in <a href="diagnostic-tools.htm#GUID-A2151E5D-9E9A-49E4-8149-C98C8A7377A9__BABDAJJH">Figure 2-8</a> represent the events in the recording. The higher the bar, the more events there are at that time. You can drag the edges of the selected time to zoom in or out in the recording. Double click the range navigator to zoom out and view the entire recording. Click the <span class="bold">Synchronize Selection</span> check box for all the subtabs to use the same zoom level.</p>
<p>See <span class="bold">Using the Range Navigator</span> in the built-in help for more information. The events are named as per the tab name.</p>
</div>
</div>
<a id="JSTGD137"></a><a id="JSTGD136"></a>
<div class="props_rev_3"><a id="GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE"></a>
<h3 id="JSTGD-GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE" class="sect3">General Tab</h3>
<div>
<p>Inspect flight recordings in the General tab.</p>
<p>The <span class="bold">General Tab</span> contains a few subtabs that describe the general application. The first subtab is <span class="bold">Overview</span>, which shows some basic information such as the maximum heap usage, total CPU usage, and GC pause time, as shown in <a href="diagnostic-tools.htm#GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE__BABHDDEG">Figure 2-9</a>.</p>
<div class="figure" id="GUID-5DD40B96-69F1-491D-87F1-8A0AC8AE59FE__BABHDDEG">
<p class="titleinfigure">Figure 2-9 Inspect Flight Recordings - General Tab</p>
<img width="1147" height="730" src="img/jfr-general-tab.png" alt="Description of Figure 2-9 follows" title="Description of Figure 2-9 follows" /><br />
<a href="img_text/jfr-general-tab.htm">Description of "Figure 2-9 Inspect Flight Recordings - General Tab"</a></div>
<!-- class="figure" -->
<p>Also, look at the <span class="bold">CPU Usage</span> over time and both the Application Usage and Machine Total. This tab is good to look at when something that goes wrong immediately in the application. For example, watch for CPU usage spiking near 100 percent or the CPU usage is too low or too long garbage collection pauses.</p>
<p><span class="italic">Note:</span> A profiling recording started with <span class="bold">Heap Statistics</span> gets two old collections, at the start and the end of the recording that may be longer than the rest.</p>
<p>The other subtab - <span class="bold">JVM Information</span> shows the JVM information. The start parameters subtabs - <span class="bold">System Properties</span> shows all system properties set, and <span class="bold">Recording</span> shows information about the specific recording such as, the events that are turned on. Click the question marks for built-in detailed information about all tabs and subtabs.</p>
</div>
</div>
<a id="JSTGD139"></a><a id="JSTGD140"></a><a id="JSTGD141"></a><a id="JSTGD138"></a>
<div class="props_rev_3"><a id="GUID-01E1A944-1918-4B46-927A-FB194E680BA6"></a>
<h3 id="JSTGD-GUID-01E1A944-1918-4B46-927A-FB194E680BA6" class="sect3">Memory Tab</h3>
<div>
<p>Inspect the flight recordings in the <span class="bold">Memory</span> tab.</p>
<p>The <span class="bold">Memory</span> tab contains information about Garbage Collections, Allocation patterns and Object Statistics. This tab is specifically helpful to debug memory leaks as well as for tuning the GC.</p>
<p>The <span class="bold">Overview</span> tab shows some general information about the memory usage and some statistics over garbage collections. <span class="italic">Note:</span> The graph scale in the <span class="bold">Overview</span> tab goes up to the available physical memory in the machine; therefore, in some cases the Java heap may take up only a small section at the bottom.</p>
<p>The following three subtabs are described from the Memory tab.</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Garbage Collection tab:</span> The <span class="bold">Garbage Collection</span> tab shows memory usage over time and information about all garbage collections.</p>
<div class="figure" id="GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABECCBH">
<p class="titleinfigure">Figure 2-10 Inspect Flight Recordings - Garbage Collections</p>
<img width="1151" height="729" src="img/jfr-memory-tab.png" alt="Description of Figure 2-10 follows" title="Description of Figure 2-10 follows" /><br />
<a href="img_text/jfr-memory-tab.htm">Description of "Figure 2-10 Inspect Flight Recordings - Garbage Collections"</a></div>
<!-- class="figure" -->
<p>As shown in <a href="diagnostic-tools.htm#GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABECCBH">Figure 2-10</a>, the spiky pattern of the heap usage is perfectly normal. In most applications, temporary objects are allocated all the time. Once a condition is met, a Garbage Collection (GC) is triggered and all the objects no longer used are removed. Therefore, the heap usage increases steadily until a GC is triggered, then it drops suddenly.</p>
<p>Most GCs in Java have some kind of smaller garbage collections. The old GC goes through the entire Java heap, while the other GC might look at part of the heap. The heap usage after an old collection is the memory the application is using, which is called the live set.</p>
<p>The flight recording generated with <span class="bold">Heap Statistics</span> enabled will start and end with an old GC. Select that old GC in the list of GCs, and then choose the <span class="bold">General</span> tab to see the <span class="bold">GC Reason</span> as - <span class="bold">Heap Inspection Initiated GC</span>. These GCs usually take slightly longer than other GCs.</p>
<p>For a better way to address memory leaks, look at the <span class="bold">Heap After GC</span> value in the first and last old GC. There could a memory leak when this value is increasing over time.</p>
<p>The <span class="bold">GC Times</span> tab has information about the time spent doing GCs and time when the application is completely paused due to GCs. The <span class="bold">GC Configuration</span> tab has GC configuration information. For more details about these tabs, click the question mark in the top right corner to see the built-in help.</p>
</li>
<li>
<p><span class="bold">Allocations tab:</span> <a href="diagnostic-tools.htm#GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABFAJAD">Figure 2-11</a> shows a selection of all memory allocations made. Small objects in Java are allocated in a <span class="bold">TLAB</span> (Thread Local Area Buffer). TLAB is a small memory area where new objects are allocated. Once a TLAB is full, the thread gets a new one. Logging all memory allocations gives an overhead; therefore, all allocations that triggered a new TLAB are logged. Larger objects are allocated outside <span class="bold">TLAB</span>, which are also logged.</p>
<div class="figure" id="GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABFAJAD">
<p class="titleinfigure">Figure 2-11 Inspect Flight Recordings - Allocations Tab</p>
<img width="1146" height="732" src="img/jfr-allocations-tab.png" alt="Description of Figure 2-11 follows" title="Description of Figure 2-11 follows" /><br />
<a href="img_text/jfr-allocations-tab.htm">Description of "Figure 2-11 Inspect Flight Recordings - Allocations Tab"</a></div>
<!-- class="figure" -->
<p>To estimate the memory allocation for each class, select the <span class="bold">Allocation in new TLAB</span> tab and then select <span class="bold">Allocations</span> tab. These allocations are object allocations that happen to trigger the new TLABs. The <code class="codeph">char</code> arrays trigger the most new TLABs. How much memory is allocated as <code class="codeph">char</code> arrays is not known. The size of the TLABs is a good estimate for memory allocated by <code class="codeph">char</code> arrays.</p>
<p><a href="diagnostic-tools.htm#GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABFAJAD">Figure 2-11</a> is an example for <code class="codeph">char</code> arrays allocating the most memory. Click one of the classes to see the <span class="bold">Stack Trace</span> of these allocations. The example recording shows that 44% of all allocation pressure comes from <code class="codeph">char</code> arrays and 27 percent comes from <code class="codeph">Array.copyOfRange</code>, which is called from <code class="codeph">StringBuilder.toString</code>. The <code class="codeph">StringBuilder.toString</code> is in turn usually called by <code class="codeph">Throwable.printStackTrace</code> and <code class="codeph">StackTraceElement.toString</code>. Expand further to see how these methods are called.</p>
<p><span class="italic">Note</span>: The more temporary objects the application allocates, the more the application must garbage collect. The <span class="bold">Allocations</span> tab helps you find the most allocations and reduce the GC pressure in your application. Look at <span class="bold">Allocation outside TLAB</span> tab to see large memory allocations, which usually have less memory pressure than the allocations in <span class="bold">New TLAB</span> tab.</p>
</li>
<li>
<p><span class="bold">Object Statistics tab:</span> The <span class="bold">Object Statistics</span> tab shows the classes that have the most live set. Read the <span class="bold">Garbage Collection</span> subtab from the <a href="diagnostic-tools.htm#GUID-01E1A944-1918-4B46-927A-FB194E680BA6" title="Inspect the flight recordings in the Memory tab.">Memory Tab</a> to understand a live set. <a href="diagnostic-tools.htm#GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABJFHJG">Figure 2-12</a> shows heap statistics for a flight recording. Enable <span class="bold">Heap Statistics</span> for a flight recording to show the data. The <span class="bold">Top Growers</span> tab at the bottom shows how each object type increased in size during a flight recording. A specific object type increased a lot in size indicates a memory leak; however, a small variance is normal. Especially, investigate the top growers of non-standard Java classes.</p>
<div class="figure" id="GUID-01E1A944-1918-4B46-927A-FB194E680BA6__BABJFHJG">
<p class="titleinfigure">Figure 2-12 Inspect Flight Recordings - Object Statistics Tab</p>
<img width="1153" height="730" src="img/jfr-statistics-tab.png" alt="Description of Figure 2-12 follows" title="Description of Figure 2-12 follows" /><br />
<a href="img_text/jfr-statistics-tab.htm">Description of "Figure 2-12 Inspect Flight Recordings - Object Statistics Tab"</a></div>
<!-- class="figure" --></li>
</ul>
</div>
</div>
<a id="JSTGD143"></a><a id="JSTGD142"></a>
<div class="props_rev_3"><a id="GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE"></a>
<h3 id="JSTGD-GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE" class="sect3">Code Tab</h3>
<div>
<p>Inspect flight recordings in the <span class="bold">Code</span> tab.</p>
<p>The <span class="bold">Code</span> tab contains information about where the application spends most of its time. The <span class="bold">Overview</span> subtab shows the packages and classes that spent the most execution time. This data comes from sampling. JFR takes samples of threads running at intervals. Only the threads running actual code are sampled; the threads that are sleeping, waiting for locks or I/O are not shown.</p>
<p>To see more details about the application time for running the actual code, look at the <span class="bold">Hot Methods</span> subtab.</p>
<div class="figure" id="GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE__BABFCFGD">
<p class="titleinfigure">Figure 2-13 Inspect Flight Recordings - Code Tab</p>
<img width="1148" height="730" src="img/jfr-code-tab.png" alt="Description of Figure 2-13 follows" title="Description of Figure 2-13 follows" /><br />
<a href="img_text/jfr-code-tab.htm">Description of "Figure 2-13 Inspect Flight Recordings - Code Tab"</a></div>
<!-- class="figure" -->
<p><a href="diagnostic-tools.htm#GUID-A11A9AA1-4DF1-4AC3-AA78-15503B4CDCFE__BABFCFGD">Figure 2-13</a> shows the methods that are sampled the most. Expand the samples to see from where they are called. If a <code class="codeph">HashMap.getEntry</code> is called a lot, then expand this node until you find the method that called the most. This is the best tab to use to find bottlenecks in the application.</p>
<p>The <span class="bold">Call Tree</span> subtab shows the same events, but starts from the bottom; for example, from <code class="codeph">Thread.run</code>.</p>
<p>The <span class="bold">Exceptions</span> sub tab shows any exceptions thrown. By default, only <span class="italic">Errors</span> are logged, but change this setting to include <span class="italic">All Exceptions</span> when starting a new recording.</p>
<p>The <span class="bold">Compilations</span> sub tab shows the methods compiled over time as the application was running.</p>
<p>The <span class="bold">Class Loading</span> sub tab shows the number of loaded classes, actual loaded classes and unloaded classes over time. This sub tab shows information only when <span class="italic">Class Loading</span> events were enabled at the start of the recording.</p>
<p>For more details about these tabs, click the question mark in the top right corner to see the built-in help.</p>
</div>
</div>
<a id="JSTGD145"></a><a id="JSTGD144"></a>
<div class="props_rev_3"><a id="GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870"></a>
<h3 id="JSTGD-GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870" class="sect3">Threads Tab</h3>
<div>
<p>Inspect flight recordings in the <span class="bold">Threads</span> tab.</p>
<p>The <span class="bold">Threads</span> tab contains information about threads, lock contention and other latencies.</p>
<p>The <span class="bold">Overview</span> subtab shows CPU usage and the number of threads over time.</p>
<p>The <span class="bold">Hot Threads</span> sub tab shows the threads that do most of the code execution. This information is based on the same sampling data as the <span class="bold">Hot Methods</span> subtab in the <span class="bold">Code</span> tab.</p>
<p>The <span class="bold">Contention</span> tab is useful for finding bottle necks due to lock contention.</p>
<div class="figure" id="GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870__BABDAEAF">
<p class="titleinfigure">Figure 2-14 Inspect Flight Recordings - Contention Tab</p>
<img width="1147" height="728" src="img/jfr-contention-tab.png" alt="Description of Figure 2-14 follows" title="Description of Figure 2-14 follows" /><br />
<a href="img_text/jfr-contention-tab.htm">Description of "Figure 2-14 Inspect Flight Recordings - Contention Tab"</a></div>
<!-- class="figure" -->
<div class="p"><a href="diagnostic-tools.htm#GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870__BABDAEAF">Figure 2-14</a> shows objects that are the most waited for due to synchronization. Select a <span class="bold">Class</span> to see the <span class="bold">Stack Trace</span> of the wait time for each object. These pauses are generally caused by synchronized methods, where another thread holds the lock.
<div class="infobox-note" id="GUID-B9234E4E-D4BD-4EBC-B116-0E7DBF63F870__GUID-8B34039A-A892-47B5-B313-E280D6A8436F">
<p class="notep1">Note:</p>
By default, only synchronization events longer than 10 ms will be recorded, but you can lower this threshold when starting a recording.</div>
</div>
<p>The <span class="bold">Latencies</span> subtab shows other sources of latencies; for example, calling sleep or wait, reading from sockets, or waiting for file I/O.</p>
<p>The <span class="bold">Thread Dumps</span> subtab shows the periodic thread dumps that can be triggered in the recording.</p>
<p>The <span class="bold">Lock Instances</span> subtab shows the exact instances of objects that are waited upon the most due to synchronization.</p>
<p>For more details about these tabs, click the question mark in the top right corner to see the built-in help.</p>
</div>
</div>
<a id="JSTGD146"></a>
<div class="props_rev_3"><a id="GUID-BD6117F3-BDC2-4E16-B3C9-A78E18AE7B2C"></a>
<h3 id="JSTGD-GUID-BD6117F3-BDC2-4E16-B3C9-A78E18AE7B2C" class="sect3">I/O Tab</h3>
<div>
<p>The <span class="bold">I/O</span> tab shows information on file reads, file writes, socket reads, and socket writes.</p>
<div class="p">This tab is helpful depending on the application; especially, when any I/O operation takes a long time.
<div class="infobox-note" id="GUID-BD6117F3-BDC2-4E16-B3C9-A78E18AE7B2C__GUID-675BC3A5-6ED8-4DCB-B88B-06C15B43B144">
<p class="notep1">Note:</p>
By default, only events longer than 10 ms are shown. The thresholds can be modified when creating a new recording.</div>
</div>
</div>
</div>
<a id="JSTGD147"></a>
<div class="props_rev_3"><a id="GUID-D1453594-A80C-4304-981C-BFD7CE572808"></a>
<h3 id="JSTGD-GUID-D1453594-A80C-4304-981C-BFD7CE572808" class="sect3">System Tab</h3>
<div>
<p>The <span class="bold">System</span> tab gives detailed information about the CPU, Memory and OS of the machine running the application.</p>
<p>It also shows environment variables and any other processes running at the same time as the JVM.</p>
</div>
</div>
<a id="JSTGD148"></a>
<div class="props_rev_3"><a id="GUID-A0A26A19-44CC-4D4E-B391-C6079FA1B910"></a>
<h3 id="JSTGD-GUID-A0A26A19-44CC-4D4E-B391-C6079FA1B910" class="sect3">Events Tab</h3>
<div>
<p>The <span class="bold">Events</span> tab shows all the events in the recording.</p>
<p>This is an advanced tab that can be used in many different ways. For more details about these tabs, click the question mark in the top right corner to see the built-in help.</p>
</div>
</div>
</div>
<a id="JSTGD149"></a>
<div class="props_rev_3"><a id="GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254"></a>
<h2 id="JSTGD-GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" class="sect2">The jcmd Utility</h2>
<div>
<p>The <code class="codeph">jcmd</code> utility is used to send diagnostic command requests to the JVM, where these requests are useful for controlling Java Flight Recordings, troubleshoot, and diagnose JVM and Java applications.</p>
<p><code class="codeph">jcmd</code> must be used on the same machine where the JVM is running, and have the same effective user and group identifiers that were used to launch the JVM.</p>
<p>A special command <code class="codeph">jcmd &lt;process id/main class&gt; PerfCounter.print</code> prints all performance counters in the process.</p>
<p>The command <code class="codeph">jcmd &lt;process id/main class&gt; &lt;command&gt; [options]</code> sends the command to the JVM.</p>
<p>The following example shows diagnostic command requests to the JVM using <code class="codeph">jcmd</code> utility.</p>
<pre dir="ltr">
&gt; jcmd
5485 sun.tools.jcmd.JCmd
2125 MyProgram
 
&gt; jcmd MyProgram help (or "jcmd 2125 help")
2125:
The following commands are available:
JFR.configure
JFR.stop
JFR.start
JFR.dump
JFR.check
VM.log
VM.native_memory
VM.check_commercial_features
VM.unlock_commercial_features
ManagementAgent.status
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
Compiler.directives_clear
Compiler.directives_remove
Compiler.directives_add
Compiler.directives_print
VM.print_touched_methods
Compiler.codecache
Compiler.codelist
Compiler.queue
VM.classloader_stats
Thread.print
JVMTI.data_dump
JVMTI.agent_load
VM.stringtable
VM.symboltable
VM.class_hierarchy
GC.class_stats
GC.class_histogram
GC.heap_dump
GC.finalizer_info
GC.heap_info
GC.run_finalization
GC.run
VM.info
VM.uptime
VM.dynlibs
VM.set_flag
VM.flags
VM.system_properties
VM.command_line
VM.version
help
For more information about a specific command use 'help &lt;command&gt;'. 

&gt; jcmd MyProgram help Thread.print
2125:
Thread.print
Print all threads with stacktraces.
 
Impact: Medium: Depends on the number of threads.
 
Permission: java.lang.management.ManagementPermission(monitor)
 
Syntax : Thread.print [options]
 
Options: (options must be specified using the &lt;key&gt; or &lt;key&gt;=&lt;value&gt; syntax)
        -l : [optional] print java.util.concurrent locks (BOOLEAN, false)
 
&gt; jcmd MyProgram Thread.print
2125:
2014-07-04 15:58:56
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.0-b69 mixed mode):
...
</pre>
<p>The following sections describe some useful commands and troubleshooting techniques with the <code class="codeph">jcmd</code> utility:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-B7480F58-82B5-4F29-94E6-1DA669947265" title="The available diagnostic command may be different in different versions of HotSpot VM; therefore, using jcmd &lt;process id/main class&gt; help is the best way to see all available options.">Useful Commands for the jcmd Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-4B2441A8-4FE7-4B88-B3F1-2774946C0E91" title="Use the jcmd utility to troubleshoot.">Troubleshoot with the jcmd Utility</a></p>
</li>
</ul>
</div>
<a id="JSTGD151"></a>
<div class="props_rev_3"><a id="GUID-B7480F58-82B5-4F29-94E6-1DA669947265"></a>
<h3 id="JSTGD-GUID-B7480F58-82B5-4F29-94E6-1DA669947265" class="sect3">Useful Commands for the jcmd Utility</h3>
<div>
<p>The available diagnostic command may be different in different versions of HotSpot VM; therefore, using <code class="codeph">jcmd &lt;process id/main class&gt; help</code> is the best way to see all available options.</p>
<div class="section">
<p>The following are some of the most useful commands in the <code class="codeph">jcmd</code> tool. Remember you can always use <code class="codeph">jcmd &lt;process id/main class&gt; help &lt;command&gt;</code> to get any additional options to these commands:</p>
</div>
<!-- class="section" -->
<ul>
<li class="stepexpand"><span>Print full HotSpot and JDK version ID.</span>
<div><code class="codeph">jcmd &lt;process id/main class&gt; VM.version</code></div>
</li>
<li class="stepexpand"><span>Print all the system properties set for a VM.</span>
<div>
<p>There can be several hundred lines of information displayed.</p>
<p><code class="codeph">jcmd &lt;process id/main class&gt; VM.system_properties</code></p>
</div>
</li>
<li class="stepexpand"><span>Print all the flags used for a VM.</span>
<div>
<p>Even if you have provided no flags, some of the default values will be printed, for example initial and maximum heap size.</p>
<p><code class="codeph">jcmd &lt;process id/main class&gt; VM.flags</code></p>
</div>
</li>
<li class="stepexpand"><span>Print the uptime in seconds.</span>
<div>
<p><code class="codeph">jcmd &lt;process id/main class&gt; VM.uptime</code></p>
</div>
</li>
<li class="stepexpand"><span>Create a class histogram.</span>
<div>
<p>The results can be rather verbose, so you can redirect the output to a file. Both internal and application-specific classes are included in the list. Classes taking the most memory are listed at the top, and classes are listed in a descending order.</p>
<p><code class="codeph">jcmd &lt;process id/main class&gt; GC.class_histogram</code></p>
</div>
</li>
<li class="stepexpand"><span>Create a heap dump.</span>
<div>
<p><code class="codeph">jcmd GC.heap_dump filename=Myheapdump</code></p>
<p>This is the same as using <code class="codeph">jmap -dump:file=&lt;file&gt; &lt;pid&gt;</code>, but <code class="codeph">jcmd</code> is the recommended tool to use.</p>
</div>
</li>
<li class="stepexpand"><span>Create a heap histogram.</span>
<div>
<p><code class="codeph">jcmd &lt;process id/main class&gt; GC.class_histogram filename=Myheaphistogram</code></p>
<p>This is the same as using <code class="codeph">jmap -histo &lt;pid&gt;</code>, but <code class="codeph">jcmd</code> is the recommended tool to use.</p>
</div>
</li>
<li class="stepexpand"><span>Print all threads with stack traces.</span>
<div>
<p><code class="codeph">jcmd &lt;process id/main class&gt; Thread.print</code></p>
</div>
</li>
</ul>
</div>
</div>
<a id="JSTGD152"></a>
<div class="props_rev_3"><a id="GUID-4B2441A8-4FE7-4B88-B3F1-2774946C0E91"></a>
<h3 id="JSTGD-GUID-4B2441A8-4FE7-4B88-B3F1-2774946C0E91" class="sect3">Troubleshoot with the jcmd Utility</h3>
<div>
<p>Use the <code class="codeph">jcmd</code> utility to troubleshoot.</p>
<div class="section">
<p>The <code class="codeph">jcmd</code> utility provides the following troubleshooting options:</p>
</div>
<!-- class="section" -->
<ul>
<li class="stepexpand"><span>Start a recording.</span>
<div>
<p>For example, to start a 2-minute recording on the running Java process with the identifier <code class="codeph">7060</code> and save it to myrecording.jfr in the current directory, use the following:</p>
<p><code class="codeph">jcmd 7060 JFR.start name=MyRecording settings=profile delay=20s duration=2m filename=C:\TEMP\myrecording.jfr</code></p>
</div>
</li>
<li class="stepexpand"><span>Check a recording.</span>
<div>
<p>The <code class="codeph">JFR.check</code> diagnostic command checks a running recording. For example:</p>
<p><code class="codeph">jcmd 7060 JFR.check</code></p>
</div>
</li>
<li class="stepexpand"><span>Stop a recording.</span>
<div>
<p>The <code class="codeph">JFR.stop</code> diagnostic command stops a running recording and has the option to discard the recording data. For example:</p>
<p><code class="codeph">jcmd 7060 JFR.stop</code></p>
</div>
</li>
<li class="stepexpand"><span>Dump a recording.</span>
<div>
<p>The <code class="codeph">JFR.dump</code> diagnostic command stops a running recording and has the option to dump recordings to a file. For example:</p>
<p><code class="codeph">jcmd 7060 JFR.dump name=MyRecording filename=C:\TEMP\myrecording.jfr</code></p>
</div>
</li>
<li class="stepexpand"><span>Create a heap dump.</span>
<div>
<p>The preferred way to create a heap dump is</p>
<p><code class="codeph">jcmd &lt;pid&gt; GC.heap_dump filename=Myheapdump</code></p>
</div>
</li>
<li class="stepexpand"><span>Create a heap histogram.</span>
<div>
<p>The preferred way to create a heap histogram is</p>
<p><code class="codeph">jcmd &lt;pid&gt; GC.class_histogram filename=Myheaphistogram</code></p>
</div>
</li>
</ul>
</div>
</div>
</div>
<a id="JSTGD153"></a>
<div class="props_rev_3"><a id="GUID-1F53A50E-86FF-491D-A023-8EC4F1D1AC77"></a>
<h2 id="JSTGD-GUID-1F53A50E-86FF-491D-A023-8EC4F1D1AC77" class="sect2">Native Memory Tracking</h2>
<div>
<p>The Native Memory Tracking (NMT) is a Java HotSpot VM feature that tracks internal memory usage for a Java HotSpot VM.</p>
<p>Since NMT doesn't track memory allocations by non-JVM code, you may have to use tools supported by the operating system to detect memory leaks in native code.</p>
<p>The following sections describe how to monitor VM internal memory allocations and diagnose VM memory leaks.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-635E34C2-CDDC-4C1A-8C3E-3C68F1FEC775" title="Procedure to use Native Memory Tracking to detect memory leaks.">Use NMT to Detect a Memory Leak</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-FB0581EA-2F91-4093-B2FA-46687F7AB081" title="Native Memory Tracking can be set up to monitor memory and ensure that an application does not start to use increasing amounts of memory during development or maintenance.">How to Monitor VM Internal Memory</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37" title="List of native memory tracking memory categories used by NMT.">NMT Memory Categories</a></p>
</li>
</ul>
</div>
<a id="JSTGD154"></a>
<div class="props_rev_3"><a id="GUID-635E34C2-CDDC-4C1A-8C3E-3C68F1FEC775"></a>
<h3 id="JSTGD-GUID-635E34C2-CDDC-4C1A-8C3E-3C68F1FEC775" class="sect3">Use NMT to Detect a Memory Leak</h3>
<div>
<p>Procedure to use Native Memory Tracking to detect memory leaks.</p>
<div class="section">
<p>Follow these steps to detect a memory leak:</p>
</div>
<!-- class="section" -->
<ol>
<li><span>Start the JVM with <span class="italic"><span class="bold">summary</span></span> or <span class="italic"><span class="bold">detail</span></span> tracking using the command line option: <code class="codeph">-XX:NativeMemoryTracking=summary</code> or <code class="codeph">-XX:NativeMemoryTracking=detail</code>.</span></li>
<li><span>Establish an early baseline. Use NMT baseline feature to get a baseline to compare during development and maintenance by running: <code class="codeph">jcmd &lt;pid&gt; VM.native_memory baseline</code>.</span></li>
<li><span>Monitor memory changes using: <code class="codeph">jcmd &lt;pid&gt; VM.native_memory detail.diff</code>.</span></li>
<li><span>If the application leaks a small amount of memory, then it may take a while to show up.</span></li>
</ol>
</div>
</div>
<a id="JSTGD155"></a>
<div class="props_rev_3"><a id="GUID-FB0581EA-2F91-4093-B2FA-46687F7AB081"></a>
<h3 id="JSTGD-GUID-FB0581EA-2F91-4093-B2FA-46687F7AB081" class="sect3">How to Monitor VM Internal Memory</h3>
<div>
<p>Native Memory Tracking can be set up to monitor memory and ensure that an application does not start to use increasing amounts of memory during development or maintenance.</p>
<div class="section">
<p>See <a href="diagnostic-tools.htm#GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37__BABHIFJC" title="This table describes native memory tracking memory categories">Table 2-1</a> for details about NMT memory categories.</p>
<p>The following sections describe how to get <span class="italic"><span class="bold">summary</span></span> or <span class="italic"><span class="bold">detail</span></span> data for NMT and describes how to interpret the sample output.</p>
</div>
<!-- class="section" -->
<ul>
<li class="stepexpand"><span><span class="bold">Interpret sample output:</span> From the following sample output, you will see <span class="italic"><span class="bold">reserved</span></span> and <span class="italic"><span class="bold">committed</span></span> memory. Note that only <span class="italic"><span class="bold">committed</span></span> memory is actually used. For example, if you run with <code class="codeph">-Xms100m -Xmx1000m</code>, then the JVM will reserve 1000 MB for the Java heap. Because the initial heap size is only 100 MB, only 100 MB will be committed to begin with. For a 64-bit machine where address space is almost unlimited, there is no problem if a JVM reserves a lot of memory. The problem arises if more and more memory gets committed, which may lead to swapping or native out of memory (OOM) situations.</span>
<div>
<p>An arena is a chunk of memory allocated using malloc. Memory is freed from these chunks in bulk, when exiting a scope or leaving an area of code. These chunks can be reused in other subsystems to hold temporary memory, for example, pre-thread allocations. An arena malloc policy ensures no memory leakage. So arena is tracked as a whole and not individual objects. Some initial memory cannot be tracked.</p>
<p>Enabling NMT will result in a <span class="italic"><span class="bold">5-10 percent</span></span> JVM performance drop, and memory usage for NMT adds 2 machine words to all malloc memory as a malloc header. NMT memory usage is also tracked by NMT.</p>
<pre dir="ltr">
Total:  reserved=664192KB,  committed=253120KB                                           &lt;--- total memory tracked by Native Memory Tracking
 
-                 Java Heap (reserved=516096KB, committed=204800KB)                      &lt;--- Java Heap
                            (mmap: reserved=516096KB, committed=204800KB)
 
-                     Class (reserved=6568KB, committed=4140KB)                          &lt;--- class metadata
                            (classes #665)                                               &lt;--- number of loaded classes
                            (malloc=424KB, #1000)                                        &lt;--- malloc'd memory, #number of malloc
                            (mmap: reserved=6144KB, committed=3716KB)
 
-                    Thread (reserved=6868KB, committed=6868KB)
                            (thread #15)                                                 &lt;--- number of threads
                            (stack: reserved=6780KB, committed=6780KB)                   &lt;--- memory used by thread stacks
                            (malloc=27KB, #66)
                            (arena=61KB, #30)                                            &lt;--- resource and handle areas
 
-                      Code (reserved=102414KB, committed=6314KB)
                            (malloc=2574KB, #74316)
                            (mmap: reserved=99840KB, committed=3740KB)
 
-                        GC (reserved=26154KB, committed=24938KB)
                            (malloc=486KB, #110)
                            (mmap: reserved=25668KB, committed=24452KB)
 
-                  Compiler (reserved=106KB, committed=106KB)
                            (malloc=7KB, #90)
                            (arena=99KB, #3)
 
-                  Internal (reserved=586KB, committed=554KB)
                            (malloc=554KB, #1677)
                            (mmap: reserved=32KB, committed=0KB)
 
-                    Symbol (reserved=906KB, committed=906KB)
                            (malloc=514KB, #2736)
                            (arena=392KB, #1)
 
-           Memory Tracking (reserved=3184KB, committed=3184KB)
                            (malloc=3184KB, #300)
 
-        Pooled Free Chunks (reserved=1276KB, committed=1276KB)
                            (malloc=1276KB)
 
-                   Unknown (reserved=33KB, committed=33KB)
                            (arena=33KB, #1)
</pre></div>
</li>
<li class="stepexpand"><span><span class="bold">Get detail data:</span> To get a more detailed view of native memory usage, start the JVM with command line option: <code class="codeph">-XX:NativeMemoryTracking=detail</code>. This will track exactly what methods allocate the most memory. Enabling NMT will result in <span class="italic"><span class="bold">5-10 percent</span></span> JVM performance drop and memory usage for NMT adds 2 words to all malloc memory as malloc header. NMT memory usage is also tracked by NMT.</span>
<div>
<p>The following example shows a sample output for virtual memory for track level set to <span class="italic"><span class="bold">detail</span></span>. One way to get this sample output is to run: <code class="codeph">jcmd &lt;pid&gt; VM.native_memory detail</code>.</p>
<pre dir="ltr">
Virtual memory map:
 
[0x8f1c1000 - 0x8f467000] reserved 2712KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0x8f1c1000 - 0x8f467000] committed 2712KB from [Thread::record_stack_base_and_size()+0xca]
 
[0x8f585000 - 0x8f729000] reserved 1680KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0x8f585000 - 0x8f729000] committed 1680KB from [Thread::record_stack_base_and_size()+0xca]
 
[0x8f930000 - 0x90100000] reserved 8000KB for GC
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0x8f930000 - 0x90100000] committed 8000KB from [PSVirtualSpace::expand_by(unsigned int)+0x95]
 
[0x902dd000 - 0x9127d000] reserved 16000KB for GC
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0x902dd000 - 0x9127d000] committed 16000KB from [os::pd_commit_memory(char*, unsigned int, unsigned int, bool)+0x36]
 
[0x9127d000 - 0x91400000] reserved 1548KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0x9127d000 - 0x91400000] committed 1548KB from [Thread::record_stack_base_and_size()+0xca]
 
[0x91400000 - 0xb0c00000] reserved 516096KB for Java Heap                                                                            &lt;--- reserved memory range
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x190]                  &lt;--- callsite that reserves the memory
        [0x91400000 - 0x93400000] committed 32768KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x3e8]               &lt;--- committed memory range and its callsite
        [0xa6400000 - 0xb0c00000] committed 172032KB from [PSVirtualSpace::expand_by(unsigned int)+0x95]                             &lt;--- committed memory range and its callsite
 
[0xb0c61000 - 0xb0ce2000] reserved 516KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0xb0c61000 - 0xb0ce2000] committed 516KB from [Thread::record_stack_base_and_size()+0xca]
 
[0xb0ce2000 - 0xb0e83000] reserved 1668KB for GC
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0xb0ce2000 - 0xb0cf0000] committed 56KB from [PSVirtualSpace::expand_by(unsigned int)+0x95]
        [0xb0d88000 - 0xb0d96000] committed 56KB from [CardTableModRefBS::resize_covered_region(MemRegion)+0xebf]
        [0xb0e2e000 - 0xb0e83000] committed 340KB from [CardTableModRefBS::resize_covered_region(MemRegion)+0xebf]
 
[0xb0e83000 - 0xb7003000] reserved 99840KB for Code
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0xb0e83000 - 0xb0e92000] committed 60KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x3e8]
        [0xb1003000 - 0xb139b000] committed 3680KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x37a]
 
[0xb7003000 - 0xb7603000] reserved 6144KB for Class
                from [ReservedSpace::initialize(unsigned int, unsigned int, bool, char*, unsigned int, bool)+0x555]
        [0xb7003000 - 0xb73a4000] committed 3716KB from [VirtualSpace::initialize(ReservedSpace, unsigned int)+0x37a]
 
[0xb7603000 - 0xb760b000] reserved 32KB for Internal
                from [PerfMemory::create_memory_region(unsigned int)+0x8ba]
 
[0xb770b000 - 0xb775c000] reserved 324KB for Thread Stack
                from [Thread::record_stack_base_and_size()+0xca]
        [0xb770b000 - 0xb775c000] committed 324KB from [Thread::record_stack_base_and_size()+0xca]
</pre></div>
</li>
<li class="stepexpand"><span><span class="bold">Get diff from NMT baseline:</span> For both <span class="italic">summary</span> and <span class="italic">detail</span> level tracking, you can set a baseline after the application is up and running. Do this by running <code class="codeph">jcmd &lt;pid&gt; VM.native_memory baseline</code> after the application warms up. Then, you can run<code class="codeph">jcmd &lt;pid&gt; VM.native_memory summary.diff</code> or <code class="codeph">jcmd &lt;pid&gt; VM.native_memory detail.diff</code>.</span>
<div>
<p>The following example shows sample output for the <span class="italic"><span class="bold">summary</span></span> difference in native memory usage since the baseline was set and is a great way to find memory leaks.</p>
<pre dir="ltr">
Total:  reserved=664624KB  -20610KB, committed=254344KB -20610KB                         &lt;--- total memory changes vs. earlier baseline. '+'=increase '-'=decrease
 
-                 Java Heap (reserved=516096KB, committed=204800KB)
                            (mmap: reserved=516096KB, committed=204800KB)
 
-                     Class (reserved=6578KB +3KB, committed=4530KB +3KB)
                            (classes #668 +3)                                            &lt;--- 3 more classes loaded
                            (malloc=434KB +3KB, #930 -7)                                 &lt;--- malloc'd memory increased by 3KB, but number of malloc count decreased by 7
                            (mmap: reserved=6144KB, committed=4096KB)
 
-                    Thread (reserved=60KB -1129KB, committed=60KB -1129KB)
                            (thread #16 +1)                                              &lt;--- one more thread
                            (stack: reserved=7104KB +324KB, committed=7104KB +324KB)
                            (malloc=29KB +2KB, #70 +4)
                            (arena=31KB -1131KB, #32 +2)                                 &lt;--- 2 more arenas (one more resource area and one more handle area)
 
-                      Code (reserved=102328KB +133KB, committed=6640KB +133KB)
                            (malloc=2488KB +133KB, #72694 +4287)
                            (mmap: reserved=99840KB, committed=4152KB)
 
-                        GC (reserved=26154KB, committed=24938KB)
                            (malloc=486KB, #110)
                            (mmap: reserved=25668KB, committed=24452KB)
 
-                  Compiler (reserved=106KB, committed=106KB)
                            (malloc=7KB, #93)
                            (arena=99KB, #3)
 
-                  Internal (reserved=590KB +35KB, committed=558KB +35KB)
                            (malloc=558KB +35KB, #1699 +20)
                            (mmap: reserved=32KB, committed=0KB)
 
-                    Symbol (reserved=911KB +5KB, committed=911KB +5KB)
                            (malloc=519KB +5KB, #2921 +180)
                            (arena=392KB, #1)
 
-           Memory Tracking (reserved=2073KB -887KB, committed=2073KB -887KB)
                            (malloc=2073KB -887KB, #84 -210)
 
-        Pooled Free Chunks (reserved=2624KB -15876KB, committed=2624KB -15876KB)
                            (malloc=2624KB -15876KB)
</pre>
<p>The following example is a sample output that shows the <span class="italic"><span class="bold">detail</span></span> difference in native memory usage since the baseline and is a great way to find memory leaks.</p>
<pre dir="ltr">
Details:
 
[0x01195652] ChunkPool::allocate(unsigned int)+0xe2
                            (malloc=482KB -481KB, #8 -8)
 
[0x01195652] ChunkPool::allocate(unsigned int)+0xe2
                            (malloc=2786KB -19742KB, #134 -618)
 
[0x013bd432] CodeBlob::set_oop_maps(OopMapSet*)+0xa2
                            (malloc=591KB +6KB, #681 +37)
 
[0x013c12b1] CodeBuffer::block_comment(int, char const*)+0x21                &lt;--- [callsite address] method name + offset
                            (malloc=562KB +33KB, #35940 +2125)               &lt;--- malloc'd amount, increased by 33KB #malloc count, increased by 2125
 
[0x0145f172] ConstantPool::ConstantPool(Array&lt;unsigned char&gt;*)+0x62
                            (malloc=69KB +2KB, #610 +15)
 
...
 
[0x01aa3ee2] Thread::allocate(unsigned int, bool, unsigned short)+0x122
                            (malloc=21KB +2KB, #13 +1)
 
[0x01aa73ca] Thread::record_stack_base_and_size()+0xca
                            (mmap: reserved=7104KB +324KB, committed=7104KB +324KB)
</pre></div>
</li>
</ul>
</div>
</div>
</div>
<a id="JSTGD173"></a>
<div class="props_rev_3"><a id="GUID-92074912-77E2-46B4-9A2F-A27F10331576"></a>
<h2 id="JSTGD-GUID-92074912-77E2-46B4-9A2F-A27F10331576" class="sect2">JConsole</h2>
<div>
<p>Another useful tool included in the JDK download is the <code class="codeph">JConsole</code> monitoring tool. This tool is compliant with JMX. The tool uses the built-in JMX instrumentation in the JVM to provide information about the performance and resource consumption of running applications.</p>
<p>Although the tool is included in the JDK download, it can also be used to monitor and manage applications deployed with the JRE.</p>
<p>The <code class="codeph">JConsole</code> tool can attach to any Java application in order to display useful information such as thread usage, memory consumption, and details about class loading, runtime compilation, and the operating system.</p>
<p>This output helps with the high-level diagnosis of problems such as memory leaks, excessive class loading, and running threads. It can also be useful for tuning and heap sizing.</p>
<p>In addition to monitoring, <code class="codeph">JConsole</code> can be used to dynamically change several parameters in the running system. For example, the setting of the <code class="codeph">-verbose:gc</code> option can be changed so that the garbage collection trace output can be dynamically enabled or disabled for a running application.</p>
<p>The following sections describe troubleshooting techniques with the JConsole tool.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-10CE3834-3A19-40E1-964D-A41740FC93E6" title="Use the JConsole tool to monitor data.">Troubleshoot with the JConsole Tool</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9" title="JConsole can monitor both local applications and remote applications. If you start the tool with an argument specifying a JMX agent to connect to, then the tool will automatically start monitoring the specified application.">Monitor Local and Remote Applications with JConsole</a></p>
</li>
</ul>
</div>
<a id="JSTGD174"></a>
<div class="props_rev_3"><a id="GUID-10CE3834-3A19-40E1-964D-A41740FC93E6"></a>
<h3 id="JSTGD-GUID-10CE3834-3A19-40E1-964D-A41740FC93E6" class="sect3">Troubleshoot with the JConsole Tool</h3>
<div>
<p>Use the <code class="codeph">JConsole</code> tool to monitor data.</p>
<p>The following list provides an idea of the data that can be monitored using the <code class="codeph">JConsole</code> tool. Each heading corresponds to a tab pane in the tool.</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Overview</span></p>
<p>This pane displays graphs that shows the heap memory usage, number of threads, number of classes, and CPU usage over time. This overview allows you to visualize the activity of several resources at once.</p>
</li>
<li>
<p><span class="bold">Memory</span></p>
<ul style="list-style-type: disc;">
<li>
<p>For a selected memory area (heap, non-heap, various memory pools):</p>
<ul style="list-style-type: disc;">
<li>
<p>Graph showing memory usage over time</p>
</li>
<li>
<p>Current memory size</p>
</li>
<li>
<p>Amount of committed memory</p>
</li>
<li>
<p>Maximum memory size</p>
</li>
</ul>
</li>
<li>
<p>Garbage collector information, including the number of collections performed, and the total time spent performing garbage collection</p>
</li>
<li>
<p>Graph showing the percentage of heap and non-heap memory currently used</p>
</li>
</ul>
<p>In addition, on this pane you can request garbage collection to be performed.</p>
</li>
<li>
<p><span class="bold">Threads</span></p>
<ul style="list-style-type: disc;">
<li>
<p>Graph showing thread usage over time.</p>
</li>
<li>
<p>Live threads: Current number of live threads.</p>
</li>
<li>
<p>Peak: Highest number of live threads since the JVM started.</p>
</li>
<li>
<p>For a selected thread, the name, state, and stack trace, as well as, for a blocked thread, the synchronizer that the thread is waiting to acquire, and the thread that ownsthe lock.</p>
</li>
<li>
<p>The <span class="bold">Deadlock Detection</span> button sends a request to the target application to perform deadlock detection and displays each deadlock cycle in a separate tab.</p>
</li>
</ul>
</li>
<li>
<p><span class="bold">Classes</span></p>
<ul style="list-style-type: disc;">
<li>
<p>Graph showing the number of loaded classes over time</p>
</li>
<li>
<p>Number of classes currently loaded into memory</p>
</li>
<li>
<p>Total number of classes loaded into memory since the JVM started, including those subsequently unloaded</p>
</li>
<li>
<p>Total number of classes unloaded from memory since the JVM started</p>
</li>
</ul>
</li>
<li>
<p><span class="bold">VM Summary</span></p>
<ul style="list-style-type: disc;">
<li>
<p>General information, such as the JConsole connection data, uptime for the JVM, CPU time consumed by the JVM, complier name, total compile time, and so on.</p>
</li>
<li>
<p>Thread and class summary information</p>
</li>
<li>
<p>Memory and garbage collection information, including number of objects pending finalization, and so on</p>
</li>
<li>
<p>Information about the operating system, including physical characteristics, the amount of virtual memory for the running process, and swap space</p>
</li>
<li>
<p>Information about the JVM itself, such as the arguments and class path</p>
</li>
</ul>
</li>
<li>
<p><span class="bold">MBeans</span></p>
<p>This pane displays a tree structure that shows all platform and application MBeans that are registered in the connected JMX agent. When you select an MBean in the tree, its attributes, operations, notifications, and other information are displayed.</p>
<ul style="list-style-type: disc;">
<li>
<p>You can invoke operations, if any. For example, the operation <code class="codeph">dumpHeap</code> for the <code class="codeph">HotSpotDiagnostic</code> MBean, which is in the <code class="codeph">com.sun.management</code> domain, performs a heap dump. The input parameter for this operation is the path name of the heap dump file on the machine where the target VM is running.</p>
</li>
<li>
<p>You can set the value of writable attributes. For example, you can set, unset, or change the value of certain VM flags by invoking the <code class="codeph">setVMOption</code> operation of the <code class="codeph">HotSpotDiagnostic</code> MBean. The flags are indicated by the list of values of the <code class="codeph">DiagnosticOptions</code> attribute.</p>
</li>
<li>
<p>You can subscribe to notifications, if any, by using the <span class="bold">Subscribe</span> and <span class="bold">Unsubscribe</span> buttons.</p>
</li>
</ul>
</li>
</ul>
</div>
</div>
<a id="JSTGD176"></a><a id="JSTGD175"></a>
<div class="props_rev_3"><a id="GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9"></a>
<h3 id="JSTGD-GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9" class="sect3">Monitor Local and Remote Applications with JConsole</h3>
<div>
<p>JConsole can monitor both local applications and remote applications. If you start the tool with an argument specifying a JMX agent to connect to, then the tool will automatically start monitoring the specified application.</p>
<div class="section">
<p>To monitor a local application, execute the command <code class="codeph">jconsole<span class="variable">pid</span></code> , where <code class="codeph"><span class="variable">pid</span></code> is the process ID of the application.</p>
<p>To monitor a remote application, execute the command <code class="codeph">jconsole<span class="variable">hostname</span>:</code> <span class="variable">portnumber</span>, where <code class="codeph"><span class="variable">hostname</span></code> is the name of the host running the application, and <code class="codeph"><span class="variable">portnumber</span></code> is the port number you specified when you enabled the JMX agent.</p>
<p>If you execute the <code class="codeph">jconsole</code> command without arguments, the tool will start by displaying the <span class="bold">New Connection</span> window, where you specify the local or remote process to be monitored. You can connect to a different host at any time by using the <span class="bold">Connection</span> menu.</p>
<p>With the latest JDK releases, no option is necessary when you start the application to be monitored.</p>
<p>As an example of the output of the monitoring tool, <a href="diagnostic-tools.htm#GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9__BABJECGB">Figure 2-15</a> shows a chart of the heap memory usage.</p>
<div class="figure" id="GUID-B783B7CD-CA94-45D0-92CE-C35ABE8CA7E9__BABJECGB">
<p class="titleinfigure">Figure 2-15 Sample Output from JConsole</p>
<img width="676" height="578" src="img/jconsole-memory-tab.gif" alt="Description of Figure 2-15 follows" title="Description of Figure 2-15 follows" /><br />
<a href="img_text/jconsole-memory-tab.htm">Description of "Figure 2-15 Sample Output from JConsole"</a></div>
<!-- class="figure" --></div>
<!-- class="section" --></div>
</div>
</div>
<a id="JSTGD179"></a>
<div class="props_rev_3"><a id="GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7"></a>
<h2 id="JSTGD-GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" class="sect2">The jdb Utility</h2>
<div>
<p>The <code class="codeph">jdb</code> utility is included in the JDK as an example command-line debugger. The <code class="codeph">jdb</code> utility uses the Java Debug Interface (JDI) to launch or connect to the target JVM.</p>
<p>The source code for <code class="codeph">jdb</code> is included in <code class="codeph">$JAVA_HOME/demo/jpda/examples.jar</code>.</p>
<p>The JDI is a high-level Java API that provides information useful for debuggers and similar systems that need access to the running state of a (usually remote) virtual machine. JDI is a component of the Java Platform Debugger Architecture (JPDA). See <a href="diagnostic-tools.htm#GUID-5C5F526F-9F19-43FA-BB0C-C7FC1BAB8D97" title="The Java Platform Debugger Architecture (JPDA) is the architecture designed for use by debuggers and debugger-like tools.">Java Platform Debugger Architecture</a>.</p>
<p>The following sections provide troubleshooting techniques for <code class="codeph">jdb</code> utility.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-4D0B048D-F352-48B6-BCA4-BD31C9300B27" title="The jdb utility is used to monitor the debugger connectors used for remote debugging.">Troubleshoot with the jdb Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-D9481012-2E50-46CE-8B7F-1BABA8820ABD">Attach a Process</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-76F4E095-0E93-4CD8-9914-C03B643D713E" title="The SA Core Attaching Connector is used to attach the debugger to a core file.">Attach to a Core File on the Same Machine</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-8ADCA645-9831-4972-87C0-184C12B188E1" title="On the machine where the debugger is installed, you can use the SA Debug Server Attaching Connector to connect to the debug server.">Attach to a Core File or a Hung Process from a Different Machine</a></p>
</li>
</ul>
</div>
<a id="JSTGD180"></a>
<div class="props_rev_3"><a id="GUID-4D0B048D-F352-48B6-BCA4-BD31C9300B27"></a>
<h3 id="JSTGD-GUID-4D0B048D-F352-48B6-BCA4-BD31C9300B27" class="sect3">Troubleshoot with the jdb Utility</h3>
<div>
<p>The jdb utility is used to monitor the debugger connectors used for remote debugging.</p>
<p>In JDI, a connector is the way that the debugger connects to the target JVM. The JDK traditionally ships with connectors that launch and establish a debugging session with a target JVM, as well as connectors that are used for remote debugging (using TCP/IP or shared memory transports).</p>
<p>The JDK also ships with several Serviceability Agent (SA) connectors that allow a Java language debugger to attach to a crash dump or hung process. This can be useful in determining what the application was doing at the time of the crash or hang.</p>
<p>These connectors are <code class="codeph">SACoreAttachingConnector</code>, <code class="codeph">SADebugServerAttachingConnector</code>, and <code class="codeph">SAPIDAttachingConnector</code>.</p>
<p>These connectors are generally used with enterprise debuggers, such as the NetBeans integrated development environment (IDE) or commercial IDEs. The following sections demonstrate how these connectors can be used with the <code class="codeph">jdb</code> command-line debugger.</p>
<p>The command <code class="codeph">jdb -listconnectors</code> prints a list of the available connectors. The command <code class="codeph">jdb -help</code> prints the command usage help.</p>
<p>See <a class="olink JSWOR-GUID-B801F121-35B5-4FE2-A307-950412CE4E99" target="_blank" href="../tools/jdb.htm#JSWOR-GUID-B801F121-35B5-4FE2-A307-950412CE4E99">jdb Utility</a> in the <span><cite>Java Platform, Standard Edition Tools Reference</cite></span></p>
</div>
</div>
<a id="JSTGD181"></a>
<div class="props_rev_3"><a id="GUID-D9481012-2E50-46CE-8B7F-1BABA8820ABD"></a>
<h3 id="JSTGD-GUID-D9481012-2E50-46CE-8B7F-1BABA8820ABD" class="sect3">Attach a Process</h3>
<div>
<div class="section">
<p>The following example uses the SA PID Attaching Connector to attach to a process. The target process is not started with any special options; that is, the <code class="codeph">-agentlib:jdwp</code> option is not required. When this connector attaches to a process, it does so in read-only mode: the debugger can examine threads and the running application, but it cannot change anything. The process is frozen while the debugger is attached.</p>
<p>The command in the following example instructs <code class="codeph">jdb</code> to use a connector named <code class="codeph">sun.jvm.hotspot.jdi.SAPIDAttachingConnector</code>. This is a connector name rather than a class name. The connector takes one argument named <code class="codeph">pid</code>, whose value is the process ID of the target process (<code class="codeph">9302</code>).</p>
<pre dir="ltr">
$ <span class="bold">jdb -connect sun.jvm.hotspot.jdi.SAPIDAttachingConnector:pid=9302</span>

Initializing jdb ...
&gt; <span class="bold">threads</span>
Group system:
  (java.lang.ref.Reference$ReferenceHandler)0xa Reference Handler unknown
  (java.lang.ref.Finalizer$FinalizerThread)0x9  Finalizer         unknown
  (java.lang.Thread)0x8                         Signal Dispatcher running
  (java.lang.Thread)0x7                         Java2D Disposer   unknown
  (java.lang.Thread)0x2                         TimerQueue        unknown
Group main:
  (java.lang.Thread)0x6                         AWT-XAWT          running
  (java.lang.Thread)0x5                         AWT-Shutdown      unknown
  (java.awt.EventDispatchThread)0x4             AWT-EventQueue-0  unknown
  (java.lang.Thread)0x3                         DestroyJavaVM     running
  (sun.awt.image.ImageFetcher)0x1               Image Animator 0  sleeping
  (java.lang.Thread)0x0                         Intro             running
&gt; <span class="bold">thread 0x7</span>
Java2D Disposer[1] <span class="bold">where</span>
  [1] java.lang.Object.wait (native method)
  [2] java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:116)
  [3] java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:132)
  [4] sun.java2d.Disposer.run (Disposer.java:125)
  [5] java.lang.Thread.run (Thread.java:619)
Java2D Disposer[1] <span class="bold">up 1</span>
Java2D Disposer[2] <span class="bold">where</span>
  [2] java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:116)
  [3] java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:132)
  [4] sun.java2d.Disposer.run (Disposer.java:125)
  [5] java.lang.Thread.run (Thread.java:619)
</pre>
<p>In this example, the <code class="codeph">threads</code> command is used to get a list of all threads. Then, a specific thread is selected with the <code class="codeph">thread 0x7</code> command, and the <code class="codeph">where</code> command is used to get a thread dump. Next, the <code class="codeph">up 1</code> command is used to move up one frame in the stack, and the <code class="codeph">where</code> command is used again to get a thread dump.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="JSTGD183"></a>
<div class="props_rev_3"><a id="GUID-76F4E095-0E93-4CD8-9914-C03B643D713E"></a>
<h3 id="JSTGD-GUID-76F4E095-0E93-4CD8-9914-C03B643D713E" class="sect3">Attach to a Core File on the Same Machine</h3>
<div>
<p>The SA Core Attaching Connector is used to attach the debugger to a core file.</p>
<div class="section">
<p>The core file might have been created after a crash. See <a href="troubleshoot-system-crashes.htm#GUID-BDA1D041-355C-4C85-9ED0-E2AC46D67BED" title="Information and guidance about some specific procedures for troubleshooting system crashes.">Troubleshoot System Crashes</a>. The core file can also be obtained by using the <code class="codeph">gcore</code> command on the Oracle Solaris operating system or the <code class="codeph">gcore</code> command in <code class="codeph">gdb</code> on Linux. Because the core file is a snapshot of the process at the time the core file was created, the connector attaches in read-only mode: the debugger can examine threads and the running application at the time of the crash.</p>
<p>The command in the following example instructs <code class="codeph">jdb</code> to use a connector named <code class="codeph">sun.jvm.hotspot.jdi.SACoreAttachingConnector</code>. The connector takes two arguments: <code class="codeph">javaExecutable</code> and <code class="codeph">core</code>. The <code class="codeph">javaExecutable</code> argument indicates the name of the Java binary. The <code class="codeph">core</code> argument is the core file name (the core from the process with PID 20441, as shown in the following example).</p>
<pre dir="ltr">
$ jdb -connect sun.jvm.hotspot.jdi.SACoreAttachingConnector:javaExecutable=<span class="variable">$JAVA_HOME</span>/bin/java,core=core.20441
</pre></div>
<!-- class="section" --></div>
</div>
<a id="JSTGD185"></a>
<div class="props_rev_3"><a id="GUID-8ADCA645-9831-4972-87C0-184C12B188E1"></a>
<h3 id="JSTGD-GUID-8ADCA645-9831-4972-87C0-184C12B188E1" class="sect3">Attach to a Core File or a Hung Process from a Different Machine</h3>
<div>
<p>On the machine where the debugger is installed, you can use the SA Debug Server Attaching Connector to connect to the debug server.</p>
<div class="section">
<p>To debug a core file that was transported from another machine, the operating system versions and libraries must match. In this case, you can first run a proxy server called the SA Debug Server. Then, on the machine where the debugger is installed, you can use the SA Debug Server Attaching Connector to connect to the debug server.</p>
<p>For example, there are two machines: machine1 and machine2. A core file is available on machine1, and the debugger is available on machine2. The SA Debug Server is started on machine1, as shown in the following example.</p>
<pre dir="ltr">
$ jsadebugd <span class="variable">$JAVA_HOME</span>/bin/java core.20441
</pre>
<p>The <code class="codeph">jsadebugd</code> command takes two arguments. The first argument is the name of the executable file. Usually, this is <code class="codeph">java</code>, but it can be another name (in embedded VMs, for example). The second argument is the name of the core file. In this example, the core file was obtained for a process with PID 20441 using the <code class="codeph">gcore</code> utility.</p>
<p>On machine2, the debugger connects to the remote SA Debug Server using the SA Debug Server Attaching Connector, as shown in the following example.</p>
<pre dir="ltr">
$ jdb -connect sun.jvm.hotspot.jdi.SADebugServerAttachingConnector:debugServerName=machine1
</pre>
<p>The command in the example instructs <code class="codeph">jdb</code> to use a connector named <code class="codeph">sun.jvm.hotspot.jdi.SADebugServerAttachingConnector</code>. The connector has one argument, <code class="codeph">debugServerName</code>, which is the host name or IP address of the machine where the SA Debug Server is running.</p>
<div class="infobox-note" id="GUID-8ADCA645-9831-4972-87C0-184C12B188E1__GUID-AF35BFD7-389E-4E03-9DF0-05CE4E8898CC">
<p class="notep1">Note:</p>
<p>The SA Debug Server can also be used to remotely debug a hung process. In that case, it takes a single argument, which is the PID of the process. In addition, if it is required to run multiple debug servers on the same machine, each one must be provided with a unique ID. With the SA Debug Server Attaching Connector, this ID is provided as an additional connector argument.</p>
</div>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="JSTGD196"></a>
<div class="props_rev_3"><a id="GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE"></a>
<h2 id="JSTGD-GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE" class="sect2">The jinfo Utility</h2>
<div>
<p>The <code class="codeph">jinfo</code> command-line utility gets configuration information from a running Java process or crash dump, and prints the system properties or the command-line flags that were used to start the JVM.</p>
<p>Java Mission Control, Java Flight Recorder, and <code class="codeph">jcmd</code> utility can be used for diagnosing problems with JVM and Java applications. Use the latest utility, <code class="codeph">jcmd</code>, instead of the previous <code class="codeph">jinfo</code> utility for enhanced diagnostics and reduced performance overhead.</p>
<div class="p">The <code class="codeph">jinfo</code> utility can also use the <code class="codeph">jsadebugd</code> daemon to query a process or core file on a remote machine.
<div class="infobox-note" id="GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE__GUID-7EC37A3A-6BB8-426C-B66C-BB1BF51EAAC7">
<p class="notep1">Note:</p>
The output takes longer to print in this case.</div>
</div>
<p>With the <code class="codeph">-flag</code> option, the <code class="codeph">jinfo</code> utility can dynamically set, unset, or change the value of certain JVM flags for the specified Java process. See <a href="command-line-options1.htm#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6" title="Command-line options that are prefixed with -XX are specific to the Java HotSpot Virtual Machine. Many of these options are important for performance tuning and diagnostic purposes, and are therefore described in this appendix.">Java HotSpot VM Command-Line Options</a>.</p>
<p>The output for the <code class="codeph">jinfo</code> utility for a Java process with PID number 29620 is shown in the following example.</p>
<pre dir="ltr">
$ <span class="bold">jinfo 29620</span>
Attaching to process ID 29620, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 1.6.0-rc-b100
Java System Properties:

java.runtime.name = Java(TM) SE Runtime Environment
sun.boot.library.path = /usr/jdk/instances/jdk1.6.0/jre/lib/sparc
java.vm.version = 1.6.0-rc-b100
java.vm.vendor = Sun Microsystems Inc.
java.vendor.url = http://java.sun.com/
path.separator = :
java.vm.name = Java HotSpot(TM) Client VM
file.encoding.pkg = sun.io
sun.java.launcher = SUN_STANDARD
sun.os.patch.level = unknown
java.vm.specification.name = Java Virtual Machine Specification
user.dir = /home/js159705
java.runtime.version = 1.6.0-rc-b100
java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment
java.endorsed.dirs = /usr/jdk/instances/jdk1.6.0/jre/lib/endorsed
os.arch = sparc
java.io.tmpdir = /var/tmp/
line.separator =

java.vm.specification.vendor = Sun Microsystems Inc.
os.name = SunOS
sun.jnu.encoding = ISO646-US
java.library.path = /usr/jdk/instances/jdk1.6.0/jre/lib/sparc/client:/usr/jdk/instances/jdk1.6.0/jre/lib/sparc:
/usr/jdk/instances/jdk1.6.0/jre/../lib/sparc:/net/gtee.sfbay/usr/sge/sge6/lib/sol-sparc64:
/usr/jdk/packages/lib/sparc:/lib:/usr/lib
java.specification.name = Java Platform API Specification
java.class.version = 50.0
sun.management.compiler = HotSpot Client Compiler
os.version = 5.10
user.home = /home/js159705
user.timezone = US/Pacific
java.awt.printerjob = sun.print.PSPrinterJob
file.encoding = ISO646-US
java.specification.version = 1.6
java.class.path = /usr/jdk/jdk1.6.0/demo/jfc/Java2D/Java2Demo.jar
user.name = js159705
java.vm.specification.version = 1.0
java.home = /usr/jdk/instances/jdk1.6.0/jre
sun.arch.data.model = 32
user.language = en
java.specification.vendor = Sun Microsystems Inc.
java.vm.info = mixed mode, sharing
java.version = 1.6.0-rc
java.ext.dirs = /usr/jdk/instances/jdk1.6.0/jre/lib/ext:/usr/jdk/packages/lib/ext
sun.boot.class.path = /usr/jdk/instances/jdk1.6.0/jre/lib/resources.jar:
/usr/jdk/instances/jdk1.6.0/jre/lib/rt.jar:/usr/jdk/instances/jdk1.6.0/jre/lib/sunrsasign.jar:
/usr/jdk/instances/jdk1.6.0/jre/lib/jsse.jar:
/usr/jdk/instances/jdk1.6.0/jre/lib/jce.jar:/usr/jdk/instances/jdk1.6.0/jre/lib/charsets.jar:
/usr/jdk/instances/jdk1.6.0/jre/classes
java.vendor = Sun Microsystems Inc.
file.separator = /
java.vendor.url.bug = http://java.sun.com/cgi-bin/bugreport.cgi
sun.io.unicode.encoding = UnicodeBig
sun.cpu.endian = big
sun.cpu.isalist =

VM Flags:
</pre>
<p>The following topic describes the troubleshooting technique with <code class="codeph">jinfo</code> utility.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-085D7019-5A14-4F58-A385-FB6E200B3DC1" title="The output from jinfo provides the settings for java.class.path and sun.boot.class.path.">Troubleshooting with the jinfo Utility</a></p>
</li>
</ul>
</div>
<a id="JSTGD198"></a>
<div class="props_rev_3"><a id="GUID-085D7019-5A14-4F58-A385-FB6E200B3DC1"></a>
<h3 id="JSTGD-GUID-085D7019-5A14-4F58-A385-FB6E200B3DC1" class="sect3">Troubleshooting with the jinfo Utility</h3>
<div>
<p>The output from <code class="codeph">jinfo</code> provides the settings for <code class="codeph">java.class.path</code> and <code class="codeph">sun.boot.class.path</code>.</p>
<div class="section">
<p>If you start the target JVM with the <code class="codeph">-classpath</code> and <code class="codeph">-Xbootclasspath</code> arguments, then the output from <code class="codeph">jinfo</code> provides the settings for <code class="codeph">java.class.path</code> and <code class="codeph">sun.boot.class.path</code>. This information might be needed when investigating class loader issues.</p>
<p>In addition to getting information from a process, the <code class="codeph">jinfo</code> tool can use a core file as input. On the Oracle Solaris operating system, for example, the <code class="codeph">gcore</code> utility can be used to get a core file of the process in the preceding example. The core file will be named <code class="codeph">core.29620</code> and will be generated in the working directory of the process. The path to the Java executable file and the core file must be specified as arguments to the <code class="codeph">jinfo</code> utility, as shown in the following example.</p>
<pre dir="ltr">
$ jinfo <span class="variable">$JAVA_HOME</span>/bin/java core.29620
</pre>
<p>Sometimes, the binary name will not be <code class="codeph">java</code>. This happens when the VM is created using the JNI invocation API. The <code class="codeph">jinfo</code> tool requires the binary from which the core file was generated.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="JSTGD200"></a>
<div class="props_rev_3"><a id="GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818"></a>
<h2 id="JSTGD-GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" class="sect2">The jmap Utility</h2>
<div>
<p>The <code class="codeph">jmap</code> command-line utility prints memory-related statistics for a running VM or core file.</p>
<p>The utility can also use the <code class="codeph">jsadebugd</code> daemon to query a process or core file on a remote machine. The output takes longer to print in this case.</p>
<p>Java Mission Control, Java Flight Recorder, and <code class="codeph">jcmd</code> utility can be used for diagnosing problems with JVM and Java applications. It is suggested to use the latest utility, <code class="codeph">jcmd</code> instead of the previous <code class="codeph">jmap</code> utility for enhanced diagnostics and reduced performance overhead.</p>
<p>If <code class="codeph">jmap</code> is used with a process or core file without any command-line options, then it prints the list of shared objects loaded (the output is similar to the <code class="codeph">pmap</code> utility on Oracle Solaris operating system). For more specific information, you can use the options <code class="codeph">-heap</code>, <code class="codeph">-histo</code>, or <code class="codeph">-permstat</code>. These options are described in the subsections that follow.</p>
<p>In addition, the JDK 7 release introduced the <code class="codeph">-dump:format=b,file=<span class="variable">filename</span></code> option, which causes <code class="codeph">jmap</code> to dump the Java heap in binary format to a specified file.</p>
<p>If the <code class="codeph">jmap<span class="variable">pid</span></code> command does not respond because of a hung process, then the <code class="codeph">-F</code> option can be used (on Oracle Solaris and Linux operating systems only) to force the use of the Serviceability Agent.</p>
<p>The following sections describe the <code class="codeph">jmap</code> command usage and troubleshooting techniques with examples that print memory-related statistics for a running VM or a core file.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-4ED34AB6-AC5E-40D7-8A3F-86174670B4AB" title="Use the jmap -heap command to get the Java heap information.">Heap Configuration and Usage</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-A69901EC-F87D-4B63-A8B7-DE8684AD4FF9" title="The jmap command with the -histo option can be used to get a class-specific histogram of the heap.">Heap Histogram</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-9609A5F3-88DA-48D9-971E-330DDD7A7876" title="The permanent generation is the area of the heap that holds all the reflective data of the virtual machine itself, such as class and method objects.">Permanent Generation Statistics</a></p>
</li>
</ul>
</div>
<a id="JSTGD201"></a>
<div class="props_rev_3"><a id="GUID-4ED34AB6-AC5E-40D7-8A3F-86174670B4AB"></a>
<h3 id="JSTGD-GUID-4ED34AB6-AC5E-40D7-8A3F-86174670B4AB" class="sect3">Heap Configuration and Usage</h3>
<div>
<p>Use the <code class="codeph">jmap -heap</code> command to get the Java heap information.</p>
<div class="section">
<p>The <code class="codeph">-heap</code> option is used to get the following Java heap information:</p>
</div>
<!-- class="section" -->
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p>Information specific to the garbage collection (GC) algorithm, including the name of the GC algorithm (for example, parallel GC) and algorithm-specific details (such as the number of threads for parallel GC).</p>
</li>
<li>
<p>Heap configuration that might have been specified as command-line options or selected by the VM based on the machine configuration.</p>
</li>
<li>
<p>Heap usage summary: For each generation (area of the heap), the tool prints the total heap capacity, in-use memory, and available free memory. If a generation is organized as a collection of spaces (for example, the new generation), then a space-specific memory size summary is included.</p>
</li>
</ul>
<p>The following example shows output from the <code class="codeph">jmap -heap</code> command.</p>
<pre dir="ltr">
$ <span class="bold">jmap -heap 29620</span>
Attaching to process ID 29620, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 1.6.0-rc-b100

using thread-local object allocation.
Mark Sweep Compact GC

Heap Configuration:
   MinHeapFreeRatio = 40
   MaxHeapFreeRatio = 70
   MaxHeapSize      = 67108864 (64.0MB)
   NewSize          = 2228224 (2.125MB)
   MaxNewSize       = 4294901760 (4095.9375MB)
   OldSize          = 4194304 (4.0MB)
   NewRatio         = 8
   SurvivorRatio    = 8
   PermSize         = 12582912 (12.0MB)
   MaxPermSize      = 67108864 (64.0MB)

Heap Usage:
New Generation (Eden + 1 Survivor Space):
   capacity = 2031616 (1.9375MB)
   used     = 70984 (0.06769561767578125MB)
   free     = 1960632 (1.8698043823242188MB)
   3.4939673639112905% used
Eden Space:
   capacity = 1835008 (1.75MB)
   used     = 36152 (0.03447723388671875MB)
   free     = 1798856 (1.7155227661132812MB)
   1.9701276506696428% used
From Space:
   capacity = 196608 (0.1875MB)
   used     = 34832 (0.0332183837890625MB)
   free     = 161776 (0.1542816162109375MB)
   17.716471354166668% used
To Space:
   capacity = 196608 (0.1875MB)
   used     = 0 (0.0MB)
   free     = 196608 (0.1875MB)
   0.0% used
tenured generation:
   capacity = 15966208 (15.2265625MB)
   used     = 9577760 (9.134063720703125MB)
   free     = 6388448 (6.092498779296875MB)
   59.98769400974859% used
Perm Generation:
   capacity = 12582912 (12.0MB)
   used     = 1469408 (1.401336669921875MB)
   free     = 11113504 (10.598663330078125MB)
   11.677805582682291% used
</pre></div>
<!-- class="section" --></div>
</div>
<a id="JSTGD203"></a>
<div class="props_rev_3"><a id="GUID-A69901EC-F87D-4B63-A8B7-DE8684AD4FF9"></a>
<h3 id="JSTGD-GUID-A69901EC-F87D-4B63-A8B7-DE8684AD4FF9" class="sect3">Heap Histogram</h3>
<div>
<p>The <code class="codeph">jmap</code> command with the <code class="codeph">-histo</code> option can be used to get a class-specific histogram of the heap.</p>
<div class="section">
<p>Depending on the parameter specified, the <code class="codeph">jmap -histo</code> command can print the heap histogram for a running process or a core file.</p>
<p>When the command is executed on a running process, the tool prints the number of objects, memory size in bytes, and fully qualified class name for each class. Internal classes in the Java HotSpot VM are enclosed within angle brackets. The histogram is useful to understand how the heap is used. To get the size of an object, you must divide the total size by the count of that object type.</p>
<p>The following example shows output from the <code class="codeph">jmap -histo</code> command when it is executed on a process with PID number 29620.</p>
<pre dir="ltr">
$ <span class="bold">jmap -histo 29620</span>
num   #instances    #bytes  class name
--------------------------------------
  1:      1414     6013016  [I
  2:       793      482888  [B
  3:      2502      334928  &lt;constMethodKlass&gt;
  4:       280      274976  &lt;instanceKlassKlass&gt;
  5:       324      227152  [D
  6:      2502      200896  &lt;methodKlass&gt;
  7:      2094      187496  [C
  8:       280      172248  &lt;constantPoolKlass&gt;
  9:      3767      139000  [Ljava.lang.Object;
 10:       260      122416  &lt;constantPoolCacheKlass&gt;
 11:      3304      112864  &lt;symbolKlass&gt;
 12:       160       72960  java2d.Tools$3
 13:       192       61440  &lt;objArrayKlassKlass&gt;
 14:       219       55640  [F
 15:      2114       50736  java.lang.String
 16:      2079       49896  java.util.HashMap$Entry
 17:       528       48344  [S
 18:      1940       46560  java.util.Hashtable$Entry
 19:       481       46176  java.lang.Class
 20:        92       43424  javax.swing.plaf.metal.MetalScrollButton
... more lines removed here to reduce output...
1118:         1           8  java.util.Hashtable$EmptyIterator
1119:         1           8  sun.java2d.pipe.SolidTextRenderer
Total    61297    10152040
</pre>
<p>When the <code class="codeph">jmap -histo</code> command is executed on a core file, the tool prints the size, count, and class name for each class. Internal classes in the Java HotSpot VM are prefixed with an asterisk (*).</p>
<p>shows output of the <code class="codeph">jmap -histo</code> command when it is executed on a core file.</p>
<pre dir="ltr">
&amp; <span class="bold">jmap -histo /net/koori.sfbay/onestop/jdk/6.0/promoted/all/b100/binaries/solaris-sparcv9/bin/java core</span>
Attaching to core core from executable /net/koori.sfbay/onestop/jdk/6.0/
promoted/all/b100/binaries/solaris-sparcv9/bin/java, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 1.6.0-rc-b100
Iterating over heap. This may take a while...
Heap traversal took 8.902 seconds.

Object Histogram:

Size    Count    Class description
-------------------------------------------------------
4151816    2941    int[]
2997816    26403    * ConstMethodKlass
2118728    26403    * MethodKlass
1613184    39750    * SymbolKlass
1268896    2011    * ConstantPoolKlass
1097040    2011    * InstanceKlassKlass
882048    1906    * ConstantPoolCacheKlass
758424    7572    char[]
733776    2518    byte[]
252240    3260    short[]
214944    2239    java.lang.Class
177448    3341    * System ObjArray
176832    7368    java.lang.String
137792    3756    java.lang.Object[]
121744    74    long[]
72960    160    java2d.Tools$3
63680    199    * ObjArrayKlassKlass
53264    158    float[]
... more lines removed here to reduce output...
</pre></div>
<!-- class="section" --></div>
</div>
<a id="JSTGD206"></a>
<div class="props_rev_3"><a id="GUID-9609A5F3-88DA-48D9-971E-330DDD7A7876"></a>
<h3 id="JSTGD-GUID-9609A5F3-88DA-48D9-971E-330DDD7A7876" class="sect3">Permanent Generation Statistics</h3>
<div>
<p>The permanent generation is the area of the heap that holds all the reflective data of the virtual machine itself, such as class and method objects.</p>
<div class="section">
<p>This area is also called method area in <span class="italic">The Java Virtual Machine Specification</span>.</p>
<p>Configuring the size of the permanent generation can be important for applications that dynamically generate and load a very large number of classes (for example, Java Server Pages or web containers). If an application loads too many classes, then it is possible it will terminate with the following error:</p>
<pre dir="ltr">
Exception in thread <span class="variable">thread_name</span> java.lang.OutOfMemoryError: PermGen space
</pre>
<p>See <a href="troubleshoot-memory-leaks.htm#GUID-19F6D28E-75A1-4480-9879-D0932B2F305B" title="java.lang.OutOfMemoryError error is thrown when there is insufficient space to allocate an object in the Java heap.">Understand the OutOfMemoryError Exception</a>.</p>
<p>To get further information about the permanent generation, you can use the <code class="codeph">-permstat</code> option of the <code class="codeph">jmap</code> command to print statistics for the objects in the permanent generation.</p>
<p>The following example shows the output from the <code class="codeph">jmap -permstat</code> command executed on a process with PID number 29620.</p>
<pre dir="ltr">
$ <span class="bold">jmap -permstat 29620</span>
Attaching to process ID 29620, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 1.6.0-rc-b100
12674 intern Strings occupying 1082616 bytes.
finding class loader instances ..Unknown oop at 0xd0400900
Oop's klass is 0xd0bf8408
Unknown oop at 0xd0401100
Oop's klass is null
done.
computing per loader stat ..done.
please wait.. computing liveness.........................................done.
class_loader    classes bytes   parent_loader   alive?  type

&lt;bootstrap&gt;     1846 5321080  null        live   &lt;internal&gt;
0xd0bf3828  0      0      null         live    sun/misc/Launcher$ExtClassLoader@0xd8c98c78
0xd0d2f370  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0c99280  1   1440      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0b71d90  0      0   0xd0b5b9c0    live java/util/ResourceBundle$RBClassLoader@0xd8d042e8
0xd0d2f4c0  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0b5bf98  1    920   0xd0b5bf38      dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0c99248  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f488  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0b5bf38  6   11832  0xd0b5b9c0      dead    sun/reflect/misc/MethodUtil@0xd8e8e560
0xd0d2f338  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f418  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f3a8  1    904     null          dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0b5b9c0  317 1397448 0xd0bf3828     live    sun/misc/Launcher$AppClassLoader@0xd8cb83d8
0xd0d2f300  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f3e0  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0ec3968  1   1440      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0e0a248  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0c99210  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f450  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0d2f4f8  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50
0xd0e0a280  1    904      null         dead    sun/reflect/DelegatingClassLoader@0xd8c22f50

total = 22      2186    6746816   N/A   alive=4, dead=18       N/A    
</pre>
<p>For each class loader object, the following details are printed:</p>
<ul style="list-style-type: disc;">
<li>
<p>The address of the class loader object at the snapshot when the utility was run</p>
</li>
<li>
<p>The number of classes loaded</p>
</li>
<li>
<p>The approximate number of bytes consumed by metadata for all classes loaded by this class loader</p>
</li>
<li>
<p>The address of the parent class loader (if any)</p>
</li>
<li>
<p>A <span class="italic"><span class="bold">live</span></span> or <span class="italic"><span class="bold">dead</span></span> indication of whether the loader object will be garbage collected in the future</p>
</li>
<li>
<p>The class name of this class loader</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="JSTGD208"></a>
<div class="props_rev_3"><a id="GUID-FC269C18-470F-441E-9564-7EEA182F8125"></a>
<h2 id="JSTGD-GUID-FC269C18-470F-441E-9564-7EEA182F8125" class="sect2">The jps Utility</h2>
<div>
<p>The <code class="codeph">jps</code> utility lists every instrumented Java HotSpot VM for the current user on the target system.</p>
<div class="section">
<p>The utility is very useful in environments where the VM is embedded, that is, where it is started using the JNI Invocation API rather than the <code class="codeph">java</code> launcher. In these environments, it is not always easy to recognize the Java processes in the process list.</p>
<p>The following example shows the use of the <code class="codeph">jps</code> utility.</p>
<pre dir="ltr">
$ <span class="bold">jps</span>
16217 MyApplication
16342 jps
</pre>
<p>The <code class="codeph">jps</code> utility lists the virtual machines for which the user has access rights. This is determined by access-control mechanisms specific to the operating system. On the Oracle Solaris operating system, for example, if a non-root user executes the <code class="codeph">jps</code> utility, then the output is a list of the virtual machines that were started with that user's UID.</p>
<p>In addition to listing the PID, the utility provides options to output the arguments passed to the application's <code class="codeph">main</code> method, the complete list of VM arguments, and the full package name of the application's <code class="codeph">main</code> class. The <code class="codeph">jps</code> utility can also list processes on a remote system if the remote system is running the <code class="codeph">jstatd</code> daemon.</p>
<p>If you are running several Java Web Start applications on a system, then they tend to look the same, as shown in the following example.</p>
<pre dir="ltr">
$ <span class="bold">jps</span>
1271 jps
     1269 Main
     1190 Main
</pre>
<p>In this case, use <code class="codeph">jps -m</code> to distinguish them, as shown in the following example.</p>
<pre dir="ltr">
$ <span class="bold">jps -m</span>
1271 jps -m
     1269 Main http://bugster.central.sun.com/bugster.jnlp
     1190 Main http://webbugs.sfbay/IncidentManager/incident.jnlp
</pre></div>
<!-- class="section" --></div>
</div>
<a id="JSTGD212"></a>
<div class="props_rev_3"><a id="GUID-36CBAF37-0B61-4455-9183-1268E6D497DD"></a>
<h2 id="JSTGD-GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" class="sect2">The jstack Utility</h2>
<div>
<p>Use the <code class="codeph">jcmd</code> utility, instead of <code class="codeph">jcmd</code> utility to diagnose problems with JVM and Java applications.</p>
<p>Java Mission Control, Java Flight Recorder, and <code class="codeph">jcmd</code> utility can be used to diagnose problems with JVM and Java applications. It is suggested to use the latest utility, <code class="codeph">jcmd</code>, instead of the previous <code class="codeph">jstack</code> utility for enhanced diagnostics and reduced performance overhead.</p>
<p>The following sections describe troubleshooting techniques with the <code class="codeph">jstack</code> utility.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-1240C470-CA56-4045-8098-E6E2FA259F6A" title="The jstack command-line utility attaches to the specified process or core file, and prints the stack traces of all threads that are attached to the virtual machine, including Java threads and VM internal threads, and optionally native stack frames. The utility also performs deadlock detection.">Troubleshoot with the jstack Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-E789DE61-D453-48D0-9EBE-F81E4261379A" title="Use the jstack command to obtain stack traces from a core dump.">Stack Trace from a Core Dump</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-716DD9D6-308B-41BE-878F-01863ABCBA5E" title="The jstack utility can also be used to print a mixed stack; that is, it can print native stack frames in addition to the Java stack. Native frames are the C/C++ frames associated with VM code and JNI/native code.">Mixed Stack</a></p>
</li>
</ul>
</div>
<a id="JSTGD213"></a>
<div class="props_rev_3"><a id="GUID-1240C470-CA56-4045-8098-E6E2FA259F6A"></a>
<h3 id="JSTGD-GUID-1240C470-CA56-4045-8098-E6E2FA259F6A" class="sect3">Troubleshoot with the jstack Utility</h3>
<div>
<p>The <code class="codeph">jstack</code> command-line utility attaches to the specified process or core file, and prints the stack traces of all threads that are attached to the virtual machine, including Java threads and VM internal threads, and optionally native stack frames. The utility also performs deadlock detection.</p>
<div class="section">
<p>The utility can also use the <code class="codeph">jsadebugd</code> daemon to query a process or core file on a remote machine. The output takes longer to print in this case.</p>
<p>A stack trace of all threads can be useful in diagnosing a number of issues, such as deadlocks or hangs.</p>
<p>The <code class="codeph">-l</code> option instructs the utility to look for ownable synchronizers in the heap and print information about <code class="codeph">java.util.concurrent.locks</code>. Without this option, the thread dump includes information only on monitors.</p>
<p>The output from the <code class="codeph">jstack <span class="variable">pid</span></code> option is the same as that obtained by pressing Ctrl+\ at the application console (standard input) or by sending the process a quit signal. See <a href="diagnostic-tools.htm#GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" title="The result of pressing the Control key and the backslash (\) key at the application console on operating systems such as Oracle Solaris or Linux, or Windows.">Control+Break Handler</a> for an example of the output.</p>
<p>Thread dumps can also be obtained programmatically using the <code class="codeph">Thread.getAllStackTraces</code> method, or in the debugger using the debugger option to print all thread stacks (the <code class="codeph">where</code> command in the case of the <code class="codeph">jdb</code> sample debugger).</p>
</div>
<!-- class="section" --></div>
</div>
<a id="JSTGD216"></a>
<div class="props_rev_3"><a id="GUID-E789DE61-D453-48D0-9EBE-F81E4261379A"></a>
<h3 id="JSTGD-GUID-E789DE61-D453-48D0-9EBE-F81E4261379A" class="sect3">Stack Trace from a Core Dump</h3>
<div>
<p>Use the <code class="codeph">jstack</code> command to obtain stack traces from a core dump.</p>
<div class="section">
<p>To get stack traces from a core dump, execute the <code class="codeph">jstack</code> command on a core file, as shown in the following example.</p>
<pre dir="ltr">
$ jstack <span class="variable">$JAVA_HOME</span>/bin/java core
</pre></div>
<!-- class="section" --></div>
</div>
<a id="JSTGD218"></a>
<div class="props_rev_3"><a id="GUID-716DD9D6-308B-41BE-878F-01863ABCBA5E"></a>
<h3 id="JSTGD-GUID-716DD9D6-308B-41BE-878F-01863ABCBA5E" class="sect3">Mixed Stack</h3>
<div>
<p>The <code class="codeph">jstack</code> utility can also be used to print a mixed stack; that is, it can print native stack frames in addition to the Java stack. Native frames are the C/C++ frames associated with VM code and JNI/native code.</p>
<div class="section">
<p>To print a mixed stack, use the <code class="codeph">-m</code> option, as shown in the following example.</p>
<pre dir="ltr">
$ <span class="bold">jstack -m 21177</span>
Attaching to process ID 21177, please wait...
Debugger attached successfully.
Client compiler detected.
JVM version is 1.6.0-rc-b100
Deadlock Detection:

Found one Java-level deadlock:
=============================

"Thread1":
  waiting to lock Monitor@0x0005c750 (Object@0xd4405938, a java/lang/String),
  which is held by "Thread2"
"Thread2":
  waiting to lock Monitor@0x0005c6e8 (Object@0xd4405900, a java/lang/String),
  which is held by "Thread1"

Found a total of 1 deadlock.

----------------- t@1 -----------------
0xff2c0fbc    __lwp_wait + 0x4
0xff2bc9bc    _thrp_join + 0x34
0xff2bcb28    thr_join + 0x10
0x00018a04    ContinueInNewThread + 0x30
0x00012480    main + 0xeb0
0x000111a0    _start + 0x108
----------------- t@2 -----------------
0xff2c1070    ___lwp_cond_wait + 0x4
0xfec03638    bool Monitor::wait(bool,long) + 0x420
0xfec9e2c8    bool Threads::destroy_vm() + 0xa4
0xfe93ad5c    jni_DestroyJavaVM + 0x1bc
0x00013ac0    JavaMain + 0x1600
0xff2bfd9c    _lwp_start
----------------- t@3 -----------------
0xff2c1070    ___lwp_cond_wait + 0x4
0xff2ac104    _lwp_cond_timedwait + 0x1c
0xfec034f4    bool Monitor::wait(bool,long) + 0x2dc
0xfece60bc    void VMThread::loop() + 0x1b8
0xfe8b66a4    void VMThread::run() + 0x98
0xfec139f4    java_start + 0x118
0xff2bfd9c    _lwp_start
----------------- t@4 -----------------
0xff2c1070    ___lwp_cond_wait + 0x4
0xfec195e8    void os::PlatformEvent::park() + 0xf0
0xfec88464    void ObjectMonitor::wait(long long,bool,Thread*) + 0x548
0xfe8cb974    void ObjectSynchronizer::wait(Handle,long long,Thread*) + 0x148
0xfe8cb508    JVM_MonitorWait + 0x29c
0xfc40e548    * java.lang.Object.wait(long) bci:0 (Interpreted frame)
0xfc40e4f4    * java.lang.Object.wait(long) bci:0 (Interpreted frame)
0xfc405a10    * java.lang.Object.wait() bci:2 line:485 (Interpreted frame)
... more lines removed here to reduce output...
----------------- t@12 -----------------
0xff2bfe3c    __lwp_park + 0x10
0xfe9925e4    AttachOperation*AttachListener::dequeue() + 0x148
0xfe99115c    void attach_listener_thread_entry(JavaThread*,Thread*) + 0x1fc
0xfec99ad8    void JavaThread::thread_main_inner() + 0x48
0xfec139f4    java_start + 0x118
0xff2bfd9c    _lwp_start
----------------- t@13 -----------------
0xff2c1500    _door_return + 0xc
----------------- t@14 -----------------
0xff2c1500    _door_return + 0xc
</pre>
<p>Frames that are prefixed with an asterisk (*) are Java frames, whereas frames that are not prefixed with an asterisk are native C/C++ frames.</p>
<p>The output of the utility can be piped through <code class="codeph">c++filt</code> to demangle C++ mangled symbol names. Because the Java HotSpot VM is developed in the C++ language, the <code class="codeph">jstack</code> utility prints C++ mangled symbol names for the Java HotSpot internal functions.</p>
<p>The <code class="codeph">c++filt</code> utility is delivered with the native C++ compiler suite: <code class="codeph">SUNWspro</code> on the Oracle Solaris operating system and <code class="codeph">gnu</code> on Linux.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="JSTGD220"></a>
<div class="props_rev_3"><a id="GUID-370616DE-AB80-49EB-9802-C278AF75AAE8"></a>
<h2 id="JSTGD-GUID-370616DE-AB80-49EB-9802-C278AF75AAE8" class="sect2">The jstat Utility</h2>
<div>
<p>The <code class="codeph">jstat</code> utility uses the built-in instrumentation in the Java HotSpot VM to provide information about performance and resource consumption of running applications.</p>
<div class="section">
<p>The tool can be used when diagnosing performance issues, and in particular issues related to heap sizing and garbage collection. The <code class="codeph">jstat</code> utility does not require the VM to be started with any special options. The built-in instrumentation in the Java HotSpot VM is enabled by default. This utility is included in the JDK download for all operating system platforms supported by Oracle.</p>
<div class="infobox-note" id="GUID-370616DE-AB80-49EB-9802-C278AF75AAE8__GUID-3212741D-DBEE-4479-A36D-3B430AE7F89B">
<p class="notep1">Note:</p>
<p>The instrumentation is not accessible on a FAT32 file system.</p>
</div>
<p>See <a class="olink JSWOR734" target="_blank" href="../tools/jstat.htm#JSWOR734">jstat</a> in the <span><cite>Java Platform, Standard Edition Tools Reference</cite></span>.</p>
<p>The <code class="codeph">jstat</code> utility uses the virtual machine identifier (VMID) to identify the target process. The documentation describes the syntax of the VMID, but its only required component is the local virtual machine identifier (LVMID). The LVMID is typically (but not always) the operating system's PID for the target JVM process.</p>
<p>The <code class="codeph">jstat</code> utility provides data similar to the data provided by the <code class="codeph">vmstat</code> and <code class="codeph">iostat</code> on Oracle Solaris and Linux operating systems.</p>
<p>For a graphical representation of the data, you can use the <code class="codeph">visualgc</code> tool. See <a href="diagnostic-tools.htm#GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25" title="The visualgc tool provides a graphical view of the garbage collection (GC) system.">The visualgc Tool</a>.</p>
<p>The following example illustrates the use of the <code class="codeph">-gcutil</code> option, where the <code class="codeph">jstat</code> utility attaches to LVMID number 2834 and takes 7 samples at 250-millisecond intervals.</p>
<pre dir="ltr">
$ <span class="bold">jstat -gcutil 2834 250 7</span>
  S0     S1     E      O      M     YGC     YGCT    FGC    FGCT     GCT   
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
  0.00  99.74  13.49   7.86  95.82      3    0.124     0    0.000    0.124
</pre>
<p>The output of this example shows you that a young generation collection occurred between the third and fourth samples. The collection took 0.017 seconds and promoted objects from the eden space (E) to the old space (O), resulting in an increase of old space utilization from 46.56% to 54.60%.</p>
<p>The following example illustrates the use of the <code class="codeph">-gcnew</code> option where the <code class="codeph">jstat</code> utility attaches to LVMID number 2834, takes samples at 250-millisecond intervals, and displays the output. In addition, it uses the <code class="codeph">-h3</code> option to display the column headers after every 3 lines of data.</p>
<pre dir="ltr">
$ <span class="bold">jstat -gcnew -h3 2834 250</span>
S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
 192.0  192.0    0.0    0.0 15  15   96.0   1984.0    942.0    218    1.999
 192.0  192.0    0.0    0.0 15  15   96.0   1984.0   1024.8    218    1.999
 192.0  192.0    0.0    0.0 15  15   96.0   1984.0   1068.1    218    1.999
 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
 192.0  192.0    0.0    0.0 15  15   96.0   1984.0   1109.0    218    1.999
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0      0.0    219    2.019
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0     71.6    219    2.019
 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0     73.7    219    2.019
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0     78.0    219    2.019
 192.0  192.0    0.0  103.2  1  15   96.0   1984.0    116.1    219    2.019
</pre>
<p>In addition to showing the repeating header string, this example shows that between the fourth and fifth samples, a young generation collection occurred, whose duration was 0.02 seconds. The collection found enough live data that the survivor space 1 utilization (S1U) would have exceeded the desired survivor size (DSS). As a result, objects were promoted to the old generation (not visible in this output), and the tenuring threshold (TT) was lowered from 15 to 1.</p>
<p>The following example illustrates the use of the <code class="codeph">-gcoldcapacity</code> option, where the <code class="codeph">jstat</code> utility attaches to LVMID number 21891 and takes 3 samples at 250-millisecond intervals. The <code class="codeph">-t</code> option is used to generate a time stamp for each sample in the first column.</p>
<pre dir="ltr">
$ <span class="bold">jstat -gcoldcapacity -t 21891 250 3</span>
Timestamp    OGCMN     OGCMX       OGC        OC   YGC   FGC     FGCT     GCT
    150.1   1408.0   60544.0   11696.0   11696.0   194    80    2.874   3.799
    150.4   1408.0   60544.0   13820.0   13820.0   194    81    2.938   3.863
    150.7   1408.0   60544.0   13820.0   13820.0   194    81    2.938   3.863
</pre>
<p>The Timestamp column reports the elapsed time in seconds since the start of the target JVM. In addition, the <code class="codeph">-gcoldcapacity</code> output shows the old generation capacity (OGC) and the old space capacity (OC) increasing as the heap expands to meet the allocation or promotion demands. The OGC has grown from 11696 KB to 13820 KB after the 81<sup>st</sup> full generation capacity (FGC). The maximum capacity of the generation (and space) is 60544 KB (OGCMX), so it still has room to expand.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="JSTGD225"></a><a id="JSTGD224"></a>
<div class="props_rev_3"><a id="GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25"></a>
<h2 id="JSTGD-GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25" class="sect2">The visualgc Tool</h2>
<div>
<p>The <code class="codeph">visualgc</code> tool provides a graphical view of the garbage collection (GC) system.</p>
<p>The <code class="codeph">visualgc</code> tool is related to the <code class="codeph">jstat</code> tool. See <a href="diagnostic-tools.htm#GUID-370616DE-AB80-49EB-9802-C278AF75AAE8" title="The jstat utility uses the built-in instrumentation in the Java HotSpot VM to provide information about performance and resource consumption of running applications.">The jstat Utility</a>. The <code class="codeph">visualgc</code> tool provides a graphical view of the garbage collection (GC) system. As with <code class="codeph">jstat</code>, it uses the built-in instrumentation of the Java HotSpot VM.</p>
<p>The <code class="codeph">visualgc</code> tool is not included in the JDK release, but is available as a separate download from the <a href="http://www.oracle.com/technetwork/java/jvmstat-142257.html" target="_blank"><code class="codeph">jvmstat</code> technology</a> page.</p>
<p><a href="diagnostic-tools.htm#GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25__BABDGABF">Figure 2-16</a> shows how the GC and heap are visualized.</p>
<div class="figure" id="GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25__BABDGABF">
<p class="titleinfigure">Figure 2-16 Sample Output from <code class="codeph">visualgc</code></p>
<img width="373" height="517" src="img/visualgc.gif" alt="Description of Figure 2-16 follows" title="Description of Figure 2-16 follows" /><br />
<a href="img_text/visualgc.htm">Description of "Figure 2-16 Sample Output from visualgc"</a></div>
<!-- class="figure" --></div>
</div>
<a id="JSTGD226"></a>
<div class="props_rev_3"><a id="GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C"></a>
<h2 id="JSTGD-GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" class="sect2">Control+Break Handler</h2>
<div>
<p>The result of pressing the Control key and the backslash (\) key at the application console on operating systems such as Oracle Solaris or Linux, or Windows.</p>
<p>On Oracle Solaris or Linux operating systems, the combination of pressing the Control key and the backslash (\) key at the application console (standard input) causes the Java HotSpot VM to print a thread dump to the application's standard output. On Windows, the equivalent key sequence is the Control and Break keys. The general term for these key combinations is the Control+Break handler.</p>
<p>On Oracle Solaris and Linux operating systems, a thread dump is printed if the Java process receives a quit signal. Therefore, the <code class="codeph">kill -QUIT <span class="variable">pid</span></code> command causes the process with the ID <code class="codeph"><span class="variable">pid</span></code> to print a thread dump to standard output.</p>
<p>The following sections describe the data traced by the Control+Break handler:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-489BB790-A7C7-4CF0-9A6B-63FA12230238" title="The thread dump consists of the thread stack, including the thread state, for all Java threads in the virtual machine.">Thread Dump</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-1B4B0983-C25D-40FD-9D59-BF5E8C720F57" title="The Control+Break handler can be used to detect deadlocks in threads.">Detect Deadlocks</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-7C917B08-D0B7-4E9F-AA1F-603796D4CF51" title="The Control+Break handler can be used to print a heap summary.">Heap Summary</a></p>
</li>
</ul>
</div>
<a id="JSTGD227"></a>
<div class="props_rev_3"><a id="GUID-489BB790-A7C7-4CF0-9A6B-63FA12230238"></a>
<h3 id="JSTGD-GUID-489BB790-A7C7-4CF0-9A6B-63FA12230238" class="sect3">Thread Dump</h3>
<div>
<p>The thread dump consists of the thread stack, including the thread state, for all Java threads in the virtual machine.</p>
<p>The thread dump does not terminate the application: it continues after the thread information is printed.</p>
<p>The following example illustrates a thread dump.</p>
<pre dir="ltr">
Full thread dump Java HotSpot(TM) Client VM (1.6.0-rc-b100 mixed mode):

"DestroyJavaVM" prio=10 tid=0x00030400 nid=0x2 waiting on condition [0x00000000..0xfe77fbf0]
   java.lang.Thread.State: RUNNABLE

"Thread2" prio=10 tid=0x000d7c00 nid=0xb waiting for monitor entry [0xf36ff000..0xf36ff8c0]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at Deadlock$DeadlockMakerThread.run(Deadlock.java:32)
        - waiting to lock &lt;0xf819a938&gt; (a java.lang.String)
        - locked &lt;0xf819a970&gt; (a java.lang.String)

"Thread1" prio=10 tid=0x000d6c00 nid=0xa waiting for monitor entry [0xf37ff000..0xf37ffbc0]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at Deadlock$DeadlockMakerThread.run(Deadlock.java:32)
        - waiting to lock &lt;0xf819a970&gt; (a java.lang.String)
        - locked &lt;0xf819a938&gt; (a java.lang.String)

"Low Memory Detector" daemon prio=10 tid=0x000c7800 nid=0x8 runnable [0x00000000..0x00000000]
   java.lang.Thread.State: RUNNABLE

"CompilerThread0" daemon prio=10 tid=0x000c5400 nid=0x7 waiting on condition [0x00000000..0x00000000]
   java.lang.Thread.State: RUNNABLE

"Signal Dispatcher" daemon prio=10 tid=0x000c4400 nid=0x6 waiting on condition [0x00000000..0x00000000]
   java.lang.Thread.State: RUNNABLE

"Finalizer" daemon prio=10 tid=0x000b2800 nid=0x5 in Object.wait() [0xf3f7f000..0xf3f7f9c0]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0xf4000b40&gt; (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:116)
        - locked &lt;0xf4000b40&gt; (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:132)
        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)

"Reference Handler" daemon prio=10 tid=0x000ae000 nid=0x4 in Object.wait() [0xfe57f000..0xfe57f940]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0xf4000a40&gt; (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Object.java:485)
        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)
        - locked &lt;0xf4000a40&gt; (a java.lang.ref.Reference$Lock)

"VM Thread" prio=10 tid=0x000ab000 nid=0x3 runnable 

"VM Periodic Task Thread" prio=10 tid=0x000c8c00 nid=0x9 waiting on condition 
</pre>
<p>The output consists of a number of thread entries separated by an empty line. The Java Threads (threads that are capable of executing Java language code) are printed first, and these are followed by information about VM internal threads. Each thread entry consists of a header line followed by the thread stack trace.</p>
<p>The header line contains the following information about the thread:</p>
<ul style="list-style-type: disc;">
<li>
<p>Thread name.</p>
</li>
<li>
<p>Indication if the thread is a daemon thread.</p>
</li>
<li>
<p>Thread priority (prio).</p>
</li>
<li>
<p>Thread ID (tid), which is the address of a thread structure in memory.</p>
</li>
<li>
<p>ID of the native thread (nid).</p>
</li>
<li>
<p>Thread state, which indicates what the thread was doing at the time of the thread dump. See <a href="diagnostic-tools.htm#GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA__BABJFBFI" title="This table lists the possible thread states which indicate what the thread was doing at the time of the thread dump.">Table 2-6</a> for more details.</p>
</li>
<li>
<p>Address range, which gives an estimate of the valid stack region for the thread.</p>
</li>
</ul>
</div>
</div>
<a id="JSTGD229"></a>
<div class="props_rev_3"><a id="GUID-1B4B0983-C25D-40FD-9D59-BF5E8C720F57"></a>
<h3 id="JSTGD-GUID-1B4B0983-C25D-40FD-9D59-BF5E8C720F57" class="sect3">Detect Deadlocks</h3>
<div>
<p>The Control+Break handler can be used to detect deadlocks in threads.</p>
<p>In addition to the thread stacks, the Control+Break handler executes a deadlock detection algorithm. If any deadlocks are detected, then the Control+Break handler, as shown in the following example, prints additional information after the thread dump about each deadlocked thread.</p>
<pre dir="ltr">
Found one Java-level deadlock:
=============================
"Thread2":
  waiting to lock monitor 0x000af330 (object 0xf819a938, a java.lang.String),
  which is held by "Thread1"
"Thread1":
  waiting to lock monitor 0x000af398 (object 0xf819a970, a java.lang.String),
  which is held by "Thread2"

Java stack information for the threads listed above:
===================================================
"Thread2":
        at Deadlock$DeadlockMakerThread.run(Deadlock.java:32)
        - waiting to lock &lt;0xf819a938&gt; (a java.lang.String)
        - locked &lt;0xf819a970&gt; (a java.lang.String)
"Thread1":
        at Deadlock$DeadlockMakerThread.run(Deadlock.java:32)
        - waiting to lock &lt;0xf819a970&gt; (a java.lang.String)
        - locked &lt;0xf819a938&gt; (a java.lang.String)

Found 1 deadlock.
</pre>
<p>If the JVM flag <code class="codeph">-XX:+PrintConcurrentLocks</code> is set, then the Control+Break handler will also print the list of concurrent locks owned by each thread.</p>
</div>
</div>
<a id="JSTGD231"></a>
<div class="props_rev_3"><a id="GUID-7C917B08-D0B7-4E9F-AA1F-603796D4CF51"></a>
<h3 id="JSTGD-GUID-7C917B08-D0B7-4E9F-AA1F-603796D4CF51" class="sect3">Heap Summary</h3>
<div>
<p>The Control+Break handler can be used to print a heap summary.</p>
<p>The following example shows the different generations (areas of the heap), with the size, the amount used, and the address range. The address range is especially useful if you are also examining the process with tools such as <code class="codeph">pmap</code>.</p>
<pre dir="ltr">
Heap
 def new generation   total 1152K, used 435K [0x22960000, 0x22a90000, 0x22e40000
)
  eden space 1088K,  40% used [0x22960000, 0x229ccd40, 0x22a70000)
  from space 64K,   0% used [0x22a70000, 0x22a70000, 0x22a80000)
  to   space 64K,   0% used [0x22a80000, 0x22a80000, 0x22a90000)
 tenured generation   total 13728K, used 6971K [0x22e40000, 0x23ba8000, 0x269600
00)
   the space 13728K,  50% used [0x22e40000, 0x2350ecb0, 0x2350ee00, 0x23ba8000)
 compacting perm gen  total 12288K, used 1417K [0x26960000, 0x27560000, 0x2a9600
00)
   the space 12288K,  11% used [0x26960000, 0x26ac24f8, 0x26ac2600, 0x27560000)
    ro space 8192K,  62% used [0x2a960000, 0x2ae5ba98, 0x2ae5bc00, 0x2b160000)
    rw space 12288K,  52% used [0x2b160000, 0x2b79e410, 0x2b79e600, 0x2bd60000)
</pre>
<p>If the JVM flag <code>-XX:+PrintClassHistogram</code> is set, then the Control+Break handler will produce a heap histogram.</p>
</div>
</div>
</div>
<a id="JSTGD233"></a>
<div class="props_rev_3"><a id="GUID-08957176-5459-4CEA-A141-D325D1204D54"></a>
<h2 id="JSTGD-GUID-08957176-5459-4CEA-A141-D325D1204D54" class="sect2">Native Operating System Tools</h2>
<div>
<p>List of native tools available on Windows, Linux, and Oracle Solaris operating systems that are useful for troubleshooting or monitoring purposes.</p>
<p>A brief description is provided for each tool. For further details, see the operating system documentation (or man pages for the Oracle Solaris and Linux operating systems).</p>
<p>The format of log files and output from command-line utilities depends on the release. For example, if you develop a script that relies on the format of the fatal error log, then the same script may not work if the format of the log file changes in a future release.</p>
<p>You can also search for Windows-specific debug support on the <a href="http://msdn.microsoft.com" target="_blank">MSDN developer network</a>.</p>
<p>The following sections describe troubleshooting techniques and improvements to a few native operating system tools.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB" title="List of native Windows tools that can be used for troubleshooting problems.">Troubleshooting Tools Based on the Operating System</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-6A234C2A-5BFF-4781-8A68-BE826D9CAF16" title="The Oracle Solaris 10 operating system includes the DTrace tool, which allows dynamic tracing of the operating system kernel and user-level programs.">DTrace Tool</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-7F50249F-0A96-492D-B648-3EBD5F1F2C0B" title="The Java HotSpot VM contains two built-in probe providers hotspot and hotspot_jni.">Probe Providers in Java HotSpot VM</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-792C5321-65E3-40CB-8F07-DE63F2142363" title="Improvements to the pmap utility in Oracle Solaris 10 operating system.">Improvements to the pmap Utility</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-6D797E4D-7DF1-4623-8AC8-B573F09FAE8A" title="Improvements to the pstack utility in Oracle Solaris 10 operating system.">Improvements to the pstack Utility</a></p>
</li>
</ul>
</div>
<a id="JSTGD234"></a>
<div class="props_rev_3"><a id="GUID-6A234C2A-5BFF-4781-8A68-BE826D9CAF16"></a>
<h3 id="JSTGD-GUID-6A234C2A-5BFF-4781-8A68-BE826D9CAF16" class="sect3">DTrace Tool</h3>
<div>
<p>The Oracle Solaris 10 operating system includes the DTrace tool, which allows dynamic tracing of the operating system kernel and user-level programs.</p>
<p>This tool supports scripting at system-call entry and exit, at user-mode function entry and exit, and at many other probe points. The scripts are written in the <span class="bold">D programming language</span>, which is a C-like language with safe pointer semantics. These scripts can help you to troubleshoot problems or solve performance issues.</p>
<p>The <code class="codeph">dtrace</code> command is a generic front end to the DTrace tool. This command provides a simple interface to invoke the D language, to retrieve buffered trace data, and to access a set of basic routines to format and print traced data.</p>
<p>You can write your own customized DTrace scripts, using the D language, or download and use one or more of the many scripts that are already available on various sites.</p>
<p>The probes are delivered and instrumented by kernel modules called providers. The types of tracing offered by the probe providers include user instruction tracing, function boundary tracing, kernel lock instrumentation, profile interrupt, system call tracing, and many more. If you write your own scripts, you use the D language to enable the probes; this language also allows conditional tracing and output formatting.</p>
<p>You can use the <code class="codeph">dtrace -l</code> command to explore the set of providers and probes that are available on your Oracle Solaris operating system.</p>
<p>The DTraceToolkit is a collection of useful documented scripts developed by the Open Oracle Solaris DTrace community. See <a href="http://www.brendangregg.com/dtracetoolkit.html" target="_blank">DTraceToolkit</a>.</p>
<p>See <a href="http://docs.oracle.com/cd/E19253-01/817-6223/chp-intro/" target="_blank"><span class="italic">Solaris Dynamic Tracing Guide</span></a>.</p>
</div>
</div>
<a id="JSTGD235"></a>
<div class="props_rev_3"><a id="GUID-7F50249F-0A96-492D-B648-3EBD5F1F2C0B"></a>
<h3 id="JSTGD-GUID-7F50249F-0A96-492D-B648-3EBD5F1F2C0B" class="sect3">Probe Providers in Java HotSpot VM</h3>
<div>
<p>The Java HotSpot VM contains two built-in probe providers <code class="codeph">hotspot</code> and <code class="codeph">hotspot_jni</code>.</p>
<p>These providers deliver probes that can be used to monitor the internal state and activities of the VM, as well as the Java application that is running.</p>
<p>The JVM probe providers can be categorized as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>VM lifecycle: VM initialization begin and end, and VM shutdown</p>
</li>
<li>
<p>Thread lifecycle: thread start and stop, thread name, thread ID, and so on</p>
</li>
<li>
<p>Class-loading: Java class loading and unloading</p>
</li>
<li>
<p>Garbage collection: Start and stop of garbage collection, systemwide or by memory pool</p>
</li>
<li>
<p>Method compilation: Method compilation begin and end, and method loading and unloading</p>
</li>
<li>
<p>Monitor probes: Wait events, notification events, contended monitor entry and exit</p>
</li>
<li>
<p>Application tracking: Method entry and return, allocation of a Java object</p>
</li>
</ul>
<p>In order to call from native code to Java code, the native code must make a call through the JNI interface. The <code class="codeph">hotspot_jni</code> provider manages DTrace probes at the entry point and return point for each of the methods that the JNI interface provides for invoking Java code and examining the state of the VM.</p>
<p>At probe points, you can print the stack trace of the current thread using the <span class="apiname">ustack</span> built-in function. This function prints Java method names in addition to C/C++ native function names. The following example is a simple D script that prints a full stack trace whenever a thread calls the <span class="apiname">read</span> system call.</p>
<pre dir="ltr">
#!/usr/sbin/dtrace -s
syscall::read:entry 
/pid == $1 &amp;&amp; tid == 1/ {    
   ustack(50, 0x2000);
}
</pre>
<p>The script in the previous example is stored in a file named <code class="codeph">read.d</code> and is run by specifying the PID of the Java process that is traced as shown in the following example.</p>
<pre dir="ltr">
read.d <span class="italic">pid</span>
</pre>
<p>If your Java application generated a lot of I/O or had some unexpected latency, then the DTrace tool and its <span class="apiname">ustack()</span> action can help you to diagnose the problem.</p>
</div>
</div>
<a id="JSTGD238"></a>
<div class="props_rev_3"><a id="GUID-792C5321-65E3-40CB-8F07-DE63F2142363"></a>
<h3 id="JSTGD-GUID-792C5321-65E3-40CB-8F07-DE63F2142363" class="sect3">Improvements to the pmap Utility</h3>
<div>
<p>Improvements to the <code class="codeph">pmap</code> utility in Oracle Solaris 10 operating system.</p>
<p>The <code class="codeph">pmap</code> utility was improved in Oracle Solaris 10 operating system to print stack segments with the text <code class="codeph">[stack]</code>. This text helps you to locate the stack easily.</p>
<p>The following example shows the stack trace with improved <code class="codeph">pmap</code> utility.</p>
<pre dir="ltr">
19846:    /net/myserver/export1/user/j2sdk6/bin/java -Djava.endorsed.d
00010000      72K r-x--  /export/disk09/jdk/6/rc/b63/binaries/solsparc/bin/java
00030000      16K rwx--  /export/disk09/jdk/6/rc/b63/binaries/solsparc/bin/java
00034000   32544K rwx--    [ heap ]
D1378000      32K rwx-R    [ stack tid=44 ]
D1478000      32K rwx-R    [ stack tid=43 ]
D1578000      32K rwx-R    [ stack tid=42 ]
D1678000      32K rwx-R    [ stack tid=41 ]
D1778000      32K rwx-R    [ stack tid=40 ]
D1878000      32K rwx-R    [ stack tid=39 ]
D1974000      48K rwx-R    [ stack tid=38 ]
D1A78000      32K rwx-R    [ stack tid=37 ]
D1B78000      32K rwx-R    [ stack tid=36 ]
[.. more lines removed here to reduce output ..]
FF370000       8K r-x--  /usr/lib/libsched.so.1
FF380000       8K r-x--  /platform/sun4u-us3/lib/libc_psr.so.1
FF390000      16K r-x--  /lib/libthread.so.1
FF3A4000       8K rwx--  /lib/libthread.so.1
FF3B0000       8K r-x--  /lib/libdl.so.1
FF3C0000     168K r-x--  /lib/ld.so.1
FF3F8000       8K rwx--  /lib/ld.so.1
FF3FA000       8K rwx--  /lib/ld.so.1
FFB80000      24K -----    [ anon ]
FFBF0000      64K rwx--    [ stack ]
 total    167224K
</pre></div>
</div>
<a id="JSTGD240"></a>
<div class="props_rev_3"><a id="GUID-6D797E4D-7DF1-4623-8AC8-B573F09FAE8A"></a>
<h3 id="JSTGD-GUID-6D797E4D-7DF1-4623-8AC8-B573F09FAE8A" class="sect3">Improvements to the pstack Utility</h3>
<div>
<p>Improvements to the <code class="codeph">pstack</code> utility in Oracle Solaris 10 operating system.</p>
<p>Before Oracle Solaris 10 operating system, the <code class="codeph">pstack</code> utility did not support Java. It printed hexadecimal addresses for both interpreted and compiled Java methods.</p>
<p>Starting with Oracle Solaris 10 operating system, the <code class="codeph">pstack</code> command-line tool prints mixed-mode stack traces (Java and C/C++ frames) from a core file or a live process. The utility prints Java method names for interpreted, compiled, and inlined Java methods.</p>
</div>
</div>
</div>
<a id="JSTGD241"></a>
<div class="props_rev_3"><a id="GUID-55FDAAC0-8FA8-4F12-AE28-1E768FB49901"></a>
<h2 id="JSTGD-GUID-55FDAAC0-8FA8-4F12-AE28-1E768FB49901" class="sect2">Custom Diagnostic Tools</h2>
<div>
<p>The JDK has extensive APIs to develop custom tools to observe, monitor, profile, debug, and diagnose issues in applications that are deployed in the JRE.</p>
<p>The development of new tools is beyond the scope of this document. Instead, this section provides a brief overview of the APIs available.</p>
<p>All the packages mentioned in this section are described in the <a href="https://docs.oracle.com/javase/10/docs/api/" target="_blank">Java SE API specification</a>.</p>
<p>See the example and demonstration code that is included in the JDK download.</p>
<p>The following sections describe packages, interface classes, and the Java debugger that can be used as custom diagnostic tools for troubleshooting.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="diagnostic-tools.htm#GUID-73A107A9-5F24-4168-B0B7-159FDC98A3F6" title="The java.lang.management package provides the management interface for the monitoring and management of the JVM and the operating system.">The java.lang.management Package</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-40D35B58-5D51-45B2-B56F-D3E48E4BFF16" title="The java.lang.instrument package provides services that allow the Java programming language agents to instrument programs running on the JVM.">The java.lang.instrument Package</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-86702778-D112-429D-8B2C-148384FCC4E0" title="The java.lang.Thread class has a static method called getAllStackTraces, which returns a map of stack traces for all live threads.">The java.lang.Thread Class</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-74556B6E-DB9C-4A7A-9532-1733657DB69A" title="The JVM Tool Interface (JVM TI) is a native (C/C++) programming interface that can be used by a wide range of development and monitoring tools.">JVM Tool Interface</a></p>
</li>
<li>
<p><a href="diagnostic-tools.htm#GUID-5C5F526F-9F19-43FA-BB0C-C7FC1BAB8D97" title="The Java Platform Debugger Architecture (JPDA) is the architecture designed for use by debuggers and debugger-like tools.">Java Platform Debugger Architecture</a></p>
</li>
</ul>
</div>
<a id="JSTGD242"></a>
<div class="props_rev_3"><a id="GUID-5C5F526F-9F19-43FA-BB0C-C7FC1BAB8D97"></a>
<h3 id="JSTGD-GUID-5C5F526F-9F19-43FA-BB0C-C7FC1BAB8D97" class="sect3">Java Platform Debugger Architecture</h3>
<div>
<p>The Java Platform Debugger Architecture (JPDA) is the architecture designed for use by debuggers and debugger-like tools.</p>
<p>The <a href="https://docs.oracle.com/javase/10/docs/specs/jpda/jpda.html" target="_blank">Java Platform Debugger Architecture</a> consists of two programming interfaces and a wire protocol:</p>
<ul style="list-style-type: disc;">
<li>
<p>The Java Virtual Machine Tool Interface (JVM TI) is the interface to the virtual machine. See <a href="diagnostic-tools.htm#GUID-74556B6E-DB9C-4A7A-9532-1733657DB69A" title="The JVM Tool Interface (JVM TI) is a native (C/C++) programming interface that can be used by a wide range of development and monitoring tools.">JVM Tool Interface</a>.</p>
</li>
<li>
<p>The Java Debug Interface (JDI) defines information and requests at the user code level. It is a pure Java programming language interface for debugging Java programming language applications. In JPDA, the JDI is a remote view in the debugger process of a virtual machine in the process being debugged. It is implemented by the front end, where as a debugger-like application (for example, IDE, debugger, tracer, or monitoring tool) is the client. See the module <a href="https://docs.oracle.com/javase/10/docs/api/jdk.jdi-summary.html" target="_blank"><span class="apiname">jdk.jdi</span></a>.</p>
</li>
<li>
<p>The <a href="https://docs.oracle.com/javase/10/docs/specs/jdwp/jdwp-spec.html" target="_blank">Java Debug Wire Protocol (JDWP)</a> defines the format of information and requests transferred between the process being debugged and the debugger front end, which implements the JDI.</p>
</li>
</ul>
<p>The <code class="codeph">jdb</code> utility is included in the JDK as an example command-line debugger. The <code class="codeph">jdb</code> utility uses the JDI to launch or connect to the target VM. See <a href="diagnostic-tools.htm#GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" title="The jdb utility is included in the JDK as an example command-line debugger. The jdb utility uses the Java Debug Interface (JDI) to launch or connect to the target JVM.">The jdb Utility</a>.</p>
<p>In addition to traditional debugger-type tools, the JDI can also be used to develop tools that help in postmortem diagnostics and scenarios where the tool needs to attach to a process in a noncooperative manner (for example, a hung process).</p>
</div>
</div>
</div>
<a id="JSTGD244"></a><a id="JSTGD243"></a>
<div class="props_rev_3"><a id="GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37"></a>
<h2 id="JSTGD-GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37" class="sect2">NMT Memory Categories</h2>
<div>
<p>List of native memory tracking memory categories used by NMT.</p>
<p><a href="diagnostic-tools.htm#GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37__BABHIFJC" title="This table describes native memory tracking memory categories">Table 2-1</a> describes native memory categories used by NMT. These categories may change with a release.</p>
<div class="tblformal" id="GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37__BABHIFJC">
<p class="titleintable">Table 2-1 Native Memory Tracking Memory Categories</p>
<table class="cellalignment350" title="Native Memory Tracking Memory Categories" summary="This table describes native memory tracking memory categories">
<thead>
<tr class="cellalignment341">
<th class="cellalignment351" id="d2844e4311">Category</th>
<th class="cellalignment352" id="d2844e4314">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4319" headers="d2844e4311">
<p>Java Heap</p>
</td>
<td class="cellalignment354" headers="d2844e4319 d2844e4314">
<p>The heap where your objects live</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4326" headers="d2844e4311">
<p>Class</p>
</td>
<td class="cellalignment354" headers="d2844e4326 d2844e4314">
<p>Class meta data</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4333" headers="d2844e4311">
<p>Code</p>
</td>
<td class="cellalignment354" headers="d2844e4333 d2844e4314">
<p>Generated code</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4340" headers="d2844e4311">
<p>GC</p>
</td>
<td class="cellalignment354" headers="d2844e4340 d2844e4314">
<p>Data use by the GC, such as card table</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4347" headers="d2844e4311">
<p>Compiler</p>
</td>
<td class="cellalignment354" headers="d2844e4347 d2844e4314">
<p>Memory tracking used by the compiler when generating code</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4354" headers="d2844e4311">
<p>Symbol</p>
</td>
<td class="cellalignment354" headers="d2844e4354 d2844e4314">
<p>Symbols</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4361" headers="d2844e4311">
<p>Memory Tracking</p>
</td>
<td class="cellalignment354" headers="d2844e4361 d2844e4314">
<p>Memory used by NMT.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4368" headers="d2844e4311">
<p>Pooled Free Chunks</p>
</td>
<td class="cellalignment354" headers="d2844e4368 d2844e4314">
<p>Memory used by chunks in the arena chunk pool</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4375" headers="d2844e4311">
<p>Shared space for classes</p>
</td>
<td class="cellalignment354" headers="d2844e4375 d2844e4314">
<p>Memory mapped to class data sharing archive</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4382" headers="d2844e4311">
<p>Thread</p>
</td>
<td class="cellalignment354" headers="d2844e4382 d2844e4314">
<p>Memory used by threads, including thread data structure, resource area, handle area, and so on.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4389" headers="d2844e4311">
<p>Thread stack</p>
</td>
<td class="cellalignment354" headers="d2844e4389 d2844e4314">
<p>Thread stack. It is marked as committed memory, but it might not be completely committed by the OS.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4397" headers="d2844e4311">
<p>Internal</p>
</td>
<td class="cellalignment354" headers="d2844e4397 d2844e4314">
<p>Memory that does not fit the previous categories, such as the memory used by the command line parser, JVMTI, properties, and so on.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4404" headers="d2844e4311">
<p>Unknown</p>
</td>
<td class="cellalignment354" headers="d2844e4404 d2844e4314">
<p>When the memory category cannot be determined.</p>
<p>Arena: When the arena is used as a stack or value object</p>
<p>Virtual Memory: When the type information has not yet arrived</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="JSTGD246"></a><a id="JSTGD245"></a>
<div class="sect2"><a id="GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3"></a>
<h2 id="JSTGD-GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3" class="sect2">Postmortem Diagnostic Tools</h2>
<div>
<p>List of tools and options available for post-mortem diagnostics of problems between the application and the Java HotSpot VM.</p>
<p><a href="diagnostic-tools.htm#GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3__BABIEHBC" title="This table contains a list of tools and options for post-mortem diagnostics of problems between the application and the Java HotSpot VM, with their descriptions.">Table 2-2</a> summarizes the options and tools that are designed for postmortem diagnostics. If an application crashes, then these options and tools can be used to get additional information, either at the time of the crash or later using information from the crash dump.</p>
<div class="tblformal" id="GUID-AC55CC9C-91F8-4D2D-82F5-94D35B7844B3__BABIEHBC">
<p class="titleintable">Table 2-2 Postmortem Diagnostics Tools</p>
<table class="cellalignment350" title="Postmortem Diagnostics Tools" summary="This table contains a list of tools and options for post-mortem diagnostics of problems between the application and the Java HotSpot VM, with their descriptions.">
<thead>
<tr class="cellalignment341">
<th class="cellalignment351" id="d2844e4450">Tool or Option</th>
<th class="cellalignment352" id="d2844e4453">Description and Usage</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4458" headers="d2844e4450">
<p>Fatal Error Log</p>
</td>
<td class="cellalignment354" headers="d2844e4458 d2844e4453">
<p>When an irrecoverable (fatal) error occurs, an error log is created. This file contains information obtained at the time of the fatal error. In many cases, it is the first item to examine when a crash occurs. See <a href="fatal-error-log.htm#GUID-2AE5EE08-A68F-4514-9618-A581C0EDFB1B" title="Describes the fatal error log, its location, and contents.">Fatal Error Log</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4471" headers="d2844e4450">
<p><code class="codeph">-XX:+HeapDumpOnOutOfMemoryError</code> option</p>
</td>
<td class="cellalignment354" headers="d2844e4471 d2844e4453">
<p>This command-line option specifies the generation of a heap dump when the VM detects a native out-of-memory error. See <a href="command-line-options1.htm#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6__CHDFDIJI">The -XX:HeapDumpOnOutOfMemoryError Option</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4483" headers="d2844e4450">
<p><code class="codeph">-XX:OnError</code> option</p>
</td>
<td class="cellalignment354" headers="d2844e4483 d2844e4453">
<p>This command-line option specifies a sequence of user-supplied scripts or commands to be executed when a fatal error occurs. For example, on Windows, this option can execute a command to force a crash dump. This option is very useful on systems where a postmortem debugger is not configured. See <a href="command-line-options1.htm#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6__CHDFEJBB">The -XX:OnError Option</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4495" headers="d2844e4450">
<p><code class="codeph">-XX:+ShowMessageBoxOnError</code> option</p>
</td>
<td class="cellalignment354" headers="d2844e4495 d2844e4453">
<p>This command-line option suspends a process when a fatal error occurs. Depending on the user response, the option can launch the native debugger (for example, <code class="codeph">dbx</code>, <code class="codeph">gdb</code>, <code class="codeph">msdev</code>) to attach to the VM. See <a href="command-line-options1.htm#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6__CHDJIEHH">The -XX:ShowMessageBoxOnError Option</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4516" headers="d2844e4450">
<p>Other <code class="codeph">-XX</code> options</p>
</td>
<td class="cellalignment354" headers="d2844e4516 d2844e4453">
<p>Several other <code class="codeph">-XX</code> command-line options can be useful in troubleshooting. See <a href="command-line-options1.htm#GUID-B5E16C7D-AE3C-40EB-A192-234C130766A6__CHDHGIDJ">Other -XX Options</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4532" headers="d2844e4450">
<p><code class="codeph">jdb</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e4532 d2844e4453">
<p>Debugger support includes an <code class="codeph">AttachingConnector</code>, which allows <code class="codeph">jdb</code> and other Java language debuggers to attach to a core file. This can be useful when trying to understand what each thread was doing at the time of a crash. See <a href="diagnostic-tools.htm#GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" title="The jdb utility is included in the JDK as an example command-line debugger. The jdb utility uses the Java Debug Interface (JDI) to launch or connect to the target JVM.">The jdb Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4559" headers="d2844e4450">
<p><code class="codeph">jinfo</code> utility</p>
<p>(postmortem use on Oracle Solaris and Linux operating systems only)</p>
</td>
<td class="cellalignment354" headers="d2844e4559 d2844e4453">
<p>This utility can get configuration information from a core file obtained from a crash or from a core file obtained using the <code class="codeph">gcore</code> utility. See <a href="diagnostic-tools.htm#GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE" title="The jinfo command-line utility gets configuration information from a running Java process or crash dump, and prints the system properties or the command-line flags that were used to start the JVM.">The jinfo Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4582" headers="d2844e4450">
<p><code class="codeph">jmap</code> utility</p>
<p>(postmortem use on Oracle Solaris and Linux operating systems only)</p>
</td>
<td class="cellalignment354" headers="d2844e4582 d2844e4453">
<p>This utility can get memory map information, including a heap histogram, from a core file obtained from a crash or from a core file obtained using the <code class="codeph">gcore</code> utility. See <a href="diagnostic-tools.htm#GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" title="The jmap command-line utility prints memory-related statistics for a running VM or core file.">The jmap Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4605" headers="d2844e4450">
<p><code class="codeph">jsadebugd</code> daemon</p>
<p>(Oracle Solaris and Linux operating systems only)</p>
</td>
<td class="cellalignment354" headers="d2844e4605 d2844e4453">
<p>The Serviceability Agent Debug Daemon (<code class="codeph">jsadebugd</code>) attaches to a Java process or to a core file and acts as a debug server. See <a href="diagnostic-tools.htm#GUID-D3BBA20A-4777-44D2-BF04-05568AD49977" title="The Java Serviceability Agent Debug Daemon (jsadebugd) attaches to a Java process or to a core file and acts as a debug server.">The jsadebugd Daemon</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4628" headers="d2844e4450">
<p><code class="codeph">jstack</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e4628 d2844e4453">
<p>This utility can get Java and native stack information from a Java process. On the Oracle Solaris and Linux operating systems, the utility can also get the information from a core file or a remote debug server. See <a href="diagnostic-tools.htm#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="Use the jcmd utility, instead of jcmd utility to diagnose problems with JVM and Java applications.">The jstack Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4649" headers="d2844e4450">
<p>Native tools</p>
</td>
<td class="cellalignment354" headers="d2844e4649 d2844e4453">
<p>Each operating system has native tools and utilities that can be used for postmortem diagnosis. See <a href="diagnostic-tools.htm#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="List of native tools available on Windows, Linux, and Oracle Solaris operating systems that are useful for troubleshooting or monitoring purposes.">Native Operating System Tools</a>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="JSTGD248"></a><a id="JSTGD247"></a>
<div class="sect2"><a id="GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B"></a>
<h2 id="JSTGD-GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B" class="sect2">Hung Processes Tools</h2>
<div>
<p>List of tools and options for diagnosing problems between the application and the Java HotSpot VM in a hung process.</p>
<p><a href="diagnostic-tools.htm#GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B__BABIFDCH" title="This table contains a list of tools and options for diagnosing problems between the application and the Java HotSpot VM in case of a hung process, with their descriptions.">Table 2-3</a> summarizes the options and tools that can help in scenarios involving a hung or deadlocked process. These tools do not require any special options to start the application.</p>
<p>Java Mission Control, Java Flight Recorder, and the <code class="codeph">jcmd</code> utility can be used to diagnose problems with JVM and Java applications. It is suggested to use the latest utility, <code class="codeph">jcmd</code>, instead of the previous <code class="codeph">jstack</code>, <code class="codeph">jinfo,</code> and <code class="codeph">jmap</code> utilities for enhanced diagnostics and reduced performance overhead.</p>
<div class="tblformal" id="GUID-C7CC8F8A-E763-4EE2-BC41-CA7E1086570B__BABIFDCH">
<p class="titleintable">Table 2-3 Hung ProcessTools</p>
<table class="cellalignment350" title="Hung ProcessTools" summary="This table contains a list of tools and options for diagnosing problems between the application and the Java HotSpot VM in case of a hung process, with their descriptions.">
<thead>
<tr class="cellalignment341">
<th class="cellalignment351" id="d2844e4713">Tool or Option</th>
<th class="cellalignment352" id="d2844e4716">Description and Usage</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4721" headers="d2844e4713">
<p>Ctrl+Break handler</p>
<p>(Control+\ or <code class="codeph">kill -QUIT <span class="variable">pid</span></code> on the Oracle Solaris and Linux operating systems, and Control+Break on Windows)</p>
</td>
<td class="cellalignment354" headers="d2844e4721 d2844e4716">
<p>This key combination performs a thread dump and deadlock detection. The Ctrl+Break handler can optionally print a list of concurrent locks and their owners, as well as a heap histogram. See <a href="diagnostic-tools.htm#GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" title="The result of pressing the Control key and the backslash (\) key at the application console on operating systems such as Oracle Solaris or Linux, or Windows.">Control+Break Handler</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4741" headers="d2844e4713">
<p><code class="codeph">jcmd</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e4741 d2844e4716">
<p>This utility is used to send diagnostic command requests to the JVM, where these requests are useful for controlling Java Flight Recordings (JFRs). The JFRs are used to troubleshoot and diagnose flight recording events. See <a href="diagnostic-tools.htm#GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" title="The jcmd utility is used to send diagnostic command requests to the JVM, where these requests are useful for controlling Java Flight Recordings, troubleshoot, and diagnose JVM and Java applications.">The jcmd Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4759" headers="d2844e4713">
<p><code class="codeph">jdb</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e4759 d2844e4716">
<p>Debugger support includes attaching connectors, which allow <code class="codeph">jdb</code> and other Java language debuggers to attach to a process. This can help show what each thread is doing at the time of a hang or deadlock. See <a href="diagnostic-tools.htm#GUID-DAD34EEE-090B-4C2C-AAE6-5FB1D800E7A7" title="The jdb utility is included in the JDK as an example command-line debugger. The jdb utility uses the Java Debug Interface (JDI) to launch or connect to the target JVM.">The jdb Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4783" headers="d2844e4713">
<p><code class="codeph">jinfo</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e4783 d2844e4716">
<p>This utility can get configuration information from a Java process. See <a href="diagnostic-tools.htm#GUID-8201B690-78C2-417A-8186-D6ECAAA07BEE" title="The jinfo command-line utility gets configuration information from a running Java process or crash dump, and prints the system properties or the command-line flags that were used to start the JVM.">The jinfo Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4801" headers="d2844e4713">
<p><code class="codeph">jmap</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e4801 d2844e4716">
<p>This utility can get memory map information, including a heap histogram, from a Java process. On the Oracle Solaris and Linux operating systems, the <code class="codeph">-F</code> option can be used if the process is hung. See <a href="diagnostic-tools.htm#GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" title="The jmap command-line utility prints memory-related statistics for a running VM or core file.">The jmap Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4822" headers="d2844e4713">
<p><code class="codeph">jsadebugd</code> daemon</p>
<p>(Oracle Solaris and Linux operating systems only)</p>
</td>
<td class="cellalignment354" headers="d2844e4822 d2844e4716">
<p>The Serviceability Agent Debug Daemon (<code class="codeph">jsadebugd</code>) attaches to a Java process or to a core file and acts as a debug server. See <a href="diagnostic-tools.htm#GUID-D3BBA20A-4777-44D2-BF04-05568AD49977" title="The Java Serviceability Agent Debug Daemon (jsadebugd) attaches to a Java process or to a core file and acts as a debug server.">The jsadebugd Daemon</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4845" headers="d2844e4713">
<p><code class="codeph">jstack</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e4845 d2844e4716">
<p>This utility can obtain Java and native stack information from a Java process. See <a href="diagnostic-tools.htm#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="Use the jcmd utility, instead of jcmd utility to diagnose problems with JVM and Java applications.">The jstack Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4866" headers="d2844e4713">
<p>Native tools</p>
</td>
<td class="cellalignment354" headers="d2844e4866 d2844e4716">
<p>Each operating system has native tools and utilities that can be useful in hang or deadlock situations. See <a href="diagnostic-tools.htm#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="List of native tools available on Windows, Linux, and Oracle Solaris operating systems that are useful for troubleshooting or monitoring purposes.">Native Operating System Tools</a>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="JSTGD250"></a><a id="JSTGD249"></a>
<div class="sect2"><a id="GUID-90B85B8D-DCFA-4094-9A85-218D467222B0"></a>
<h2 id="JSTGD-GUID-90B85B8D-DCFA-4094-9A85-218D467222B0" class="sect2">Monitoring Tools</h2>
<div>
<p>List of tools and options for monitoring running applications and detecting problems.</p>
<p>The tools listed in the <a href="diagnostic-tools.htm#GUID-90B85B8D-DCFA-4094-9A85-218D467222B0__BABFCEHE" title="This table contains a list of tools and options for monitoring running applications and detect problems that occur between the application and the Java HotSpot VM, with their descriptions.">Table 2-4</a> are designed for monitoring applications that are running.</p>
<p>Java Mission Control, Java Flight Recorder, and the <code class="codeph">jcmd</code> utility can be used to diagnose problems with JVM and Java applications. It is suggested to use the latest utility, <code class="codeph">jcmd</code>, instead of the previous <code class="codeph">jstack</code>, <code class="codeph">jinfo,</code> and <code class="codeph">jmap</code> utilities for enhanced diagnostics and reduced performance overhead.</p>
<div class="tblformalwide" id="GUID-90B85B8D-DCFA-4094-9A85-218D467222B0__BABFCEHE">
<p class="titleintable">Table 2-4 Monitoring Tools</p>
<table class="cellalignment355" title="Monitoring Tools" summary="This table contains a list of tools and options for monitoring running applications and detect problems that occur between the application and the Java HotSpot VM, with their descriptions.">
<thead>
<tr class="cellalignment341">
<th class="cellalignment351" id="d2844e4931">Tool or Option</th>
<th class="cellalignment352" id="d2844e4934">Description and Usage</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4939" headers="d2844e4931">
<p>Java Mission Control</p>
</td>
<td class="cellalignment354" headers="d2844e4939 d2844e4934">
<p>Java Mission Control (JMC) is a new JDK profiling and diagnostic tool platform for HotSpot JVM. It is a tool suite for basic monitoring, managing, and production time profiling and diagnostics with high performance. Java Mission Control minimizes the performance overhead that's usually an issue with profiling tools.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4946" headers="d2844e4931">
<p><code class="codeph">jcmd utility</code></p>
</td>
<td class="cellalignment354" headers="d2844e4946 d2844e4934">
<p>This utility is used to send diagnostic command requests to the JVM, where these requests are useful for controlling Java Flight Recordings. The JFRs are used to troubleshoot and diagnose JVM and Java applications with flight recording events. See <a href="diagnostic-tools.htm#GUID-42A18B29-B4AD-4831-B846-2CDBA55F2254" title="The jcmd utility is used to send diagnostic command requests to the JVM, where these requests are useful for controlling Java Flight Recordings, troubleshoot, and diagnose JVM and Java applications.">The jcmd Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4963" headers="d2844e4931">
<p>JConsole utility</p>
</td>
<td class="cellalignment354" headers="d2844e4963 d2844e4934">
<p>This utility is a monitoring tool that is based on Java Management Extensions (JMX). The tool uses the built-in JMX instrumentation in the Java Virtual Machine to provide information about the performance and resource consumption of running applications. See <a href="diagnostic-tools.htm#GUID-92074912-77E2-46B4-9A2F-A27F10331576" title="Another useful tool included in the JDK download is the JConsole monitoring tool. This tool is compliant with JMX. The tool uses the built-in JMX instrumentation in the JVM to provide information about the performance and resource consumption of running applications.">JConsole</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4979" headers="d2844e4931">
<p><code class="codeph">jmap</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e4979 d2844e4934">
<p>This utility can get memory map information, including a heap histogram, from a Java process, a core file, or a remote debug server. See <a href="diagnostic-tools.htm#GUID-2E915FE8-A8A6-47C5-BA1D-4CC85174E818" title="The jmap command-line utility prints memory-related statistics for a running VM or core file.">The jmap Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e4997" headers="d2844e4931">
<p><code class="codeph">jps</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e4997 d2844e4934">
<p>This utility lists the instrumented Java HotSpot VMs on the target system. The utility is very useful in environments where the VM is embedded, that is, it is started using the JNI Invocation API rather than the <code class="codeph">java</code> launcher. See <a href="diagnostic-tools.htm#GUID-FC269C18-470F-441E-9564-7EEA182F8125" title="The jps utility lists every instrumented Java HotSpot VM for the current user on the target system.">The jps Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5018" headers="d2844e4931">
<p><code class="codeph">jstack</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e5018 d2844e4934">
<p>This utility can get Java and native stack information from a Java process. On the Oracle Solaris and Linux operating systems, the utility can also get the information from a core file or a remote debug server. See <a href="diagnostic-tools.htm#GUID-36CBAF37-0B61-4455-9183-1268E6D497DD" title="Use the jcmd utility, instead of jcmd utility to diagnose problems with JVM and Java applications.">The jstack Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5039" headers="d2844e4931">
<p><code class="codeph">jstat</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e5039 d2844e4934">
<p>This utility uses the built-in instrumentation in Java to provide information about performance and resource consumption of running applications. The tool can be used when diagnosing performance issues, especially those related to heap sizing and garbage collection. See <a href="diagnostic-tools.htm#GUID-370616DE-AB80-49EB-9802-C278AF75AAE8" title="The jstat utility uses the built-in instrumentation in the Java HotSpot VM to provide information about performance and resource consumption of running applications.">The jstat Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5057" headers="d2844e4931">
<p><code class="codeph">jstatd</code> daemon</p>
</td>
<td class="cellalignment354" headers="d2844e5057 d2844e4934">
<p>This tool is a Remote Method Invocation (RMI) server application that monitors the creation and termination of instrumented Java Virtual Machines and provides an interface to allow remote monitoring tools to attach to VMs running on the local host. See <a href="diagnostic-tools.htm#GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67" title="The jstatd daemon is an RMI server application that monitors the creation and termination of each instrumented Java HotSpot, and provides an interface to allow remote monitoring tools to attach to JVMs running on the local host.">The jstatd Daemon</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5075" headers="d2844e4931">
<p><code class="codeph">visualgc</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e5075 d2844e4934">
<p>This utility provides a graphical view of the garbage collection system. As with <code class="codeph">jstat</code>, it uses the built-in instrumentation of Java HotSpot VM. See <a href="diagnostic-tools.htm#GUID-14D6EFB0-2B53-411E-AD7F-EBDB2176EE25" title="The visualgc tool provides a graphical view of the garbage collection (GC) system.">The visualgc Tool</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5096" headers="d2844e4931">
<p>Native tools</p>
</td>
<td class="cellalignment354" headers="d2844e5096 d2844e4934">
<p>Each operating system has native tools and utilities that can be useful for monitoring purposes. For example, the dynamic tracing (DTrace) capability introduced in Oracle Solaris 10 operating system performs advanced monitoring. See <a href="diagnostic-tools.htm#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="List of native tools available on Windows, Linux, and Oracle Solaris operating systems that are useful for troubleshooting or monitoring purposes.">Native Operating System Tools</a>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="JSTGD252"></a><a id="JSTGD251"></a>
<div class="sect2"><a id="GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC"></a>
<h2 id="JSTGD-GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC" class="sect2">Other Tools, Options, Variables, and Properties</h2>
<div>
<p>List of general troubleshooting tools, options, variables, and properties that can help to diagnose issues.</p>
<p>In addition to the tools that are designed for specific types of problems, the tools, options, variables, and properties listed in <a href="diagnostic-tools.htm#GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC__BABGFGEE" title="This table contains a list of general troubleshooting tools and options which are not designed for specific types of problems that occur between the application and the Java HotSpot VM, with their descriptions.">Table 2-5</a> can help in diagnosing other issues.</p>
<p>Java Mission Control, Java Flight Recorder, and the <code class="codeph">jcmd</code> utility can be used for diagnosing problems with JVM and Java applications. It is suggested to use the latest utility, <code class="codeph">jcmd</code>, instead of the previous <code class="codeph">jstack</code>, <code class="codeph">jinfo,</code> and <code class="codeph">jmap</code> utilities for enhanced diagnostics and reduced performance overhead.</p>
<div class="tblformal" id="GUID-0A40ECEE-AFDF-48CB-AF7C-A33DDE07A8DC__BABGFGEE">
<p class="titleintable">Table 2-5 General Troubleshooting Tools and Options</p>
<table class="cellalignment350" title="General Troubleshooting Tools and Options" summary="This table contains a list of general troubleshooting tools and options which are not designed for specific types of problems that occur between the application and the Java HotSpot VM, with their descriptions.">
<thead>
<tr class="cellalignment341">
<th class="cellalignment351" id="d2844e5162">Tool or Option</th>
<th class="cellalignment352" id="d2844e5165">Description and Usage</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5170" headers="d2844e5162">
<p>Java Mission Control</p>
</td>
<td class="cellalignment354" headers="d2844e5170 d2844e5165">
<p>Java Mission Control (JMC) is a new JDK profiling and diagnostic tool platform for HotSpot JVM. It is a tool suite for basic monitoring, managing, and production time profiling and diagnostics with high performance. Java Mission Control minimizes the performance overhead that's usually an issue with profiling tools. See <a href="https://docs.oracle.com/javacomponents/index.html" target="_blank">Java Mission Control</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5181" headers="d2844e5162">
<p><code class="codeph">jcmd</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e5181 d2844e5165">
<p>This utility is used to send diagnostic command requests to the JVM, where these requests are useful for controlling Java Flight Recordings (JFRs). The JFRs are used to troubleshoot and diagnose JVM and Java applications with flight recording events.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5190" headers="d2844e5162">
<p><code class="codeph">jinfo</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e5190 d2844e5165">
<p>This utility can dynamically set, unset, and change the values of certain JVM flags for a specified Java process. On Oracle Solaris and Linux operating systems, it can also print configuration information.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5199" headers="d2844e5162">
<p><code class="codeph">jrunscript</code> utility</p>
</td>
<td class="cellalignment354" headers="d2844e5199 d2844e5165">
<p>This utility is a command-line script shell, which supports both interactive and batch-mode script execution.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5208" headers="d2844e5162">
<p>Oracle Solaris Studio <code class="codeph">dbx</code> debugger</p>
</td>
<td class="cellalignment354" headers="d2844e5208 d2844e5165">
<p>This is an interactive, command-line debugging tool, which allows you to have complete control of the dynamic execution of a program, including stopping the program and inspecting its state. For details, see the latest <code class="codeph">dbx</code> documentation located at <a href="http://docs.oracle.com/cd/E24457_01/html/E21993/blabb.html#scrolltoc" target="_blank">Oracle Solaris Studio Program Debugging</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5225" headers="d2844e5162">
<p>Oracle Solaris Studio Performance Analyzer</p>
</td>
<td class="cellalignment354" headers="d2844e5225 d2844e5165">
<p>This tool can help you assess the performance of your code, identify potential performance problems, and locate the part of the code where the problems occur. The Performance Analyzer can be used from the command line or from a graphical user interface. For details, see the <a href="http://docs.oracle.com/cd/E18659_01/html/821-1379/afabb.html#scrolltoc" target="_blank">Oracle Solaris Studio Performance Analyzer</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5236" headers="d2844e5162">
<p>Sun's Dataspace Profiling: DProfile</p>
</td>
<td class="cellalignment354" headers="d2844e5236 d2844e5165">
<p>This tool provides insight into the flow of data within Sun computing systems, helping you identify bottlenecks in both software and hardware. DProfile is supported in the Sun Studio 11 compiler suite through the Performance Analyzer GUI. See <a href="http://www.oracle.com/technetwork/server-storage/solaris/dtrace-tutorial-142317.html" target="_blank">DTrace or Dynamic Tracing diagnostic tool</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5247" headers="d2844e5162">
<p><code class="codeph">-Xcheck:jni</code> option</p>
</td>
<td class="cellalignment354" headers="d2844e5247 d2844e5165">
<p>This option is useful in diagnosing problems with applications that use the Java Native Interface (JNI) or that employ third-party libraries (some JDBC drivers, for example). See <a href="command-line-options1.htm#GUID-DE9FAAAF-DCD4-4974-A86F-C6B8907CCE9A__CHDDEGBI">The -Xcheck:jni Option</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5259" headers="d2844e5162">
<p><code class="codeph">-verbose:class</code> option</p>
</td>
<td class="cellalignment354" headers="d2844e5259 d2844e5165">
<p>This option enables logging of class loading and unloading. See <a href="command-line-options1.htm#GUID-DE9FAAAF-DCD4-4974-A86F-C6B8907CCE9A__CHDJECGJ">The -verbose:class Option</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5271" headers="d2844e5162">
<p><code class="codeph">-verbose:gc</code> option</p>
</td>
<td class="cellalignment354" headers="d2844e5271 d2844e5165">
<p>This option enables logging of garbage collection information. See <a href="command-line-options1.htm#GUID-DE9FAAAF-DCD4-4974-A86F-C6B8907CCE9A__CHDJIIFF">The -verbose:gc Option</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5283" headers="d2844e5162">
<p><code>-verbose:jni</code> option</p>
</td>
<td class="cellalignment354" headers="d2844e5283 d2844e5165">
<p>This option enables logging of JNI. See <a href="command-line-options1.htm#GUID-DE9FAAAF-DCD4-4974-A86F-C6B8907CCE9A__CHDCHGEE">The -verbose:jni Option</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5296" headers="d2844e5162">
<p><code class="codeph">JAVA_TOOL_OPTIONS</code> environment variable</p>
</td>
<td class="cellalignment354" headers="d2844e5296 d2844e5165">
<p>This environment variable allows you to specify the initialization of tools, specifically the launching of native or Java programming language agents using the <code class="codeph">-agentlib</code> or <code class="codeph">-javaagent</code> options. See <a href="environment-variables-and-system-properties.htm#GUID-A91E7E21-2E91-48C4-89A4-836A7C0EE93B" title="This appendix describes environment variables and system properties that can be useful for troubleshooting problems with the Java HotSpot VM.">Environment Variables and System Properties</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5317" headers="d2844e5162">
<p><code class="codeph">java.security.debug</code> system property</p>
</td>
<td class="cellalignment354" headers="d2844e5317 d2844e5165">
<p>This system property controls whether the security checks in the JRE of the Java print trace messages during execution. See <a href="environment-variables-and-system-properties.htm#GUID-FE488B52-B0B6-48B6-B050-D58798F5242C" title="This system property controls whether the security system of the Java Runtime Environment (JRE) prints trace messages during execution.">The java.security.debug System Property</a>.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="JSTGD253"></a>
<div class="sect2"><a id="GUID-73A107A9-5F24-4168-B0B7-159FDC98A3F6"></a>
<h2 id="JSTGD-GUID-73A107A9-5F24-4168-B0B7-159FDC98A3F6" class="sect2">The java.lang.management Package</h2>
<div>
<p>The <code class="codeph">java.lang.management</code> package provides the management interface for the monitoring and management of the JVM and the operating system.</p>
<p>Specifically, it covers interfaces for the following systems:</p>
<ul style="list-style-type: disc;">
<li>
<p>Class loading</p>
</li>
<li>
<p>Compilation</p>
</li>
<li>
<p>Garbage collection</p>
</li>
<li>
<p>Memory manager</p>
</li>
<li>
<p>Runtime</p>
</li>
<li>
<p>Threads</p>
</li>
</ul>
<p>The JDK includes example code that demonstrates the usage of the <code class="codeph">java.lang.management</code> package. These examples can be found in the <code>$JAVA_HOME/demo/management</code> directory. Some of the example code is as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">MemoryMonitor</code> demonstrates the use of the <code class="codeph">java.lang.management</code> API to observe the memory usage of all memory pools consumed by the application.</p>
</li>
<li>
<p><code class="codeph">FullThreadDump</code> demonstrates the use of the <code class="codeph">java.lang.management</code> API to get a full thread dump and detect deadlocks programmatically.</p>
</li>
<li>
<p><code class="codeph">VerboseGC</code> demonstrates the use of the <code class="codeph">java.lang.management</code> API to print the garbage collection statistics and memory usage of an application.</p>
</li>
</ul>
<p>In addition to the <code class="codeph">java.lang.management</code> package, the JDK release includes platform extensions in the <code class="codeph">com.sun.management</code> package. The platform extensions include a management interface to get detailed statistics from garbage collectors that perform collections in cycles. These extensions also include a management interface to get additional memory statistics from the operating system.</p>
</div>
</div>
<a id="JSTGD254"></a>
<div class="sect2"><a id="GUID-40D35B58-5D51-45B2-B56F-D3E48E4BFF16"></a>
<h2 id="JSTGD-GUID-40D35B58-5D51-45B2-B56F-D3E48E4BFF16" class="sect2">The java.lang.instrument Package</h2>
<div>
<p>The <code class="codeph">java.lang.instrument</code> package provides services that allow the Java programming language agents to instrument programs running on the JVM.</p>
<p>Instrumentation is used by tools such as profilers, tools for tracing method calls, and many others. The package facilitates both load-time and dynamic instrumentation. It also includes methods to get information about the loaded classes and information about the amount of storage consumed by a given object.</p>
</div>
</div>
<a id="JSTGD255"></a>
<div class="sect2"><a id="GUID-86702778-D112-429D-8B2C-148384FCC4E0"></a>
<h2 id="JSTGD-GUID-86702778-D112-429D-8B2C-148384FCC4E0" class="sect2">The java.lang.Thread Class</h2>
<div>
<p>The <code class="codeph">java.lang.Thread</code> class has a static method called <span class="apiname">getAllStackTraces</span>, which returns a map of stack traces for all live threads.</p>
<p>The <code class="codeph">Thread</code> class also has a method called <span class="apiname">getState</span>, which returns the thread state; states are defined by the <code class="codeph">java.lang.Thread.State</code> enumeration. These methods can be useful when you add diagnostic or monitoring capabilities to an application.</p>
</div>
</div>
<a id="JSTGD256"></a>
<div class="sect2"><a id="GUID-74556B6E-DB9C-4A7A-9532-1733657DB69A"></a>
<h2 id="JSTGD-GUID-74556B6E-DB9C-4A7A-9532-1733657DB69A" class="sect2">JVM Tool Interface</h2>
<div>
<p>The JVM Tool Interface (JVM TI) is a native (C/C++) programming interface that can be used by a wide range of development and monitoring tools.</p>
<p>JVM TI provides an interface for the full breadth of tools that need access to the VM state, including but not limited to profiling, debugging, monitoring, thread analysis, and coverage analysis tools.</p>
<p>Some examples of agents that rely on JVM TI are the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Java Debug Wire Protocol (JDWP)</p>
</li>
<li>
<p>The <code class="codeph">java.lang.instrument</code> package</p>
</li>
</ul>
<p>The specification for JVM TI can be found in the <a href="https://docs.oracle.com/javase/10/docs/specs/jvmti.html" target="_blank">JVM Tool Interface</a> documentation.</p>
<p>The JDK includes example code that demonstrates the usage of JVM TI. These examples can be found in the <code class="codeph">$JAVA_HOME/demo/jvmti</code> directory. Some of the example code is as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">mtrace</code> is an agent library that tracks method call and return counts. It uses bytecode instrumentation to instrument all classes loaded into the virtual machine and prints a sorted list of the frequently used methods.</p>
</li>
<li>
<p><code class="codeph">heapTracker</code> is an agent library that tracks object allocation. It uses bytecode instrumentation to instrument constructor methods.</p>
</li>
<li>
<p><code class="codeph">heapViewer</code> is an agent library that prints heap statistics when the Control+Break handler is invoked. See <a href="diagnostic-tools.htm#GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" title="The result of pressing the Control key and the backslash (\) key at the application console on operating systems such as Oracle Solaris or Linux, or Windows.">Control+Break Handler</a>. For each loaded class it prints an instance count of that class, and the space used.</p>
</li>
</ul>
</div>
</div>
<a id="JSTGD257"></a>
<div class="sect2"><a id="GUID-93AEFF21-55CC-4F4A-8810-E9F554623CF7"></a>
<h2 id="JSTGD-GUID-93AEFF21-55CC-4F4A-8810-E9F554623CF7" class="sect2">The jrunscript Utility</h2>
<div>
<p>The <code class="codeph">jrunscript</code> utility is a command-line script shell.</p>
<p>It supports script execution in both interactive mode and in batch mode. By default, the shell uses JavaScript, but you can specify any other scripting language for which you supply the path to the script engine JAR file of <code class="codeph">.class</code> files.</p>
<p>Thanks to the communication between the Java language and the scripting language, the <code class="codeph">jrunscript</code> utility supports an exploratory programming style.</p>
</div>
</div>
<a id="JSTGD258"></a>
<div class="sect2"><a id="GUID-D3BBA20A-4777-44D2-BF04-05568AD49977"></a>
<h2 id="JSTGD-GUID-D3BBA20A-4777-44D2-BF04-05568AD49977" class="sect2">The jsadebugd Daemon</h2>
<div>
<p>The Java Serviceability Agent Debug Daemon (<code class="codeph">jsadebugd</code>) attaches to a Java process or to a core file and acts as a debug server.</p>
<p>This utility is currently available only on the Oracle Solaris and Linux operating systems. Remote clients such as <code class="codeph">jstack</code>, <code class="codeph">jmap</code>, and <code class="codeph">jinfo</code> can attach to the server using Java Remote Method Invocation (RMI).</p>
</div>
</div>
<a id="JSTGD259"></a>
<div class="sect2"><a id="GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67"></a>
<h2 id="JSTGD-GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67" class="sect2">The jstatd Daemon</h2>
<div>
<p>The <code class="codeph">jstatd</code> daemon is an RMI server application that monitors the creation and termination of each instrumented Java HotSpot, and provides an interface to allow remote monitoring tools to attach to JVMs running on the local host.</p>
<p>For example, this daemon allows the <code class="codeph">jps</code> utility to list processes on a remote system.</p>
<div class="infobox-note" id="GUID-469DA1E0-66B6-47F7-A937-18826B3BBE67__GUID-72857E9D-A426-4854-BD5D-59AB363ECAC6">
<p class="notep1">Note:</p>
<p>The instrumentation is not accessible on FAT32 file system.</p>
</div>
</div>
</div>
<a id="JSTGD261"></a><a id="JSTGD260"></a>
<div class="sect2"><a id="GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA"></a>
<h2 id="JSTGD-GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA" class="sect2">Thread States for a Thread Dump</h2>
<div>
<p>List of possible thread states for a thread dump.</p>
<p><a href="diagnostic-tools.htm#GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA__BABJFBFI" title="This table lists the possible thread states which indicate what the thread was doing at the time of the thread dump.">Table 2-6</a> lists the possible thread states for a thread dump using the <a href="diagnostic-tools.htm#GUID-6BCAC887-9FC1-4CC6-AB2C-2ECCCF1D805C" title="The result of pressing the Control key and the backslash (\) key at the application console on operating systems such as Oracle Solaris or Linux, or Windows.">Control+Break Handler</a>.</p>
<div class="tblformal" id="GUID-0110914C-4E91-4983-9CDB-412BC6C36AEA__BABJFBFI">
<p class="titleintable">Table 2-6 Thread States for a Thread Dump</p>
<table class="cellalignment350" title="Thread States for a Thread Dump" summary="This table lists the possible thread states which indicate what the thread was doing at the time of the thread dump.">
<thead>
<tr class="cellalignment341">
<th class="cellalignment351" id="d2844e5672">Thread State</th>
<th class="cellalignment352" id="d2844e5675">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5680" headers="d2844e5672">
<p>NEW</p>
</td>
<td class="cellalignment354" headers="d2844e5680 d2844e5675">
<p>The thread has not yet started.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5687" headers="d2844e5672">
<p>RUNNABLE</p>
</td>
<td class="cellalignment354" headers="d2844e5687 d2844e5675">
<p>The thread is executing in the JVM.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5694" headers="d2844e5672">
<p>BLOCKED</p>
</td>
<td class="cellalignment354" headers="d2844e5694 d2844e5675">
<p>The thread is blocked, waiting for a monitor lock.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5701" headers="d2844e5672">
<p>WAITING</p>
</td>
<td class="cellalignment354" headers="d2844e5701 d2844e5675">
<p>The thread is waiting indefinitely for another thread to perform a particular action.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5708" headers="d2844e5672">
<p>TIMED_WAITING</p>
</td>
<td class="cellalignment354" headers="d2844e5708 d2844e5675">
<p>The thread is waiting for another thread to perform an action for up to a specified waiting time.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5715" headers="d2844e5672">
<p>TERMINATED</p>
</td>
<td class="cellalignment354" headers="d2844e5715 d2844e5675">
<p>The thread has exited.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="JSTGD263"></a><a id="JSTGD264"></a><a id="JSTGD265"></a><a id="JSTGD262"></a>
<div class="sect2"><a id="GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB"></a>
<h2 id="JSTGD-GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB" class="sect2">Troubleshooting Tools Based on the Operating System</h2>
<div>
<p>List of native Windows tools that can be used for troubleshooting problems.</p>
<p><a href="diagnostic-tools.htm#GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABIJHEH" title="This table contains a list of native Windows tools which can be used for troubleshooting problems with the Java HotSpot VM.">Table 2-7</a> lists the troubleshooting tools available on the Windows operating system.</p>
<div class="tblformal" id="GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABIJHEH">
<p class="titleintable">Table 2-7 Native Troubleshooting Tools on Windows</p>
<table class="cellalignment350" title="Native Troubleshooting Tools on Windows" summary="This table contains a list of native Windows tools which can be used for troubleshooting problems with the Java HotSpot VM.">
<thead>
<tr class="cellalignment341">
<th class="cellalignment351" id="d2844e5759">Tool</th>
<th class="cellalignment352" id="d2844e5762">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5767" headers="d2844e5759">
<p><code class="codeph">dumpchk</code></p>
</td>
<td class="cellalignment354" headers="d2844e5767 d2844e5762">
<p>Command-line utility to verify that a memory dump file was created correctly. This tool is included in the Debugging Tools for Windows download available from the Microsoft website. See <a href="submit-bug-report.htm#GUID-F7841268-D783-4E3D-9BB3-3EB50CD186BE" title="In the Windows operating system there are three types of crash dumps: Dr. Watson log file, user minidump, and Dr. Watson full dump.">Collect Crash Dumps on Windows</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5781" headers="d2844e5759">
<p><code class="codeph">msdev</code> debugger</p>
</td>
<td class="cellalignment354" headers="d2844e5781 d2844e5762">
<p>Command-line utility that can be used to launch Visual C++ and the Win32 debugger</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5790" headers="d2844e5759">
<p><code class="codeph">userdump</code></p>
</td>
<td class="cellalignment354" headers="d2844e5790 d2844e5762">
<p>The User Mode Process Dumper is included in the OEM Support Tools download available from the Microsoft website. See <a href="submit-bug-report.htm#GUID-F7841268-D783-4E3D-9BB3-3EB50CD186BE" title="In the Windows operating system there are three types of crash dumps: Dr. Watson log file, user minidump, and Dr. Watson full dump.">Collect Crash Dumps on Windows</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5804" headers="d2844e5759">
<p><code class="codeph">windbg</code></p>
</td>
<td class="cellalignment354" headers="d2844e5804 d2844e5762">
<p>Windows debugger can be used to debug Windows applications or crash dumps. This tool is included in the Debugging Tools for Windows download available from the Microsoft website. See <a href="submit-bug-report.htm#GUID-F7841268-D783-4E3D-9BB3-3EB50CD186BE" title="In the Windows operating system there are three types of crash dumps: Dr. Watson log file, user minidump, and Dr. Watson full dump.">Collect Crash Dumps on Windows</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5818" headers="d2844e5759">
<p><code class="codeph">/Md</code> and <code class="codeph">/Mdd</code> compiler options</p>
</td>
<td class="cellalignment354" headers="d2844e5818 d2844e5762">
<p>Compiler options that automatically include extra support for tracking memory allocations</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="diagnostic-tools.htm#GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABECEAH" title="This table contains a list of native Linux tools which can be used for troubleshooting problems with the Java HotSpot VM.">Table 2-8</a> describes some troubleshooting tools introduced or improved in the Linux operating system version 10.</p>
<div class="tblformal" id="GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABECEAH">
<p class="titleintable">Table 2-8 Native Troubleshooting Tools on Linux</p>
<table class="cellalignment350" title="Native Troubleshooting Tools on Linux" summary="This table contains a list of native Linux tools which can be used for troubleshooting problems with the Java HotSpot VM.">
<thead>
<tr class="cellalignment341">
<th class="cellalignment351" id="d2844e5845">Tool</th>
<th class="cellalignment352" id="d2844e5848">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5853" headers="d2844e5845">
<p><code class="codeph">c++filt</code></p>
</td>
<td class="cellalignment354" headers="d2844e5853 d2844e5848">
<p>Demangle C++ mangled symbol names. This utility is delivered with the native C++ compiler suite: <code class="codeph">gcc</code> on Linux.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5864" headers="d2844e5845">
<p><code class="codeph">gdb</code></p>
</td>
<td class="cellalignment354" headers="d2844e5864 d2844e5848">
<p>GNU debugger</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5872" headers="d2844e5845">
<p><code class="codeph">libnjamd</code></p>
</td>
<td class="cellalignment354" headers="d2844e5872 d2844e5848">
<p>Memory allocation tracking</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5880" headers="d2844e5845">
<p><code class="codeph">lsstack</code></p>
</td>
<td class="cellalignment354" headers="d2844e5880 d2844e5848">
<p>Print thread stack (similar to <code class="codeph">pstack</code> in the Oracle Solaris operating system)</p>
<p>Not all distributions provide this tool by default; therefore, you might have to download it from <a href="http://sourceforge.net" target="_blank">Open Source downloads</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5897" headers="d2844e5845">
<p><code class="codeph">ltrace</code></p>
</td>
<td class="cellalignment354" headers="d2844e5897 d2844e5848">
<p>Library call tracer (equivalent to <code class="codeph">truss -u</code> in the Oracle Solaris operating system)</p>
<p>Not all distributions provide this tool by default; therefore, you might have to download it from <a href="http://sourceforge.net" target="_blank">Open Source downloads</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5914" headers="d2844e5845">
<p><code class="codeph">mtrace</code> and <code class="codeph">muntrace</code></p>
</td>
<td class="cellalignment354" headers="d2844e5914 d2844e5848">
<p>GNU <code class="codeph">malloc</code> tracer</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5928" headers="d2844e5845">
<p><code class="codeph">proc</code> tools such as <code class="codeph">pmap</code> and <code class="codeph">pstack</code></p>
</td>
<td class="cellalignment354" headers="d2844e5928 d2844e5848">
<p>Some, but not all, of the <code class="codeph">proc</code> tools on the Oracle Solaris operating system have equivalent tools on Linux. Core file support is not as good for Linux as for Oracle Solaris operating system; for example, <code class="codeph">pstack</code> does not work for core dumps</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5948" headers="d2844e5845">
<p><code class="codeph">strace</code></p>
</td>
<td class="cellalignment354" headers="d2844e5948 d2844e5848">
<p>System call tracer (equivalent to <code class="codeph">truss -t</code> in the Oracle Solaris operating system)</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5959" headers="d2844e5845">
<p><code class="codeph">top</code></p>
</td>
<td class="cellalignment354" headers="d2844e5959 d2844e5848">
<p>Display most CPU-intensive processes.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5967" headers="d2844e5845">
<p><code class="codeph">vmstat</code></p>
</td>
<td class="cellalignment354" headers="d2844e5967 d2844e5848">
<p>Report information about processes, memory, paging, block I/O, traps, and CPU activity.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="diagnostic-tools.htm#GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABCJBCG" title="This table contains a list of native Solaris OS tools which can be used for troubleshooting problems with the Java HotSpot VM.">Table 2-9</a> lists troubleshooting tools available on Oracle Solaris operating system.</p>
<div class="tblformal" id="GUID-3A45F995-E1B7-4ABD-B7E3-DE9B85EE1BEB__BABCJBCG">
<p class="titleintable">Table 2-9 Native Troubleshooting Tools on Oracle Solaris Operating System</p>
<table class="cellalignment350" title="Native Troubleshooting Tools on Oracle Solaris Operating System" summary="This table contains a list of native Solaris OS tools which can be used for troubleshooting problems with the Java HotSpot VM.">
<thead>
<tr class="cellalignment341">
<th class="cellalignment351" id="d2844e5990">Tool</th>
<th class="cellalignment352" id="d2844e5993">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e5998" headers="d2844e5990">
<p><code class="codeph">coreadm</code></p>
</td>
<td class="cellalignment354" headers="d2844e5998 d2844e5993">
<p>Specify name and location of core files produced by the JVM.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6006" headers="d2844e5990">
<p><code class="codeph">cpustat</code></p>
</td>
<td class="cellalignment354" headers="d2844e6006 d2844e5993">
<p>Monitor system behavior using CPU performance counters.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6014" headers="d2844e5990">
<p><code class="codeph">cputrack</code></p>
</td>
<td class="cellalignment354" headers="d2844e6014 d2844e5993">
<p>Monitor process and LWP behavior using CPU performance counters.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6022" headers="d2844e5990">
<p><code class="codeph">c++filt</code></p>
</td>
<td class="cellalignment354" headers="d2844e6022 d2844e5993">
<p>Demangle C++ mangled symbol names. This utility is delivered with the native C++ compiler suite: <code class="codeph">SUNWspro</code> on the Oracle Solaris operating system.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6033" headers="d2844e5990">
<p><code class="codeph">dtrace</code></p>
</td>
<td class="cellalignment354" headers="d2844e6033 d2844e5993">
<p>Introduced in Oracle Solaris 10 operating system, DTrace is a dynamic tracing compiler and tracing utility. It can perform dynamic tracing of kernel functions, system calls, and user functions. This tool allows arbitrary, safe scripting to be executed at entry, exit, and other probe points. The script is written in the C-like, but safe, pointer semantics language called the D programming language. See also <a href="diagnostic-tools.htm#GUID-6A234C2A-5BFF-4781-8A68-BE826D9CAF16" title="The Oracle Solaris 10 operating system includes the DTrace tool, which allows dynamic tracing of the operating system kernel and user-level programs.">DTrace Tool</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6047" headers="d2844e5990">
<p><code class="codeph">gcore</code></p>
</td>
<td class="cellalignment354" headers="d2844e6047 d2844e5993">
<p>Force a core dump of a process. The process continues after the core dump is written.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6055" headers="d2844e5990">
<p><code class="codeph">intrstat</code></p>
</td>
<td class="cellalignment354" headers="d2844e6055 d2844e5993">
<p>Report statistics on the CPU consumed by interrupt threads.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6063" headers="d2844e5990">
<p><code class="codeph">iostat</code></p>
</td>
<td class="cellalignment354" headers="d2844e6063 d2844e5993">
<p>Report I/O statistics.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6071" headers="d2844e5990">
<p><code class="codeph">libumem</code></p>
</td>
<td class="cellalignment354" headers="d2844e6071 d2844e5993">
<p>Introduced in the Oracle Solaris 9 operating system update 3, this library provides fast, scalable object-caching memory allocation and extensive debugging support. The tool can be used to find and fix memory management bugs. See <a href="troubleshoot-memory-leaks.htm#GUID-28DC43A9-45EB-459C-975E-51689886126D" title="First introduced in the Oracle Solaris 9 operating system update 3, the libumem.so library, and the modular debugger mdb can be used to debug memory leaks.">Find Leaks with the libumem Tool</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6091" headers="d2844e5990">
<p><code class="codeph">mdb</code></p>
</td>
<td class="cellalignment354" headers="d2844e6091 d2844e5993">
<p>Modular debugger for kernel and user applications and crash dumps</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6099" headers="d2844e5990">
<p><code class="codeph">netstat</code></p>
</td>
<td class="cellalignment354" headers="d2844e6099 d2844e5993">
<p>Display the contents of various network-related data structures.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6108" headers="d2844e5990">
<p><code class="codeph">pargs</code></p>
</td>
<td class="cellalignment354" headers="d2844e6108 d2844e5993">
<p>Print process arguments, environment variables, or the auxiliary vector. Long output is not truncated as it would be by other commands, such as <code class="codeph">ps</code>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6119" headers="d2844e5990">
<p><code class="codeph">pfiles</code></p>
</td>
<td class="cellalignment354" headers="d2844e6119 d2844e5993">
<p>Print information on process file descriptors. Starting with the Oracle Solaris 10 operating system, the tool prints the file name also.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6127" headers="d2844e5990">
<p><code class="codeph">pldd</code></p>
</td>
<td class="cellalignment354" headers="d2844e6127 d2844e5993">
<p>Print shared objects loaded by a process.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6135" headers="d2844e5990">
<p><code class="codeph">pmap</code></p>
</td>
<td class="cellalignment354" headers="d2844e6135 d2844e5993">
<p>Print memory layout of a process or core file, including heap, data, and text sections. Starting with Oracle Solaris 10, stack segments are clearly identified with the text <code class="codeph">[stack]</code> along with the thread ID. See <a href="diagnostic-tools.htm#GUID-792C5321-65E3-40CB-8F07-DE63F2142363" title="Improvements to the pmap utility in Oracle Solaris 10 operating system.">Improvements to the pmap Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6155" headers="d2844e5990">
<p><code class="codeph">prstat</code></p>
</td>
<td class="cellalignment354" headers="d2844e6155 d2844e5993">
<p>Report statistics for active Oracle Solaris operating system processes. (Similar to <code class="codeph">top</code>)</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6166" headers="d2844e5990">
<p><code class="codeph">prun</code></p>
</td>
<td class="cellalignment354" headers="d2844e6166 d2844e5993">
<p>Set the process to running mode (reverse of <code class="codeph">pstop</code>).</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6177" headers="d2844e5990">
<p><code class="codeph">ps</code></p>
</td>
<td class="cellalignment354" headers="d2844e6177 d2844e5993">
<p>List all processes.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6185" headers="d2844e5990">
<p><code class="codeph">psig</code></p>
</td>
<td class="cellalignment354" headers="d2844e6185 d2844e5993">
<p>List the signal handlers of a process.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6193" headers="d2844e5990">
<p><code class="codeph">pstack</code></p>
</td>
<td class="cellalignment354" headers="d2844e6193 d2844e5993">
<p>Print stack of threads of a given process or core file. Starting with the Oracle Solaris 10 operating system, Java method names can be printed for Java frames. See <a href="diagnostic-tools.htm#GUID-6D797E4D-7DF1-4623-8AC8-B573F09FAE8A" title="Improvements to the pstack utility in Oracle Solaris 10 operating system.">Improvements to the pstack Utility</a>.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6210" headers="d2844e5990">
<p><code class="codeph">pstop</code></p>
</td>
<td class="cellalignment354" headers="d2844e6210 d2844e5993">
<p>Stop the process (suspend).</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6218" headers="d2844e5990">
<p><code class="codeph">ptree</code></p>
</td>
<td class="cellalignment354" headers="d2844e6218 d2844e5993">
<p>Print the process tree that contains the given PID.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6227" headers="d2844e5990">
<p><code class="codeph">sar</code></p>
</td>
<td class="cellalignment354" headers="d2844e6227 d2844e5993">
<p>System activity reporter</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6235" headers="d2844e5990">
<p><code class="codeph">sdtprocess</code></p>
</td>
<td class="cellalignment354" headers="d2844e6235 d2844e5993">
<p>Display most CPU-intensive processes. (similar to <code class="codeph">top</code>).</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6246" headers="d2844e5990">
<p><code class="codeph">sdtperfmeter</code></p>
</td>
<td class="cellalignment354" headers="d2844e6246 d2844e5993">
<p>Display graphs that show the system performance (for example, CPU, disks, and network).</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6254" headers="d2844e5990">
<p><code class="codeph">top</code></p>
</td>
<td class="cellalignment354" headers="d2844e6254 d2844e5993">
<p>Display most CPU-intensive processes. This tool is available as freeware for the Oracle Solaris operating system, but is not installed by default.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6262" headers="d2844e5990">
<p><code class="codeph">trapstat</code></p>
</td>
<td class="cellalignment354" headers="d2844e6262 d2844e5993">
<p>Display runtime trap statistics (SPARC only).</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6270" headers="d2844e5990">
<p><code class="codeph">truss</code></p>
</td>
<td class="cellalignment354" headers="d2844e6270 d2844e5993">
<p>Trace entry and exit events for system calls, user-mode functions, and signals; optionally stop the process at one of these events. This tool also prints the arguments of system calls and user functions.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6278" headers="d2844e5990">
<p><code class="codeph">vmstat</code></p>
</td>
<td class="cellalignment354" headers="d2844e6278 d2844e5993">
<p>Report system virtual memory statistics.</p>
</td>
</tr>
<tr class="cellalignment341">
<td class="cellalignment353" id="d2844e6286" headers="d2844e5990">
<p><code class="codeph">watchmalloc</code></p>
</td>
<td class="cellalignment354" headers="d2844e6286 d2844e5993">
<p>Track memory allocations.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment340">
<tr>
<td class="cellalignment347">
<table class="cellalignment345">
<tr>
<td class="cellalignment344"><a href="prepare-java-troubleshooting.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment344"><a href="troubleshoot-memory-leaks.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1995, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment349">
<table class="cellalignment343">
<tr>
<td class="cellalignment344"><a href="http://docs.oracle.com/javase/10/index.html"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment344"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment344"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
