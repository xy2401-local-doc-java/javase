<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Troubleshoot Memory Leaks</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="description" content="This chapter provides some suggestions for diagnosing problems involving possible memory leaks." />
<meta name="dcterms.created" content="2018-03-12T22:27:13Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Java Platform, Standard Edition Troubleshooting Guide" />
<meta name="dcterms.identifier" content="E91156-01" />
<meta name="dcterms.isVersionOf" content="JSTGD" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1995, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="http://docs.oracle.com/javase/10/index.html" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="diagnostic-tools.htm" title="Previous" type="text/html" />
<link rel="Next" href="troubleshoot-performance-issues-using-jfr.htm" title="Next" type="text/html" />
<link rel="alternate" href="JSTGD.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-8090B138-6E0C-4926-9659-BE739062AB75"></a> <span id="PAGE" style="display:none;">7/31</span> <!-- End Header -->
<a id="JSTGD267"></a><a id="JSTGD266"></a>
<h1 id="JSTGD-GUID-8090B138-6E0C-4926-9659-BE739062AB75" class="sect1"><span class="enumeration_chapter">3</span> Troubleshoot Memory Leaks</h1>
<div>
<div><span>This chapter provides some suggestions for diagnosing problems involving possible memory leaks.</span></div>
<p>If your application's execution time becomes longer and longer, or if the operating system seems to be performing slower and slower, this could be an indication of a memory leak. In other words, virtual memory is being allocated but is not being returned when it is no longer needed. Eventually the application or the system runs out of memory, and the application terminates abnormally.</p>
<p>This chapter contains the following sections:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-FA5677A5-B175-40B4-B7F0-851118B6B7AD" title="The Java Flight Recorder (JFR) is a commercial feature. You can use it for free on developer desktops or laptops, and for evaluation purposes in test, development, and production environments.">Debug a Memory Leak Using Java Flight Recorder</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-19F6D28E-75A1-4480-9879-D0932B2F305B" title="java.lang.OutOfMemoryError error is thrown when there is insufficient space to allocate an object in the Java heap.">Understand the OutOfMemoryError Exception</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-BFBB755F-03CF-46B4-A03E-45D280C907C2" title="Use the information in the fatal error log or the crash dump to troubleshoot a crash.">Troubleshoot a Crash Instead of OutOfMemoryError</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-442CF6A1-3DF8-496C-A910-3A239326A161" title="Use the NetBeans profiler to diagnose leaks in the Java language code.">Diagnose Leaks in Java Language Code</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-79F26B47-9240-4F32-A817-1DD77A361F31" title="Several techniques can be used to find and isolate native code memory leaks. In general, there is no ideal solution for all platforms.">Diagnose Leaks in Native Code</a></p>
</li>
</ul>
</div>
<a id="JSTGD268"></a>
<div class="props_rev_3"><a id="GUID-FA5677A5-B175-40B4-B7F0-851118B6B7AD"></a>
<h2 id="JSTGD-GUID-FA5677A5-B175-40B4-B7F0-851118B6B7AD" class="sect2">Debug a Memory Leak Using Java Flight Recorder</h2>
<div>
<p>The Java Flight Recorder (JFR) is a commercial feature. You can use it for free on developer desktops or laptops, and for evaluation purposes in test, development, and production environments.</p>
<p>However, to enable JFR <span class="bold">on a production server, you must have a commercial license</span>. Using the Java Mission Control (JMC) for other purposes on the JDK <span class="bold">does not require a commercial license</span>.</p>
<p>To know more about the JFR commercial features and availability, see the <a href="http://www.oracle.com/technetwork/java/javase/terms/products/index.html" target="_blank">product documentation</a>.</p>
<p>To know more about the JFR commercial license, see the <a href="http://www.oracle.com/technetwork/java/javase/terms/license/index.html" target="_blank">license agreement</a>.</p>
<p>The following sections show figures and describe how to debug a memory leak using Java Flight Recorder.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26" title="Detect memory leaks early and prevent OutOfmemoryErrors using Java Flight Recordings.">Detect a Memory Leak</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359" title="Use the Java Flight Recordings to identify the memory leak.">Find the Leaking Class</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-01CA595F-83F0-431F-876A-4138E68E34D2" title="Tips to identify the memory leak using the additional information using the Java Flight Recordings.">Find the Leak</a></p>
</li>
</ul>
</div>
<a id="JSTGD270"></a><a id="JSTGD269"></a>
<div class="props_rev_3"><a id="GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26"></a>
<h3 id="JSTGD-GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26" class="sect3">Detect a Memory Leak</h3>
<div>
<p>Detect memory leaks early and prevent <code class="codeph">OutOfmemoryErrors</code> using Java Flight Recordings.</p>
<div class="section">
<p>Detecting a slow memory leak can be hard. A typical symptom is that the application becomes slower after running for a long time due to frequent garbage collections. Eventually, <code class="codeph">OutOfmemoryErrors</code> may be seen. However, memory leaks can be detected early, even before a problem occurs using Java Flight Recordings.</p>
<p>Watch if the live set of your application is increasing over time. The live set is the amount of Java heap that is used after an old collection (all objects that are not live have been garbage collected). The live set can be inspected in many ways: run with the <code>-verbosegc</code> option, or connect to the JVM using the JMC JMX Console and look at <code class="codeph">com.sun.management.GarbageCollectorAggregator MBean</code>. However, another easy approach is to take a flight recording.</p>
<p>Enable <span class="bold">Heap Statistics</span> when you start your recording, which triggers an old collection at the start and at the end of the recording. This may cause a slight latency in the application. However, <span class="bold">Heap Statistics</span> generates accurate live set information. If you suspect a rather quick memory leak, then take a profiling recording that runs over, for example, an hour. Click the <span class="bold">Memory</span> tab and select the <span class="bold">Garbage Collections</span> tab to inspect the first and the last old collections, as shown in <a href="troubleshoot-memory-leaks.htm#GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26__CIHJCCEI">Figure 3-1</a>.</p>
<div class="figure" id="GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26__CIHJCCEI">
<p class="titleinfigure">Figure 3-1 Debug Memory Leaks - Garbage Collection Tab</p>
<img width="1058" height="299" src="img/jfr-gc-collectors.png" alt="Description of Figure 3-1 follows" title="Description of Figure 3-1 follows" /><br />
<a href="img_text/jfr-gc-collectors.htm">Description of "Figure 3-1 Debug Memory Leaks - Garbage Collection Tab"</a></div>
<!-- class="figure" -->
<p>Select the first old collection, as shown in <a href="troubleshoot-memory-leaks.htm#GUID-CCC45C28-F523-4C17-9A22-91CEC80F7A26__CIHJCCEI">Figure 3-1</a>, to look at the heap data and heap usage after GC. In this recording, it is 34.10 MB. Now, look at the same data from the last old collection in the list, and see if the live set has grown. Before taking the recording, you must allow the application to start and reach a stable state.</p>
<p>If the leak is slow, you can take a shorter 5-minute recording. Then, take another recording, for example 24 hours later (depending on how fast you suspect the memory leak to be). Obviously, your live set may go up and down, but if you see a steady increase over time, then you could have a memory leak.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="JSTGD272"></a><a id="JSTGD271"></a>
<div class="props_rev_3"><a id="GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359"></a>
<h3 id="JSTGD-GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359" class="sect3">Find the Leaking Class</h3>
<div>
<p>Use the Java Flight Recordings to identify the memory leak.</p>
<div class="section">
<p>After your recording showing the leak, you can look at the <span class="bold">Object Statistics</span>. Look at one long recording, then look at which classes grew the most in heap usage over the recording. If you took several recordings at intervals, then compare the heap contents section, and see which object types have increased the most between the recordings, as shown in <a href="troubleshoot-memory-leaks.htm#GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359__CIHIBAEJ">Figure 3-2</a>.</p>
<div class="figure" id="GUID-F6CA531F-CAD2-41C0-8DB9-4D922A4B0359__CIHIBAEJ">
<p class="titleinfigure">Figure 3-2 Debug Memory Leaks - Find Leaking Class</p>
<img width="1058" height="559" src="img/jfr-memory-leak.png" alt="Description of Figure 3-2 follows" title="Description of Figure 3-2 follows" /><br />
<a href="img_text/jfr-memory-leak.htm">Description of "Figure 3-2 Debug Memory Leaks - Find Leaking Class"</a></div>
<!-- class="figure" -->
<p>Especially, watch the classes that are not part of the standard library. For example, you will often see <code class="codeph">Char</code> arrays as one of the top growers. This is due to many <code class="codeph">Strings</code> being allocated; therefore, watch out for objects that keep these <code class="codeph">Strings</code> alive. If you have a class that has 10 <code class="codeph">Strings</code> as members, then the object itself will not use too much heap. The heap will be used by the <code class="codeph">Strings</code>, which mostly contains pointers to the <code class="codeph">Char</code> arrays. Therefore, it is good to sort on the number of instances and not the size of the objects. If one of your application class has many instances, then it may be those objects that keep other objects alive.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="JSTGD274"></a><a id="JSTGD273"></a>
<div class="props_rev_3"><a id="GUID-01CA595F-83F0-431F-876A-4138E68E34D2"></a>
<h3 id="JSTGD-GUID-01CA595F-83F0-431F-876A-4138E68E34D2" class="sect3">Find the Leak</h3>
<div>
<p>Tips to identify the memory leak using the additional information using the Java Flight Recordings.</p>
<div class="section">
<p>Some additional information can be found using Java Flight Recordings.</p>
<p>Look at the <span class="bold">Allocations</span> sub tab, as shown in <a href="troubleshoot-memory-leaks.htm#GUID-01CA595F-83F0-431F-876A-4138E68E34D2__CIHJCAGI">Figure 3-3</a>, for some samples of where objects were allocated.</p>
<div class="figure" id="GUID-01CA595F-83F0-431F-876A-4138E68E34D2__CIHJCAGI">
<p class="titleinfigure">Figure 3-3 Debug Memory Leaks - Allocations tab</p>
<img width="1147" height="729" src="img/jfr-find-leak.png" alt="Description of Figure 3-3 follows" title="Description of Figure 3-3 follows" /><br />
<a href="img_text/jfr-find-leak.htm">Description of "Figure 3-3 Debug Memory Leaks - Allocations tab"</a></div>
<!-- class="figure" -->
<p>If you except a specific class leak, look at the <span class="bold">Allocation in new TLAB</span> tab. Check the class samples being allocated. If the leak is slow, there may be a few allocations of this object and may be no samples. Also, it may be that only a specific allocation site is leading to a leak. To summarize, this is not guaranteed to lead you to the right allocation stack trace for the leak, but it may give vital clues.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="JSTGD275"></a>
<div class="props_rev_3"><a id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B"></a>
<h2 id="JSTGD-GUID-19F6D28E-75A1-4480-9879-D0932B2F305B" class="sect2">Understand the OutOfMemoryError Exception</h2>
<div>
<p><code class="codeph">java.lang.OutOfMemoryError</code> error is thrown when there is insufficient space to allocate an object in the Java heap.</p>
<p>One common indication of a memory leak is the <code class="codeph">java.lang.OutOfMemoryError</code> exception. In this case, The garbage collector cannot make space available to accommodate a new object, and the heap cannot be expanded further. Also, this error may be thrown when there is insufficient native memory to support the loading of a Java class. In a rare instance, a <code class="codeph">java.lang.OutOfMemoryError</code> can be thrown when an excessive amount of time is being spent doing garbage collection, and little memory is being freed.</p>
<p>When a <code class="codeph">java.lang.OutOfMemoryError</code> exception is thrown, a stack trace is also printed.</p>
<p>The <code class="codeph">java.lang.OutOfMemoryError</code> exception can also be thrown by native library code when a native allocation cannot be satisfied (for example, if swap space is low).</p>
<p>An early step to diagnose an <code class="codeph">OutOfMemoryError</code> exception is to determine the cause of the exception. Was it thrown because the Java heap is full, or because the native heap is full? To help you find the cause, the text of the exception includes a detail message at the end, as shown in the following exceptions.</p>
<dl>
<dt class="dlterm"><a id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-6640E414-548C-4308-B8A3-EAEE74A28DFA"><!-- --></a>Exception in thread <span class="variable">thread_name</span>: java.lang.OutOfMemoryError: Java heap space</dt>
<dd>
<p><span class="keyword">Cause:</span> The detailed message <span class="italic"><span class="bold">Java heap space</span></span> indicates that an object could not be allocated in the Java heap. This error does not necessarily imply a memory leak. The problem can be as simple as a configuration issue, where the specified heap size (or the default size, if it is not specified) is insufficient for the application.</p>
<p>In other cases, and in particular for a long-lived application, the message might be an indication that the application is unintentionally holding references to objects, and this prevents the objects from being garbage collected. This is the Java language equivalent of a memory leak. <span class="italic">Note:</span> The APIs that are called by an application could also be unintentionally holding object references.</p>
<p>One other potential source of this error arises with applications that make excessive use of finalizers. If a class has a <code class="codeph">finalize</code> method, then objects of that type do not have their space reclaimed at garbage collection time. Instead, after garbage collection, the objects are queued for finalization, which occurs at a later time. In the Oracle Sun implementation, finalizers are executed by a daemon thread that services the finalization queue. If the finalizer thread cannot keep up with the finalization queue, then the Java heap could fill up, and this type of <code class="codeph">OutOfMemoryError</code> exception would be thrown. One scenario that can cause this situation is when an application creates high-priority threads that cause the finalization queue to increase at a rate that is faster than the rate at which the finalizer thread is servicing that queue.</p>
</dd>
<dd class="ddexpand">
<p><span class="keyword">Action:</span> To know more about how to monitor objects for which finalization is pending <a href="troubleshoot-memory-leaks.htm#GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B" title="Different commands and options available to monitor the objects pending finalization.">Monitor the Objects Pending Finalization</a>.</p>
</dd>
<dt class="dlterm"><a id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__TAHITI1150092"><!-- --></a>Exception in thread <span class="variable">thread_name</span>: java.lang.OutOfMemoryError: GC Overhead limit exceeded</dt>
<dd>
<p><span class="keyword">Cause:</span> The detail message "GC overhead limit exceeded" indicates that the garbage collector is running all the time, and the Java program is making very slow progress. After a garbage collection, if the Java process is spending more than approximately 98% of its time doing garbage collection and if it is recovering less than 2% of the heap and has been doing so for the last 5 (compile time constant) consecutive garbage collections, then a <code class="codeph">java.lang.OutOfMemoryError</code> is thrown. This exception is typically thrown because the amount of live data barely fits into the Java heap having little free space for new allocations.</p>
</dd>
<dd class="ddexpand">
<p><span class="keyword">Action:</span> Increase the heap size. The <code class="codeph">java.lang.OutOfMemoryError</code> exception for <span class="bold">GC Overhead limit exceeded</span> can be turned off with the command-line flag <code class="codeph">-XX:-UseGCOverheadLimit</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-289BB010-8FF3-46DA-830B-B8FEFB1F18E1"><!-- --></a>Exception in thread <span class="variable">thread_name</span>: java.lang.OutOfMemoryError: Requested array size exceeds VM limit</dt>
<dd>
<p><span class="keyword">Cause:</span> The detail message "Requested array size exceeds VM limit" indicates that the application (or APIs used by that application) attempted to allocate an array that is larger than the heap size. For example, if an application attempts to allocate an array of 512 MB, but the maximum heap size is 256 MB, then <code class="codeph">OutOfMemoryError</code> will be thrown with the reason &ldquo;Requested array size exceeds VM limit."</p>
</dd>
<dd class="ddexpand">
<p><span class="keyword">Action:</span> Usually the problem is either a configuration issue (heap size too small) or a bug that results in an application attempting to create a huge array (for example, when the number of elements in the array is computed using an algorithm that computes an incorrect size).</p>
</dd>
<dt class="dlterm"><a id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-F78066FC-0EAD-41BD-BD7B-8F2ADA707AB3"><!-- --></a>Exception in thread <span class="variable">thread_name</span>: java.lang.OutOfMemoryError: Metaspace</dt>
<dd>
<p><span class="keyword">Cause:</span> Java class metadata (the virtual machines internal presentation of Java class) is allocated in native memory (referred to here as metaspace). If metaspace for class metadata is exhausted, a <code class="codeph">java.lang.OutOfMemoryError</code> exception with a detail <code class="codeph">MetaSpace</code> is thrown. The amount of metaspace that can be used for class metadata is limited by the parameter <code class="codeph">MaxMetaSpaceSize</code>, which is specified on the command line. When the amount of native memory needed for a class metadata exceeds <code class="codeph">MaxMetaSpaceSize</code>, a <code class="codeph">java.lang.OutOfMemoryError</code> exception with a detail <code class="codeph">MetaSpace</code> is thrown.</p>
</dd>
<dd class="ddexpand">
<p><span class="keyword">Action:</span> If <code class="codeph">MaxMetaSpaceSize</code>, has been set on the command-line, increase its value. <code class="codeph">MetaSpace</code> is allocated from the same address spaces as the Java heap. Reducing the size of the Java heap will make more space available for <code class="codeph">MetaSpace</code>. This is only a correct trade-off if there is an excess of free space in the Java heap. See the following action for <span class="bold">Out of swap space</span> detailed message.</p>
</dd>
<dt class="dlterm"><a id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-D21A14F5-3462-49BE-96F2-25D02A963752"><!-- --></a>Exception in thread <span class="variable">thread_name</span>: java.lang.OutOfMemoryError: request <span class="variable">size</span> bytes for <span class="variable">reason</span>. Out of swap space?</dt>
<dd>
<p><span class="keyword">Cause:</span> The detail message "request <span class="variable">size</span> bytes for <span class="variable">reason</span>. Out of swap space?" appears to be an <code class="codeph">OutOfMemoryError</code> exception. However, the Java HotSpot VM code reports this apparent exception when an allocation from the native heap failed and the native heap might be close to exhaustion. The message indicates the size (in bytes) of the request that failed and the reason for the memory request. Usually the reason is the name of the source module reporting the allocation failure, although sometimes it is the actual reason.</p>
</dd>
<dd class="ddexpand">
<p><span class="keyword">Action:</span> When this error message is thrown, the VM invokes the fatal error handling mechanism (that is, it generates a fatal error log file, which contains useful information about the thread, process, and system at the time of the crash). In the case of native heap exhaustion, the heap memory and memory map information in the log can be useful. See <a href="fatal-error-log.htm#GUID-2AE5EE08-A68F-4514-9618-A581C0EDFB1B" title="Describes the fatal error log, its location, and contents.">Fatal Error Log</a>.</p>
<p>If this type of the <code class="codeph">OutOfMemoryError</code> exception is thrown, you might need to use troubleshooting utilities on the operating system to diagnose the issue further. See <a href="diagnostic-tools.htm#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="List of native tools available on Windows, Linux, and Oracle Solaris operating systems that are useful for troubleshooting or monitoring purposes.">Native Operating System Tools</a>.</p>
</dd>
<dt class="dlterm"><a id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-01312D6E-BE5E-454A-8CC9-3DAF6CD50034"><!-- --></a>Exception in thread <span class="variable">thread_name</span>: java.lang.OutOfMemoryError: Compressed class space</dt>
<dd>
<p><span class="keyword">Cause:</span> On 64-bit platforms, a pointer to class metadata can be represented by 32-bit offset (with <code class="codeph">UseCompressedOops</code>). This is controlled by the command line flag <code class="codeph">UseCompressedClassPointers</code> (on by default). If the <code class="codeph">UseCompressedClassPointers</code> is used, the amount of space available for class metadata is fixed at the amount <code class="codeph">CompressedClassSpaceSize</code>. If the space needed for <code class="codeph">UseCompressedClassPointers</code> exceeds <code class="codeph">CompressedClassSpaceSize</code>, a <code class="codeph">java.lang.OutOfMemoryError</code> with detail <span class="bold">Compressed class space</span> is thrown.</p>
</dd>
<dd class="ddexpand">
<p><span class="keyword">Action:</span> Increase <code class="codeph">CompressedClassSpaceSize</code> to turn off <code class="codeph">UseCompressedClassPointers</code>. <span class="italic">Note:</span> There are bounds on the acceptable size of <code class="codeph">CompressedClassSpaceSize</code>. For example <code class="codeph">-XX: CompressedClassSpaceSize=4g</code>, exceeds acceptable bounds will result in a message such as</p>
<p><code class="codeph">CompressedClassSpaceSize</code> of 4294967296 is invalid; must be between 1048576 and 3221225472.</p>
<div class="infobox-note" id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-0FFF3AAB-A882-40EC-99ED-404BE63B8E62">
<p class="notep1">Note:</p>
There is more than one kind of class metadata, <code class="codeph">&ndash;klass</code> metadata, and other metadata. Only <code class="codeph">klass</code> metadata is stored in the space bounded by <code class="codeph">CompressedClassSpaceSize</code>. The other metadata is stored in <code class="codeph">Metaspace</code>.</div>
</dd>
<dt class="dlterm"><a id="GUID-19F6D28E-75A1-4480-9879-D0932B2F305B__GUID-6861E00E-EF63-4556-92DD-7029268A70A1"><!-- --></a>Exception in thread <span class="variable">thread_name</span>: java.lang.OutOfMemoryError: <span class="variable">reason</span> <span class="variable">stack_trace_with_native_method</span></dt>
<dd>
<p><span class="keyword">Cause:</span> If the detail part of the error message is "<span class="variable">reason</span> <span class="variable">stack_trace_with_native_method</span>, and a stack trace is printed in which the top frame is a native method, then this is an indication that a native method, has encountered an allocation failure. The difference between this and the previous message is that the allocation failure was detected in a Java Native Interface (JNI) or native method rather than in the JVM code.</p>
</dd>
<dd class="ddexpand">
<p><span class="keyword">Action:</span> If this type of the <code class="codeph">OutOfMemoryError</code> exception is thrown, you might need to use native utilities of the OS to further diagnose the issue. See <a href="diagnostic-tools.htm#GUID-08957176-5459-4CEA-A141-D325D1204D54" title="List of native tools available on Windows, Linux, and Oracle Solaris operating systems that are useful for troubleshooting or monitoring purposes.">Native Operating System Tools</a>.</p>
</dd>
</dl>
</div>
</div>
<a id="JSTGD276"></a>
<div class="props_rev_3"><a id="GUID-BFBB755F-03CF-46B4-A03E-45D280C907C2"></a>
<h2 id="JSTGD-GUID-BFBB755F-03CF-46B4-A03E-45D280C907C2" class="sect2">Troubleshoot a Crash Instead of OutOfMemoryError</h2>
<div>
<p>Use the information in the fatal error log or the crash dump to troubleshoot a crash.</p>
<p>Sometimes an application crashes soon after an allocation from the native heap fails. This occurs with native code that does not check for errors returned by the memory allocation functions.</p>
<p>For example, the <code class="codeph">malloc</code> system call returns <code class="codeph">null</code> if there is no memory available. If the return from <code class="codeph">malloc</code> is not checked, then the application might crash when it attempts to access an invalid memory location. Depending on the circumstances, this type of issue can be difficult to locate.</p>
<p>However, sometimes the information from the fatal error log or the crash dump is sufficient to diagnose this issue. The fatal error log is covered in detail in <a href="fatal-error-log.htm#GUID-2AE5EE08-A68F-4514-9618-A581C0EDFB1B" title="Describes the fatal error log, its location, and contents.">Fatal Error Log</a>. If the cause of the crash is an allocation failure, then determine the reason for the allocation failure. As with any other native heap issue, the system might be configured with the insufficient amount of swap space, another process on the system might be consuming all memory resources, or there might be a leak in the application (or in the APIs that it calls) that causes the system to run out of memory.</p>
</div>
</div>
<a id="JSTGD277"></a>
<div class="props_rev_3"><a id="GUID-442CF6A1-3DF8-496C-A910-3A239326A161"></a>
<h2 id="JSTGD-GUID-442CF6A1-3DF8-496C-A910-3A239326A161" class="sect2">Diagnose Leaks in Java Language Code</h2>
<div>
<p>Use the NetBeans profiler to diagnose leaks in the Java language code.</p>
<div class="section">
<p>Diagnosing leaks in the Java language code can be difficult. Usually, it requires very detailed knowledge of the application. In addition, the process is often iterative and lengthy. This section provides information about the tools that you can use to diagnose memory leaks in the Java language code.</p>
<div class="infobox-note" id="GUID-442CF6A1-3DF8-496C-A910-3A239326A161__GUID-A9D119FE-5A94-44AC-9D45-1889CBC31998">
<p class="notep1">Note:</p>
<p>Beside the tools mentioned in this section, a large number of third-party memory debugger tools are available. The Eclipse Memory Analyzer Tool (MAT), and YourKit (www.yourkit.com) are two examples of commercial tools with memory debugging capabilities. There are many others, and no specific product is recommended.</p>
</div>
<p>The following utilities used to diagnose leaks in the Java language code.</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span><span class="bold">The NetBeans Profiler:</span> The NetBeans Profiler can locate memory leaks very quickly. Commercial memory leak debugging tools can take a long time to locate a leak in a large application. The NetBeans Profiler, however, uses the pattern of memory allocations and reclamations that such objects typically demonstrate. This process includes also the lack of memory reclamations. The profiler can check where these objects were allocated, which often is sufficient to identify the root cause of the leak.</span>
<div>
<p>See <a href="http://profiler.netbeans.org" target="_blank">NetBeans Profiler</a>.</p>
</div>
</li>
</ol>
<div class="section">
<p>The following sections describe the other ways to diagnose leaks in the Java language code.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-93A2C2F1-C22C-4E76-83B8-785D3DD869E9" title="Different commands and options available to get a heap histogram to identify memory leaks.">Get a Heap Histogram</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B" title="Different commands and options available to monitor the objects pending finalization.">Monitor the Objects Pending Finalization</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<a id="JSTGD282"></a>
<div class="props_rev_3"><a id="GUID-93A2C2F1-C22C-4E76-83B8-785D3DD869E9"></a>
<h3 id="JSTGD-GUID-93A2C2F1-C22C-4E76-83B8-785D3DD869E9" class="sect3">Get a Heap Histogram</h3>
<div>
<p>Different commands and options available to get a heap histogram to identify memory leaks.</p>
<div class="section">
<p>You can try to quickly narrow down a memory leak by examining the heap histogram. You can get a heap histogram in several ways:</p>
</div>
<!-- class="section" -->
<ul>
<li class="stepexpand"><span>If the Java process is started with the <code>-XX:+PrintClassHistogram</code> command-line option, then the Control+Break handler will produce a heap histogram.</span></li>
<li class="stepexpand"><span>You can use the <code class="codeph">jmap</code> utility to get a heap histogram from a running process:</span>
<div>
<p>It is recommended to use the latest utility, <code class="codeph">jcmd</code>, instead of <code class="codeph">jmap</code> utility for enhanced diagnostics and reduced performance overhead. See <a href="diagnostic-tools.htm#GUID-B7480F58-82B5-4F29-94E6-1DA669947265" title="The available diagnostic command may be different in different versions of HotSpot VM; therefore, using jcmd &lt;process id/main class&gt; help is the best way to see all available options.">Useful Commands for the jcmd Utility</a>.The command in the following example creates a heap histogram for a running process using <code class="codeph">jcmd</code> and results similar to the following <code class="codeph">jmap</code> command.</p>
<pre dir="ltr">
jcmd &lt;process id/main class&gt; GC.class_histogram filename=Myheaphistogram
</pre>
<pre dir="ltr">
jmap -histo <span class="variable">pid</span>
</pre>
<p>The output shows the total size and instance count for each class type in the heap. If a sequence of histograms is obtained (for example, every 2 minutes), then you might be able to see a trend that can lead to further analysis.</p>
</div>
</li>
<li class="stepexpand"><span>You can use the <code class="codeph">jmap</code> utility to get a heap histogram from a core file, as shown in the following example.</span>
<div>
<pre dir="ltr">
jmap -histo <span class="variable">core_file</span>
</pre>
<p>For example, if you specify the <code>-XX:+HeapDumpOnOutOfMemoryError</code> command-line option while running your application, then when an <code class="codeph">OutOfMemoryError</code> exception is thrown, the JVM will generate a heap dump. You can then execute <code class="codeph">jmap</code> on the core file to get a histogram, as shown in the following example.</p>
<pre dir="ltr">
$ <span class="bold">jmap -histo \ /java/re/javase/6/latest/binaries/solaris-sparc/bin/java core.27421</span>

Attaching to core core.27421 from executable 
/java/re/javase/6/latest/binaries/solaris-sparc/bin/java, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 1.6.0-beta-b63
Iterating over heap. This may take a while...
Heap traversal took 8.902 seconds.

Object Histogram:
 
Size      Count   Class description
-------------------------------------------------------
86683872  3611828 java.lang.String
20979136  204     java.lang.Object[]
403728    4225    * ConstMethodKlass
306608    4225    * MethodKlass
220032    6094    * SymbolKlass
152960    294     * ConstantPoolKlass
108512    277     * ConstantPoolCacheKlass
104928    294     * InstanceKlassKlass
68024     362     byte[]
65600     559     char[]
31592     359     java.lang.Class
27176     462     java.lang.Object[]
25384     423     short[]
17192     307     int[]
:
</pre>
<p>The above example shows that the <code class="codeph">OutOfMemoryError</code> exception was caused by the number of <code class="codeph">java.lang.String</code> objects (3,611,828 instances in the heap). Without further analysis it is not clear where the strings are allocated. However, the information is still useful.</p>
</div>
</li>
</ul>
</div>
</div>
<a id="JSTGD286"></a>
<div class="props_rev_3"><a id="GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B"></a>
<h3 id="JSTGD-GUID-9E45BCA7-A377-49A4-8D62-507F6CF85E4B" class="sect3">Monitor the Objects Pending Finalization</h3>
<div>
<p>Different commands and options available to monitor the objects pending finalization.</p>
<div class="section">
<p>When the OutOfMemoryError exception is thrown with the "Java heap space" detail message, the cause can be excessive use of finalizers. To diagnose this, you have several options for monitoring the number of objects that are pending finalization:</p>
</div>
<!-- class="section" -->
<ul>
<li><span>The <a href="diagnostic-tools.htm#GUID-92074912-77E2-46B4-9A2F-A27F10331576" title="Another useful tool included in the JDK download is the JConsole monitoring tool. This tool is compliant with JMX. The tool uses the built-in JMX instrumentation in the JVM to provide information about the performance and resource consumption of running applications.">JConsole</a> management tool can be used to monitor the number of objects that are pending finalization. This tool reports the pending finalization count in the memory statistics on the <span class="bold">Summary</span> tab pane. The count is approximate, but it can be used to characterize an application and understand if it relies a lot on finalization.</span></li>
<li><span>On Oracle Solaris and Linux operating systems, the <code class="codeph">jmap</code> utility can be used with the <code class="codeph">-finalizerinfo</code> option to print information about objects awaiting finalization.</span></li>
<li><span>An application can report the approximate number of objects pending finalization using the <code class="codeph">getObjectPendingFinalizationCount</code> method of the <code class="codeph">java.lang.management.MemoryMXBean</code> class. Links to the API documentation and example code can be found in <a href="diagnostic-tools.htm#GUID-55FDAAC0-8FA8-4F12-AE28-1E768FB49901" title="The JDK has extensive APIs to develop custom tools to observe, monitor, profile, debug, and diagnose issues in applications that are deployed in the JRE.">Custom Diagnostic Tools</a>. The example code can easily be extended to include the reporting of the pending finalization count.</span></li>
</ul>
</div>
</div>
</div>
<a id="JSTGD287"></a>
<div class="props_rev_3"><a id="GUID-79F26B47-9240-4F32-A817-1DD77A361F31"></a>
<h2 id="JSTGD-GUID-79F26B47-9240-4F32-A817-1DD77A361F31" class="sect2">Diagnose Leaks in Native Code</h2>
<div>
<p>Several techniques can be used to find and isolate native code memory leaks. In general, there is no ideal solution for all platforms.</p>
<p>The following are some techniques to diagnose leaks in native code.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-06976380-65AC-4455-BBFC-94BC02A42BBC" title="Tools available to track all memory allocation and use of that memory.">Track All Memory Allocation and Free Calls</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-7AF676F1-D313-4AE2-BE62-37176A103A13" title="If you write a JNI library, then consider creating a localized way to ensure that your library does not leak memory, by using a simple wrapper approach.">Track All Memory Allocations in the JNI Library</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-24C06368-4F3D-4332-9069-0005145E24A7" title="Tools available for tracking memory allocation in an operating system.">Track Memory Allocation with Operating System Support</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D" title="The dbx debugger includes the Runtime Checking (RTC) functionality, which can find leaks. The dbx debugger is part of Oracle Solaris Studio and also available for Linux.">Find Leaks with the dbx Debugger</a></p>
</li>
<li>
<p><a href="troubleshoot-memory-leaks.htm#GUID-28DC43A9-45EB-459C-975E-51689886126D" title="First introduced in the Oracle Solaris 9 operating system update 3, the libumem.so library, and the modular debugger mdb can be used to debug memory leaks.">Find Leaks with the libumem Tool</a></p>
</li>
</ul>
</div>
<a id="JSTGD288"></a>
<div class="props_rev_3"><a id="GUID-06976380-65AC-4455-BBFC-94BC02A42BBC"></a>
<h3 id="JSTGD-GUID-06976380-65AC-4455-BBFC-94BC02A42BBC" class="sect3">Track All Memory Allocation and Free Calls</h3>
<div>
<p>Tools available to track all memory allocation and use of that memory.</p>
<div class="section">
<p>A very common practice is to track all allocation and free calls of the native allocations. This can be a fairly simple process or a very sophisticated one. Many products over the years have been built up around the tracking of native heap allocations and the use of that memory.</p>
<p>Tools like IBM Rational Purify and the runtime checking functionality of Sun Studio <code class="codeph">dbx</code> debugger can be used to find these leaks in normal native code situations and also find any access to native heap memory that represents assignments to un-initialized memory or accesses to freed memory. See <a href="troubleshoot-memory-leaks.htm#GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D" title="The dbx debugger includes the Runtime Checking (RTC) functionality, which can find leaks. The dbx debugger is part of Oracle Solaris Studio and also available for Linux.">Find Leaks with the dbx Debugger</a>.</p>
<p>Not all these types of tools will work with Java applications that use native code, and usually these tools are platform-specific. Because the virtual machine dynamically creates code at runtime, these tools can incorrectly interpret the code and fail to run at all, or give false information. Check with your tool vendor to ensure that the version of the tool works with the version of the virtual machine you are using.</p>
<p>See <a href="http://sourceforge.net/" target="_blank">sourceforge</a> for many simple and portable native memory leak detecting examples. Most libraries and tools assume that you can recompile or edit the source of the application and place wrapper functions over the allocation functions. The more powerful of these tools allow you to run your application unchanged by interposing over these allocation functions dynamically. This is the case with the library <code class="codeph">libumem.so</code> first introduced in the Oracle Solaris 9 operating system update 3; see <a href="troubleshoot-memory-leaks.htm#GUID-28DC43A9-45EB-459C-975E-51689886126D" title="First introduced in the Oracle Solaris 9 operating system update 3, the libumem.so library, and the modular debugger mdb can be used to debug memory leaks.">Find Leaks with the libumem Tool</a>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="JSTGD289"></a>
<div class="props_rev_3"><a id="GUID-7AF676F1-D313-4AE2-BE62-37176A103A13"></a>
<h3 id="JSTGD-GUID-7AF676F1-D313-4AE2-BE62-37176A103A13" class="sect3">Track All Memory Allocations in the JNI Library</h3>
<div>
<p>If you write a JNI library, then consider creating a localized way to ensure that your library does not leak memory, by using a simple wrapper approach.</p>
<div class="section">
<p>The procedure in the following example is an easy localized allocation tracking approach for a JNI library. First, define the following lines in all source files.</p>
<pre dir="ltr">
#include &lt;stdlib.h&gt;
#define malloc(n) debug_malloc(n, __FILE__, __LINE__)
#define free(p) debug_free(p, __FILE__, __LINE__)
</pre>
<p>Then, you can use the functions in the following example to watch for leaks.</p>
<pre dir="ltr">
/* Total bytes allocated */
static int total_allocated;
/* Memory alignment is important */
typedef union { double d; struct {size_t n; char *file; int line;} s; } Site;
void *
debug_malloc(size_t n, char *file, int line) 
{ 
    char *rp;
    rp = (char*)malloc(sizeof(Site)+n); 
    total_allocated += n; 
    ((Site*)rp)-&gt;s.n = n;
    ((Site*)rp)-&gt;s.file = file;
    ((Site*)rp)-&gt;s.line = line;
    return (void*)(rp + sizeof(Site));
}
void 
debug_free(void *p, char *file, int line)
{
    char *rp;
    rp = ((char*)p) - sizeof(Site);
    total_allocated -= ((Site*)rp)-&gt;s.n;
    free(rp);
}
</pre>
<p>The JNI library would then need to periodically (or at shutdown) check the value of the <code class="codeph">total_allocated</code> variable to verify that it made sense. The preceding code could also be expanded to save in a linked list the allocations that remained, and report where the leaked memory was allocated. This is a localized and portable way to track memory allocations in a single set of sources. You would need to ensure that <span class="apiname">debug_free()</span> was called only with the pointer that came from <span class="apiname">debug_malloc()</span>, and you would also need to create similar functions for <span class="apiname">realloc()</span>, <span class="apiname">calloc()</span>, <span class="apiname">strdup()</span>, and so forth, if they were used.</p>
<p>A more global way to look for native heap memory leaks involves interposition of the library calls for the entire process.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="JSTGD292"></a>
<div class="props_rev_3"><a id="GUID-24C06368-4F3D-4332-9069-0005145E24A7"></a>
<h3 id="JSTGD-GUID-24C06368-4F3D-4332-9069-0005145E24A7" class="sect3">Track Memory Allocation with Operating System Support</h3>
<div>
<p>Tools available for tracking memory allocation in an operating system.</p>
<div class="section">
<p>Most operating systems include some form of global allocation tracking support.</p>
</div>
<!-- class="section" -->
<ul>
<li><span>On Windows, search the <a href="http://msdn.microsoft.com/library" target="_blank">MSDN library</a> for debug support. The Microsoft C++ compiler has the <code class="codeph">/Md</code> and <code class="codeph">/Mdd</code> compiler options that will automatically include extra support for tracking memory allocation.</span></li>
<li><span>Linux systems have tools such as <code class="codeph">mtrace</code> and <code class="codeph">libnjamd</code> to help in dealing with allocation tracking.</span></li>
<li><span>The Oracle Solaris operating system provides the <code class="codeph">watchmalloc</code> tool. Oracle Solaris 9 operating system update 3 also introduced the <code class="codeph">libumem</code> tool. See <a href="troubleshoot-memory-leaks.htm#GUID-28DC43A9-45EB-459C-975E-51689886126D" title="First introduced in the Oracle Solaris 9 operating system update 3, the libumem.so library, and the modular debugger mdb can be used to debug memory leaks.">Find Leaks with the libumem Tool</a>.</span></li>
</ul>
</div>
</div>
<a id="JSTGD293"></a>
<div class="props_rev_3"><a id="GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D"></a>
<h3 id="JSTGD-GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D" class="sect3">Find Leaks with the dbx Debugger</h3>
<div>
<p>The <code class="codeph">dbx</code> debugger includes the Runtime Checking (RTC) functionality, which can find leaks. The <code class="codeph">dbx</code> debugger is part of Oracle Solaris Studio and also available for Linux.</p>
<div class="section">
<p>The following example shows a sample <code class="codeph">dbx</code> session.</p>
<pre dir="ltr">
$ <span class="bold">dbx ${java_home}/bin/java</span>
Reading java
Reading ld.so.1
Reading libthread.so.1
Reading libdl.so.1
Reading libc.so.1
(dbx) <span class="bold">dbxenv rtc_inherit on</span>
(dbx) <span class="bold">check -leaks</span>
leaks checking - ON
(dbx) <span class="bold">run HelloWorld</span>
Running: java HelloWorld 
(process id 15426)
Reading rtcapihook.so
Reading rtcaudit.so
Reading libmapmalloc.so.1
Reading libgen.so.1
Reading libm.so.2
Reading rtcboot.so
Reading librtc.so
RTC: Enabling Error Checking...
RTC: Running program...
dbx: process 15426 about to exec("/net/bonsai.sfbay/export/home2/user/ws/j2se/build/solaris-i586/bin/java")
dbx: program "/net/bonsai.sfbay/export/home2/user/ws/j2se/build/solaris-i586/bin/java"
just exec'ed
dbx: to go back to the original program use "debug $oprog"
RTC: Enabling Error Checking...
RTC: Running program...
t@1 (l@1) stopped in main at 0x0805136d
0x0805136d: main       :        pushl    %ebp
(dbx) <span class="bold">when dlopen libjvm { suppress all in libjvm.so; }</span>
(2) when dlopen libjvm { suppress all in libjvm.so; }  
(dbx) <span class="bold">when dlopen libjava { suppress all in libjava.so; }</span>
(3) when dlopen libjava { suppress all in libjava.so; }  
(dbx) cont                                             
Reading libjvm.so
Reading libsocket.so.1
Reading libsched.so.1
Reading libCrun.so.1
Reading libm.so.1
Reading libnsl.so.1
Reading libmd5.so.1
Reading libmp.so.2
Reading libhpi.so
Reading libverify.so
Reading libjava.so
Reading libzip.so
Reading en_US.ISO8859-1.so.3
hello world
hello world
Checking for memory leaks...

Actual leaks report    (actual leaks:           27  total size:      46851 bytes)

  Total     Num of  Leaked     Allocation call stack
  Size      Blocks  Block
                    Address
==========  ====== =========== =======================================
     44376       4      -      calloc &lt; zcalloc 
      1072       1  0x8151c70  _nss_XbyY_buf_alloc &lt; get_pwbuf &lt; _getpwuid &lt;
                               GetJavaProperties &lt; Java_java_lang_System_initProperties &lt;
                               0xa740a89a&lt; 0xa7402a14&lt; 0xa74001fc
       814       1  0x8072518  MemAlloc &lt; CreateExecutionEnvironment &lt; main 
       280      10      -      operator new &lt; Thread::Thread 
       102       1  0x8072498  _strdup &lt; CreateExecutionEnvironment &lt; main 
        56       1  0x81697f0  calloc &lt; Java_java_util_zip_Inflater_init &lt; 0xa740a89a&lt;
                               0xa7402a6a&lt; 0xa7402aeb&lt; 0xa7402a14&lt; 0xa7402a14&lt; 0xa7402a14
        41       1  0x8072bd8  main 
        30       1  0x8072c58  SetJavaCommandLineProp &lt; main 
        16       1  0x806f180  _setlocale &lt; GetJavaProperties &lt;
                               Java_java_lang_System_initProperties &lt; 0xa740a89a&lt; 0xa7402a14&lt;
                               0xa74001fc&lt; JavaCalls::call_helper &lt; os::os_exception_wrapper 
        12       1  0x806f2e8  operator new &lt; instanceKlass::add_dependent_nmethod &lt;
                               nmethod::new_nmethod &lt; ciEnv::register_method &lt;
                               Compile::Compile #Nvariant 1 &lt; C2Compiler::compile_method &lt;
                               CompileBroker::invoke_compiler_on_method &lt;
                               CompileBroker::compiler_thread_loop 
        12       1  0x806ee60  CheckJvmType &lt; CreateExecutionEnvironment &lt; main 
        12       1  0x806ede8  MemAlloc &lt; CreateExecutionEnvironment &lt; main 
        12       1  0x806edc0  main 
         8       1  0x8071cb8  _strdup &lt; ReadKnownVMs &lt; CreateExecutionEnvironment &lt; main 
         8       1  0x8071cf8  _strdup &lt; ReadKnownVMs &lt; CreateExecutionEnvironment &lt; main 
</pre>
<p>The output shows that the <code class="codeph">dbx</code> debugger reports memory leaks if memory is not freed at the time the process is about to exit. However, memory that is allocated at initialization time and needed for the life of the process is often never freed in native code. Therefore, in such cases, the <code class="codeph">dbx</code> debugger can report memory leaks that are not really leaks.</p>
<div class="p">
<div class="infobox-note" id="GUID-E4DE7573-781F-47FC-A506-7BE3EA1EBB2D__GUID-8E64CCB7-2ABF-4F1A-8C3F-3F94514665F1">
<p class="notep1">Note:</p>
The previous example used two <code class="codeph">suppress</code> commands to suppress the leaks reported in the virtual machine: <code class="codeph">libjvm.so</code> and the Java support library, <code class="codeph">libjava.so</code>.</div>
</div>
</div>
<!-- class="section" --></div>
</div>
<a id="JSTGD295"></a>
<div class="props_rev_3"><a id="GUID-28DC43A9-45EB-459C-975E-51689886126D"></a>
<h3 id="JSTGD-GUID-28DC43A9-45EB-459C-975E-51689886126D" class="sect3">Find Leaks with the libumem Tool</h3>
<div>
<p>First introduced in the Oracle Solaris 9 operating system update 3, the <code class="codeph">libumem.so</code> library, and the modular debugger <code class="codeph">mdb</code> can be used to debug memory leaks.</p>
<div class="p">
<p>Before using <code class="codeph">libumem</code>, you must preload the <code class="codeph">libumem</code> library and set an environment variable, as shown in the following example.</p>
</div>
<!-- class="section" -->
<div class="section">
<pre dir="ltr">
$ LD_PRELOAD=libumem.so
$ export LD_PRELOAD
$ UMEM_DEBUG=default
$ export UMEM_DEBUG
</pre>
<p>Now, run the Java application, but stop it before it exits. The following example uses <code class="codeph">truss</code> to stop the process when it calls the <code class="codeph">_exit</code> system call.</p>
<pre dir="ltr">
$ truss -f -T _exit java MainClass <span class="variable">arguments</span>
</pre>
<p>At this point you can attach the <code class="codeph">mdb</code> debugger, as shown in the following example.</p>
<pre dir="ltr">
$ <span class="bold">mdb -p </span><span class="italic"><span class="bold">pid</span></span>
&gt;<span class="bold">::findleaks</span>
</pre>
<p>The <code class="codeph">::findleaks</code> command is the <code class="codeph">mdb</code> command to find memory leaks. If a leak is found, then this command prints the address of the allocation call, buffer address, and nearest symbol.</p>
<p>It is also possible to get the stack trace for the allocation that resulted in the memory leak by dumping the <code class="codeph">bufctl</code> structure. The address of this structure can be obtained from the output of the <code class="codeph">::findleaks</code> command.</p>
<p>See <a href="http://docs.oracle.com/docs/cd/E19424-01/820-4814/geogv/" target="_blank">analyzing memory leaks using <code class="codeph">libumem</code></a> for troubleshooting the cause for a memory leak.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment340">
<tr>
<td class="cellalignment347">
<table class="cellalignment345">
<tr>
<td class="cellalignment344"><a href="diagnostic-tools.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment344"><a href="troubleshoot-performance-issues-using-jfr.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1995, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment349">
<table class="cellalignment343">
<tr>
<td class="cellalignment344"><a href="http://docs.oracle.com/javase/10/index.html"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment344"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment344"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
