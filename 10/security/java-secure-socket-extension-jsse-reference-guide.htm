<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Java Secure Socket Extension (JSSE) Reference Guide</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="description" content="The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the SSL, TLS, and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication." />
<meta name="dcterms.created" content="2018-03-13T07:25:33Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Java Platform, Standard Edition Security Developer&rsquo;s Guide" />
<meta name="dcterms.identifier" content="E91076-01" />
<meta name="dcterms.isVersionOf" content="JSSEC" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1993, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="http://docs.oracle.com/javase/10/index.html" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="kerberos-5-gss-api-mechanism.htm" title="Previous" type="text/html" />
<link rel="Next" href="running-jsse-sample-code1.htm" title="Next" type="text/html" />
<link rel="alternate" href="JSSEC.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345"></a> <span id="PAGE" style="display:none;">45/59</span> <!-- End Header -->
<script  >
//<![CDATA[
window.name='java-secure-socket-extension-jsse-reference-guide'
//]]>
</script> <script  >
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en-us" ><head><title>');
   
    msg.document.write('Footnote&amp;nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
</script><noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<h1 id="JSSEC-GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345" class="sect1"><span class="enumeration_chapter">8</span> Java Secure Socket Extension (JSSE) Reference Guide</h1>
<div>
<p>The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the SSL, TLS, and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.</p>
</div>
<div class="sect2"><a id="GUID-0EF5DA4E-856C-4AD2-A9FD-0837C5881DDA"></a>
<h2 id="JSSEC-GUID-0EF5DA4E-856C-4AD2-A9FD-0837C5881DDA" class="sect2">Introduction to JSSE</h2>
<div>
<p>Data that travels across a network can easily be accessed by someone who is not the intended recipient. When the data includes private information, such as passwords and credit card numbers, steps must be taken to make the data unintelligible to unauthorized parties. It is also important to ensure that the data has not been modified, either intentionally or unintentionally, during transport. The Secure Sockets Layer (SSL) and Transport Layer Security (TLS) protocols were designed to help protect the privacy and integrity of data while it is being transferred across a network.</p>
<div class="section">
<p>The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the SSL and TLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication. Using JSSE, developers can provide for the secure passage of data between a client and a server running any application protocol (such as HTTP, Telnet, or FTP) over TCP/IP. For an introduction to SSL, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-69ECD56C-3B20-47F4-AEF0-A06EFA13A61D" title="Secure Sockets Layer (SSL) is the most widely used protocol for implementing cryptography on the web. SSL uses a combination of cryptographic processes to provide secure communication over a network. This section provides an introduction to SSL and the cryptographic processes it uses.">Secure Sockets Layer (SSL) Protocol Overview</a>.</p>
<p>By abstracting the complex underlying security algorithms and handshaking mechanisms, JSSE minimizes the risk of creating subtle but dangerous security vulnerabilities. Furthermore, it simplifies application development by serving as a building block that developers can integrate directly into their applications.</p>
<p>JSSE provides both an application programming interface (API) framework and an implementation of that API. The JSSE API supplements the core network and cryptographic services defined by the <code class="codeph">java.security</code> and <code class="codeph">java.net</code> packages by providing extended networking socket classes, trust managers, key managers, SSL contexts, and a socket factory framework for encapsulating socket creation behavior. Because the <code class="codeph">SSLSocket</code> class is based on a blocking I/O model, the Java Development Kit (JDK) includes a nonblocking <code class="codeph">SSLEngine</code> class to enable implementations to choose their own I/O methods.</p>
<p>The JSSE API supports the following security protocols:</p>
<ul style="list-style-type: disc;">
<li>
<p>SSL: version 3.0</p>
</li>
<li>
<p>TLS: version 1.0, 1.1, and 1.2</p>
</li>
<li>
<p>DTLS: versions 1.0 and 1.2</p>
</li>
</ul>
<p>These security protocols encapsulate a normal bidirectional stream socket, and the JSSE API adds transparent support for authentication, encryption, and integrity protection.sions. Note that the JSSE implementation that is shipped with the JDK does not implement SSL 2.0.</p>
<p>JSSE is a security component of the Java SE platform, and is based on the same design principles found elsewhere in the <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>Java Cryptography Architecture (JCA) Reference Guide</a> framework. This framework for cryptography-related security components allows them to have implementation independence and, whenever possible, algorithm independence. JSSE uses the <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">Cryptographic Service Providers</a> defined by the JCA framework.</p>
<p>Other security components in the Java SE platform include the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/JAASRefGuide.html" target="_blank">Java Authentication and Authorization Service (JAAS) Reference Guide</a> and the <a class="olink JSWOR691" target="_blank" href="../tools/security-tools-and-commands.htm#JSWOR691">Java Security Tools</a>. JSSE encompasses many of the same concepts and algorithms as those in JCA but automatically applies them underneath a simple stream socket API.</p>
<p>The JSSE API was designed to allow other SSL/TLS/DTLS protocol and Public Key Infrastructure (PKI) implementations to be plugged in seamlessly. Developers can also provide alternative logic to determine if remote hosts should be trusted or what authentication key material should be sent to a remote host.</p>
</div>
<!-- class="section" --></div>
<div class="sect3"><a id="GUID-F069F4ED-DF2C-4B3B-90FB-F89E700CF21A"></a>
<h3 id="JSSEC-GUID-F069F4ED-DF2C-4B3B-90FB-F89E700CF21A" class="sect3">JSSE Features and Benefits</h3>
<div>
<p>JSSE includes the following important benefits and features:</p>
<ul style="list-style-type: disc;">
<li>Included as a standard component of the JDK</li>
<li>Extensible, provider-based architecture</li>
<li>Implemented in 100% pure Java</li>
<li>Provides API support for SSL/TLS/DTLS</li>
<li>Provides implementations of SSL 3.0, TLS (versions 1.0, 1.1, and 1.2), and DTLS (versions 1.0 and 1.2)</li>
<li>Includes classes that can be instantiated to create secure channels (<code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code>, and <code class="codeph">SSLEngine</code>)</li>
<li>Provides support for cipher suite negotiation, which is part of the SSL/TLS/DTLS handshaking used to initiate or verify secure communications</li>
<li>Provides support for client and server authentication, which is part of the normal SSL/TLS/DTLS handshaking</li>
<li>Provides support for HTTP encapsulated in the SSL/TLS protocol, which allows access to data such as web pages using HTTPS</li>
<li>Provides server session management APIs to manage memory-resident SSL sessions</li>
<li>Provides support for server name indication extension, which facilitates secure connections to virtual servers.</li>
<li>Provides support for certificate status request extension (OCSP stapling), which saves client certificate validation round-trips and resources.</li>
<li>Provides support for Server Name Indication (SNI) Extension, which extends the SSL/TLS/DTLS protocols to indicate what server name the client is attempting to connect to during handshaking.</li>
<li>Provides support for endpoint identification during handshaking, which prevents man-in-the-middle attacks.</li>
<li>Provides support for cryptographic algorithm constraints, which provides fine-grained control over algorithms negotiated by JSSE.</li>
</ul>
<p>JSSE uses the following cryptographic algorithms:</p>
<div class="tblformal" id="GUID-F069F4ED-DF2C-4B3B-90FB-F89E700CF21A__GUID-7DC2C301-C20F-4381-9B3F-9376E97783B2">
<p class="titleintable">Table 8-1 Cryptographic Algorithms Used by JSSE</p>
<table class="cellalignment466" title="Cryptographic Algorithms Used by JSSE" summary="List of cryptographic algorithms used by JSSE">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" id="d108102e141">Cryptographic Functionality</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e143">Cryptographic Algorithm<a id="fn_1" href="#fn_1" onclick='footdisplay(1,"The SunJSSE implementation uses the Java Cryptography Architecture (JCA) for all its cryptographic algorithms.")'><sup>Foot&nbsp;1</sup></a></th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e154">Key Lengths (Bits)<a id="fn_2" href="#fn_2" onclick='footdisplay(2,"A JSSE provider may disable or deactivate weak algorithms and weak keys.")'><sup>Foot&nbsp;2</sup></a></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e160" headers="d108102e141">Bulk encryption</td>
<td class="cellalignment456" headers="d108102e160 d108102e143">Advanced Encryption Standard (AES)</td>
<td class="cellalignment456" headers="d108102e160 d108102e154">256<a id="fn_3" href="#fn_3" onclick='footdisplay(3,"Cipher suites that use AES_256 require the appropriate Java Cryptography Extension (JCE) unlimited strength jurisdiction policy file set, which is included in the JDK. By default, the active cryptography policy is unlimited. See Cryptographic Strength Configuration.")'><sup>Foot&nbsp;3</sup></a>
<p>128</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e176" headers="d108102e141">Bulk encryption</td>
<td class="cellalignment456" headers="d108102e176 d108102e143">Data Encryption Standard (DES)</td>
<td class="cellalignment456" headers="d108102e176 d108102e154">64 (56 effective)
<p>64 (40 effective)</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e185" headers="d108102e141">Bulk encryption</td>
<td class="cellalignment456" headers="d108102e185 d108102e143">Rivest Cipher 4 (RC4)</td>
<td class="cellalignment456" headers="d108102e185 d108102e154">128
<p>128 (40 effective)</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e194" headers="d108102e141">Bulk encryption</td>
<td class="cellalignment456" headers="d108102e194 d108102e143">Triple DES (3DES)</td>
<td class="cellalignment456" headers="d108102e194 d108102e154">192 (112 effective)</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e201" headers="d108102e141">Hash algorithm</td>
<td class="cellalignment456" headers="d108102e201 d108102e143">Message Digest Algorithm (MD5)</td>
<td class="cellalignment456" headers="d108102e201 d108102e154">128</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e208" headers="d108102e141">Hash algorithm</td>
<td class="cellalignment456" headers="d108102e208 d108102e143">Secure Hash Algorithm 1 (SHA1)</td>
<td class="cellalignment456" headers="d108102e208 d108102e154">160</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e215" headers="d108102e141">Hash algorithm</td>
<td class="cellalignment456" headers="d108102e215 d108102e143">Secure Hash Algorithm 224 (SHA224)</td>
<td class="cellalignment456" headers="d108102e215 d108102e154">224</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e222" headers="d108102e141">Hash algorithm</td>
<td class="cellalignment456" headers="d108102e222 d108102e143">Secure Hash Algorithm 256 (SHA256)</td>
<td class="cellalignment456" headers="d108102e222 d108102e154">256</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e229" headers="d108102e141">Hash algorithm</td>
<td class="cellalignment456" headers="d108102e229 d108102e143">Secure Hash Algorithm 384 (SHA384)</td>
<td class="cellalignment456" headers="d108102e229 d108102e154">384</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e236" headers="d108102e141">Hash algorithm</td>
<td class="cellalignment456" headers="d108102e236 d108102e143">Secure Hash Algorithm 512 (SHA512)</td>
<td class="cellalignment456" headers="d108102e236 d108102e154">512</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e243" headers="d108102e141">Authentication</td>
<td class="cellalignment456" headers="d108102e243 d108102e143">Digital Signature Algorithm (DSA)</td>
<td class="cellalignment456" headers="d108102e243 d108102e154">1024, 2048, 3072</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e251" headers="d108102e141">Authentication</td>
<td class="cellalignment456" headers="d108102e251 d108102e143">Elliptic Curve Digital Signature Algorithm (ECDSA)</td>
<td class="cellalignment456" headers="d108102e251 d108102e154">160 through 512</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e258" headers="d108102e141">Authentication and key exchange</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e258 d108102e143">Rivest-Shamir-Adleman (RSA)</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e258 d108102e154">512 and larger</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e265" headers="d108102e141">Key exchange</td>
<td class="cellalignment456" headers="d108102e265 d108102e143">Static Elliptic Curve Diffie-Hellman (ECDH)</td>
<td class="cellalignment456" headers="d108102e265 d108102e154">160 through 512</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e272" headers="d108102e141">Key exchange</td>
<td class="cellalignment456" headers="d108102e272 d108102e143">Ephemeral Elliptic Curve Diffie-Hellman (ECDHE)</td>
<td class="cellalignment456" headers="d108102e272 d108102e154">160 through 512</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e279" headers="d108102e141">Key agreement</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e279 d108102e143">Diffie-Hellman (DH)</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e279 d108102e154">512, 768, 1024, 2048, 3072, 4096, 6144, 8192</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1</sup> The SunJSSE implementation uses the <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>Java Cryptography Architecture (JCA)</a> for all its cryptographic algorithms.</p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2</sup> A JSSE provider may disable or deactivate weak algorithms and weak keys.</p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;3</sup> Cipher suites that use AES_256 require the appropriate Java Cryptography Extension (JCE) unlimited strength jurisdiction policy file set, which is included in the JDK. By default, the active cryptography policy is unlimited. See <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1">Cryptographic Strength Configuration</a>.</p>
</div>
</div>
<div class="sect3"><a id="GUID-2DF22C2B-C32E-4665-BB4B-E9510865FDC0"></a>
<h3 id="JSSEC-GUID-2DF22C2B-C32E-4665-BB4B-E9510865FDC0" class="sect3">JSSE Standard API</h3>
<div>
<p>The JSSE standard API, available in the <code class="codeph">javax.net</code> and <code class="codeph">javax.net.ssl</code> packages, provides:</p>
<ul style="list-style-type: disc;">
<li>Secure sockets tailored to client and server-side applications.</li>
<li>A non-blocking engine for producing and consuming streams of SSL/TLS/DTLS data (<code class="codeph">SSLEngine</code>).</li>
<li>Factories for creating sockets, server sockets, SSL sockets, and SSL server sockets. By using socket factories, you can encapsulate socket creation and configuration behavior.</li>
<li>A class representing a secure socket context that acts as a factory for secure socket factories and engines.</li>
<li>Key and trust manager interfaces (including X.509-specific key and trust managers), and factories that can be used for creating them.</li>
<li>A class for secure HTTP URL connections (HTTPS).</li>
</ul>
</div>
</div>
<div class="sect3"><a id="GUID-59EC25A8-4CE4-4D94-896B-8E6FB23C2838"></a>
<h3 id="JSSEC-GUID-59EC25A8-4CE4-4D94-896B-8E6FB23C2838" class="sect3">SunJSSE Provider</h3>
<div>
<p>Oracle's implementation of Java SE includes a JSSE provider named <span class="variable">SunJSSE</span>, which comes preinstalled and preregistered with the JCA. This provider supplies the following cryptographic services:</p>
<ul style="list-style-type: disc;">
<li>An implementation of the SSL 3.0, TLS (versions 1.0, 1.1, and 1.2), and DTLS (versions 1.0 and 1.2) security protocols.</li>
<li>An implementation of the most common SSL, TLS, and DTLS cipher suites. This implementation encompasses a combination of authentication, key agreement, encryption, and integrity protection.</li>
<li>An implementation of an X.509-based key manager that chooses appropriate authentication keys from a standard JCA keystore.</li>
<li>An implementation of an X.509-based trust manager that implements rules for certificate chain path validation.</li>
</ul>
<p>See <a href="oracle-providers.htm#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">The SunJSSE Provider</a>.</p>
</div>
</div>
<div class="sect3"><a id="GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA"></a>
<h3 id="JSSEC-GUID-DF5DA7C2-7B13-4341-B8F2-E4A64F8C0FFA" class="sect3">JSSE Related Documentation</h3>
<div>
<p>The following list contains links to online documentation and names of books about related subjects:</p>
<div class="section">
<p class="subhead3">JSSE API Documentation</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/package-summary.html" target="_blank"><span class="apiname">javax.net</span></a> package</p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/package-summary.html" target="_blank"><span class="apiname">javax.net.ssl</span></a> package</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Java SE Security</p>
<ul style="list-style-type: disc;">
<li>
<p>The <a href="http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html" target="_blank">Java SE Security</a> home page</p>
</li>
<li>
<p>The <a href="https://docs.oracle.com/javase/tutorial/security/" target="_blank">Security Features in Java SE</a> trail of the Java Tutorial</p>
</li>
<li>
<p><a href="java-pki-programmers-guide.htm#GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" title="The Java Certification Path API consists of classes and interfaces for handling certification paths, which are also called certification chains. If a certification path meets certain validation rules, it may be used to securely establish the mapping of a public key to a subject.">Java PKI Programmers Guide</a></p>
</li>
<li>
<p><a href="http://www.oracle.com/technetwork/java/javaee/gong-135902.html" target="_blank">Inside Java 2 Platform Security, Second Edition: Architecture, API Design and Implementation</a></p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Cryptography</p>
<ul style="list-style-type: disc;">
<li>
<p>The <a href="http://people.csail.mit.edu/rivest/crypto-security.html" target="_blank">Cryptography and Security</a> page by Dr. Ronald L. Rivest (no longer maintained)</p>
</li>
<li>
<p><cite>Applied Cryptography</cite>, Second Edition by Bruce Schneier. John Wiley and Sons, Inc., 1996.</p>
</li>
<li>
<p><cite>Cryptography Theory and Practice</cite> by Doug Stinson. CRC Press, Inc., 1995. Third edition published in 2005.</p>
</li>
<li>
<p><cite>Cryptography &amp; Network Security: Principles &amp; Practice</cite> by William Stallings. Prentice Hall, 1998. Fifth edition published in 2010.</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Secure Sockets Layer (SSL)</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="https://www.rfc-editor.org/rfc/rfc6101.txt" target="_blank">The Secure Sockets Layer (SSL) Protocol Version 3.0 RFC</a></p>
</li>
<li>
<p><a href="http://www.ietf.org/rfc/rfc2246.txt" target="_blank">The TLS Protocol Version 1.0 RFC</a></p>
</li>
<li>
<p><a href="http://www.ietf.org/rfc/rfc2818.txt" target="_blank">HTTP Over TLS RFC</a></p>
</li>
<li>
<p><cite>SSL and TLS: Designing and Building Secure Systems</cite> by Eric Rescorla. Addison Wesley Professional, 2000.</p>
</li>
<li>
<p><cite>SSL and TLS Essentials: Securing the Web</cite> by Stephen Thomas. John Wiley and Sons, Inc., 2000.</p>
</li>
<li>
<p><cite>Java 2 Network Security</cite>, Second Edition, by Marco Pistoia, Duane F Reller, Deepak Gupta, Milind Nagnur, and Ashok K Ramani. Prentice Hall, 1999.</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Transport Layer Security (TLS)</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="http://www.ietf.org/rfc/rfc2246.txt" target="_blank">The TLS Protocol Version 1.0 RFC</a></p>
</li>
<li>
<p><a href="https://www.ietf.org/rfc/rfc4346.txt" target="_blank">The TLS Protocol Version 1.1 RFC</a></p>
</li>
<li>
<p><a href="https://www.ietf.org/rfc/rfc5246.txt" target="_blank">The TLS Protocol Version 1.2 RFC</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6066.txt" target="_blank">Transport Layer Security (TLS) Extensions</a></p>
</li>
<li>
<p><a href="http://www.ietf.org/rfc/rfc2818.txt" target="_blank">HTTP Over TLS RFC</a></p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Datagram Transport Layer Security (DTLS)</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="https://tools.ietf.org/html/rfc4347.txt" target="_blank">The DTLS Protocol Version 1.0 RFC</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6347.txt" target="_blank">The DTLS Protocol Version 1.2 RFC</a></p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">U.S. Encryption Policies</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="http://www.commerce.gov/" target="_blank">U.S. Department of Commerce</a></p>
</li>
<li>
<p><a href="http://www.techceocouncil.org" target="_blank">Technology CEO Council</a></p>
</li>
<li>
<p>Current export policies: <a href="https://www.bis.doc.gov/index.php/policy-guidance/encryption" target="_blank">Encryption and Export Administration Regulations (EAR)</a></p>
</li>
<li>
<p><a href="http://csrc.nist.gov/publications/index.html" target="_blank">NIST Computer Security Publications</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect2"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329"></a>
<h2 id="JSSEC-GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329" class="sect2">Terms and Definitions</h2>
<div>
<p>The following are commonly used cryptography terms and their definitions.</p>
<div class="section">
<dl>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-075E9DFF-524E-4884-876F-34F1AA3882AA"><!-- --></a>authentication</dt>
<dd>
<p>The process of confirming the identity of a party with whom one is communicating.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-7FF9BA53-CF01-4D61-A040-D569A1A49EDE"><!-- --></a>certificate</dt>
<dd>
<p>A digitally signed statement vouching for the identity and public key of an entity (person, company, and so on). Certificates can either be self-signed or issued by a Certificate Authority (CA) an entity that is trusted to issue valid certificates for other entities. Well-known CAs include Comodo, Entrust, and GoDaddy. X509 is a common certificate format that can be managed by the JDK's <code class="codeph">keytool</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-AA9858E7-5643-40A3-B495-83C296EBC4BB"><!-- --></a>cipher suite</dt>
<dd>
<p>A combination of cryptographic parameters that define the security algorithms and key sizes used for authentication, key agreement, encryption, and integrity protection.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-909E701D-8DA3-4DA2-8270-EEF43AE39BEB"><!-- --></a>cryptographic hash function</dt>
<dd>
<p>An algorithm that is used to produce a relatively small fixed-size string of bits (called a hash) from an arbitrary block of data. A cryptographic hash function is similar to a checksum and has three primary characteristics: it&rsquo;s a one-way function, meaning that it is not possible to produce the original data from the hash; a small change in the original data produces a large change in the resulting hash; and it doesn&rsquo;t require a cryptographic key.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-60304F31-E57E-4DF6-8A0F-ED84B5EDEFBF"><!-- --></a>Cryptographic Service Provider (CSP)</dt>
<dd>
<p>Sometimes referred to simply as <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">providers</a> for short, the Java Cryptography Architecture (JCA) defines it as a package (or set of packages) that implements one or more engine classes for specific cryptographic algorithms. An engine class defines a cryptographic service in an abstract fashion without a concrete implementation.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-6649F852-7B07-422E-B564-31C78CE6F722"><!-- --></a>Datagram Transport Layer Security (DTLS) Protocol</dt>
<dd>
<p>A protocol that manages client and server authentication, data integrity, and encrypted communication between the client and server based on an unreliable transport channel such as UDP.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-AA38F0B8-97E2-410E-BAA4-4BECE30D36A5"><!-- --></a>decryption</dt>
<dd>
<p>See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__ENCRYPTION_DECRYPTION_TERM_JSSEREFGUIDE">encryption/decryption</a>.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-2BBD1416-FE35-4349-B19E-00DBAE4A2157"><!-- --></a>digital signature</dt>
<dd>
<p>A digital equivalent of a handwritten signature. It is used to ensure that data transmitted over a network was sent by whoever claims to have sent it and that the data has not been modified in transit. For example, an RSA-based digital signature is calculated by first computing a cryptographic hash of the data and then encrypting the hash with the sender's private key.</p>
</dd>
<dt class="dlterm" id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__ENCRYPTION_DECRYPTION_TERM_JSSEREFGUIDE"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-0DEFA86F-0CD5-47F0-B646-A839235155D2"><!-- --></a>encryption/decryption</dt>
<dd>
<p>Encryption is the process of using a complex algorithm to convert an original message (<span>cleartext</span>) to an encoded message (<span>ciphertext</span>) that is unintelligible unless it is decrypted. Decryption is the inverse process of producing cleartext from ciphertext.</p>
<p>The algorithms used to encrypt and decrypt data typically come in two categories: secret key (<span>symmetric</span>) cryptography and public key (<span>asymmetric</span>) cryptography.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-25F35B62-4DF2-41E8-AB27-4CAEE441D1BC"><!-- --></a>endpoint identification</dt>
<dd>
<p>An IPv4 or IPv6 address used to identify an endpoint on the network.</p>
<p>Endpoint identification procedures are handled during SSL/TLS handshake.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-1B478F10-1ADC-4F49-9A48-EAE466C590CE"><!-- --></a>handshake protocol</dt>
<dd>
<p>The negotiation phase during which the two socket peers agree to use a new or existing session. The handshake protocol is a series of messages exchanged over the record protocol. At the end of the handshake, new connection-specific encryption and integrity protection keys are generated based on the key agreement secrets in the session.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-56B237A2-73C5-4403-9B88-A875D527F7E8"><!-- --></a><span class="italic">java-home</span></dt>
<dd>
<p>Variable placeholder used throughout this document to refer to the directory where the Java Development Kit (JDK) is installed.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-D64212F7-DDE3-44E4-8CE1-9321BA096EC6"><!-- --></a>key agreement</dt>
<dd>
<p>A method by which two parties cooperate to establish a common key. Each side generates some data, which is exchanged. These two pieces of data are then combined to generate a key. Only those holding the proper private initialization data can obtain the final key. Diffie-Hellman (DH) is the most common example of a key agreement algorithm.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-C11E0DE5-5263-42BE-8E22-45A6B8497484"><!-- --></a>key exchange</dt>
<dd>
<p>A method by which keys are exchanged. One side generates a private key and encrypts it using the peer's public key (typically RSA). The data is transmitted to the peer, who decrypts the key using the corresponding private key.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-D7CAC72A-2714-4C9B-88E2-7F317DE94CEE"><!-- --></a>key manager/trust manager</dt>
<dd>
<p>Key managers and trust managers use keystores for their key material. A key manager manages a keystore and supplies public keys to others as needed (for example, for use in authenticating the user to others). A trust manager decides who to trust based on information in the truststore it manages.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-E3D57C3C-21D3-47E2-95BC-1B2825E8AFCB"><!-- --></a>keystore/truststore</dt>
<dd>
<p>A keystore is a database of key material. Key material is used for a variety of purposes, including authentication and data integrity. Various types of keystores are available, including PKCS12 and Oracle's JKS.</p>
<p>Generally speaking, keystore information can be grouped into two categories: key entries and trusted certificate entries. A key entry consists of an entity's identity and its private key, and can be used for a variety of cryptographic purposes. In contrast, a trusted certificate entry contains only a public key in addition to the entity's identity. Thus, a trusted certificate entry can&rsquo;t be used where a private key is required, such as in a <code class="codeph">javax.net.ssl.KeyManager</code>. In the JDK implementation of JKS, a keystore may contain both key entries and trusted certificate entries.</p>
<p>A truststore is a keystore that is used when making decisions about what to trust. If you receive data from an entity that you already trust, and if you can verify that the entity is the one that it claims to be, then you can assume that the data really came from that entity.</p>
<p>An entry should only be added to a truststore if the user trusts that entity. By either generating a key pair or by importing a certificate, the user gives trust to that entry. Any entry in the truststore is considered a trusted entry.</p>
<p>It may be useful to have two different keystore files: one containing just your key entries, and the other containing your trusted certificate entries, including CA certificates. The former contains private information, whereas the latter does not. Using two files instead of a single keystore file provides a cleaner separation of the logical distinction between your own certificates (and corresponding private keys) and others' certificates. To provide more protection for your private keys, store them in a keystore with restricted access, and provide the trusted certificates in a more publicly accessible keystore if needed.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-4B34D2B2-316D-486B-9472-56AAA9C25C6A"><!-- --></a>message authentication code (MAC)</dt>
<dd>
<p>Provides a way to check the integrity of information transmitted over or stored in an unreliable medium, based on a secret key. Typically, MACs are used between two parties that share a secret key in order to validate information transmitted between these parties.</p>
<p>A MAC mechanism that is based on cryptographic hash functions is referred to as HMAC. HMAC can be used with any cryptographic hash function, such as Message Digest 5 (MD5) and the Secure Hash Algorithm (SHA-256), in combination with a secret shared key. HMAC is specified in RFC 2104.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-7DFACB29-B03D-4FCF-B0F6-3A03D703AE37"><!-- --></a>public-key cryptography</dt>
<dd>
<p>A cryptographic system that uses an encryption algorithm in which two keys are produced. One key is made public, whereas the other is kept private. The public key and the private key are cryptographic inverses; what one key encrypts only the other key can decrypt. Public-key cryptography is also called <span>asymmetric cryptography</span>.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-1270AA98-9C99-475F-B98E-5A4B36F2D772"><!-- --></a>Record Protocol</dt>
<dd>
<p>A protocol that packages all data (whether application-level or as part of the handshake process) into discrete records of data much like a TCP stream socket converts an application byte stream into network packets. The individual records are then protected by the current encryption and integrity protection keys.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-92FD0D23-A4E1-4472-87D3-E569B0BD206F"><!-- --></a>secret-key cryptography</dt>
<dd>
<p>A cryptographic system that uses an encryption algorithm in which the same key is used both to encrypt and decrypt the data. Secret-key cryptography is also called <span>symmetric cryptography</span>.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-1EAB6FA7-7147-45D0-AAA1-9B3C82616A38"><!-- --></a>Secure Sockets Layer (SSL) Protocol</dt>
<dd>
<p>A protocol that manages client and server authentication, data integrity, and encrypted communication between the client and server.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-9CDD96C7-62D6-436A-ACF0-900C955673EC"><!-- --></a>session</dt>
<dd>
<p>A named collection of state information including authenticated peer identity, cipher suite, and key agreement secrets that are negotiated through a secure socket handshake and that can be shared among multiple secure socket instances.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-F6D857BB-D1B9-4E43-AEB4-FB6840216E6D"><!-- --></a>Transport Layer Security (TLS) Protocol</dt>
<dd>
<p>A protocol that manages client and server authentication, data integrity, and encrypted communication between the client and server based on a reliable transport channel such as TCP.</p>
<p>TLS 1 is the successor of the SSL 3.0 protocol.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-8E9201DB-D0D5-4DFB-AB72-CDBF7C797D92"><!-- --></a>trust manager</dt>
<dd>
<p>See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-D7CAC72A-2714-4C9B-88E2-7F317DE94CEE">"key manager/trust manager"</a>.</p>
</dd>
<dt class="dlterm"><a id="GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-4B18A49C-1C39-49B9-B650-AA22C80AF68D"><!-- --></a>truststore</dt>
<dd>
<p>See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329__GUID-E3D57C3C-21D3-47E2-95BC-1B2825E8AFCB">"keystore/truststore"</a>.</p>
</dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<div class="sect2"><a id="GUID-69ECD56C-3B20-47F4-AEF0-A06EFA13A61D"></a>
<h2 id="JSSEC-GUID-69ECD56C-3B20-47F4-AEF0-A06EFA13A61D" class="sect2">Secure Sockets Layer (SSL) Protocol Overview</h2>
<div>
<p>Secure Sockets Layer (SSL) is the most widely used protocol for implementing cryptography on the web. SSL uses a combination of cryptographic processes to provide secure communication over a network. This section provides an introduction to SSL and the cryptographic processes it uses.</p>
<div class="section">
<p>SSL provides a secure enhancement to the standard TCP/IP sockets protocol used for Internet communications. As shown in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-69ECD56C-3B20-47F4-AEF0-A06EFA13A61D__GUID-44FB6EEC-B8FB-410E-8FB8-8E74A2F6CC06" title="List of protocols supported in each layer of the TCP/IP protocol stack.">Table 8-2</a>, the secure sockets layer is added between the transport layer and the application layer in the standard TCP/IP protocol stack. The application most commonly used with SSL is Hypertext Transfer Protocol (HTTP), the protocol for Internet web pages. Other applications, such as Net News Transfer Protocol (NNTP), Telnet, Lightweight Directory Access Protocol (LDAP), Interactive Message Access Protocol (IMAP), and File Transfer Protocol (FTP), can be used with SSL as well.</p>
<div class="tblformal" id="GUID-69ECD56C-3B20-47F4-AEF0-A06EFA13A61D__GUID-44FB6EEC-B8FB-410E-8FB8-8E74A2F6CC06">
<p class="titleintable">Table 8-2 TCP/IP Protocol Stack with SSL</p>
<table class="cellalignment468" title="TCP/IP Protocol Stack with SSL" summary="List of protocols supported in each layer of the TCP/IP protocol stack.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e822">TCP/IP Layer</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e824">Protocol</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e828" headers="d108102e822">Application Layer</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e828 d108102e824">HTTP, NNTP, Telnet, FTP, and so on</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e833" headers="d108102e822">Secure Sockets Layer</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e833 d108102e824">SSL</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e838" headers="d108102e822">Transport Layer</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e838 d108102e824">TCP</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e843" headers="d108102e822">Internet Layer</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e843 d108102e824">IP</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>SSL was developed by Netscape in 1994, and with input from the Internet community, has evolved to become a standard. It is now under the control of the international standards organization, the Internet Engineering Task Force (IETF). The IETF renamed SSL to Transport Layer Security (TLS), and released the first specification, version 1.0, in January 1999. TLS 1.0 is a modest upgrade to the most recent version of SSL, version 3.0. This upgrade corrected defects in previous versions and prohibited the use of known weak algorithms. TLS 1.1 was released in April 2006, and TLS 1.2 in August 2008.</p>
</div>
<!-- class="section" --></div>
<div class="sect3"><a id="GUID-4F882170-B4A9-4E61-8411-6D7194B32FED"></a>
<h3 id="JSSEC-GUID-4F882170-B4A9-4E61-8411-6D7194B32FED" class="sect3">Why Use SSL?</h3>
<div>
<p>Transferring sensitive information over a network can be risky due to the following issues:</p>
<ul style="list-style-type: disc;">
<li>You can&rsquo;t always be sure that the entity with whom you are communicating is really who you think it is.</li>
<li>Network data can be intercepted, so it&rsquo;s possible that it can be read by an unauthorized third party, sometimes known as an attacker.</li>
<li>An attacker who intercepts data may be able to modify it before sending it on to the receiver.</li>
</ul>
<p>SSL addresses each of these issues. It addresses the first issue by optionally allowing each of two communicating parties to ensure the identity of the other party in a process called authentication. After the parties are authenticated, SSL provides an encrypted connection between the two parties for secure message transmission. Encrypting the communication between the two parties provides privacy and therefore addresses the second issue. The encryption algorithms used with SSL include a secure hash function, which is similar to a checksum. This ensures that data isn&rsquo;t modified in transit. The secure hash function addresses the third issue of data integrity.</p>
<div class="infobox-note" id="GUID-4F882170-B4A9-4E61-8411-6D7194B32FED__GUID-54858195-D682-43E1-BC8F-07ED16B4211C">
<p class="notep1">Note:</p>
Both authentication and encryption are optional and depend on the negotiated cipher suites between the two entities.</div>
<p>An e-commerce transaction is an obvious example of when to use SSL. In an e-commerce transaction, it would be foolish to assume that you can guarantee the identity of the server with whom you are communicating. It would be easy enough for someone to create a phony website promising great services if only you enter your credit card number. SSL allows you, the client, to authenticate the identity of the server. It also allows the server to authenticate the identity of the client, although in Internet transactions, this is seldom done.</p>
<p>After the client and the server are comfortable with each other's identity, SSL provides privacy and data integrity through the encryption algorithms that it uses. This allows sensitive information, such as credit card numbers, to be transmitted securely over the Internet.</p>
<p>Although SSL provides authentication, privacy, and data integrity, it doesn&rsquo;t provide nonrepudiation services. <span>Nonrepudiation</span> means that an entity that sends a message can&rsquo;t later deny sending it. When the digital equivalent of a signature is associated with a message, the communication can later be proved. SSL alone does not provide nonrepudiation.</p>
</div>
</div>
<div class="sect3"><a id="GUID-83C9697A-35B7-4962-972F-06795E705BE9"></a>
<h3 id="JSSEC-GUID-83C9697A-35B7-4962-972F-06795E705BE9" class="sect3">How SSL Works</h3>
<div>
<p>One of the reasons that SSL is effective is that it uses several different cryptographic processes. SSL uses public-key cryptography to provide authentication, and secret-key cryptography with hash functions to provide for privacy and data integrity. Before you can understand SSL, it&rsquo;s helpful to understand these cryptographic processes.</p>
</div>
</div>
<div class="sect3"><a id="GUID-AE5F865E-126F-4EF2-8333-DBEB879E06EC"></a>
<h3 id="JSSEC-GUID-AE5F865E-126F-4EF2-8333-DBEB879E06EC" class="sect3">Cryptographic Processes</h3>
<div>
<p>The primary purpose of cryptography is to make it difficult for an unauthorized third party to access and understand private communication between two parties. It is not always possible to restrict all unauthorized access to data, but private data can be made unintelligible to unauthorized parties through the process of encryption. Encryption uses complex algorithms to convert the original message (cleartext) to an encoded message (ciphertext). The algorithms used to encrypt and decrypt data that is transferred over a network typically come in two categories: secret-key cryptography and public-key cryptography.</p>
<div class="section">
<p>Both secret-key cryptography and public-key cryptography depend on the use of an agreed-upon cryptographic key or pair of keys. A key is a string of bits that is used by the cryptographic algorithm or algorithms during the process of encrypting and decrypting the data. A cryptographic key is like a key for a lock; only with the right key can you open the lock.</p>
<p>Safely transmitting a key between two communicating parties is not a trivial matter. A public key certificate enables a party to safely transmit its public key, while providing assurance to the receiver of the authenticity of the public key. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-2EEF5310-2407-45E2-A3A5-81532D247CD1">Public Key Certificates</a>.</p>
<p>The descriptions of the cryptographic processes in secret-key cryptography and public-key cryptography follow conventions widely used by the security community: the two communicating parties are labeled with the names Alice and Bob. The unauthorized third party, also known as the attacker, is named Charlie.</p>
</div>
<!-- class="section" --></div>
<div class="sect4"><a id="GUID-D2F6DDC1-9689-4BC2-B6D5-4EA13596AEB0"></a>
<h4 id="JSSEC-GUID-D2F6DDC1-9689-4BC2-B6D5-4EA13596AEB0" class="sect4">Secret-Key Cryptography</h4>
<div>
<p>With secret-key cryptography, both communicating parties, Alice and Bob, use the same key to encrypt and decrypt the messages. Before any encrypted data can be sent over the network, both Alice and Bob must have the key and must agree on the cryptographic algorithm that they will use for encryption and decryption</p>
<p>One of the major problems with secret-key cryptography is the logistical issue of how to get the key from one party to the other without allowing access to an attacker. If Alice and Bob are securing their data with secret-key cryptography, and if Charlie gains access to their key, then Charlie can understand any secret messages he intercepts between Alice and Bob. Not only can Charlie decrypt Alice's and Bob's messages, but he can also pretend that he is Alice and send encrypted data to Bob. Bob won&rsquo;t know that the message came from Charlie, not Alice.</p>
<p>After the problem of secret key distribution is solved, secret-key cryptography can be a valuable tool. The algorithms provide excellent security and encrypt data relatively quickly. The majority of the sensitive data sent in an SSL session is sent using secret-key cryptography.</p>
<p>Secret-key cryptography is also called <span>symmetric cryptography</span> because the same key is used to both encrypt and decrypt the data. Well-known secret-key cryptographic algorithms include Advanced Encryption Standard (AES), Triple Data Encryption Standard (3DES), and Rivest Cipher 4 (RC4).</p>
</div>
</div>
<div class="sect4"><a id="GUID-0B0D23FF-1AE8-42FC-95F2-3767833D5E86"></a>
<h4 id="JSSEC-GUID-0B0D23FF-1AE8-42FC-95F2-3767833D5E86" class="sect4">Public-Key Cryptography</h4>
<div>
<p>Public-key cryptography solves the logistical problem of key distribution by using both a public key and a private key. The public key can be sent openly through the network while the private key is kept private by one of the communicating parties. The public and the private keys are cryptographic inverses of each other; what one key encrypts, the other key will decrypt.</p>
<p>Assume that Bob wants to send a secret message to Alice using public-key cryptography. Alice has both a public key and a private key, so she keeps her private key in a safe place and sends her public key to Bob. Bob encrypts the secret message to Alice using Alice's public key. Alice can later decrypt the message with her private key.</p>
<p>If Alice encrypts a message using her private key and sends the encrypted message to Bob, then Bob can be sure that the data he receives comes from Alice; if Bob can decrypt the data with Alice's public key, the message must have been encrypted by Alice with her private key, and only Alice has Alice's private key. The problem is that anybody else can read the message as well because Alice's public key is public. Although this scenario does not allow for secure data communication, it does provide the basis for digital signatures. A digital signature is one of the components of a public key certificate, and is used in SSL to authenticate a client or a server. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-2EEF5310-2407-45E2-A3A5-81532D247CD1">Public Key Certificates</a> and <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-ECC35863-046D-40D4-8B74-5F0150D4342A" title="Once a cryptographic hash is created for a message, the hash is encrypted with the sender's private key. This encrypted hash is called a digital signature.">Digital Signatures</a>.</p>
<p>Public-key cryptography is also called <span class="italic">asymmetric cryptography</span> because different keys are used to encrypt and decrypt the data. A well-known public key cryptographic algorithm often used with SSL is the Rivest Shamir Adleman (RSA) algorithm. Another public key algorithm used with SSL that is designed specifically for secret key exchange is the Diffie-Hellman (DH) algorithm. Public-key cryptography requires extensive computations, making it very slow. It is therefore typically used only for encrypting small pieces of data, such as secret keys, rather than for the bulk of encrypted data communications.</p>
</div>
</div>
<div class="sect4"><a id="GUID-694CE95C-6E3C-4F0E-9ABB-E8DCA655EAA7"></a>
<h4 id="JSSEC-GUID-694CE95C-6E3C-4F0E-9ABB-E8DCA655EAA7" class="sect4">Comparison Between Secret-Key and Public-Key Cryptography</h4>
<div>
<p>Both secret-key cryptography and public-key cryptography have strengths and weaknesses. With secret-key cryptography, data can be encrypted and decrypted quickly, but because both communicating parties must share the same secret key information, the logistics of exchanging the key can be a problem. With public-key cryptography, key exchange is not a problem because the public key does not need to be kept secret, but the algorithms used to encrypt and decrypt data require extensive computations, and are therefore very slow</p>
</div>
</div>
<div class="sect4"><a id="GUID-2EEF5310-2407-45E2-A3A5-81532D247CD1"></a>
<h4 id="JSSEC-GUID-2EEF5310-2407-45E2-A3A5-81532D247CD1" class="sect4">Public Key Certificates</h4>
<div>
<div class="section">
<p>A public key certificate provides a safe way for an entity to pass on its public key to be used in asymmetric cryptography. The public key certificate avoids the following situation: if Charlie creates his own public key and private key, he can claim that he is Alice and send his public key to Bob. Bob will be able to communicate with Charlie, but Bob will think that he is sending his data to Alice.</p>
<p>A public key certificate can be thought of as the digital equivalent of a passport. It is issued by a trusted organization and provides identification for the bearer. A trusted organization that issues public key certificates is known as a Certificate Authority (CA). The CA can be likened to a notary public. To obtain a certificate from a CA, one must provide proof of identity. Once the CA is confident that the applicant represents the organization it says it represents, the CA signs the certificate attesting to the validity of the information contained within the certificate.</p>
<p>A public key certificate contains the following fields:</p>
<dl>
<dt class="dlterm"><a id="GUID-2EEF5310-2407-45E2-A3A5-81532D247CD1__GUID-DF67D8BF-E90F-4CE0-966A-285C7EE4D31E"><!-- --></a>Issuer</dt>
<dd>The CA that issued the certificate. If a user trusts the CA that issued the certificate, and if the certificate is valid, then the user can trust the certificate.</dd>
<dt class="dlterm"><a id="GUID-2EEF5310-2407-45E2-A3A5-81532D247CD1__GUID-3C068594-4632-4DDA-9727-1F3A6091C943"><!-- --></a>Period of validity</dt>
<dd>A certificate has an expiration date. This date should be checked when verifying the validity of a certificate.</dd>
<dt class="dlterm"><a id="GUID-2EEF5310-2407-45E2-A3A5-81532D247CD1__GUID-56FADB73-2F48-4C4A-9530-DF911AEA23E3"><!-- --></a>Subject</dt>
<dd>Includes information about the entity that the certificate represents.</dd>
<dt class="dlterm"><a id="GUID-2EEF5310-2407-45E2-A3A5-81532D247CD1__GUID-5DFE9BC0-59C1-4755-A986-6864F3DC58A1"><!-- --></a>Subject's public key</dt>
<dd>The primary piece of information that the certificate provides is the subject's public key. All the other fields are provided to ensure the validity of this key.</dd>
<dt class="dlterm"><a id="GUID-2EEF5310-2407-45E2-A3A5-81532D247CD1__GUID-8AEA3D0D-F256-46CE-ABD1-2D381BBE91B6"><!-- --></a>Signature</dt>
<dd>The certificate is digitally signed by the CA that issued the certificate. The signature is created using the CA's private key and ensures the validity of the certificate. Because only the certificate is signed, not the data sent in the SSL transaction, SSL does not provide for nonrepudiation.</dd>
</dl>
<p>If Bob only accepts Alice's public key as valid when she sends it in a public key certificate, then Bob won&rsquo;t be fooled into sending secret information to Charlie when Charlie masquerades as Alice.</p>
<p>Multiple certificates may be linked in a certificate chain. When a certificate chain is used, the first certificate is always that of the sender. The next is the certificate of the entity that issued the sender's certificate. If more certificates are in the chain, then each is that of the authority that issued the previous certificate. The final certificate in the chain is the certificate for a root CA. A root CA is a public Certificate Authority that is widely trusted. Information for several root CAs is typically stored in the client's Internet browser. This information includes the CA's public key. Well-known CAs include VeriSign, Entrust, and GTE CyberTrust.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-86CD4C06-0B0F-4B0F-9C41-3EDC5658F491"></a>
<h4 id="JSSEC-GUID-86CD4C06-0B0F-4B0F-9C41-3EDC5658F491" class="sect4">Cryptographic Hash Functions</h4>
<div>
<p>When sending encrypted data, SSL typically uses a cryptographic hash function to ensure data integrity. The hash function prevents Charlie from tampering with data that Alice sends to Bob.</p>
<p>A cryptographic hash function is similar to a checksum. The main difference is that whereas a checksum is designed to detect accidental alterations in data, a cryptographic hash function is designed to detect deliberate alterations. When data is processed by a cryptographic hash function, a small string of bits, known as a <span>hash</span>, is generated. The slightest change to the message typically makes a large change in the resulting hash. A cryptographic hash function does not require a cryptographic key. A hash function often used with SSL is Secure Hash Algorithm (SHA). SHA was proposed by the <a href="http://www.nist.gov/index.html" target="_blank">U.S. National Institute of Standards and Technology (NIST)</a>.</p>
</div>
</div>
<div class="sect4"><a id="GUID-0EB1B09A-0B04-43EA-873D-1E7EE325010D"></a>
<h4 id="JSSEC-GUID-0EB1B09A-0B04-43EA-873D-1E7EE325010D" class="sect4">Message Authentication Code</h4>
<div>
<p>A message authentication code (MAC) is similar to a cryptographic hash, except that it is based on a secret key. When secret key information is included with the data that is processed by a cryptographic hash function, then the resulting hash is known as an HMAC.</p>
<p>If Alice wants to be sure that Charlie does not tamper with her message to Bob, then she can calculate an HMAC for her message and append the HMAC to her original message. She can then encrypt the message plus the HMAC using a secret key that she shares with Bob. When Bob decrypts the message and calculates the HMAC, he will be able to tell if the message was modified in transit. With SSL, an HMAC is used with the transmission of secure data.</p>
</div>
</div>
<div class="sect4"><a id="GUID-ECC35863-046D-40D4-8B74-5F0150D4342A"></a>
<h4 id="JSSEC-GUID-ECC35863-046D-40D4-8B74-5F0150D4342A" class="sect4">Digital Signatures</h4>
<div>
<p>Once a cryptographic hash is created for a message, the hash is encrypted with the sender's private key. This encrypted hash is called a digital signature.</p>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-7FCC21CB-158B-440C-B5E4-E4E5A2D7352B"></a>
<h3 id="JSSEC-GUID-7FCC21CB-158B-440C-B5E4-E4E5A2D7352B" class="sect3">The SSL Handshake</h3>
<div>
<p>Communication using SSL begins with an exchange of information between the client and the server. This exchange of information is called the SSL handshake. The SSL handshake includes the following stages:</p>
<ol>
<li><span class="bold">Negotiating the cipher suite</span>
<p>The SSL session begins with a negotiation between the client and the server as to which cipher suite they will use. A <span>cipher suite</span> is a set of cryptographic algorithms and key sizes that a computer can use to encrypt data. The cipher suite includes information about the public key exchange algorithms or key agreement algorithms, and cryptographic hash functions. The client tells the server which cipher suites it has available, and the server chooses the best mutually acceptable cipher suite.</p>
</li>
<li><span class="bold">Authenticating the server's identity (optional)</span>
<p>In SSL, the authentication step is optional, but in the example of an e-commerce transaction over the web, the client will generally want to authenticate the server. Authenticating the server allows the client to be sure that the server represents the entity that the client believes the server represents.</p>
<p>To prove that a server belongs to the organization that it claims to represent, the server presents its public key certificate to the client. If this certificate is valid, then the client can be sure of the identity of the server.</p>
<p>The client and server exchange information that allows them to agree on the same secret key. For example, with RSA, the client uses the server's public key, obtained from the public key certificate, to encrypt the secret key information. The client sends the encrypted secret key information to the server. Only the server can decrypt this message because the server's private key is required for this decryption.</p>
</li>
<li><span class="bold">Agreeing on encryption mechanisms</span>
<p>Both the client and the server now have access to the same secret key. With each message, they use the cryptographic hash function, chosen in the first step of the handshake, and shared secret information, to compute an HMAC that they append to the message. They then use the secret key and the secret key algorithm negotiated in the first step of the handshake to encrypt the secure data and the HMAC. The client and server can now communicate securely using their encrypted and hashed data.</p>
</li>
</ol>
</div>
</div>
<div class="sect3"><a id="GUID-D04EF7C1-B1D4-4611-9896-A7B5573CBEED"></a>
<h3 id="JSSEC-GUID-D04EF7C1-B1D4-4611-9896-A7B5573CBEED" class="sect3">The SSL Protocol</h3>
<div>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7FCC21CB-158B-440C-B5E4-E4E5A2D7352B">The SSL Handshake</a> provides a high-level description of the SSL handshake, which is the exchange of information between the client and the server prior to sending the encrypted message. <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-D04EF7C1-B1D4-4611-9896-A7B5573CBEED__GUID-14810B76-CBF2-4F3C-9493-DDDB93358230">Figure 8-1</a> provides more detail. It shows the sequence of messages that are exchanged in the SSL handshake. Messages that are sent only in certain situations are noted as optional. Each of the SSL messages is described in detail afterward.</p>
<div class="figure" id="GUID-D04EF7C1-B1D4-4611-9896-A7B5573CBEED__GUID-14810B76-CBF2-4F3C-9493-DDDB93358230">
<p class="titleinfigure">Figure 8-1 The SSL/TLS Handshake</p>
<img width="393" height="341" src="img/ssl-client.png" alt="This figure shows the sequence of messages that are exchanged in the SSL handshake. These messages are described in detail in the following text." title="This figure shows the sequence of messages that are exchanged in the SSL handshake. These messages are described in detail in the following text." /></div>
<!-- class="figure" -->
<p>The SSL messages are sent in the following order:</p>
<ol>
<li><span class="bold">Client hello:</span> The client sends the server information including the highest version of SSL that it supports and a list of the cipher suites that it supports (TLS 1.0 is indicated as SSL 3.1). The cipher suite information includes cryptographic algorithms and key sizes.</li>
<li><span class="bold">Server hello:</span> The server chooses the highest version of SSL and the best cipher suite that both the client and server support and sends this information to the client.</li>
<li>(Optional) <span class="bold">Certificate:</span> The server sends the client a certificate or a certificate chain. A certificate chain typically begins with the server's public key certificate and ends with the certificate authority's root certificate. This message is optional, but is used whenever server authentication is required.</li>
<li>(Optional) <span class="bold">Certificate request:</span> If the server must authenticate the client, then it sends the client a certificate request. In Internet applications, this message is rarely sent.</li>
<li>(Optional) <span class="bold">Server key exchange:</span> The server sends the client a server key exchange message if the public key information from the Certificate is not sufficient for key exchange. For example, in cipher suites based on Diffie-Hellman (DH), this message contains the server's DH public key.</li>
<li><span class="bold">Server hello done:</span> The server tells the client that it is finished with its initial negotiation messages.</li>
<li>(Optional) <span class="bold">Certificate:</span> If the server Certificate request from the client, the client sends its certificate chain, just as the server did previously.
<div class="p">
<div class="infobox-note" id="GUID-D04EF7C1-B1D4-4611-9896-A7B5573CBEED__GUID-296D3B3F-97C6-466C-BDB7-716D4EDEA51C">
<p class="notep1">Note:</p>
Only a few Internet server applications ask for a certificate from the client.</div>
</div>
</li>
<li><span class="bold">Client key exchange:</span> The client generates information used to create a key to use for symmetric encryption. For RSA, the client then encrypts this key information with the server's public key and sends it to the server. For cipher suites based on DH, this message contains the client's DH public key.</li>
<li>(Optional) <span class="bold">Certificate verify:</span> This message is sent by the client when the client presents a certificate as previously explained. Its purpose is to allow the server to complete the process of authenticating the client. When this message is used, the client sends information that it digitally signs using a cryptographic hash function. When the server decrypts this information with the client's public key, the server is able to authenticate the client.</li>
<li><span class="bold">Change cipher spec:</span> The client sends a message telling the server to change to encrypted mode.</li>
<li><span class="bold">Finished</span> The client tells the server that it is ready for secure data communication to begin.</li>
<li><span class="bold">Change cipher spec:</span> The server sends a message telling the client to change to encrypted mode.</li>
<li><span class="bold">Finished:</span> The server tells the client that it is ready for secure data communication to begin. This is the end of the SSL handshake.</li>
<li><span class="bold">Encrypted data:</span> The client and the server communicate using the symmetric encryption algorithm and the cryptographic hash function negotiated during the client hello and server hello, and using the secret key that the client sent to the server during the client key exchange. The handshake can be renegotiated at this time. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-FCA1CA1F-9FF1-4C9F-8FE8-EBFDE84F735F" title="Once the initial handshake is finished and application data is flowing, either side is free to initiate a new handshake at any time. An application might like to use a stronger cipher suite for especially critical operations, or a server application might want to require client authentication.">Handshaking Again (Renegotiation)</a>.</li>
<li><span class="bold">Close Messages:</span>At the end of the connection, each side sends a <code class="codeph">close_notify</code> alert to inform the peer that the connection is closed.</li>
</ol>
<p>If the parameters generated during an SSL session are saved, then these parameters can sometimes be reused for future SSL sessions. Saving SSL session parameters allows encrypted communication to begin much more quickly.</p>
</div>
<div class="sect4"><a id="GUID-FCA1CA1F-9FF1-4C9F-8FE8-EBFDE84F735F"></a>
<h4 id="JSSEC-GUID-FCA1CA1F-9FF1-4C9F-8FE8-EBFDE84F735F" class="sect4">Handshaking Again (Renegotiation)</h4>
<div>
<p>Once the initial handshake is finished and application data is flowing, either side is free to initiate a new handshake at any time. An application might like to use a stronger cipher suite for especially critical operations, or a server application might want to require client authentication.</p>
<p>Regardless of the reason, the new handshake takes place over the existing encrypted session, and application data and handshake messages are interleaved until a new session is established.</p>
<p>Your application can initiate a new handshake by using one of the following methods:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">SSLSocket.startHandshake()</code></li>
<li><code class="codeph">SSLEngine.beginHandshake()</code></li>
</ul>
<div class="infobox-note" id="GUID-FCA1CA1F-9FF1-4C9F-8FE8-EBFDE84F735F__GUID-B4E262C5-520F-4941-B49D-791402E56838">
<p class="notep1">Note:</p>
a protocol flaw related to renegotiation was found in 2009. The protocol and the Java SE implementation have both been fixed. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-9C767872-3A6C-4AD1-9805-49F112A0FA28" title="In the fall of 2009, a flaw was discovered in the SSL/TLS protocols. A fix to the protocol was developed by the IETF TLS Working Group, and current versions of the JDK contain this fix. This section describes the situation in much more detail, along with interoperability issues when communicating with older implementations that do not contain this protocol fix.">Transport Layer Security (TLS) Renegotiation Issue</a>.</div>
</div>
</div>
<div class="sect4"><a id="GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38"></a>
<h4 id="JSSEC-GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38" class="sect4">Cipher Suite Choice and Remote Entity Verification</h4>
<div>
<p>The SSL/TLS protocols define a specific series of steps to ensure a <span class="italic">protected</span> connection. However, the choice of cipher suite directly affects the type of security that the connection enjoys. For example, if an anonymous cipher suite is selected, then the application has no way to verify the remote peer's identity. If a suite with no encryption is selected, then the privacy of the data cannot be protected. Additionally, the SSL/TLS protocols do not specify that the credentials received must match those that peer might be expected to send. If the connection were somehow redirected to a rogue peer, but the rogue's credentials were acceptable based on the current trust material, then the connection would be considered valid.</p>
<p>When using raw <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code> classes, you should always check the peer's credentials before sending any data. The <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code> classes do not automatically verify that the host name in a URL matches the host name in the peer's credentials. An application could be exploited with URL spoofing if the host name is not verified. Since JDK 7, endpoint identification/verification procedures can be handled during SSL/TLS handshaking. See the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#getEndpointIdentificationAlgorithm--" target="_blank"><span class="apiname">SSLParameters.getEndpointIdentificationAlgorithm</span></a> method.</p>
<p>Protocols such as HTTPS (<a href="http://www.ietf.org/rfc/rfc2818.txt" target="_blank">HTTP Over TLS</a>) do require host name verification. Since JDK 7, the HTTPS endpoint identification is enforced during handshaking for <span class="apiname">HttpsURLConnection</span> by default. See the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#getEndpointIdentificationAlgorithm--" target="_blank"><span class="apiname">SSLParameters.getEndpointIdentificationAlgorithm</span></a> method. Alternatively, applications can use the <span class="apiname">HostnameVerifier</span> interface to override the default HTTPS host name rules. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587">The HostnameVerifier Interface</a> and <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863" title="The javax.net.ssl.HttpsURLConnection class extends the java.net.HttpURLConnection class and adds support for HTTPS-specific features.">HttpsURLConnection Class</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2"><a id="GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86"></a>
<h2 id="JSSEC-GUID-E1A3A7C3-309A-4415-903B-B31C96F68C86" class="sect2">Client-Driven OCSP and OCSP Stapling</h2>
<div>
<p>Use the Online Certificate Status Protocol (OCSP) to determine the X.509 certificate revocation status during the Transport Layer Security (TLS) handshake.</p>
<div class="p">X.509 certificates used in TLS can be revoked by the issuing Certificate Authority (CA) if there is reason to believe that a certificate is compromised. You can check the revocation status of certificates during the TLS handshake by using one of the following approaches.
<ul style="list-style-type: disc;">
<li><span class="bold">Certificate Revocation List (CRL)</span>
<p>A CRL is a simple list of revoked certificates. The application receiving a certificate gets the CRL from a CRL server and checks if the certificate received is on the list. There are two disadvantages to using CRLs that mean a certificate could be revoked, but the revoked certificate is not listed in the&nbsp;CRL:</p>
<ul style="list-style-type: disc;">
<li>
<p>CRLs can become very large so there can be a substantial increase in network traffic.</p>
</li>
<li>
<p>Many CRLs are created with longer validity periods, which increases the possibility of a certificate being revoked within that validity period and not showing up until the next CRL refresh.</p>
</li>
</ul>
<p>See <a href="java-pki-programmers-guide.htm#GUID-AB96FD45-6F8A-4785-B6C5-082BEB6CDA5E" title="The Java Certification Path API includes the CertStore class for retrieving certificates and CRLs from a repository.">Certificate/CRL Storage Classes</a> topic of the <cite>Java PKI Programmer's Guide</cite>.</p>
</li>
<li><span class="bold">Client-driven OCSP</span>
<p>In client-driven OCSP, the client uses OCSP to contact an OCSP responder to check the certificate&rsquo;s revocation status. The amount of data required is small, and the OCSP responder is likely to be more up-to-date with the revocation status than a CRL. Each client connecting to a server requires an OCSP response for each certificate being checked. If the server is a popular one, and&nbsp;many&nbsp;of the clients are using client&shy;-driven OCSP, these OCSP requests can&nbsp;have a negative effect on the performance of the OCSP responder.</p>
</li>
<li><span class="bold">OCSP stapling</span>
<p>OCSP stapling enables the server, rather than the client, to make the request to the OCSP responder. The server staples the OCSP response to the certificate and returns it to the client during the TLS handshake. This approach enables the presenter of the certificate, rather than the issuing CA, to bear the resource cost of providing OCSP responses. It also enables the server to cache the OCSP responses and supply them to all clients. This significantly reduces the load on the OCSP responder because the response can be cached and periodically refreshed by the server rather than by each client.</p>
</li>
</ul>
</div>
</div>
<div class="sect3"><a id="GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1"></a>
<h3 id="JSSEC-GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1" class="sect3">Client-Driven OCSP and Certificate Revocation</h3>
<div>
<p>Client-driven Online Certificate Status Protocol (OCSP) enables the client to check the certificate revocation status by connecting to an OCSP responder during the Transport Layer Security (TLS) handshake.</p>
<p>The client-driven OCSP request occurs during the TLS handshake just after the client receives the certificate from the server and validates it. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7FCC21CB-158B-440C-B5E4-E4E5A2D7352B">SSL Handshake</a>.</p>
<div class="section">
<p class="subhead3">TLS Handshake with Client-Driven OCSP</p>
<p>Client-driven OCSP is used during the TLS handshake between the client and the server to check the server certificate revocation status. After the client receives the certificate it performs certificate validation. If the validation is successful, then the client verifies that the certificate was not revoked by the issuer. This is done by sending an OCSP request to an OCSP responder. After receiving the OCSP response, the client checks this response before to completing the TLS handshake.</p>
<div class="figure" id="GUID-5B5A093F-FE4E-4D57-B66C-93CD6F78B1D1__GUID-68392211-A1E0-4D96-97AD-3E6FFEA4AE40">
<p class="titleinfigure">Figure 8-2 TLS Handshake with Client-Driven OCSP</p>
<img width="575" height="308" src="img/client-driven-ocsp.png" alt="Description of Figure 8-2 follows" title="Description of Figure 8-2 follows" /><br />
<a href="img_text/client-driven-ocsp.htm">Description of "Figure 8-2 TLS Handshake with Client-Driven OCSP"</a></div>
<!-- class="figure" -->
<p>Usually the client finds the OCSP responder's URL by looking in the Authority Information Access (AIA) extension of the certificate, but it can be set to a static URL through the use of a system property.</p>
</div>
<!-- class="section" --></div>
<div class="sect4"><a id="GUID-4E3834C7-E741-499E-9646-3557670FD88A"></a>
<h4 id="JSSEC-GUID-4E3834C7-E741-499E-9646-3557670FD88A" class="sect4">Setting up a Java Client to use Client-Driven OCSP</h4>
<div>
<p>Client-driven OCSP is enabled by enabling revocation checking and enabling OCSP.</p>
<div class="p">To configure a Java client to use client-driven OCSP, the Java client must already be set up to connect to a server using TLS.</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Enable revocation checking. You can do this in two different ways.</span>
<ul>
<li>Set the system property <code class="codeph">com.sun.net.ssl.checkRevocation</code> to <code class="codeph">true</code>.</li>
<li>Use the <code class="codeph">setRevocationEnabled</code> method on <code class="codeph">PKIXParameters</code>. See <a href="java-pki-programmers-guide.htm#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="The PKIXParametersClass class specifies the set of input parameters defined by the PKIX certification path validation algorithm. It also includes a few additional useful parameters.">The PKIXParameters Class</a>.</li>
</ul>
</li>
<li class="stepexpand"><span>Enable client-driven OCSP:</span>
<div>
<p>Set the Security Property <code class="codeph">ocsp.enable</code> to <code class="codeph">true</code>.</p>
</div>
</li>
</ol>
<div class="section">Both steps are necessary. The <code class="codeph">ocsp.enable</code> setting has no effect unless revocation checking is enabled.</div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect3"><a id="GUID-489366D5-635A-4204-8980-3FB126047C45"></a>
<h3 id="JSSEC-GUID-489366D5-635A-4204-8980-3FB126047C45" class="sect3">OCSP Stapling and Certificate Revocation</h3>
<div>
<p>Online Certificate Status Protocol (OCSP) stapling enables the presenter of a certificate, rather than the issuing Certificate Authority (CA), to bear the resource cost of providing the OCSP responses that contain the certificate&rsquo;s revocation status.</p>
<div class="section">
<p class="subhead3">TLS Handshake with OCSP Stapling</p>
<p>OCSP stapling is used during the Transport Layer Security (TLS) handshake between the client and the server to check the server certificate revocation status. The server makes the OCSP request to the OCSP responder and staples the OCSP responses to the certificates returned to the client. By having the server make the request to the OCSP responder, the responses can be cached, and then used multiple times for many clients.</p>
<p>The TLS handshake begins with the TLS <code class="codeph">ClientHello</code> message. When OCSP stapling is used, this message is sent to the server with the <code class="codeph">status_request</code> extension that indicates that the server should perform an OCSP request. After processing the <code class="codeph">ClientHello</code> message, the server sends an OCSP request to the appropriate OCSP responder for each certificate. When the server receives the OCSP responses from the OCSP responders, it sends a <code class="codeph">ServerHello</code> message with its <code class="codeph">status_request</code> extension, indicating that OCSP responses will be provided in the TLS handshake. The server will then present the server certificate chain, followed by a message that consists of one or more OCSP responses for those certificates. The client receiving the certificates with stapled OCSP responses validates each certificate, and then checks the OCSP responses before continuing with the handshake.</p>
<p>If, from the client&rsquo;s perspective, the stapled OCSP response from the server for a certificate is missing, the client will attempt to use client-driven OCSP or CRLs to get revocation information, if either of these are enabled and revocation checking is set to <code class="codeph">true</code>.</p>
<div class="figure" id="GUID-489366D5-635A-4204-8980-3FB126047C45__GUID-E53642EE-979E-49F0-A632-BD6A560AEC64">
<p class="titleinfigure">Figure 8-3 TLS Handshake with OCSP Stapling</p>
<img width="575" height="393" src="img/ocsp-stapling.png" alt="Description of Figure 8-3 follows" title="Description of Figure 8-3 follows" /><br />
<a href="img_text/ocsp-stapling.htm">Description of "Figure 8-3 TLS Handshake with OCSP Stapling"</a></div>
<!-- class="figure" -->
<p>For more information about TLS handshake messages, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7FCC21CB-158B-440C-B5E4-E4E5A2D7352B">The SSL Handshake</a>.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Status Request Versus Multiple Status Request</p>
<p>The OCSP stapling feature implements the TLS Certificate Status Request extension (section 8 of&nbsp;<a href="http://tools.ietf.org/html/rfc6066" target="_blank">RFC 6066</a>) and the Multiple Certificate Status Request Extension (<a href="http://tools.ietf.org/html/rfc6961" target="_blank">RFC 6961</a>).</p>
<p>The TLS Certificate Status Request extension requests revocation information for only the server certificate in the certificate chain while the Multiple Certificate Status Request Extension requests revocation information for all certificates in the certificate chain. In the case where only the server certificate's revocation information is sent to the client, other certificates in the chain may be verified using using the Certificate Revocation Lists (CRLs) or client-driven OCSP (but the client will need to be set up to do this).</p>
<p>Although TLS allows the server to also request the client&rsquo;s certificate, there is no provision in OCSP stapling that enables the client to contact the appropriate OCSP responder and staple the response to the certificate sent to the server.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">The OCSP Request and Response</p>
<p>OCSP request and response messages are usually sent over unencrypted HTTP. The response is signed by the CA.</p>
<p>If necessary, the stapled responses can be obtained in the client code by calling the <code class="codeph">getStatusResponses</code> method on the <code class="codeph">ExtendedSSLSession</code> object. The method signature is:</p>
<pre dir="ltr">
public List&lt;byte[]&gt; getStatusResponses();
</pre>
<p>The OCSP response is encoded using the Distinguished Encoding Rules (DER) in a format described by the ASN.1 found in <a href="http://tools.ietf.org/html/rfc6960" target="_blank">RFC 6960</a>.</p>
</div>
<!-- class="section" --></div>
<div class="sect4"><a id="GUID-F15D190D-85A1-4012-8FE3-060DBD90E579"></a>
<h4 id="JSSEC-GUID-F15D190D-85A1-4012-8FE3-060DBD90E579" class="sect4">Setting Up a Java Client to Use OCSP Stapling</h4>
<div>
<p>Online Certificate Status Protocol (OCSP) stapling is enabled on the client side by setting the system property <code class="codeph">jdk.tls.client.enableStatusRequestExtension</code> to <code class="codeph">true</code> (its default value).</p>
<div class="p">To configure a Java client to make use of the OCSP response stapled to the certificate returned by a server, the Java client must already be set up to connect to a server using TLS, and the server must be set up to staple an OCSP response to the certificate it returns part of the TLS handshake.</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Enable OCSP stapling on the client:</span>
<div>
<p>If necessary, set the system property <code class="codeph">jdk.tls.client.enableStatusRequestExtension</code> to <code class="codeph">true</code>.</p>
</div>
</li>
<li class="stepexpand"><span>Enable revocation checking. You can do this in two different ways.</span>
<ul>
<li>Set the system property <code class="codeph">com.sun.net.ssl.checkRevocation</code> to <code class="codeph">true</code>. You can do this from the command line or in the code.</li>
<li>Use the <code class="codeph">setRevocationEnabled</code> method on the <code class="codeph">PKIXParameters</code> class. See <a href="java-pki-programmers-guide.htm#GUID-3D95A3BE-74CB-4357-BB85-9A8DEA36A457" title="The PKIXParametersClass class specifies the set of input parameters defined by the PKIX certification path validation algorithm. It also includes a few additional useful parameters.">The PKIXParameters Class</a>.</li>
</ul>
<div>
<p>For the client to include the stapled responses received from the server in the certificate validation, revocation checking must be set to <code class="codeph">true</code>. If revocation checking is not set to <code class="codeph">true</code>, then the connection will be allowed to proceed regardless of the presence or status of the revocation information</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4"><a id="GUID-423716FB-DA34-4C73-B3A1-EB4CE120BB62"></a>
<h4 id="JSSEC-GUID-423716FB-DA34-4C73-B3A1-EB4CE120BB62" class="sect4">Setting Up a Java Server to Use OCSP Stapling</h4>
<div>
<p>Online Certificate Status Protocol (OCSP) stapling is enabled on the server by setting the system property <code class="codeph">jdk.tls.server.enableStatusRequestExtension</code> to <code class="codeph">true</code>. (It is set to <code class="codeph">false</code> by default.)</p>
<div class="p">The following steps can be used to configure a Java server to connect to an OCSP responder and staple the OCSP response to the certificate to be returned to the client. The Java server must already be set up to respond to clients using TLS.</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Enable OCSP stapling on the server:</span>
<div>
<p>Set the system property <code class="codeph">jdk.tls.server.enableStatusRequestExtension</code> to <code class="codeph">true</code>.</p>
</div>
</li>
<li class="stepexpand"><strong>Optional:</strong> <span>Set other properties as required. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37" title="This topic lists the effects of setting various properties when using the Online Certificate Status Protocol (OCSP). It shows the properties used in both client-driven OCSP and OCSP stapling.">OCSP Stapling Configuration Properties</a> for a list of the valid properties.</span></li>
</ol>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37"></a>
<h3 id="JSSEC-GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37" class="sect3">OCSP Stapling Configuration Properties</h3>
<div>
<p>This topic lists the effects of setting various properties when using the Online Certificate Status Protocol (OCSP). It shows the properties used in both client-driven OCSP and OCSP stapling.</p>
<div class="section">
<p class="subhead3">Server-side Properties</p>
<p>Most of the properties are read at <code class="codeph">SSLContext</code> instantiation time. This means that if you set a property, you must obtain a new <code class="codeph">SSLContext</code> object so that an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> object you obtain from that <code class="codeph">SSLContext</code> object will reflect the property setting. The one exception is the <code class="codeph">jdk.tls.stapling.responseTimeout</code> property. That property is evaluated when the <code class="codeph">ServerHandshaker</code> object is created (essentially at the same time that an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> object gets created).</p>
</div>
<!-- class="section" -->
<div class="section">
<div class="tblformalwide" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-B67B52FB-CD64-48FC-9552-23E929727680">
<p class="titleintable">Table 8-3 Server-Side OCSP stapling Properties</p>
<table class="cellalignment469" title="Server-Side OCSP stapling Properties" summary="This table shows the properties that can be set for the server in OCSP stapling. Only the first property jdk.tls.server.enableStatusRequestExtension, is needed to enable OCSP stapling.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment474" id="d108102e1687">Property</th>
<th class="cellalignment482" id="d108102e1689">Description</th>
<th class="cellalignment473" id="d108102e1691">Default Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment479" id="d108102e1695" headers="d108102e1687"><code class="codeph">jdk.tls.server.enableStatusRequestExtension</code></td>
<td class="cellalignment483" headers="d108102e1695 d108102e1689">Enables the server-side support for OCSP stapling.</td>
<td class="cellalignment478" headers="d108102e1695 d108102e1691">False</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment479" id="d108102e1703" headers="d108102e1687"><code class="codeph">jdk.tls.stapling.responseTimeout</code></td>
<td class="cellalignment483" headers="d108102e1703 d108102e1689">
<p>Controls the maximum amount of time the server will use to obtain OCSP responses, whether from the cache or by contacting an OCSP responder.</p>
<p>The responses that are already received will be sent in a <code class="codeph">CertificateStatus</code> message, if applicable based on the type of stapling being done.</p>
</td>
<td class="cellalignment478" headers="d108102e1703 d108102e1691">5000 (integer value in milliseconds)</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment479" id="d108102e1717" headers="d108102e1687"><code class="codeph">jdk.tls.stapling.cacheSize</code></td>
<td class="cellalignment483" headers="d108102e1717 d108102e1689">
<p>Controls the maximum cache size in entries.</p>
<p>If the cache is full and a new response needs to be cached, then the least recently used cache entry will be replaced with the new one. A value of zero or less for this property means that the cache will have no upper bound on the number of responses it can contain.</p>
</td>
<td class="cellalignment478" headers="d108102e1717 d108102e1691">256 objects</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment479" id="d108102e1728" headers="d108102e1687"><code class="codeph">jdk.tls.stapling.cacheLifetime</code></td>
<td class="cellalignment483" headers="d108102e1728 d108102e1689">
<p>Controls the maximum life of a cached response.</p>
<p>It is possible for responses to have shorter lifetimes than the value set with this property if the response has a <span class="bold">nextUpdate</span> field that expires sooner than the cache lifetime. A value of zero or less for this property disables the cache lifetime. If an object has no <span class="bold">nextUpdate</span> value and cache lifetimes are disabled, then the response will not be cached.</p>
</td>
<td class="cellalignment478" headers="d108102e1728 d108102e1691">3600 seconds (1 hour)</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment479" id="d108102e1745" headers="d108102e1687"><code class="codeph">jdk.tls.stapling.responderURI</code></td>
<td class="cellalignment483" headers="d108102e1745 d108102e1689">
<p>Enables the administrator to set a default URI in the event that certificates used for TLS do not have the Authority Info Access (AIA) extension.</p>
<p>It will not override the Authority Info Access extension value unless the <code class="codeph">jdk.tls.stapling.responderOverride</code> property is set.</p>
</td>
<td class="cellalignment478" headers="d108102e1745 d108102e1691">Not set</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment479" id="d108102e1759" headers="d108102e1687"><code class="codeph">jdk.tls.stapling.responderOverride</code></td>
<td class="cellalignment483" headers="d108102e1759 d108102e1689">
<p>Enables a URI provided through the <code class="codeph">jdk.tls.stapling.responderURI</code> property to override any AIA extension value.</p>
</td>
<td class="cellalignment478" headers="d108102e1759 d108102e1691">False</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment479" id="d108102e1771" headers="d108102e1687"><code class="codeph">jdk.tls.stapling.ignoreExtensions</code></td>
<td class="cellalignment483" headers="d108102e1771 d108102e1689">
<p>Disables the forwarding of OCSP extensions specified in the&nbsp;<code class="codeph">status_request</code>&nbsp;or&nbsp;<code class="codeph">status_request_v2</code>&nbsp;TLS extensions.</p>
</td>
<td class="cellalignment478" headers="d108102e1771 d108102e1691">False</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Client-Side Settings</p>
</div>
<!-- class="section" -->
<div class="section">
<div class="tblformal" id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__GUID-F7BC7AEB-8918-40C7-AA80-E0CF554FD1F3">
<p class="titleintable">Table 8-4 Client-Side Settings Used in OCSP Stapling</p>
<table class="cellalignment468" title="Client-Side Settings Used in OCSP Stapling" summary="This table shows the effects of different settings of PKIXBuilderParameters and the checkRevocation property (assume OCSP stapling is enabled in both the client and server).">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" id="d108102e1801">PKIXBuilderParameters</th>
<th class="cellalignment467" id="d108102e1803">checkRevocation Property</th>
<th class="cellalignment467" id="d108102e1805">PKIXRevocationChecker</th>
<th class="cellalignment467" id="d108102e1807">Result</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e1811" headers="d108102e1801">Default</td>
<td class="cellalignment456" headers="d108102e1811 d108102e1803">Default</td>
<td class="cellalignment456" headers="d108102e1811 d108102e1805">Default</td>
<td class="cellalignment456" headers="d108102e1811 d108102e1807">Revocation checking is disabled.</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e1820" headers="d108102e1801">Default</td>
<td class="cellalignment456" headers="d108102e1820 d108102e1803">True</td>
<td class="cellalignment456" headers="d108102e1820 d108102e1805">Default</td>
<td class="cellalignment456" headers="d108102e1820 d108102e1807">Revocation checking is enabled.<a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">[1]</a></td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e1832" headers="d108102e1801">Instantiated</td>
<td class="cellalignment456" headers="d108102e1832 d108102e1803">Default</td>
<td class="cellalignment456" headers="d108102e1832 d108102e1805">Default</td>
<td class="cellalignment456" headers="d108102e1832 d108102e1807">Revocation checking is enabled.<a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">[1]</a></td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e1844" headers="d108102e1801">Instantiated</td>
<td class="cellalignment456" headers="d108102e1844 d108102e1803">Default</td>
<td class="cellalignment456" headers="d108102e1844 d108102e1805">Instantiated, added to <code class="codeph">PKIXBuilderParameters</code> object.</td>
<td class="cellalignment456" headers="d108102e1844 d108102e1807">Revocation checking is enabled and<a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">[1]</a>will behave according to the <code class="codeph">PKIXRevocationChecker</code> settings.</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p id="GUID-3A540C8F-5EB7-4E96-9051-92A1E2D8AF37__NOTETHATCLIENT-SIDEOCSPFALLBACKWILL-1B855C3C">Footnote 1 Note that client-side OCSP fallback will occur only if the <code class="codeph">ocsp.enable</code> Security Property is set to <code class="codeph">true</code>.</p>
<p>Developers have some flexibility in how to handle the responses provided through OCSP stapling. OCSP stapling makes no changes to the current methodologies involved in certificate path checking and revocation checking. This means that it is possible to have both client and server assert the&nbsp;<code class="codeph">status_request</code>&nbsp;extensions, obtain OCSP responses through the <code class="codeph">CertificateStatus</code>&nbsp;message, and provide user flexibility in how to react to revocation information, or the lack thereof.</p>
<p>If no&nbsp;<code class="codeph">PKIXBuilderParameters</code>&nbsp;is provided by the caller, then revocation checking is disabled. If the caller creates a&nbsp;<code class="codeph">PKIXBuilderParameters</code>&nbsp;object and uses the&nbsp;<code class="codeph">setRevocationEnabled</code>&nbsp;method to enable revocation checking, then stapled OCSP responses will be evaluated. This is also the case if the&nbsp;<code class="codeph">com.sun.net.ssl.checkRevocation</code>&nbsp;property is set to&nbsp;<code class="codeph">true</code>.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect2"><a id="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC"></a>
<h2 id="JSSEC-GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC" class="sect2">JSSE Classes and Interfaces</h2>
<div>
<div class="section">
<p>To communicate securely, both sides of the connection must be SSL-enabled. In the JSSE API, the endpoint classes of the connection are <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code>. In <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC__GUID-A0AB7CF4-2CB8-4F12-8EF8-68EA03C6217D">Figure 8-4</a>, the major classes used to create <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code> are laid out in a logical ordering.</p>
<div class="figure" id="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC__GUID-A0AB7CF4-2CB8-4F12-8EF8-68EA03C6217D">
<p class="titleinfigure">Figure 8-4 JSSE Classes Used to Create SSLSocket and SSLEngine</p>
<img width="459" height="333" src="img/jsse-classes-and-interfaces.png" alt="Description of Figure 8-4 follows" title="Description of Figure 8-4 follows" /><br />
<a href="img_text/jsse-classes-and-interfaces.htm">Description of "Figure 8-4 JSSE Classes Used to Create SSLSocket and SSLEngine"</a></div>
<!-- class="figure" -->
<p>An <code class="codeph">SSLSocket</code> is created either by an <code class="codeph">SSLSocketFactory</code> or by an <code class="codeph">SSLServerSocket</code> accepting an inbound connection. In turn, an <code class="codeph">SSLServerSocket</code> is created by an <code class="codeph">SSLServerSocketFactory</code>. Both <code class="codeph">SSLSocketFactory</code> and <code class="codeph">SSLServerSocketFactory</code> objects are created by an <code class="codeph">SSLContext</code>. An <code class="codeph">SSLEngine</code> is created directly by an <code class="codeph">SSLContext</code>, and relies on the application to handle all I/O.</p>
<div class="infobox-note" id="GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC__GUID-1C41051F-5CE0-44B3-A0E9-D7FC41D3C6EE">
<p class="notep1">Note:</p>
When using raw <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> classes, you should always check the peer's credentials before sending any data. Since JDK 7, endpoint identification/verification procedures can be handled during SSL/TLS handshaking. See the method <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#getEndpointIdentificationAlgorithm--" target="_blank"><span class="apiname">SSLParameters.setEndpointIdentificationAlgorithm</span></a>.
<p>For example, the host name in a URL matches the host name in the peer's credentials. An application could be exploited with URL spoofing if the host name is not verified.</p>
</div>
</div>
<!-- class="section" --></div>
<div class="sect3"><a id="GUID-4A6ABFE4-6B0E-4DF2-A9E8-EEEB71935293"></a>
<h3 id="JSSEC-GUID-4A6ABFE4-6B0E-4DF2-A9E8-EEEB71935293" class="sect3">JSSE Core Classes and Interfaces</h3>
<div>
<p>The core JSSE classes are part of the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/package-summary.html" target="_blank"><span class="apiname">javax.net</span></a> and <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/package-summary.html" target="_blank"><span class="apiname">javax.net.ssl</span></a> packages.</p>
</div>
</div>
<div class="sect3"><a id="GUID-6AF71CD9-4E87-49E1-B175-89810D54139E"></a>
<h3 id="JSSEC-GUID-6AF71CD9-4E87-49E1-B175-89810D54139E" class="sect3">SocketFactory and ServerSocketFactory Classes</h3>
<div>
<p>The abstract <code class="codeph">javax.net.SocketFactory</code> class is used to create sockets. Subclasses of this class are factories that create particular subclasses of sockets and thus provide a general framework for the addition of public socket-level functionality. For example, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B">SSLSocketFactory and SSLServerSocketFactory Classes</a>.</p>
<p>The abstract <code class="codeph">javax.net.ServerSocketFactory</code> class is analogous to the <code class="codeph">SocketFactory</code> class, but is used specifically for creating server sockets.</p>
<p>Socket factories are a simple way to capture a variety of policies related to the sockets being constructed, producing such sockets in a way that does not require special configuration of the code that asks for the sockets:</p>
<ul style="list-style-type: disc;">
<li>Due to polymorphism of both factories and sockets, different kinds of sockets can be used by the same application code just by passing different kinds of factories.</li>
<li>Factories can themselves be customized with parameters used in socket construction. For example, factories could be customized to return sockets with different networking timeouts or security parameters already configured.</li>
<li>The sockets returned to the application can be subclasses of <code class="codeph">java.net.Socket</code> (or <code class="codeph">javax.net.ssl.SSLSocket</code>), so that they can directly expose new APIs for features such as compression, security, record marking, statistics collection, or firewall tunneling.</li>
</ul>
</div>
</div>
<div class="sect3"><a id="GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B"></a>
<h3 id="JSSEC-GUID-F0917FCC-FBB0-4E36-8D79-37F14F8A274B" class="sect3">SSLSocketFactory and SSLServerSocketFactory Classes</h3>
<div>
<p>The <code class="codeph">javax.net.ssl.SSLSocketFactory</code> class acts as a factory for creating secure sockets. This class is an abstract subclass of <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/SocketFactory.html" target="_blank"><code class="codeph">javax.net.SocketFactory</code></a>.</p>
<p>Secure socket factories encapsulate the details of creating and initially configuring secure sockets. This includes authentication keys, peer certificate validation, enabled cipher suites, and the like.</p>
<p>The <code class="codeph">javax.net.ssl.SSLServerSocketFactory</code> class is analogous to the <code class="codeph">SSLSocketFactory</code> class, but is used specifically for creating server sockets.</p>
</div>
<div class="sect4"><a id="GUID-86684173-0E06-4EA9-AF89-B80E0D7B602E"></a>
<h4 id="JSSEC-GUID-86684173-0E06-4EA9-AF89-B80E0D7B602E" class="sect4">Obtaining an SSLSocketFactory</h4>
<div>
<p>The following ways can be used to obtain an <code class="codeph">SSLSocketFactory</code>:</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>Get the default factory by calling the <code class="codeph">SSLSocketFactory.getDefault()</code> static method.</li>
<li>Receive a factory as an API parameter. That is, code that must create sockets but does not care about the details of how the sockets are configured can include a method with an <code class="codeph">SSLSocketFactory</code> parameter that can be called by clients to specify which <code class="codeph">SSLSocketFactory</code> to use when creating sockets (for example, <code class="codeph">javax.net.ssl.HttpsURLConnection</code>).</li>
<li>Construct a new factory with specifically configured behavior.</li>
</ul>
<p>The default factory is typically configured to support server authentication only so that sockets created by the default factory do not leak any more information about the client than a normal TCP socket would.</p>
<p>Many classes that create and use sockets do not need to know the details of socket creation behavior. Creating sockets through a socket factory passed in as a parameter is a good way of isolating the details of socket configuration, and increases the reusability of classes that create and use sockets.</p>
<p>You can create new socket factory instances either by implementing your own socket factory subclass or by using another class which acts as a factory for socket factories. One example of such a class is <code class="codeph">SSLContext</code>, which is provided with the JSSE implementation as a provider-based configuration class.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect3"><a id="GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB"></a>
<h3 id="JSSEC-GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB" class="sect3">SSLSocket and SSLServerSocket Classes</h3>
<div>
<p>The <code class="codeph">javax.net.ssl.SSLSocket</code> class is a subclass of the standard Java <code class="codeph">java.net.Socket</code> class. It supports all of the standard socket methods and adds methods specific to secure sockets. It supports all of the standard socket methods and adds methods specific to secure sockets. Instances of this class encapsulate the <span class="apiname">SSLContext</span> under which they were created. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" title="The javax.net.ssl.SSLContext class is an engine class for an implementation of a secure socket protocol. An instance of this class acts as a factory for SSLSocket, SSLServerSocket, and SSLEngine. An SSLContext object holds all of the state information shared across all objects created under that context. For example, session state is associated with the SSLContext when it is negotiated through the handshake protocol by sockets created by socket factories provided by the context. These cached sessions can be reused and shared by other sockets created under the same context.">The SSLContext Class</a>. There are APIs to control the creation of secure socket sessions for a socket instance, but trust and key management are not directly exposed.</p>
<p>The <code class="codeph">javax.net.ssl.SSLServerSocket</code> class is analogous to the <code class="codeph">SSLSocket</code> class, but is used specifically for creating server sockets.</p>
<p>To prevent peer spoofing, you should always verify the credentials presented to an <code class="codeph">SSLSocket</code>. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38">Cipher Suite Choice and Remote Entity Verification</a>.</p>
<div class="p">
<div class="infobox-note" id="GUID-8EF3AA86-6559-482D-82C7-4F6F6951A1AB__GUID-1242F7C2-58EE-4389-BD47-8316EBD20B28">
<p class="notep1">Note:</p>
Due to the complexity of the SSL and TLS protocols, it is difficult to predict whether incoming bytes on a connection are handshake or application data, and how that data might affect the current connection state (even causing the process to block). In the Oracle JSSE implementation, the <code class="codeph">available()</code> method on the object obtained by <code class="codeph">SSLSocket.getInputStream()</code> returns a count of the number of application data bytes successfully decrypted from the SSL connection but not yet read by the application.</div>
</div>
</div>
<div class="sect4"><a id="GUID-BA88D2CC-EC63-4A74-A696-E1A56BD68BF0"></a>
<h4 id="JSSEC-GUID-BA88D2CC-EC63-4A74-A696-E1A56BD68BF0" class="sect4">Obtaining an SSLSocket</h4>
<div>
<p>Instances of <span class="apiname">SSLSocket</span> can be obtained in one of the following ways:</p>
<ul>
<li><span>An <span class="apiname">SSLSocket</span> can be created by an instance of <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocketFactory.html" target="_blank"><span class="apiname">SSLSocketFactory</span></a> via one of the several <span class="apiname">createSocket</span> methods of that class.</span></li>
<li><span>An <span class="apiname">SSLSocket</span> can be created through the <span class="apiname">accept</span> method of the <span class="apiname">SSLServerSocket</span> class.</span></li>
</ul>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB"></a>
<h3 id="JSSEC-GUID-8796681D-06C8-4884-ADE4-782394F6F6FB" class="sect3">SSLEngine Class</h3>
<div>
<p>SSL/TLS/DTLS is becoming increasingly popular. It is being used in a wide variety of applications across a wide range of computing platforms and devices. Along with this popularity come demands to use SSL/TLS/DTLS with different I/O and threading models to satisfy the applications' performance, scalability, footprint, and other requirements. There are demands to use SSL/TLS/DTLS with blocking and nonblocking I/O channels, asynchronous I/O, arbitrary input and output streams, and byte buffers. There are demands to use it in highly scalable, performance-critical environments, requiring management of thousands of network connections.</p>
<p>Abstraction of the I/O transport mechanism using the <code class="codeph">SSLEngine</code> class in Java SE allows applications to use the SSL/TLS/DTLS protocols in a transport-independent way, and thus frees application developers to choose transport and computing models that best meet their needs. Not only does this abstraction allow applications to use nonblocking I/O channels and other I/O models, it also accommodates different threading models. This effectively leaves the I/O and threading decisions up to the application developer. Because of this flexibility, the application developer must manage I/O and threading (complex topics in and of themselves), as well as have some understanding of the SSL/TLS/DTLS protocols. The abstraction is therefore an advanced API: beginners should use <code class="codeph">SSLSocket</code>.</p>
<p>Users of other Java programming language APIs such as the Java Generic Security Services (Java GSS-API) and the Java Simple Authentication Security Layer (Java SASL) will notice similarities in that the application is also responsible for transporting data.</p>
<p>The core class is <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html" target="_blank"><code class="codeph">javax.net.ssl.SSLEngine</code></a>. It encapsulates an SSL/TLS/DTLS state machine and operates on inbound and outbound byte buffers supplied by the user of the <code class="codeph">SSLEngine</code> class. <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-A02F05DD-41AA-47E3-A1BE-9AB4AC6E4BC2">Figure 8-5</a> illustrates the flow of data from the application, through <code class="codeph">SSLEngine</code>, to the transport mechanism, and back.</p>
<div class="figure" id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-A02F05DD-41AA-47E3-A1BE-9AB4AC6E4BC2">
<p class="titleinfigure">Figure 8-5 Flow of Data Through SSLEngine</p>
<img width="458" height="203" src="img/sslengine_jsse.png" alt="The following text describes this figure." title="The following text describes this figure." /></div>
<!-- class="figure" -->
<p>The application, shown on the left, supplies application (plaintext) data in an application buffer and passes it to <span class="apiname">SSLEngine</span>. The <span class="apiname">SSLEngine</span> object processes the data contained in the buffer, or any handshaking data, to produce SSL/TLS/DTLS encoded data and places it to the network buffer supplied by the application. The application is then responsible for using an appropriate transport (shown on the right) to send the contents of the network buffer to its peer. Upon receiving SSL/TLS/DTLS encoded data from its peer (via the transport), the application places the data into a network buffer and passes it to <span class="apiname">SSLEngine</span>. The <span class="apiname">SSLEngine</span> object processes the network buffer's contents to produce handshaking data or application data.</p>
<p>An instance of the <code class="codeph">SSLEngine</code> class can be in one of the following states:</p>
<dl>
<dt class="dlterm"><a id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-B02D18CC-ADD5-44A5-805E-25CD2998855B"><!-- --></a>Creation</dt>
<dd>The <code class="codeph">SSLEngine</code> has been created and initialized, but has not yet been used. During this phase, an application may set any <code class="codeph">SSLEngine</code>-specific settings (enabled cipher suites, whether the <code class="codeph">SSLEngine</code> should handshake in client or server mode, and so on). Once handshaking has begun, though, any new settings (except client/server mode) will be used for the next handshake.</dd>
<dt class="dlterm"><a id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-0F78430D-0144-4BFE-8E16-6DE2FAD40A64"><!-- --></a>Initial handshaking</dt>
<dd>The initial handshake is a procedure by which the two peers exchange communication parameters until an <code class="codeph">SSLSession</code> is established. Application data can&rsquo;t be sent during this phase.</dd>
<dt class="dlterm"><a id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-4FFB7915-D7CE-49E5-9E71-0C542A09854A"><!-- --></a>Application data</dt>
<dd>After the communication parameters have been established and the handshake is complete, application data can flow through the <code class="codeph">SSLEngine</code>. Outbound application messages are encrypted and integrity protected, and inbound messages reverse the process.</dd>
<dt class="dlterm"><a id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-21E779D2-2FBB-46D2-9275-E742012D20DB"><!-- --></a>Rehandshaking</dt>
<dd>Either side can request a renegotiation of the session at any time during the Application Data phase. New handshaking data can be intermixed among the application data. Before starting the rehandshake phase, the application may reset the SSL/TLS/DTLS communication parameters such as the list of enabled ciphersuites and whether to use client authentication, but can not change between client/server modes. As before, after handshaking has begun, any new <code class="codeph">SSLEngine</code> configuration settings won&rsquo;t be used until the next handshake.</dd>
<dt class="dlterm"><a id="GUID-8796681D-06C8-4884-ADE4-782394F6F6FB__GUID-5FBA1A16-3A76-416F-A4F9-3271D9F2E45D"><!-- --></a>Closure</dt>
<dd>When the connection is no longer needed, the application should close the <code class="codeph">SSLEngine</code> and should send/receive any remaining messages to the peer before closing the underlying transport mechanism. Once an engine is closed, it is not reusable: a new <code class="codeph">SSLEngine</code> must be created.</dd>
</dl>
</div>
<div class="sect4"><a id="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7"></a>
<h4 id="JSSEC-GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" class="sect4">Creating an SSLEngine Object</h4>
<div>
<p>Use the <code class="codeph">SSLContext.createSSLEngine()</code> method to create an <code class="codeph">SSLEngine</code> object.</p>
<div class="section">
<p>Before you create an <code class="codeph">SSLEngine</code> object, you must configure the engine to act as a client or a server, and set other configuration parameters, such as which cipher suites to use and whether client authentication is required. The <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#createSSLEngine--" target="_blank"><code class="codeph">SSLContext.createSSLEngine</code></a> method creates an <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html" target="_blank"><code class="codeph">javax.net.ssl.SSLEngine</code></a> object.</p>
<div class="infobox-note" id="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__GUID-E7142213-957C-4DEB-8C5D-CD8BE3E5A286">
<p class="notep1">Note:</p>
The server name and port number are not used for communicating with the server (all transport is the responsibility of the application). They are hints to the JSSE provider to use for SSL session caching, and for Kerberos-based cipher suite implementations to determine which server credentials should be obtained.</div>
</div>
<!-- class="section" -->
<div class="example" id="GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FBEA9">
<p class="titleinexample">Example 8-1 Sample Code for Creating an SSLEngine Client for TLS with JKS as Keystore</p>
<p>The following sample code creates an <span class="apiname">SSLEngine</span> client for TLS that uses JKS as keystore:</p>
<pre class="codeblock" dir="ltr">
    import javax.net.ssl.*;
    import java.security.*;

    // Create and initialize the SSLContext with key material
    char[] passphrase = "passphrase".toCharArray();

    // First initialize the key and trust material
    KeyStore ksKeys = KeyStore.getInstance("JKS");
    ksKeys.load(new FileInputStream("testKeys"), passphrase);
    KeyStore ksTrust = KeyStore.getInstance("JKS");
    ksTrust.load(new FileInputStream("testTrust"), passphrase);

    // KeyManagers decide which key material to use
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
    kmf.init(ksKeys, passphrase);

    // TrustManagers decide whether to allow connections
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ksTrust);

    // Get an instance of SSLContext for SSL/TLS protocols
    sslContext = SSLContext.getInstance("TLS");
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

    // Create the engine
    SSLEngine engine = sslContext.createSSLengine(hostname, port);

    // Use as client
    engine.setUseClientMode(true);
</pre></div>
<!-- class="example" --></div>
</div>
<div class="sect4"><a id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4"></a>
<h4 id="JSSEC-GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4" class="sect4">Generating and Processing SSL/TLS Data</h4>
<div>
<p>The two main <code class="codeph">SSLEngine</code> methods are <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code>. They are responsible for generating and consuming network data respectively. Depending on the state of the <code class="codeph">SSLEngine</code> object, this data might be handshake or application data.</p>
<div class="section">
<p>Each <code class="codeph">SSLEngine</code> object has several phases during its lifetime. Before application data can be sent or received, the SSL/TLS protocol requires a handshake to establish cryptographic parameters. This handshake requires a series of back-and-forth steps by the <code class="codeph">SSLEngine</code> object. For more details about the handshake itself, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7FCC21CB-158B-440C-B5E4-E4E5A2D7352B">The SSL Handshake</a>.</p>
<p>During the initial handshaking, the <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> methods generate and consume handshake data, and the application is responsible for transporting the data. The <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> method sequence is repeated until the handshake is finished. Each <code class="codeph">SSLEngine</code> operation generates an instance of the <code class="codeph">SSLEngineResult</code> class, in which the <code class="codeph">SSLEngineResult.HandshakeStatus</code> field is used to determine what operation must occur next to move the handshake along.</p>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-498B945A-6C5B-4291-8278-B34D79CCF010" title="Sequence of methods called during a typical handshake, with corresponding messages and statuses">Table 8-5</a> shows the sequence of methods called during a typical handshake, with corresponding messages and statuses.</p>
<div class="tblformal" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-498B945A-6C5B-4291-8278-B34D79CCF010">
<p class="titleintable">Table 8-5 Typical Handshake</p>
<table class="cellalignment468" title="Typical Handshake" summary="Sequence of methods called during a typical handshake, with corresponding messages and statuses">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" id="d108102e2444">Client</th>
<th class="cellalignment467" id="d108102e2446">SSL/TLS Message</th>
<th class="cellalignment467" id="d108102e2448"><span class="apiname">HandshakeStatus</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e2453" headers="d108102e2444"><span class="apiname">wrap()</span></td>
<td class="cellalignment456" headers="d108102e2453 d108102e2446"><span class="apiname">ClientHello</span></td>
<td class="cellalignment456" headers="d108102e2453 d108102e2448"><span class="apiname">NEED_UNWRAP</span></td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e2463" headers="d108102e2444"><span class="apiname">unwrap()</span></td>
<td class="cellalignment456" headers="d108102e2463 d108102e2446"><span class="apiname">ServerHello</span>/<span class="apiname">Cert</span>/<span class="apiname">ServerHelloDone</span></td>
<td class="cellalignment456" headers="d108102e2463 d108102e2448"><span class="apiname">NEED_WRAP</span></td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e2479" headers="d108102e2444"><span class="apiname">wrap()</span></td>
<td class="cellalignment456" headers="d108102e2479 d108102e2446"><span class="apiname">ClientKeyExchange</span></td>
<td class="cellalignment456" headers="d108102e2479 d108102e2448"><span class="apiname">NEED_WRAP</span></td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e2489" headers="d108102e2444"><span class="apiname">wrap()</span></td>
<td class="cellalignment456" headers="d108102e2489 d108102e2446"><span class="apiname">ChangeCipherSpec</span></td>
<td class="cellalignment456" headers="d108102e2489 d108102e2448"><span class="apiname">NEED_WRAP</span></td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e2499" headers="d108102e2444"><span class="apiname">wrap()</span></td>
<td class="cellalignment456" headers="d108102e2499 d108102e2446"><span class="apiname">Finished</span></td>
<td class="cellalignment456" headers="d108102e2499 d108102e2448"><span class="apiname">NEED_UNWRAP</span></td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e2509" headers="d108102e2444"><span class="apiname">unwrap()</span></td>
<td class="cellalignment456" headers="d108102e2509 d108102e2446"><span class="apiname">ChangeCipherSpec</span></td>
<td class="cellalignment456" headers="d108102e2509 d108102e2448"><span class="apiname">NEED_UNWRAP</span></td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e2519" headers="d108102e2444"><span class="apiname">unwrap()</span></td>
<td class="cellalignment456" headers="d108102e2519 d108102e2446"><span class="apiname">Finished</span></td>
<td class="cellalignment456" headers="d108102e2519 d108102e2448"><span class="apiname">FINISHED</span></td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__STATEMACHINEDURINGDTLSHANDSHAKE-D6B2B3FD">Figure 8-6</a> shows the state machine during a typical SSL/TLS handshake, with corresponding messages and statuses:</p>
<div class="figure" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__STATEMACHINEDURINGDTLSHANDSHAKE-D6B2B3FD">
<p class="titleinfigure">Figure 8-6 State Machine during SSL/TLS Handshake</p>
<img width="416" height="536" src="img/ssl-tls-handshake.png" alt="Description of Figure 8-6 follows" title="Description of Figure 8-6 follows" /><br />
<a href="img_text/ssl-tls-handshake.htm">Description of "Figure 8-6 State Machine during SSL/TLS Handshake"</a></div>
<!-- class="figure" -->
<p>When handshaking is complete, further calls to <code class="codeph">wrap()</code> will attempt to consume application data and package it for transport. The <code class="codeph">unwrap()</code> method will attempt the opposite.</p>
<p>To send data to the peer, the application first supplies the data that it wants to send via <code class="codeph">SSLEngine.wrap()</code> to obtain the corresponding SSL/TLS encoded data. The application then sends the encoded data to the peer using its chosen transport mechanism. When the application receives the SSL/TLS encoded data from the peer via the transport mechanism, it supplies this data to the <code class="codeph">SSLEngine</code> via <code class="codeph">SSLEngine.unwrap()</code> to obtain the plaintext data sent by the peer.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-223D79BF-70AD-4F6C-B472-81C28C010BD9">
<p class="titleinexample">Example 8-2 Sample Code for Creating a Nonblocking SocketChannel</p>
<p>The following example is an SSL application that uses a non-blocking <code class="codeph">SocketChannel</code> to communicate with its peer. It sends the string "hello" to the peer by encoding it using the <code class="codeph">SSLEngine</code> created in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FBEA9">Example 8-1</a> . It uses information from the <code class="codeph">SSLSession</code> to determine how large to make the byte buffers.</p>
<div class="infobox-note" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-6DE5C28C-B4CD-438F-9A68-33BB5C3E2E94">
<p class="notep1">Note:</p>
The example can be made more robust and scalable by using a <code class="codeph">Selector</code> with the nonblocking <code class="codeph">SocketChannel</code>.</div>
<pre class="codeblock" dir="ltr">
    // Create a nonblocking socket channel
    SocketChannel socketChannel = SocketChannel.open();
    socketChannel.configureBlocking(false);
    socketChannel.connect(new InetSocketAddress(hostname, port));

    // Complete connection
    while (!socketChannel.finishedConnect()) {
    // do something until connect completed
    }

    //Create byte buffers for holding application and encoded data

    SSLSession session = engine.getSession();
    ByteBuffer myAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
    ByteBuffer myNetData = ByteBuffer.allocate(session.getPacketBufferSize());
    ByteBuffer peerAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
    ByteBuffer peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());

    // Do initial handshake
    doHandshake(socketChannel, engine, myNetData, peerNetData);

    myAppData.put("hello".getBytes());
    myAppData.flip();

    while (myAppData.hasRemaining()) {
    // Generate SSL/TLS/DTLS encoded data (handshake or application data)
    SSLEngineResult res = engine.wrap(myAppData, myNetData);

    // Process status of call
    if (res.getStatus() == SSLEngineResult.Status.OK) {
        myAppData.compact();

        // Send SSL/TLS/DTLS encoded data to peer
        while(myNetData.hasRemaining()) {
            int num = socketChannel.write(myNetData);
            if (num == 0) {
                // no bytes written; try again later
            }
        }
    }

    // Handle other status:  BUFFER_OVERFLOW, CLOSED
    ...
    }
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-FDF2BEE0-D9F4-4653-BD90-4167FEB96C45">
<p class="titleinexample">Example 8-3 Sample Code for Reading Data From Nonblocking SocketChannel</p>
The following sample code illustrates how to read data from the same nonblocking <code class="codeph">SocketChannel</code> and extract the plaintext data from it by using <code class="codeph">SSLEngine</code> created in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FBEA9">Example 8-1</a>. Each iteration of this code may or may not produce plaintext data, depending on whether handshaking is in progress.
<pre class="codeblock" dir="ltr">
    // Read SSL/TLS/DTLS encoded data from peer
    int num = socketChannel.read(peerNetData);
    if (num == -1) {
        // The channel has reached end-of-stream
    } else if (num == 0) {
        // No bytes read; try again ...
    } else {
        // Process incoming data
        peerNetData.flip();
        res = engine.unwrap(peerNetData, peerAppData);

        if (res.getStatus() == SSLEngineResult.Status.OK) {
            peerNetData.compact();

        if (peerAppData.hasRemaining()) {
            // Use peerAppData
        }
    }
    // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
    ...
    }
</pre></div>
<!-- class="example" --></div>
</div>
<div class="sect4"><a id="GUID-D0F8B9C3-721B-43A4-B2CE-7512B175F76D"></a>
<h4 id="JSSEC-GUID-D0F8B9C3-721B-43A4-B2CE-7512B175F76D" class="sect4">Datagram Transport Layer Security (DTLS) Protocol</h4>
<div>
<p>Datagram Transport Layer Security (DTLS) protocol is designed to construct &ldquo;TLS over datagram&rdquo; traffic that doesn't require or provide reliable or in-order delivery of data. Java Secure Socket Extension (JSSE) API and the SunJSSE security provider support the DTLS protocol.</p>
<p>Because the TLS requires a transparent reliable transport channel such as TCP it can&rsquo;t be used to secure unreliable datagram traffic. DTLS is a datagram-compatible variant of TLS.</p>
<p>The JSSE API now supports <a href="http://tools.ietf.org/html/rfc4347" target="_blank">DTLS Version 1.0</a> and <a href="http://tools.ietf.org/html/rfc6347" target="_blank">DTLS Version 1.2</a> along with Secure Socket Layer (SSL) and Transport Layer Security (TLS) protocols.</p>
<p>The <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html" target="_blank"><code class="codeph">javax.net.ssl.SSLEngine</code></a> programming model is used by the JSSE API for DTLS.</p>
</div>
<div class="sect5"><a id="GUID-B62245D1-5337-4B51-B1F3-CA89099157C1"></a>
<h5 id="JSSEC-GUID-B62245D1-5337-4B51-B1F3-CA89099157C1" class="sect5">The DTLS Handshake</h5>
<div>
<p>Before application data can be sent or received, the DTLS protocol requires a handshake to establish cryptographic parameters. This handshake requires a series of back-and-forth messages between the client and server by the <code class="codeph">SSLEngine</code> object.</p>
<div class="section" id="GUID-B62245D1-5337-4B51-B1F3-CA89099157C1__THESSLHANDSHAKE-7D20D1E0">
<p>DTLS handshake requires all messages be received properly. Thus, in unreliable datagram traffic, missing or delayed packets must be retransmitted. Since <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html" target="_blank"><code class="codeph">javax.net.ssl.SSLEngine</code></a> is not responsible for I/O operations, it is up to the application to provide timers and signal the SSLEngine when a retransmission is needed. It is important that you implement a timer and retransmission strategy for your application. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7" title="In SSL/TLS over a reliable connection, data is guaranteed to arrive in the proper order, and retransmission is unnecessary. However, for DTLS, which often works over unreliable media, missing or delayed handshake messages must be retransmitted.">Handling Retransmissions in DTLS Connections</a>.</p>
<p>The DTLS handshake includes the following stages:</p>
<ol>
<li><span class="bold">Negotiating the cipher suite</span>
<p>The DTLS session begins with a negotiation between the client and the server as to which cipher suite they will use. A <span>cipher suite</span> is a set of cryptographic algorithms and key sizes that a computer can use to encrypt data. The cipher suite includes information about the public key exchange algorithms or key agreement algorithms, and cryptographic hash functions. The client tells the server which cipher suites it has available, and the server chooses the best mutually acceptable cipher suite.</p>
<p>A cookie is exchanged between the client and server along with the cipher suite in order to prevent denial of service attacks (DoS).</p>
</li>
<li><span class="bold">Authenticating the server's identity (optional)</span>
<p>The authentication step is optional, but in the example of an e-commerce transaction over the web, the client chooses to authenticate the server. Authenticating the server allows the client to be sure that the server represents the entity that the client believes the server represents.</p>
<p>To prove that a server belongs to the organization that it claims to represent, the server presents its public key certificate to the client. If this certificate is valid, then the client can be sure of the identity of the server.</p>
<p>The client and server exchange information that allows them to agree on the same secret key. For example, with RSA, the client uses the server's public key, obtained from the public key certificate, to encrypt the secret key information. The client sends the encrypted secret key information to the server. Only the server can decrypt this message because the server's private key is required for this decryption.</p>
</li>
<li><span class="bold">Agreeing on encryption mechanisms</span>
<p>Both the client and the server now have access to the same secret key. With each message, they use the cryptographic hash function, chosen in the first step of the handshake, and shared secret information, to compute an HMAC that they append to the message. They then use the secret key and the secret key algorithm negotiated in the first step of the handshake to encrypt the secure data and the HMAC. The client and server can now communicate securely using their encrypted and hashed data.</p>
</li>
</ol>
</div>
<!-- class="section" --></div>
<div class="sect6"><a id="GUID-F1BFB231-BE35-4B14-BB8D-7F33D31A117D"></a>
<h6 id="JSSEC-GUID-F1BFB231-BE35-4B14-BB8D-7F33D31A117D" class="sect6">The DTLS Handshake Message Exchange</h6>
<div>
<p>In a DTLS handshake, series of back-and-forth messages are exchanged between the client and server by the <code class="codeph">SSLEngine</code> object.</p>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-F1BFB231-BE35-4B14-BB8D-7F33D31A117D__GUID-72C1D49C-0A80-4548-BF96-2D72E1C65912">Figure 8-7</a> shows the sequence of messages that are exchanged in the DTLS handshake. Messages that are sent only in certain situations are noted as optional. Each message is described following the figure.</p>
<p>To know more about DTLS handshake messages, see <a href="http://tools.ietf.org/html/rfc4347" target="_blank">DTLS Version 1.0</a> and <a href="http://tools.ietf.org/html/rfc6347" target="_blank">DTLS Version 1.2</a>.</p>
<div class="figure" id="GUID-F1BFB231-BE35-4B14-BB8D-7F33D31A117D__GUID-72C1D49C-0A80-4548-BF96-2D72E1C65912">
<p class="titleinfigure">Figure 8-7 DTLS Handshake</p>
<img width="401" height="375" src="img/dtls-handshake.png" alt="Description of Figure 8-7 follows" title="Description of Figure 8-7 follows" /><br />
<a href="img_text/dtls-handshake.htm">Description of "Figure 8-7 DTLS Handshake"</a></div>
<!-- class="figure" -->
<p>The following handshake messages are exchanged between the client and server during DTLS handshake:</p>
<ol>
<li><span class="bold">ClientHello:</span>
<p>The client sends the server information including the highest version of DTLS that it supports and a list of the cipher suites that it supports. The cipher suite information includes cryptographic algorithms and key sizes.</p>
</li>
<li><span class="bold">HelloVerifyRequest:</span>
<p>The server responds to the ClientHello message from the client with a cookie.</p>
</li>
<li><span class="bold">ClientHello:</span>
<p>The client sends a second ClientHello message to the server with highest version of DTLS that it supports and a list of the cipher suites that it supports. The cookie received in the HelloVerifyRequest is sent back to the server.</p>
</li>
<li><span class="bold">ServerHello:</span>
<p>The server chooses the highest version of DTLS and the best cipher suite that both the client and server support and sends this information to the client.</p>
</li>
<li>(Optional) <span class="bold">Certificate:</span>
<p>The server sends the client a certificate or a certificate chain. A certificate chain typically begins with the server's public key certificate and ends with the certificate authority's root certificate. This message is optional, but is used whenever server authentication is required</p>
</li>
<li>(Optional) <span class="bold">CertificateRequest:</span>
<p>If the server must authenticate the client, then it sends the client a certificate request. In Internet applications, this message is rarely sent.</p>
</li>
<li>(Optional) <span class="bold">ServerKeyExchange:</span>
<p>The server sends the client a server key exchange message if the public key information from the Certificate is not sufficient for key exchange. For example, in cipher suites based on Diffie-Hellman (DH), this message contains the server's DH public key.</p>
</li>
<li><span class="bold">ServerHelloDone:</span>
<p>The server tells the client that it is finished with its initial negotiation messages.</p>
</li>
<li>(Optional) <span class="bold">Certificate:</span>
<p>If the server Certificate request from the client, the client sends its certificate chain, just as the server did previously.</p>
<div class="p">
<div class="infobox-note" id="GUID-F1BFB231-BE35-4B14-BB8D-7F33D31A117D__GUID-296D3B3F-97C6-466C-BDB7-716D4EDEA51C">
<p class="notep1">Note:</p>
Only a few Internet server applications ask for a certificate from the client.</div>
</div>
</li>
<li><span class="bold">ClientKeyExchange:</span>
<p>The client generates information used to create a key to use for symmetric encryption. For RSA, the client then encrypts this key information with the server's public key and sends it to the server. For cipher suites based on DH, this message contains the client's DH public key.</p>
</li>
<li>(Optional) <span class="bold">CertificateVerify:</span>
<p>This message is sent by the client when the client presents a certificate as previously explained. Its purpose is to allow the server to complete the process of authenticating the client. When this message is used, the client sends information that it digitally signs using a cryptographic hash function. When the server decrypts this information with the client's public key, the server is able to authenticate the client.</p>
</li>
<li><span class="bold">ChangeCipherSpec:</span>
<p>The client sends a message telling the server that subsequent data will be protected under the newly negotiated CipherSpec and keys and the data is encrypted</p>
</li>
<li><span class="bold">Finished:</span>
<p>The client tells the server that it is ready for secure data communication to begin.</p>
</li>
<li><span class="bold">ChangeCipherSpec:</span>
<p>The server sends a message telling the client that subsequent data will be protected under the newly negotiated CipherSpec and keys and the data is encrypted.</p>
</li>
<li><span class="bold">Finished:</span>
<p>The server tells the client that it is ready for secure data communication to begin. This is the end of the DTLS handshake.</p>
</li>
</ol>
</div>
</div>
<div class="sect6"><a id="GUID-E1E48823-8B76-456A-88FA-B4D531183520"></a>
<h6 id="JSSEC-GUID-E1E48823-8B76-456A-88FA-B4D531183520" class="sect6">Handshaking Again (Renegotiation)</h6>
<div>
<p>Once the initial handshake is finished and application data is flowing, either side is free to initiate a new handshake at any time. An application might like to use a stronger cipher suite for especially critical operations, or a server application might want to require client authentication.</p>
<p>Regardless of the reason, the new handshake takes place over the existing encrypted session, and application data and handshake messages are interleaved until a new session is established.</p>
<p>Your application can initiate a new handshake by using the <code class="codeph">SSLEngine.beginHandshake()</code> method.</p>
<div class="infobox-note" id="GUID-E1E48823-8B76-456A-88FA-B4D531183520__GUID-B4E262C5-520F-4941-B49D-791402E56838">
<p class="notep1">Note:</p>
A protocol flaw related to renegotiation was found in 2009. The protocol and the Java SE implementation have both been fixed. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-9C767872-3A6C-4AD1-9805-49F112A0FA28" title="In the fall of 2009, a flaw was discovered in the SSL/TLS protocols. A fix to the protocol was developed by the IETF TLS Working Group, and current versions of the JDK contain this fix. This section describes the situation in much more detail, along with interoperability issues when communicating with older implementations that do not contain this protocol fix.">Transport Layer Security (TLS) Renegotiation Issue</a>.</div>
<div class="example" id="GUID-E1E48823-8B76-456A-88FA-B4D531183520__GUID-E31F4DB7-7133-414A-A7A8-4AECA3A8A5CA">
<p class="titleinexample">Example 8-4 Sample Code for Handling DTLS handshake Status and Overall Status</p>
<pre dir="ltr">
void handshake(SSLEngine engine, DatagramSocket socket, SocketAddress peerAddr) throws Exception {
    boolean endLoops = false;
    // private static int MAX_HANDSHAKE_LOOPS = 60;
    int loops = MAX_HANDSHAKE_LOOPS;
    engine.beginHandshake();
    while (!endLoops &amp;&amp; (serverException == null) &amp;&amp; (clientException == null)) {
        if (--loops &lt; 0) {
            throw new RuntimeException("Too many loops to produce handshake packets");
        }
        SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
        if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||
                hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
            ByteBuffer iNet;
            ByteBuffer iApp;
            if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                // Receive ClientHello request and other SSL/TLS/DTLS records
                byte[] buf = new byte[1024];
                DatagramPacket packet = new DatagramPacket(buf, buf.length);
                try {
                    socket.receive(packet);
                } catch (SocketTimeoutException ste) {
                    // Retransmit the packet if timeout
                    List &lt;Datagrampacket&gt; packets = onReceiveTimeout(engine, peerAddr);
                    for (DatagramPacket p : packets) {
                        socket.send(p);
                    }
                    continue;
                }
                iNet = ByteBuffer.wrap(buf, 0, packet.getLength());
                iApp = ByteBuffer.allocate(1024);
            } else {
                iNet = ByteBuffer.allocate(0);
                iApp = ByteBuffer.allocate(1024);
            }
            SSLEngineResult r = engine.unwrap(iNet, iApp);
            SSLEngineResult.Status rs = r.getStatus();
            hs = r.getHandshakeStatus();
            if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {
                // The client maximum fragment size config does not work?
                throw new Exception("Buffer overflow: " +
                                    "incorrect client maximum fragment size");
            } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
                // Bad packet, or the client maximum fragment size
                // config does not work?
                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                    throw new Exception("Buffer underflow: " +
                                        "incorrect client maximum fragment size");
                } // Otherwise, ignore this packet
            } else if (rs == SSLEngineResult.Status.CLOSED) {
                endLoops = true;
            } // Otherwise, SSLEngineResult.Status.OK
            if (rs != SSLEngineResult.Status.OK) {
                continue;
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
            // Call a function to produce handshake packets
            List &lt;DatagramPacket&gt; packets = produceHandshakePackets(engine, peerAddr);
            for (DatagramPacket p : packets) {
                socket.send(p);
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {
            runDelegatedTasks(engine);
        } else if (hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
            // OK, time to do application data exchange
            endLoops = true;
        } else if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {
            endLoops = true;
        }
    }
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
    if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
        throw new Exception("Not ready for application data yet");
    }
}
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<div class="sect5"><a id="GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7"></a>
<h5 id="JSSEC-GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7" class="sect5">Handling Retransmissions in DTLS Connections</h5>
<div>
<p>In SSL/TLS over a reliable connection, data is guaranteed to arrive in the proper order, and retransmission is unnecessary. However, for DTLS, which often works over unreliable media, missing or delayed handshake messages must be retransmitted.</p>
<div class="section">
<p>The <code class="codeph">SSLEngine</code> class operates in a completely transport-neutral manner, and the application layer performs all I/O. Because the <code class="codeph">SSLEngine</code> class isn&rsquo;t responsible for I/O, the application instead is responsible for providing timers and signalling the <code class="codeph">SSLEngine</code> class when a retransmission is needed. The application layer must determine the right timeout value and when to trigger the timeout event. During handshaking, if an <code class="codeph">SSLEngine</code> object is in <code class="codeph">HandshakeStatus.NEED_UNWRAP</code> state, a call to <span class="apiname">SSLEngine.wrap()</span> means that the previous packets were lost, and must be retransmitted. For such cases, the DTLS implementation of the <code class="codeph">SSLEngine</code> class takes the responsibility to wrap the previous necessary handshaking messages again if necessary.</p>
<div class="infobox-note" id="GUID-6C8AA45B-EB45-4767-BBB4-B7C5A64A60B7__GUID-3AC8121B-28CE-4611-8E66-06E9CEC39B5E">
<p class="notep1">Note:</p>
In a DTLS engine, only handshake messages must be properly exchanged. Application data can handle packet loss without the need for timers.</div>
</div>
<!-- class="section" --></div>
<div class="sect6"><a id="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3"></a>
<h6 id="JSSEC-GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3" class="sect6">Handling Retransmission in an Application</h6>
<div>
<p><code class="codeph">SSLEngine.unwrap()</code> and <code class="codeph">SSLEngine.wrap()</code> can be used together to handle retransmission in an application.</p>
<div class="section">
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3__GUID-62CAEA17-2745-42AE-94C6-2E35852FC63A">Figure 8-8</a> shows a typical scenario for handling DTLS handshaking retransmission:</p>
<div class="figure" id="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3__GUID-62CAEA17-2745-42AE-94C6-2E35852FC63A">
<p class="titleinfigure">Figure 8-8 DTLS Handshake Retransmission State Flow</p>
<img width="408" height="535" src="img/state-flow-need_unwrap_again_new.png" alt="This image illustrates the DTLS handshake retransmission state flow. The flow is described in the numbered steps that follow the image." title="This image illustrates the DTLS handshake retransmission state flow. The flow is described in the numbered steps that follow the image." /></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create and initialize an instance of DTLS <code class="codeph">SSLEngine</code>.</span>
<div>See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" title="Use the SSLContext.createSSLEngine() method to create an SSLEngine object.">Creating an SSLEngine Object</a>. The DTLS handshake process begins. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-B62245D1-5337-4B51-B1F3-CA89099157C1" title="Before application data can be sent or received, the DTLS protocol requires a handshake to establish cryptographic parameters. This handshake requires a series of back-and-forth messages between the client and server by the SSLEngine object.">The DTLS Handshake</a>.</div>
</li>
<li class="stepexpand"><span>If the handshake status is <code class="codeph">HandshakeStatus.NEED_UNWRAP</code>, wait for data from network.</span></li>
<li class="stepexpand"><span>If the timer times out, it indicates that the previous delivered handshake messages may have been lost.</span>
<div>
<div class="infobox-note" id="GUID-32494D9D-B0FC-4DFC-B747-F4115B6112E3__GUID-39A9DD22-1E2F-4924-8960-9DCAF232DE86">
<p class="notep1">Note:</p>
In DTLS handshaking retransmission, the determined handshake status isn&rsquo;t necessarily <code class="codeph">HandshakeStatus.NEED_WRAP</code> for the call to <code class="codeph">SSLEngine.wrap()</code>.</div>
</div>
</li>
<li class="stepexpand"><span>Call <code class="codeph">SSLEngine.wrap()</code>.</span></li>
<li class="stepexpand"><span>The wrapped packets are delivered.</span></li>
</ol>
</div>
</div>
<div class="sect6"><a id="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381"></a>
<h6 id="JSSEC-GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381" class="sect6">Handling a Buffered Handshake Message in an Application</h6>
<div>
<p>Datagram transport doesn&rsquo;t require or provide reliable or in-order delivery of data.&nbsp;Handshake messages may be lost or need to be reordered. In the DTLS implementation, a handshake message may need to be buffered for future handling before all previous messages have been received.</p>
<div class="section">
<p>The DTLS implementation of <code class="codeph">SSLEngine</code> takes the responsibility to reorder handshake messages. Handshake message buffering and reordering are transparent to applications.</p>
<p>However, applications must manage <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code> status. This status indicates that for the next <span class="apiname">SSLEngine.unwrap()</span> operation no additional data from the remote side is required.</p>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381__GUID-693172EF-782D-4676-BA14-27B0794F8B72">Figure 8-9</a> shows a typical scenario for using the <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>.</p>
<div class="figure" id="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381__GUID-693172EF-782D-4676-BA14-27B0794F8B72">
<p class="titleinfigure">Figure 8-9 State Machine of DTLS Buffered Handshake with NEED_UNWRAP_AGAIN</p>
<img width="414" height="536" src="img/dtls-buffered-handshake-message-new.png" alt="This flowchart illustrates the sequence of messages that are exchanged in the DTLS buffered handshake. Messages that are sent only in certain situations are noted as optional. The sequence is described in the numbered list that follows the image." title="This flowchart illustrates the sequence of messages that are exchanged in the DTLS buffered handshake. Messages that are sent only in certain situations are noted as optional. The sequence is described in the numbered list that follows the image." /></div>
<!-- class="figure" --></div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>Create and initialize an instance of DTLS <code class="codeph">SSLEngine</code>.</span>
<div>See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-16B697CD-77EB-468F-94A1-04254BA75FD7" title="Use the SSLContext.createSSLEngine() method to create an SSLEngine object.">Creating an SSLEngine Object</a>. The DTLS handshake process begins, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-B62245D1-5337-4B51-B1F3-CA89099157C1" title="Before application data can be sent or received, the DTLS protocol requires a handshake to establish cryptographic parameters. This handshake requires a series of back-and-forth messages between the client and server by the SSLEngine object.">The DTLS Handshake</a>.</div>
</li>
<li class="stepexpand"><strong>Optional:</strong> <span>If the handshake status is <code class="codeph">HandshakeStatus.NEED_UNWRAP</code>, wait for data from network.</span></li>
<li class="stepexpand"><strong>Optional:</strong> <span>If you received the network data, call <span class="apiname">SSLEngine.unwrap()</span>.</span></li>
<li class="stepexpand"><span>Determine the handshake status for next processing. The handshake status can be <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>, <code class="codeph">HandshakeStatus.NEED_UNWRAP</code>, or <code class="codeph">HandshakeStatus.NEED_WRAP</code>.</span>
<ul>
<li>If the handshake status is <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>, call <span class="apiname">SSLEngine.unwrap()</span>.</li>
</ul>
<div>
<div class="infobox-note" id="GUID-F8FB4BE7-3A43-41FB-8642-07848FCA9381__GUID-4201EFCD-11F7-4175-A530-80F779E79E05">
<p class="notep1">Note:</p>
For <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code> status, no additional data from the network is required for an <span class="apiname">SSLEngine.unwrap()</span> operation.</div>
</div>
</li>
<li class="stepexpand"><span>Determine the handshake status for further processing. The handshake status can be <code class="codeph">HandshakeStatus.NEED_UNWRAP_AGAIN</code>, <code class="codeph">HandshakeStatus.NEED_UNWRAP</code>, or <code class="codeph">HandshakeStatus.NEED_WRAP</code>.</span></li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect4"><a id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF"></a>
<h4 id="JSSEC-GUID-4D854666-433A-4672-B902-565CC7AEE0BF" class="sect4">Creating an SSLEngine Object for DTLS</h4>
<div>
<p>The following examples illustrate how to create an <code class="codeph">SSLEngine</code> object for DTLS.</p>
<div class="p">
<div class="infobox-note" id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF__GUID-4E9C2C41-E06E-4412-A9C8-20DBFA93CC0B">
<p class="notep1">Note:</p>
The server name and port number are not used for communicating with the server (all transport is the responsibility of the application). They are hints to the JSSE provider to use for DTLS session caching, and for Kerberos-based cipher suite implementations to determine which server credentials should be obtained.</div>
</div>
<div class="example" id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FCB3A">
<p class="titleinexample">Example 8-5 Sample Code for Creating an SSLEngine Client for DTLS with PKCS12 as Keystore</p>
<p>The following sample code creates an <span class="apiname">SSLEngine</span> client for DTLS that uses PKCS12 as keystore:</p>
<pre class="codeblock" dir="ltr">
    import javax.net.ssl.*;
    import java.security.*;

    // Create and initialize the SSLContext with key material
    char[] passphrase = "passphrase".toCharArray();

    // First initialize the key and trust material
    KeyStore ksKeys = KeyStore.getInstance("PKCS12");
    ksKeys.load(new FileInputStream("testKeys"), passphrase);
    KeyStore ksTrust = KeyStore.getInstance("PKCS12");
    ksTrust.load(new FileInputStream("testTrust"), passphrase);

    // KeyManagers decide which key material to use
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
    kmf.init(ksKeys, passphrase);

    // TrustManagers decide whether to allow connections
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ksTrust);

    // Get an instance of SSLContext for DTLS protocols
    sslContext = SSLContext.getInstance("DTLS");
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

    // Create the engine
    SSLEngine engine = sslContext.createSSLengine(hostname, port);

    // Use engine as client
    engine.setUseClientMode(true);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-4D854666-433A-4672-B902-565CC7AEE0BF__THEFOLLOWINGSAMPLECODECREATESASSLEN-225FC3CE">
<p class="titleinexample">Example 8-6 Sample Code for Creating an SSLEngine Server for DTLS with PKCS12 as Keystore</p>
The following sample code creates an <span class="apiname">SSLEngine</span> server for DTLS that uses PKCS12 as keystore:
<pre class="codeblock" dir="ltr">
    import javax.net.ssl.*;
    import java.security.*;

    // Create and initialize the SSLContext with key material
    char[] passphrase = "passphrase".toCharArray();

    // First initialize the key and trust material
    KeyStore ksKeys = KeyStore.getInstance("PKCS12");
    ksKeys.load(new FileInputStream("testKeys"), passphrase);
    KeyStore ksTrust = KeyStore.getInstance("PKCS12");
    ksTrust.load(new FileInputStream("testTrust"), passphrase);

    // KeyManagers decide which key material to use
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
    kmf.init(ksKeys, passphrase);

    // TrustManagers decide whether to allow connections
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ksTrust);

    // Get an SSLContext for DTLS Protocol without authentication
    sslContext = SSLContext.getInstance("DTLS");
    sslContext.init(null, null, null);

    // Create the engine
    SSLEngine engine = sslContext.createSSLeEngine(hostname, port);

    // Use the engine as server
    engine.setUseClientMode(false);

    // Require client authentication
    engine.setNeedClientAuth(true);
</pre></div>
<!-- class="example" --></div>
</div>
<div class="sect4"><a id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45"></a>
<h4 id="JSSEC-GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45" class="sect4">Generating and Processing DTLS Data</h4>
<div>
<p>A DTLS handshake and a SSL/TLS handshake generate and process data similarly. (See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4" title="The two main SSLEngine methods are wrap() and unwrap(). They are responsible for generating and consuming network data respectively. Depending on the state of the SSLEngine object, this data might be handshake or application data.">Generating and Processing SSL/TLS Data</a>.) They both use the <span class="apiname">SSLEngine.wrap()</span> and <span class="apiname">SSLEngine.wrap()</span> methods to generate and consume network data, respectively.</p>
<p>The following diagram shows the state machine during a typical DTLS handshake, with corresponding messages and statuses:</p>
<div class="figure" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-85F0E791-66C0-479B-855B-86509CE249FE">
<p class="titleinfigure">Figure 8-10 State Machine during DTLS Handshake</p>
<img width="412" height="535" src="img/jsse-handshake-state-machine-new.png" alt="Description of Figure 8-10 follows" title="Description of Figure 8-10 follows" /><br />
<a href="img_text/jsse-handshake-state-machine-new.htm">Description of "Figure 8-10 State Machine during DTLS Handshake"</a></div>
<!-- class="figure" -->
<div class="section">
<p class="subhead3">Difference Between the SSL/TLS and DTLS SSLEngine.wrap() Methods</p>
<div class="p">The <code class="codeph">SSLEngine.wrap()</code> method for DTLS is different from SSL/TLS as follows:
<ul style="list-style-type: disc;">
<li>
<p>In the SSL/TLS implementation of <code class="codeph">SSLEngine</code>, the output buffer of <code class="codeph">SSLEngine.wrap()</code> contains one or more TLS records (due to the TLSv1 BEAST Cipher Block Chaining vulnerability).</p>
</li>
<li>
<p>In the DTLS implementation of <code class="codeph">SSLEngine</code>, the output buffer of <code class="codeph">SSLEngine.wrap()</code> contains at most one record, so that every DTLS record can be marshaled and delivered to the datagram layer individually.</p>
</li>
</ul>
<div class="infobox-note" id="GUID-80EBB1BB-8A36-4B6F-BC35-AF235F30EF45__GUID-52C4A89B-A524-44E5-9626-136B0C65EB0C">
<p class="notep1">Note:</p>
Each record produced by <code class="codeph">SSLEngine.wrap()</code> should comply to the maximum packet size limitation as specified by <code class="codeph">SSLParameters.getMaximumPacketSize()</code>.</div>
&nbsp;</div>
</div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744"></a>
<h4 id="JSSEC-GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" class="sect4">Understanding SSLEngine Operation Statuses</h4>
<div>
<p>The status of the SSLEngine is represented by <code class="codeph">SSLEngineResult.Status</code>.</p>
<div class="section">
<p>To indicate the status of the engine and what actions the application should take, the <code class="codeph">SSLEngine.wrap()</code> and <code class="codeph">SSLEngine.unwrap()</code> methods return an <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngineResult.html" target="_blank"><code class="codeph">SSLEngineResult</code></a> instance, as shown in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-6DB10B60-4FE0-4C29-8E6D-DC661522A2B4__GUID-223D79BF-70AD-4F6C-B472-81C28C010BD9">Example 8-2</a>. This <code class="codeph">SSLEngineResult</code> object contains two pieces of status information: the overall status of the engine and the handshaking status.</p>
<p>The possible overall statuses are represented by the <code class="codeph">SSLEngineResult.Status</code> enum. The following statuses are available:</p>
<dl>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-F79D56D5-8F54-4E4E-ACFB-4BEF8B9B9E7D"><!-- --></a><code class="codeph">OK</code></dt>
<dd>There was no error.</dd>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-55BEDBCE-8E29-45B8-98D1-9E6929540C3D"><!-- --></a><code class="codeph">CLOSED</code></dt>
<dd>The operation closed the <code class="codeph">SSLEngine</code> or the operation could not be completed because it was already closed.</dd>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-C5AE7AA6-7EA1-447A-B443-6895062E1F87"><!-- --></a><code class="codeph">BUFFER_UNDERFLOW</code></dt>
<dd>The input buffer had insufficient data, indicating that the application must obtain more data from the peer (for example, by reading more data from the network).</dd>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-B67FEDA3-B9B6-4730-9C49-9D3D60E3255C"><!-- --></a><code class="codeph">BUFFER_OVERFLOW</code></dt>
<dd>The output buffer had insufficient space to hold the result, indicating that the application must clear or enlarge the destination buffer.</dd>
</dl>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE4HANDLINGBUFFER_UNDERFLOWAND-78F60126">Example 8-7</a> illustrates how to handle the <code class="codeph">BUFFER_UNDERFLOW</code> and <code class="codeph">BUFFER_OVERFLOW</code> statuses of the <code class="codeph">SSLEngine.unwrap()</code> method. It uses <code class="codeph">SSLSession.getApplicationBufferSize()</code> and <code class="codeph">SSLSession.getPacketBufferSize()</code> to determine how large to make the byte buffers.</p>
<p>The possible handshaking statuses are represented by the <code class="codeph">SSLEngineResult.HandshakeStatus</code> enum. They represent whether handshaking has completed, whether the caller must obtain more handshaking data from the peer or send more handshaking data to the peer, and so on. The following handshake statuses are available:</p>
<dl>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-6738EEFA-1FE5-48B8-9E03-B99B688FD77F"><!-- --></a><code class="codeph">FINISHED</code></dt>
<dd>The <code class="codeph">SSLEngine</code> has just finished handshaking.</dd>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-29199762-DA07-4595-B35D-A0271A229020"><!-- --></a><code class="codeph">NEED_TASK</code></dt>
<dd>The <code class="codeph">SSLEngine</code> needs the results of one (or more) delegated tasks before handshaking can continue.</dd>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-DEFA0BD8-5FC5-41E8-AEB4-82542DDDF7CA"><!-- --></a><code class="codeph">NEED_UNWRAP</code></dt>
<dd>The <code class="codeph">SSLEngine</code> needs to receive data from the remote side before handshaking can continue.</dd>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-C4CCD4B8-357E-4F8B-95E2-89B2A255D9E3"><!-- --></a><code class="codeph">NEED_UNWRAP_AGAIN</code></dt>
<dd>The <code class="codeph">SSLEngine</code> needs to unwrap before handshaking can continue. This value indicates that not-yet-interpreted data has been previously received from the remote side and does not need to be received again; the data has been brought into the JSSE framework but has not been processed yet.</dd>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-2FCB0DC1-F723-4036-B8DA-0A885ECA17E7"><!-- --></a><code class="codeph">NEED_WRAP</code></dt>
<dd>The <code class="codeph">SSLEngine</code> must send data to the remote side before handshaking can continue, so <span class="apiname">SSLEngine.wrap()</span> should be called.</dd>
<dt class="dlterm"><a id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-215B8B63-813A-4B80-98DE-3C16A0F2926A"><!-- --></a><code class="codeph">NOT_HANDSHAKING</code></dt>
<dd>The <code class="codeph">SSLEngine</code> is not currently handshaking.</dd>
</dl>
<p>Having two statuses per result allows the <span class="apiname">SSLEngine</span> to indicate that the application must take two actions: one in response to the handshaking and one representing the overall status of the <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> methods. For example, the engine might, as the result of a single <code class="codeph">SSLEngine.unwrap()</code> call, return <code class="codeph">SSLEngineResult.Status.OK</code> to indicate that the input data was processed successfully and <code class="codeph">SSLEngineResult.HandshakeStatus.NEED_UNWRAP</code> to indicate that the application should obtain more SSL/TLS/DTLS encoded data from the peer and supply it to <code class="codeph">SSLEngine.unwrap()</code> again so that handshaking can continue. As you can see, the previous examples were greatly simplified; they would need to be expanded significantly to properly handle all of these statuses.</p>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-CEB4C19E-7DB9-4CD8-8315-8FEDD212BAD3">Example 8-9</a> and <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE5CHECKINGANDPROCESSINGHANDSH-78F5FE16">Example 8-8</a> illustrate how to process handshaking data by checking handshaking status and the overall status of the <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> methods.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE4HANDLINGBUFFER_UNDERFLOWAND-78F60126">
<p class="titleinexample">Example 8-7 Sample Code for Handling BUFFER_UNDERFLOW and BUFFER_OVERFLOW</p>
<p>The following code sample illustrates how to handle BUFFER_UNDERFLOW and BUFFER_OVERFLOW status:</p>
<pre class="codeblock" dir="ltr">
    SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
    switch (res.getStatus()) {

    case BUFFER_OVERFLOW:
            // Maybe need to enlarge the peer application data buffer.
        if (engine.getSession().getApplicationBufferSize() &gt; peerAppData.capacity()) {
            // enlarge the peer application data buffer
        } else {
            // compact or clear the buffer
        }
        // retry the operation
    break;

    case BUFFER_UNDERFLOW:
        // Maybe need to enlarge the peer network packet buffer
        if (engine.getSession().getPacketBufferSize() &gt; peerNetData.capacity()) {
        // enlarge the peer network packet buffer
        } else {
        // compact or clear the buffer
        }
        // obtain more inbound network data and then retry the operation
       break;

       // Handle other status: CLOSED, OK
       // ...
    }
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__EXAMPLE5CHECKINGANDPROCESSINGHANDSH-78F5FE16">
<p class="titleinexample">Example 8-8 Sample Code for Checking and Processing Handshaking Statuses and Overall Statuses</p>
<p>The following code sample illustrates how to process handshaking data by checking handshaking status and the overall status of the <span class="apiname">wrap()</span> and <span class="apiname">unwrap()</span> methods:</p>
<pre class="codeblock" dir="ltr">
void doHandshake(SocketChannel socketChannel, SSLEngine engine,
    ByteBuffer myNetData, ByteBuffer peerNetData) throws Exception {

    // Create byte buffers to use for holding application data
    int appBufferSize = engine.getSession().getApplicationBufferSize();
    ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);
    ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);

    // Begin handshake
    engine.beginHandshake();
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();

    // Process handshaking message
    while (hs != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp;
        hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {

        switch (hs) {

        case NEED_UNWRAP:
            // Receive handshaking data from peer
            if (socketChannel.read(peerNetData) &lt; 0) {
                // The channel has reached end-of-stream
            }

            // Process incoming handshaking data
            peerNetData.flip();
            SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
            peerNetData.compact();
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                // Handle OK status
                break;

            // Handle other status: BUFFER_UNDERFLOW, BUFFER_OVERFLOW, CLOSED
            // ...
            }
            break;

        case NEED_WRAP :
            // Empty the local network packet buffer.
            myNetData.clear();

            // Generate handshaking data
            res = engine.wrap(myAppData, myNetData);
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                myNetData.flip();

                // Send the handshaking data to peer
                while (myNetData.hasRemaining()) {
                    socketChannel.write(myNetData);
                }
                break;

            // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
            // ...
            }
            break;

        case NEED_TASK :
            // Handle blocking tasks
            break;

            // Handle other status:  // FINISHED or NOT_HANDSHAKING
            // ...
        }
    }

    // Processes after handshaking
    // ...
}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744__GUID-CEB4C19E-7DB9-4CD8-8315-8FEDD212BAD3">
<p class="titleinexample">Example 8-9 Sample Code for Handling DTLS handshake Status and Overall Status</p>
<p>The following code sample illustrates how to handle DTLS handshake status:</p>
<pre dir="ltr">
void handshake(SSLEngine engine, DatagramSocket socket,
               SocketAddress peerAddr) throws Exception {
    boolean endLoops = false;
    // private static int MAX_HANDSHAKE_LOOPS = 60;
    int loops = MAX_HANDSHAKE_LOOPS;
    engine.beginHandshake();
    while (!endLoops &amp;&amp; (serverException == null) &amp;&amp; (clientException == null)) {
        if (--loops &lt; 0) {
            throw new RuntimeException("Too many loops to produce handshake packets");
        }
        SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
        if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ||
                hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN) {
            ByteBuffer iNet;
            ByteBuffer iApp;
            if (hs == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                // receive ClientHello request and other SSL/TLS/DTLS records
                byte[] buf = new byte[1024];
                DatagramPacket packet = new DatagramPacket(buf, buf.length);
                try {
                    socket.receive(packet);
                } catch (SocketTimeoutException ste) {
                    // retransmit the packet if timeout
                    List &lt;Datagrampacket&gt; packets =
                        onReceiveTimeout(engine, peerAddr);
                    for (DatagramPacket p : packets) {
                        socket.send(p);
                    }
                    continue;
                }
                iNet = ByteBuffer.wrap(buf, 0, packet.getLength());
                iApp = ByteBuffer.allocate(1024);
            } else {
                iNet = ByteBuffer.allocate(0);
                iApp = ByteBuffer.allocate(1024);
            }
            SSLEngineResult r = engine.unwrap(iNet, iApp);
            SSLEngineResult.Status rs = r.getStatus();
            hs = r.getHandshakeStatus();
            if (rs == SSLEngineResult.Status.BUFFER_OVERFLOW) {
                // the client maximum fragment size config does not work?
                throw new Exception("Buffer overflow: " +
                                    "incorrect client maximum fragment size");
            } else if (rs == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
                // bad packet, or the client maximum fragment size
                // config does not work?
                if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                    throw new Exception("Buffer underflow: " +
                                        "incorrect client maximum fragment size");
                } // otherwise, ignore this packet
            } else if (rs == SSLEngineResult.Status.CLOSED) {
                endLoops = true;
            }   // otherwise, SSLEngineResult.Status.OK:
            if (rs != SSLEngineResult.Status.OK) {
                continue;
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
            List &lt;DatagramPacket&gt; packets =
                // Call a function to produce handshake packets
                produceHandshakePackets(engine, peerAddr);
            for (DatagramPacket p : packets) {
                socket.send(p);
            }
        } else if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {
            runDelegatedTasks(engine);
        } else if (hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
            // OK, time to do application data exchange.
            endLoops = true;
        } else if (hs == SSLEngineResult.HandshakeStatus.FINISHED) {
            endLoops = true;
        }
    }
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();
    if (hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
        throw new Exception("Not ready for application data yet");
    }
}
</pre></div>
<!-- class="example" --></div>
</div>
<div class="sect4"><a id="GUID-7ED13982-53B2-455B-9198-3289F19905B6"></a>
<h4 id="JSSEC-GUID-7ED13982-53B2-455B-9198-3289F19905B6" class="sect4">Dealing With Blocking Tasks</h4>
<div>
<div class="section">
<p>During handshaking, an <code class="codeph">SSLEngine</code> might encounter tasks that can block or take a long time. For example, a <code class="codeph">TrustManager</code> may need to connect to a remote certificate validation service, or a <code class="codeph">KeyManager</code> might need to prompt a user to determine which certificate to use as part of client authentication. To preserve the nonblocking nature of <code class="codeph">SSLEngine</code>, when the engine encounters such a task, it will return <code class="codeph">SSLEngineResult.HandshakeStatus.NEED_TASK</code>. Upon receiving this status, the application should invoke <code class="codeph">SSLEngine.getDelegatedTask()</code> to get the task, and then, using the threading model appropriate for its requirements, process the task. The application might, for example, obtain threads from a thread pool to process the tasks, while the main thread handles other I/O.</p>
<p>The following code executes each task in a newly created thread:</p>
<pre class="codeblock" dir="ltr">
if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {
    Runnable task;
    while ((task = engine.getDelegatedTask()) != null) {
        new Thread(task).start();
    }
}
</pre>
<p>The <code class="codeph">SSLEngine</code> will block future <code class="codeph">wrap()</code> and <code class="codeph">unwrap()</code> calls until all of the outstanding tasks are completed.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33"></a>
<h4 id="JSSEC-GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33" class="sect4">Shutting Down a SSL/TLS/DTLS Connection</h4>
<div>
<div class="section">
<p>For an orderly shutdown of an SSL/TLS/DTLS connection, the SSL/TLS/DTLS protocols require transmission of close messages. Therefore, when an application is done with the SSL/TLS/DTLS connection, it should first obtain the close messages from the <code class="codeph">SSLEngine</code>, then transmit them to the peer using its transport mechanism, and finally shut down the transport mechanism. <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">Example 8-10</a> illustrates this.</p>
<p>In addition to an application explicitly closing the <code class="codeph">SSLEngine</code>, the <code class="codeph">SSLEngine</code> might be closed by the peer (via receipt of a close message while it is processing handshake data), or by the <code class="codeph">SSLEngine</code> encountering an error while processing application or handshake data, indicated by throwing an <code class="codeph">SSLException</code>. In such cases, the application should invoke <code class="codeph">SSLEngine.wrap()</code> to get the close message and send it to the peer until <code class="codeph">SSLEngine.isOutboundDone()</code> returns <code class="codeph">true</code> (as shown in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">Example 8-10</a>), or until the <code class="codeph">SSLEngineResult.getStatus()</code> returns <code class="codeph">CLOSED</code>.</p>
<p>In addition to orderly shutdowns, there can also be unexpected shutdowns when the transport link is severed before close messages are exchanged. In the previous examples, the application might get <code class="codeph">-1</code> or <code class="codeph">IOException</code> when trying to read from the nonblocking <code class="codeph">SocketChannel</code>, or get <code class="codeph">IOException</code> when trying to write to the non-blocking <code class="codeph">SocketChannel</code>. When you get to the end of your input data, you should call <code class="codeph">engine.closeInbound()</code>, which will verify with the <code class="codeph">SSLEngine</code> that the remote peer has closed cleanly from the SSL/TLS/DTLS perspective. Then the application should still try to shut down cleanly by using the procedure in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">Example 8-10</a>. Obviously, unlike <code class="codeph">SSLSocket</code>, the application using <code class="codeph">SSLEngine</code> must deal with more state transitions, statuses, and programming. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGTHEUSEOFANSSL-7D23A601">Sample Code Illustrating the Use of an SSLEngine</a>.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-2B54A68F-75AF-4FEA-9339-F7082FE5DA33__SHUTTINGDOWNANSSLTLSCONNECTION-B4C0BC69">
<p class="titleinexample">Example 8-10 Sample Code for Shutting Down a SSL/TLS/DTLS Connection</p>
<p>The following code sample illustrates how to shut down a SSL/TLS/DTLS connection:</p>
<pre class="codeblock" dir="ltr">
// Indicate that application is done with engine
engine.closeOutbound();

while (!engine.isOutboundDone()) {
    // Get close message
    SSLEngineResult res = engine.wrap(empty, myNetData);

    // Check res statuses

    // Send close message to peer
    while(myNetData.hasRemaining()) {
        int num = socketChannel.write(myNetData);
        if (num == 0) {
            // no bytes written; try again later
        }
        myNetData().compact();
    }
}

// Close transport
socketChannel.close();
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<div class="sect3"><a id="GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B"></a>
<h3 id="JSSEC-GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" class="sect3">SSLSession and ExtendedSSLSession</h3>
<div>
<p>The <code class="codeph">javax.net.ssl.SSLSession</code> interface represents a security context negotiated between the two peers of an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> connection. After a session has been arranged, it can be shared by future <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> objects connected between the same two peers.</p>
<div class="section">
<p>In some cases, parameters negotiated during the handshake are needed later in the handshake to make decisions about trust. For example, the list of valid signature algorithms might restrict the certificate types that can be used for authentication. The <code class="codeph">SSLSession</code> can be retrieved <span class="italic">during</span> the handshake by calling <code class="codeph">getHandshakeSession()</code> on an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code>. Implementations of <code class="codeph">TrustManager</code> or <code class="codeph">KeyManager</code> can use the <code class="codeph">getHandshakeSession()</code> method to get information about session parameters to help them make decisions.</p>
<p>A fully initialized <code class="codeph">SSLSession</code> contains the cipher suite that will be used for communications over a secure socket as well as a nonauthoritative hint as to the network address of the remote peer, and management information such as the time of creation and last use. A session also contains a shared master secret negotiated between the peers that is used to create cryptographic keys for encrypting and guaranteeing the integrity of the communications over an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> connection. The value of this master secret is known only to the underlying secure socket implementation and is not exposed through the <code class="codeph">SSLSession</code> API.</p>
<p><code class="codeph">ExtendedSSLSession</code> extends the <code class="codeph">SSLSession</code> interface to support additional session attributes. The <code class="codeph">ExtendedSSLSession</code> class adds methods that describe the signature algorithms that are supported by the local implementation and the peer. The <code class="codeph">getRequestedServerNames()</code> method called on an <code class="codeph">ExtendedSSLSession</code> instance is used to obtain a list of <code class="codeph">SNIServerName</code> objects in the requested <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a>. The server should use the requested server names to guide its selection of an appropriate authentication certificate, and/or other aspects of the security policy. The client should use the requested server names to guide its endpoint identification of the peer's identity, and/or other aspects of the security policy.</p>
<p>Calls to the <code class="codeph">getPacketBufferSize()</code> and <code class="codeph">getApplicationBufferSize()</code> methods on <code class="codeph">SSLSession</code> are used to determine the appropriate buffer sizes used by <code class="codeph">SSLEngine</code>.</p>
<div class="p">
<div class="infobox-note" id="GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B__GUID-17258111-C234-4640-B886-D85221CCE842">
<p class="notep1">Note:</p>
The SSL/TLS protocols specify that implementations are to produce packets containing at most 16 kilobytes (KB) of plain text. However, some implementations violate the specification and generate large records up to 32 KB. If the <code class="codeph">SSLEngine.unwrap()</code> code detects large inbound packets, then the buffer sizes returned by <code class="codeph">SSLSession</code> will be updated dynamically. Applications should always check the BUFFER_OVERFLOW and BUFFER_UNDERFLOW statuses and enlarge the corresponding buffers if necessary. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" title="The status of the SSLEngine is represented by SSLEngineResult.Status.">Understanding SSLEngine Operation Statuses</a>. SunJSSE will always send standard compliant 16 KB records and allow incoming 32 KB records. For a workaround, see the System property <code class="codeph">jsse.SSLEngine.acceptLargeFragments</code> in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" title="JSSE includes a standard implementation that can be customized by plugging in different implementations or specifying the default keystore, and so on.">Customizing JSSE</a>.</div>
</div>
</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863"></a>
<h3 id="JSSEC-GUID-A14E129D-4D9D-4F38-A9F0-ED6F97B18863" class="sect3">HttpsURLConnection Class</h3>
<div>
<p>The <code class="codeph">javax.net.ssl.HttpsURLConnection</code> class extends the <code class="codeph">java.net.HttpURLConnection</code> class and adds support for HTTPS-specific features.</p>
<div class="section">
<p>The HTTPS protocol is similar to HTTP, but HTTPS first establishes a secure channel via SSL/TLS sockets and then verifies the identity of the peer (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-D6A538A2-8CEF-4C6D-9C44-295758E64E38">Cipher Suite Choice and Remote Entity Verification</a>) before requesting or receiving data. The <code class="codeph">javax.net.ssl.HttpsURLConnection</code> class extends the <code class="codeph">java.net.HttpURLConnection</code> class and adds support for HTTPS-specific features. To know more about how HTTPS URLs are constructed and used, see the<a href="https://docs.oracle.com/javase/10/docs/api/java/net/URL.html" target="_blank"><span class="apiname">java.net.URL</span></a>, <a href="https://docs.oracle.com/javase/10/docs/api/java/net/URLConnection.html" target="_blank"><span class="apiname">java.net.URLConnection</span></a>, <a href="https://docs.oracle.com/javase/10/docs/api/java/net/HttpURLConnection.html" target="_blank"><span class="apiname">java.net.HttpURLConnection</span></a>, and <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><span class="apiname">javax.net.ssl.HttpsURLConnection</span></a> classes.</p>
<p>Upon obtaining an <code class="codeph">HttpsURLConnection</code> instance, you can configure a number of HTTP and HTTPS parameters before actually initiating the network connection via the <code class="codeph">URLConnection.connect()</code> method. Of particular interest are:</p>
<ul style="list-style-type: disc;">
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA">Setting the Assigned SSLSocketFactory</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573">Setting the Assigned HostnameVerifier</a></li>
</ul>
</div>
<!-- class="section" --></div>
<div class="sect4"><a id="GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA"></a>
<h4 id="JSSEC-GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA" class="sect4">Setting the Assigned SSLSocketFactory</h4>
<div>
<div class="section">
<p>In some situations, it is desirable to specify the <code class="codeph">SSLSocketFactory</code> that an <code class="codeph">HttpsURLConnection</code> instance uses. For example, you might want to tunnel through a proxy type that is not supported by the default implementation. The new <code class="codeph">SSLSocketFactory</code> could return sockets that have already performed all necessary tunneling, thus allowing <code class="codeph">HttpsURLConnection</code> to use additional proxies.</p>
<p>The <code class="codeph">HttpsURLConnection</code> class has a default <code class="codeph">SSLSocketFactory</code> that is assigned when the class is loaded (this is the factory returned by the <code class="codeph">SSLSocketFactory.getDefault()</code> method). Future instances of <code class="codeph">HttpsURLConnection</code> will inherit the current default <code class="codeph">SSLSocketFactory</code> until a new default <code class="codeph">SSLSocketFactory</code> is assigned to the class via the static <code class="codeph">HttpsURLConnection.setDefaultSSLSocketFactory()</code> method. Once an instance of <code class="codeph">HttpsURLConnection</code> has been created, the inherited <code class="codeph">SSLSocketFactory</code> on this instance can be overridden with a call to the <code class="codeph">setSSLSocketFactory()</code> method.</p>
<div class="p">
<div class="infobox-note" id="GUID-8BE4AE6F-21EF-4DF0-91D4-B2D36EF625CA__GUID-2DF8B087-98E2-490B-89EC-BA0A4E86DC57">
<p class="notep1">Note:</p>
Changing the default static <code class="codeph">SSLSocketFactory</code> has no effect on existing instances of <code class="codeph">HttpsURLConnection</code>. A call to the <code class="codeph">setSSLSocketFactory()</code> method is necessary to change the existing instances.</div>
</div>
<p>You can obtain the per-instance or per-class <code class="codeph">SSLSocketFactory</code> by making a call to the <code class="codeph">getSSLSocketFactory()</code> or <code class="codeph">getDefaultSSLSocketFactory()</code> method, respectively.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573"></a>
<h4 id="JSSEC-GUID-ABE2057C-0F36-48E1-8E76-4FC8D72A6573" class="sect4">Setting the Assigned HostnameVerifier</h4>
<div>
<p>If the host name of the URL does not match the host name in the credentials received as part of the SSL/TLS handshake, then it is possible that URL spoofing has occurred. If the implementation cannot determine a host name match with reasonable certainty, then the SSL implementation performs a callback to the instance's assigned <span class="apiname">HostnameVerifier</span> for further checking. The host name verifier can take whatever steps are necessary to make the determination, such as performing host name pattern matching or perhaps opening an interactive dialog box. An unsuccessful verification by the host name verifier closes the connection. For more information regarding host name verification, see <a href="http://www.ietf.org/rfc/rfc2818.txt?number=2818" target="_blank">RFC 2818</a>.</p>
<p>The <span class="apiname">setHostnameVerifier()</span> and <span class="apiname">setDefaultHostnameVerifier()</span> methods operate in a similar manner to the <span class="apiname">setSSLSocketFactory()</span> and <span class="apiname">setDefaultSSLSocketFactory()</span> methods, in that <span class="apiname">HostnameVerifier</span> objects are assigned on a per-instance and per-class basis, and the current values can be obtained by a call to the <span class="apiname">getHostnameVerifier()</span> or <span class="apiname">getDefaultHostnameVerifier()</span> method.</p>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-AD2529FD-8778-4A02-B544-5F58E083774B"></a>
<h3 id="JSSEC-GUID-AD2529FD-8778-4A02-B544-5F58E083774B" class="sect3">Support Classes and Interfaces</h3>
<div>
<p>The classes and interfaces in this section are provided to support the creation and initialization of <code class="codeph">SSLContext</code> objects, which are used to create <code class="codeph">SSLSocketFactory</code>, <code class="codeph">SSLServerSocketFactory</code>, and <code class="codeph">SSLEngine</code> objects. The support classes and interfaces are part of the <code class="codeph">javax.net.ssl</code> package.</p>
<p>Three of the classes described in this section (<a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" title="The javax.net.ssl.SSLContext class is an engine class for an implementation of a secure socket protocol. An instance of this class acts as a factory for SSLSocket, SSLServerSocket, and SSLEngine. An SSLContext object holds all of the state information shared across all objects created under that context. For example, session state is associated with the SSLContext when it is negotiated through the handshake protocol by sockets created by socket factories provided by the context. These cached sessions can be reused and shared by other sockets created under the same context.">The SSLContext Class</a>, <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F" title="The javax.net.ssl.KeyManagerFactory class is an engine class for a provider-based service that acts as a factory for one or more types of KeyManager objects. The SunJSSE provider implements a factory that can return a basic X.509 key manager. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative key managers.">The KeyManagerFactory Class</a>, and <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" title="The javax.net.ssl.TrustManagerFactory is an engine class for a provider-based service that acts as a factory for one or more types of TrustManager objects. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative trust managers that provide more sophisticated services or that implement installation-specific authentication policies.">The TrustManagerFactory Class</a>) are <span class="italic"><span>engine classes</span></span>. An engine class is an API class for specific algorithms (or protocols, in the case of <code class="codeph">SSLContext</code>), for which implementations may be provided in one or more Cryptographic Service Provider (provider) packages. See <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-71693272-7F57-4155-99F9-A2139271FD6D">JCA Design Principles</a> and <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>.</p>
<p>The SunJSSE provider that comes standard with JSSE provides <code class="codeph">SSLContext</code>, <code class="codeph">KeyManagerFactory</code>, and <code class="codeph">TrustManagerFactory</code> implementations, as well as implementations for engine classes in the standard <code class="codeph">java.security</code> API. <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AD2529FD-8778-4A02-B544-5F58E083774B__GUID-8487642F-B1E3-4DB7-BA5E-ABF8971F8A58" title="The following table lists implementations supplied by SunJSSE.">Table 8-6</a> lists implementations supplied by SunJSSE.</p>
<div class="tblformal" id="GUID-AD2529FD-8778-4A02-B544-5F58E083774B__GUID-8487642F-B1E3-4DB7-BA5E-ABF8971F8A58">
<p class="titleintable">Table 8-6 Implementations Supplied by SunJSSE</p>
<table class="cellalignment466" title="Implementations Supplied by SunJSSE" summary="The following table lists implementations supplied by SunJSSE.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e3984">Engine Class Implemented</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e3986">Algorithm or Protocol</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e3990" headers="d108102e3984"><code class="codeph">KeyStore</code></td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e3990 d108102e3986">PKCS12</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e3996" headers="d108102e3984"><code class="codeph">KeyManagerFactory</code></td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e3996 d108102e3986">PKIX, SunX509</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e4002" headers="d108102e3984"><code class="codeph">TrustManagerFactory</code></td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e4002 d108102e3986">PKIX (X509 or SunPKIX), SunX509</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e4008" headers="d108102e3984">
<p><code class="codeph">SSLContext</code></p>
</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e4008 d108102e3986">SSLv3<a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AD2529FD-8778-4A02-B544-5F58E083774B__FOOTNOTE1SSLV3ISENABLEDSTARTINGWITH-8E8BD3EF">[1]</a>, TLSv1, TLSv1.1, TLSv1.2, DTLSv1.0, DTLSv1.2</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p id="GUID-AD2529FD-8778-4A02-B544-5F58E083774B__FOOTNOTE1SSLV3ISENABLEDSTARTINGWITH-8E8BD3EF">Footnote 1: Starting with JDK 8u31, the SSLv3 protocol (Secure Socket Layer) has been deactivated and is not available by default. See the <code class="codeph">java.security.Security</code> property <code class="codeph">jdk.tls.disabledAlgorithms</code> in the <code class="codeph"><span class="variable">&lt;java_home&gt;</span>/conf/security/java.security</code> file. If SSLv3 is absolutely required, the protocol can be reactivated by removing <code class="codeph">SSLv3</code> from the <code class="codeph">jdk.tls.disabledAlgorithms</code> property in the <code>java.security</code> file or by dynamically setting this Security Property before JSSE is initialized. To enable SSLv3 protocol at deploy level, after following the previous steps, add the line <code class="codeph">deployment.security.SSLv3=true</code> to the <code>deployment.properties</code> file.</p>
</div>
<div class="sect4"><a id="GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F"></a>
<h4 id="JSSEC-GUID-C281CAF3-275F-4DE4-8B47-4A84363CF39F" class="sect4">The SSLContext Class</h4>
<div>
<p>The <code class="codeph">javax.net.ssl.SSLContext</code> class is an engine class for an implementation of a secure socket protocol. An instance of this class acts as a factory for <code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code>, and <code class="codeph">SSLEngine</code>. An <code class="codeph">SSLContext</code> object holds all of the state information shared across all objects created under that context. For example, session state is associated with the <code class="codeph">SSLContext</code> when it is negotiated through the handshake protocol by sockets created by socket factories provided by the context. These cached sessions can be reused and shared by other sockets created under the same context.</p>
<p>Each instance is configured through its <code class="codeph">init</code> method with the keys, certificate chains, and trusted root CA certificates that it needs to perform authentication. This configuration is provided in the form of key and trust managers. These managers provide support for the authentication and key agreement aspects of the cipher suites supported by the context.</p>
<p>Currently, only X.509-based managers are supported.</p>
</div>
<div class="sect5"><a id="GUID-1F3F9B1E-143A-4C05-922E-152EA1DFAE90"></a>
<h5 id="JSSEC-GUID-1F3F9B1E-143A-4C05-922E-152EA1DFAE90" class="sect5">Obtaining and Initializing the SSLContext Class</h5>
<div>
<p>The <code class="codeph">SSLContext</code> class is used to create the <code class="codeph">SSLSocketFactory</code> or <code class="codeph">SSLServerSocketFactory</code> class.</p>
<p>There are two ways to obtain and initialize an <code class="codeph">SSLContext</code>:</p>
<ul style="list-style-type: disc;">
<li>The simplest way is to call the static <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#getDefault" target="_blank"><code class="codeph">SSLContext.getDefault</code></a> method on either the <code class="codeph">SSLSocketFactory</code> or <code class="codeph">SSLServerSocketFactory</code> class. This method creates a default <code class="codeph">SSLContext</code> with a default <code class="codeph">KeyManager</code>, <code class="codeph">TrustManager</code>, and <code class="codeph">SecureRandom</code> (a secure random number generator). A default <code class="codeph">KeyManagerFactory</code> and <code class="codeph">TrustManagerFactory</code> are used to create the <code class="codeph">KeyManager</code> and <code class="codeph">TrustManager</code>, respectively. The key material used is found in the default keystore and truststore, as determined by system properties described in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>.</li>
<li>The approach that gives the caller the most control over the behavior of the created context is to call the static method <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#getDefault" target="_blank"><code class="codeph">SSLContext.getDefault</code></a> on the <code class="codeph">SSLContext</code> class, and then initialize the context by calling the instance's proper <code class="codeph">init()</code> method. One variant of the <code class="codeph">init()</code> method takes three arguments: an array of <code class="codeph">KeyManager</code> objects, an array of <code class="codeph">TrustManager</code> objects, and a <code class="codeph">SecureRandom</code> object. The <code class="codeph">KeyManager</code> and <code class="codeph">TrustManager</code> objects are created by either implementing the appropriate interfaces or using the <code class="codeph">KeyManagerFactory</code> and <code class="codeph">TrustManagerFactory</code> classes to generate implementations. The <code class="codeph">KeyManagerFactory</code> and <code class="codeph">TrustManagerFactory</code> can then each be initialized with key material contained in the <code class="codeph">KeyStore</code> passed as an argument to the <code class="codeph">init()</code> method of the <code class="codeph">TrustManagerFactory</code> or <code class="codeph">KeyManagerFactory</code> classes. Finally, the <code class="codeph">getTrustManagers()</code> method (in <code class="codeph">TrustManagerFactory</code>) and <code class="codeph">getKeyManagers()</code> method (in <code class="codeph">KeyManagerFactory</code>) can be called to obtain the array of trust managers or key managers, one for each type of trust or key material.</li>
</ul>
<p>Once an SSL connection is established, an <code class="codeph">SSLSession</code> is created which contains various information, such as identities established and cipher suite used. The <code class="codeph">SSLSession</code> is then used to describe an ongoing relationship and state information between two entities. Each SSL connection involves one session at a time, but that session may be used on many connections between those entities, simultaneously or sequentially.</p>
</div>
</div>
<div class="sect5"><a id="GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7"></a>
<h5 id="JSSEC-GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7" class="sect5">Creating an SSLContext Object</h5>
<div>
<p>Like other JCA provider-based engine classes, <code class="codeph">SSLContext</code> objects are created using the <code class="codeph">getInstance()</code> factory methods of the <code class="codeph">SSLContext</code> class. These static methods each return an instance that implements <span class="italic">at least</span> the requested secure socket protocol. The returned instance may implement other protocols, too. For example, <code class="codeph">getInstance("TLSv1")</code> may return an instance that implements TLSv1, TLSv1.1, and TLSv1.2. The <code class="codeph">getSupportedProtocols()</code> method returns a list of supported protocols when an <code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code>, or <code class="codeph">SSLEngine</code> is created from this context. You can control which protocols are actually enabled for an SSL connection by using the <code class="codeph">setEnabledProtocols(String[] protocols)</code> method.</p>
<div class="section">
<div class="infobox-note" id="GUID-9BAC1902-A203-4422-8163-61D64ADD2FF7__GUID-AEF580E3-5151-4C8F-A5DE-A21E08BC18A2">
<p class="notep1">Note:</p>
An <code class="codeph">SSLContext</code> object is automatically created, initialized, and statically assigned to the <code class="codeph">SSLSocketFactory</code> class when you call the <code class="codeph">SSLSocketFactory.getDefault()</code> method. Therefore, you do not have to directly create and initialize an <span class="apiname">SSLContext</span> object (unless you want to override the default behavior).</div>
<p>To create an <code class="codeph">SSLContext</code> object by calling the <code class="codeph">getInstance()</code> factory method, you must specify the protocol name. You may also specify which provider you want to supply the implementation of the requested protocol:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">public static SSLContext getInstance(String protocol);</code></li>
<li><code class="codeph">public static SSLContext getInstance(String protocol, String provider);</code></li>
<li><code class="codeph">public static SSLContext getInstance(String protocol, Provider provider);</code></li>
</ul>
<p>If just a protocol name is specified, then the system will determine whether an implementation of the requested protocol is available in the environment. If there is more than one implementation, then it will determine whether there is a preferred one.</p>
<p>If both a protocol name and a provider are specified, then the system will determine whether an implementation of the requested protocol is in the provider requested. If there is no implementation, an exception will be thrown.</p>
<p>A protocol is a string (such as <code class="codeph">"TLS"</code>) that describes the secure socket protocol desired. Common protocol names for <code class="codeph">SSLContext</code> objects are defined in <a href="https://docs.oracle.com/javase/10/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names Specification</a>.</p>
<p>An <code class="codeph">SSLContext</code> can be obtained as follows:</p>
<pre class="codeblock" dir="ltr">
SSLContext sc = SSLContext.getInstance("TLS");
</pre>
<p>A newly created <code class="codeph">SSLContext</code> should be initialized by calling the <code class="codeph">init</code> method:</p>
<pre class="codeblock" dir="ltr">
public void init(KeyManager[] km, TrustManager[] tm, SecureRandom random);
</pre>
<p>If the <code class="codeph">KeyManager[]</code> parameter is null, then an empty <code class="codeph">KeyManager</code> will be defined for this context. If the <code class="codeph">TrustManager[]</code> parameter is null, then the installed security providers will be searched for the highest-priority implementation of the <span class="apiname">TrustManagerFactory</span> class (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" title="The javax.net.ssl.TrustManagerFactory is an engine class for a provider-based service that acts as a factory for one or more types of TrustManager objects. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative trust managers that provide more sophisticated services or that implement installation-specific authentication policies.">The TrustManagerFactory Class</a>), from which an appropriate <code class="codeph">TrustManager</code> will be obtained. Likewise, the <code class="codeph">SecureRandom</code> parameter may be null, in which case a default implementation will be used.</p>
<p>If the internal default context is used, (for example, an <code class="codeph">SSLContext</code> is created by <code class="codeph">SSLSocketFactory.getDefault()</code> or <code class="codeph">SSLServerSocketFactory.getDefault()</code>), then a <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">default KeyManager and TrustManager</a> are created. The default <code class="codeph">SecureRandom</code> implementation is also chosen.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect4"><a id="GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9"></a>
<h4 id="JSSEC-GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9" class="sect4">The TrustManager Interface</h4>
<div>
<p>The primary responsibility of the <code class="codeph">TrustManager</code> is to determine whether the presented authentication credentials should be trusted. If the credentials are not trusted, then the connection will be terminated. To authenticate the remote identity of a secure socket peer, you must initialize an <code class="codeph">SSLContext</code> object with one or more <code class="codeph">TrustManager</code> objects. You must pass one <code class="codeph">TrustManager</code> for each authentication mechanism that is supported. If null is passed into the <code class="codeph">SSLContext</code> initialization, then a trust manager will be created for you. Typically, a single trust manager supports authentication based on X.509 public key certificates (for example, <code class="codeph">X509TrustManager</code>). Some secure socket implementations may also support authentication based on shared secret keys, Kerberos, or other mechanisms.</p>
<p><code class="codeph">TrustManager</code> objects are created either by a <code class="codeph">TrustManagerFactory</code>, or by providing a concrete implementation of the interface.</p>
</div>
</div>
<div class="sect4"><a id="GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F"></a>
<h4 id="JSSEC-GUID-AB5DA59B-B070-4AC5-A9C1-C3C30BF9209F" class="sect4">The TrustManagerFactory Class</h4>
<div>
<p>The <code class="codeph">javax.net.ssl.TrustManagerFactory</code> is an engine class for a provider-based service that acts as a factory for one or more types of <code class="codeph">TrustManager</code> objects. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative trust managers that provide more sophisticated services or that implement installation-specific authentication policies.</p>
</div>
<div class="sect5"><a id="GUID-CF1771C6-D881-48E3-BB0D-49DC3E7C893B"></a>
<h5 id="JSSEC-GUID-CF1771C6-D881-48E3-BB0D-49DC3E7C893B" class="sect5">Creating a TrustManagerFactory</h5>
<div>
<p>You create an instance of this class in a similar manner to <code class="codeph">SSLContext</code>, except for passing an algorithm name string instead of a protocol name to the <code class="codeph">getInstance()</code> method:</p>
<div class="section">
<pre class="codeblock" dir="ltr">
TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm);
TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm, String provider);
TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm, Provider provider);
</pre>
<p>A sample call is as follows:</p>
<pre class="codeblock" dir="ltr">
TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX", "SunJSSE");
</pre>
<p>The preceding call creates an instance of the SunJSSE provider's PKIX trust manager factory. This factory can be used to create trust managers that provide X.509 PKIX-based certification path validity checking.</p>
<p>When initializing an <code class="codeph">SSLContext</code>, you can use trust managers created from a trust manager factory, or you can write your own trust manager, for example, using the <a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/CertPath.html" target="_blank"><code class="codeph">CertPath</code></a> API. See <a href="java-pki-programmers-guide.htm#GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" title="The CertPath class is an abstract class for certification paths. It defines the functionality shared by all certification path objects. Various certification path types can be implemented by subclassing the CertPath class, even though they may have different contents and ordering schemes.">Java PKI Programmer&rsquo;s Guide</a>. You do not need to use a trust manager factory if you implement a trust manager using the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/X509TrustManager.html" target="_blank"><code class="codeph">X509TrustManager</code></a> interface.</p>
<p>A newly created factory should be initialized by calling one of the <code class="codeph">init()</code> methods:</p>
<pre class="codeblock" dir="ltr">
public void init(KeyStore ks);
public void init(ManagerFactoryParameters spec);
</pre>
<p>Call whichever <code class="codeph">init()</code> method is appropriate for the <code class="codeph">TrustManagerFactory</code> you are using. If you are not sure, then ask the provider vendor.</p>
<p>For many factories, such as the SunX509 <code class="codeph">TrustManagerFactory</code> from the SunJSSE provider, the <code class="codeph">KeyStore</code> is the only information required to initialize the <code class="codeph">TrustManagerFactory</code> and thus the first <code class="codeph">init</code> method is the appropriate one to call. The <code class="codeph">TrustManagerFactory</code> will query the <code class="codeph">KeyStore</code> for information about which remote certificates should be trusted during authorization checks.</p>
<p>Sometimes, initialization parameters other than a <code class="codeph">KeyStore</code> are needed by a provider. Users of that provider are expected to pass an implementation of the appropriate <code class="codeph">ManagerFactoryParameters</code> as defined by the provider. The provider can then call the specified methods in the <code class="codeph">ManagerFactoryParameters</code> implementation to obtain the needed information.</p>
<p>For example, suppose the <code class="codeph">TrustManagerFactory</code> provider requires initialization parameters B, R, and S from any application that wants to use that provider. Like all providers that require initialization parameters other than a <code class="codeph">KeyStore</code>, the provider requires the application to provide an instance of a class that implements a particular <code class="codeph">ManagerFactoryParameters</code> subinterface. In the example, suppose that the provider requires the calling application to implement and create an instance of <code class="codeph">MyTrustManagerFactoryParams</code> and pass it to the second <code class="codeph">init()</code> method. The following example illustrates what <code class="codeph">MyTrustManagerFactoryParams</code> can look like:</p>
<pre class="codeblock" dir="ltr">
public interface MyTrustManagerFactoryParams extends ManagerFactoryParameters {
  public boolean getBValue();
  public float getRValue();
  public String getSValue();
}
</pre>
<p>Some trust managers can make trust decisions without being explicitly initialized with a <code class="codeph">KeyStore</code> object or any other parameters. For example, they may access trust material from a local directory service via LDAP, use a remote online certificate status checking server, or access default trust material from a standard local location.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect5"><a id="GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151"></a>
<h5 id="JSSEC-GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151" class="sect5">PKIX TrustManager Support</h5>
<div>
<p>The default trust manager algorithm is PKIX. It can be changed by editing the <code class="codeph">ssl.TrustManagerFactory.algorithm</code> property in the <code class="codeph">java.security</code> file.</p>
<p>The PKIX trust manager factory uses the CertPath PKIX implementation (see <a href="java-pki-programmers-guide.htm#GUID-D6A18B1E-A2A8-4CA2-BD18-514CD807810E" title="The Java Certification Path API defines interfaces and abstract classes for creating, building, and validating certification paths.&nbsp; Implementations may be plugged in using a provider-based interface.">PKI Programmers Guide Overview</a>) from an installed security provider. The trust manager factory can be initialized using the normal <code class="codeph">init(KeyStores)</code> method, or by passing <span class="apiname">CertPath</span> parameters to the PKIX trust manager using the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/CertPathTrustManagerParameters.html" target="_blank"><span class="apiname">CertPathTrustManagerParameters</span></a> class.</p>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151__EXAMPLE-1326-635DA89D">Example 8-11</a> illustrates how to get the trust manager to use a particular LDAP certificate store and enable revocation checking.</p>
<p>If the <code class="codeph">TrustManagerFactory.init(KeyStore)</code> method is used, then default PKIX parameters are used with the exception that revocation checking is disabled. It can be enabled by setting the <code class="codeph">com.sun.net.ssl.checkRevocation</code> system property to <code class="codeph">true</code>. This setting requires that the CertPath implementation can locate revocation information by itself. The PKIX implementation in the provider can do this in many cases but requires that the system property <code class="codeph">com.sun.security.enableCRLDP</code> be set to <code class="codeph">true</code>. Note that the <span class="apiname">TrustManagerFactory.init(ManagerFactoryParameters)</span> method has revocation checking enabled by default.</p>
<p>See <a href="java-pki-programmers-guide.htm#GUID-5BBEF087-CA8A-4287-97FB-BD88DCD12FE5" title="The Java Certification Path API includes a set of algorithm-specific classes modeled for use with the PKIX certification path validation algorithm.">PKIX Classes</a> and <a href="java-pki-programmers-guide.htm#GUID-E47B8A0E-6B3A-4B49-994D-CF185BF441EC" title="The CertPath class is an abstract class for certification paths. It defines the functionality shared by all certification path objects. Various certification path types can be implemented by subclassing the CertPath class, even though they may have different contents and ordering schemes.">The CertPath Class</a>.</p>
<div class="example" id="GUID-ED23411A-B4AA-4E46-A5E9-619A0CF30151__EXAMPLE-1326-635DA89D">
<p class="titleinexample">Example 8-11 Sample Code for Using a LDAP Certificate to Enable Revocation Checking</p>
<p>The following example illustrates how to get the trust manager to use a particular LDAP certificate store and enable revocation checking:</p>
<pre class="codeblock" dir="ltr">
    import javax.net.ssl.*;
    import java.security.cert.*;
    import java.security.KeyStore;
    import java.io.FileInputStream;
    ...
    
    // Obtain Keystore password
    char[] pass = System.console().readPassword("Password: ");

    // Create PKIX parameters
    KeyStore anchors = KeyStore.getInstance("JKS");
    anchors.load(new FileInputStream(anchorsFile, pass));
    PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(anchors, new X509CertSelector());
    
    // Specify LDAP certificate store to use
    LDAPCertStoreParameters lcsp = new LDAPCertStoreParameters("ldap.imc.org", 389);
    pkixParams.addCertStore(CertStore.getInstance("LDAP", lcsp));
    
    // Specify that revocation checking is to be enabled
    pkixParams.setRevocationEnabled(true);
    
    // Wrap PKIX parameters as trust manager parameters
    ManagerFactoryParameters trustParams = new CertPathTrustManagerParameters(pkixParams);
    
    // Create TrustManagerFactory for PKIX-compliant trust managers
    TrustManagerFactory factory = TrustManagerFactory.getInstance("PKIX");
    
    // Pass parameters to factory to be passed to CertPath implementation
    factory.init(trustParams);
    
    // Use factory
    SSLContext ctx = SSLContext.getInstance("TLS");
    ctx.init(null, factory.getTrustManagers(), null);
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<div class="sect4"><a id="GUID-7932AB21-2FED-402E-A806-3088402BAEA6"></a>
<h4 id="JSSEC-GUID-7932AB21-2FED-402E-A806-3088402BAEA6" class="sect4">The X509TrustManager Interface</h4>
<div>
<p>The <code class="codeph">javax.net.ssl.X509TrustManager</code> interface extends the general <code class="codeph">TrustManager</code> interface. It must be implemented by a trust manager when using X.509-based authentication.</p>
<p>To support X.509 authentication of remote socket peers through JSSE, an instance of this interface must be passed to the <code class="codeph">init</code> method of an <code class="codeph">SSLContext</code> object.</p>
</div>
<div class="sect5"><a id="GUID-32CF3420-56E8-4BC5-8D3B-1F6B4692A290"></a>
<h5 id="JSSEC-GUID-32CF3420-56E8-4BC5-8D3B-1F6B4692A290" class="sect5">Creating an X509TrustManager</h5>
<div>
<p>You can either implement this interface directly yourself or obtain one from a provider-based <code class="codeph">TrustManagerFactory</code> (such as that supplied by the SunJSSE provider). You could also implement your own interface that delegates to a factory-generated trust manager. For example, you might do this to filter the resulting trust decisions and query an end-user through a graphical user interface.</p>
<div class="section">
<p>If a null KeyStore parameter is passed to the SunJSSE PKIX or SunX509 <code class="codeph">TrustManagerFactory</code>, then the factory uses the following process to try to find trust material:</p>
<ol>
<li>
<p>If the <code class="codeph">javax.net.ssl.trustStore</code> property is defined, then the <code class="codeph">TrustManagerFactory</code> attempts to find a file using the file name specified by that system property, and uses that file for the KeyStore parameter. If the <code class="codeph">javax.net.ssl.trustStorePassword</code> system property is also defined, then its value is used to check the integrity of the data in the truststore before opening it.</p>
<p>If the <code class="codeph">javax.net.ssl.trustStore</code> property is defined but the specified file does not exist, then a default <code class="codeph">TrustManager</code> using an empty keystore is created.</p>
</li>
<li>If the <code class="codeph">javax.net.ssl.trustStore</code> system property was not specified, then:
<ul style="list-style-type: disc;">
<li>if the file <span class="variable">java-home</span><code class="codeph">/lib/security/jssecacerts</code> exists, that file is used;</li>
<li>if the file <span class="variable">java-home</span><code class="codeph">/lib/security/cacerts</code> exists, that file is used;</li>
<li>if neither of these files exists, then the SSL cipher suite is anonymous, does not perform any authentication, and thus does not need a truststore.</li>
</ul>
</li>
</ol>
<p>To know more about what <span class="variable">java-home</span> refers to, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329" title="The following are commonly used cryptography terms and their definitions.">Terms and Definitions</a>.</p>
<p>The factory looks for a file specified via the <code class="codeph">javax.net.ssl.trustStore</code> Security Property or for the <code>jssecacerts</code> file before checking for a <code class="codeph">cacerts</code> file. Therefore, you can provide a JSSE-specific set of trusted root certificates separate from ones that might be present in <code>cacerts</code> for code-signing purposes.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect5"><a id="GUID-E1205974-3249-4E40-83C0-5F89C7375CF4"></a>
<h5 id="JSSEC-GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" class="sect5">Creating Your Own X509TrustManager</h5>
<div>
<p>If the supplied <code class="codeph">X509TrustManager</code> behavior is not suitable for your situation, then you can create your own <code class="codeph">X509TrustManager</code> by either creating and registering your own <code class="codeph">TrustManagerFactory</code> or by implementing the <code class="codeph">X509TrustManager</code> interface directly.</p>
<div class="section">
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-E1205974-3249-4E40-83C0-5F89C7375CF4__EXAMPLE-1327-635DA68E">Example 8-12</a> illustrates a <code class="codeph">MyX509TrustManager</code> class that enhances the default SunJSSE <code class="codeph">X509TrustManager</code> behavior by providing alternative authentication logic when the default <code class="codeph">X509TrustManager</code> fails.</p>
<p>Once you have created such a trust manager, assign it to an <code class="codeph">SSLContext</code> via the <code class="codeph">init()</code> method, as in the following example. Future <code class="codeph">SocketFactories</code> created from this <code class="codeph">SSLContext</code> will use your new <code class="codeph">TrustManager</code> when making trust decisions.</p>
<pre class="codeblock" dir="ltr">
TrustManager[] myTMs = new TrustManager[] { new MyX509TrustManager() };
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(null, myTMs, null);
</pre></div>
<!-- class="section" -->
<div class="example" id="GUID-E1205974-3249-4E40-83C0-5F89C7375CF4__EXAMPLE-1327-635DA68E">
<p class="titleinexample">Example 8-12 Sample Code for Creating a X509TrustManager</p>
<p>The following code sample illustrates <code class="codeph">MyX509TrustManager</code> class that enhances the default SunJSSE <code class="codeph">X509TrustManager</code> behavior by providing alternative authentication logic when the default <code class="codeph">X509TrustManager</code> fails:</p>
<pre class="codeblock" dir="ltr">
class MyX509TrustManager implements X509TrustManager {

     /*
      * The default PKIX X509TrustManager9.  Decisions are delegated
      * to it, and a fall back to the logic in this class is performed
      * if the default X509TrustManager does not trust it.
      */
     X509TrustManager pkixTrustManager;

     MyX509TrustManager() throws Exception {
         // create a "default" JSSE X509TrustManager.

         KeyStore ks = KeyStore.getInstance("JKS");
         ks.load(new FileInputStream("trustedCerts"), "passphrase".toCharArray());

         TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
         tmf.init(ks);

         TrustManager tms [] = tmf.getTrustManagers();

         /*
          * Iterate over the returned trust managers, looking
          * for an instance of X509TrustManager.  If found,
          * use that as the default trust manager.
          */
         for (int i = 0; i &lt; tms.length; i++) {
             if (tms[i] instanceof X509TrustManager) {
                 pkixTrustManager = (X509TrustManager) tms[i];
                 return;
             }
         }

         /*
          * Find some other way to initialize, or else the
          * constructor fails.
          */
         throw new Exception("Couldn't initialize");
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkClientTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkClientTrusted(chain, authType);
         } catch (CertificateException excep) {
             // do any special handling here, or rethrow exception.
         }
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkServerTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkServerTrusted(chain, authType);
         } catch (CertificateException excep) {
             /*
              * Possibly pop up a dialog box asking whether to trust the
              * cert chain.
              */
         }
     }

     /*
      * Merely pass this through.
      */
     public X509Certificate[] getAcceptedIssuers() {
         return pkixTrustManager.getAcceptedIssuers();
     }
}
</pre></div>
<!-- class="example" --></div>
</div>
<div class="sect5"><a id="GUID-43F18232-8DDE-4F0C-B2AB-0EE4B472B15F"></a>
<h5 id="JSSEC-GUID-43F18232-8DDE-4F0C-B2AB-0EE4B472B15F" class="sect5">Updating the Keystore Dynamically</h5>
<div>
<p>You can enhance <code class="codeph">MyX509TrustManager</code> to handle dynamic keystore updates. When a <code class="codeph">checkClientTrusted</code> or <code class="codeph">checkServerTrusted</code> test fails and does not establish a trusted certificate chain, you can add the required trusted certificate to the keystore. You must create a new <code class="codeph">pkixTrustManager</code> from the <code class="codeph">TrustManagerFactory</code> initialized with the updated keystore. When you establish a new connection (using the previously initialized <code class="codeph">SSLContext</code>), the newly added certificate will be used when making trust decisions.</p>
</div>
</div>
</div>
<div class="sect4"><a id="GUID-BAAC4A6F-2705-4A16-874A-1CDF0E48B8E3"></a>
<h4 id="JSSEC-GUID-BAAC4A6F-2705-4A16-874A-1CDF0E48B8E3" class="sect4">X509ExtendedTrustManager Class</h4>
<div>
<p>The <code class="codeph">X509ExtendedTrustManager</code> class is an abstract implementation of the <code class="codeph">X509TrustManager</code> interface. It adds methods for connection-sensitive trust management. In addition, it enables endpoint verification at the TLS layer.</p>
<p>In TLS 1.2 and later, both client and server can specify which hash and signature algorithms they will accept. To authenticate the remote side, authentication decisions must be based on both X509 certificates and the local accepted hash and signature algorithms. The local accepted hash and signature algorithms can be obtained using the <code class="codeph">ExtendedSSLSession.getLocalSupportedSignatureAlgorithms()</code> method.</p>
<p>The <code class="codeph">ExtendedSSLSession</code> object can be retrieved by calling the <code class="codeph">SSLSocket.getHandshakeSession()</code> method or the <code class="codeph">SSLEngine.getHandshakeSession()</code> method.</p>
<p>The <code class="codeph">X509TrustManager</code> interface is not connection-sensitive. It provides no way to access <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> session properties.</p>
<p>Besides TLS 1.2 support, the <code class="codeph">X509ExtendedTrustManager</code> class also supports algorithm constraints and SSL layer host name verification. For JSSE providers and trust manager implementations, the <code class="codeph">X509ExtendedTrustManager</code> class is highly recommended over the legacy <code class="codeph">X509TrustManager</code> interface.</p>
</div>
<div class="sect5"><a id="GUID-A6B7B05A-3696-4F86-A05C-9500EEC91C2D"></a>
<h5 id="JSSEC-GUID-A6B7B05A-3696-4F86-A05C-9500EEC91C2D" class="sect5">Creating an X509ExtendedTrustManager</h5>
<div>
<p>You can either create an <code class="codeph">X509ExtendedTrustManager</code> subclass yourself (which is outlined in the following section) or obtain one from a provider-based <code class="codeph">TrustManagerFactory</code> (such as that supplied by the SunJSSE provider). In Java SE 7, the PKIX or SunX509 <code class="codeph">TrustManagerFactory</code> returns an <code class="codeph">X509ExtendedTrustManager</code> instance.</p>
</div>
</div>
<div class="sect5"><a id="GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248"></a>
<h5 id="JSSEC-GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248" class="sect5">Creating Your Own X509ExtendedTrustManager</h5>
<div>
<p>This section outlines how to create a subclass of <code class="codeph">X509ExtendedTrustManager</code> in nearly the same way as described for <code class="codeph">X509TrustManager</code>.</p>
<div class="section">
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248__IMPORTJAVA.IO.IMPORTJAVA.NET.IMPORT-635DA3F9">Example 8-13</a> illustrates how to create a class that uses the PKIX <code class="codeph">TrustManagerFactory</code> to locate a default <code class="codeph">X509ExtendedTrustManager</code> that will be used to make decisions about trust.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-AC443CF8-4CBD-4B77-8733-46D8DA2E3248__IMPORTJAVA.IO.IMPORTJAVA.NET.IMPORT-635DA3F9">
<p class="titleinexample">Example 8-13 Sample Code for Creating a PKIX TrustManagerFactory</p>
<p>The following code sample illustrates how to create a class that uses the PKIX <code class="codeph">TrustManagerFactory</code> to locate a default <code class="codeph">X509ExtendedTrustManager</code> that will be used to make decisions about trust. If the default trust manager fails for any reason, then the subclass can add other behavior. In the sample, these locations are indicated by comments in the <code class="codeph">catch</code> clauses.</p>
<pre class="codeblock" dir="ltr">
import java.io.*;
import java.net.*;
import java.security.*;
import java.security.cert.*;
import javax.net.ssl.*;
    
public class MyX509ExtendedTrustManager extends X509ExtendedTrustManager {

  /*
   * The default PKIX X509ExtendedTrustManager.  Decisions are
   * delegated to it, and a fall back to the logic in this class is
   * performed if the default X509ExtendedTrustManager does not
   * trust it.
   */
  
  X509ExtendedTrustManager pkixTrustManager;
    
  MyX509ExtendedTrustManager() throws Exception {
    // create a "default" JSSE X509ExtendedTrustManager.
    
    KeyStore ks = KeyStore.getInstance("JKS");
    ks.load(new FileInputStream("trustedCerts"), "passphrase".toCharArray());
    
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
    tmf.init(ks);
    
    TrustManager tms [] = tmf.getTrustManagers();
    
    /*
     * Iterate over the returned trust managers, looking
     * for an instance of X509ExtendedTrustManager. If found,
     * use that as the default trust manager.
     */
    for (int i = 0; i &lt; tms.length; i++) {
      if (tms[i] instanceof X509ExtendedTrustManager) {
        pkixTrustManager = (X509ExtendedTrustManager) tms[i];
        return;
      }
    }
    
    /*
     * Find some other way to initialize, or else we have to fail the
     * constructor.
     */
    throw new Exception("Couldn't initialize");
  }
    
  /*
   * Delegate to the default trust manager.
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType)
    throws CertificateException {
    try {
      pkixTrustManager.checkClientTrusted(chain, authType);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  /*
   * Delegate to the default trust manager.
   */
  public void checkServerTrusted(X509Certificate[] chain, String authType)
    throws CertificateException {
    try {
      pkixTrustManager.checkServerTrusted(chain, authType);
    } catch (CertificateException excep) {
      /*
       * Possibly pop up a dialog box asking whether to trust the
       * cert chain.
       */
    }
  }
    
  /*
   * Connection-sensitive verification.
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket)
    throws CertificateException {
    try {
      pkixTrustManager.checkClientTrusted(chain, authType, socket);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
    throws CertificateException {
    try {
      pkixTrustManager.checkClientTrusted(chain, authType, engine);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket)
    throws CertificateException {
    try {
      pkixTrustManager.checkServerTrusted(chain, authType, socket);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
    
  public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
    throws CertificateException {
    try {
      pkixTrustManager.checkServerTrusted(chain, authType, engine);
    } catch (CertificateException excep) {
      // do any special handling here, or rethrow exception.
    }
  }
         
  /*
   * Merely pass this through.
   */
  public X509Certificate[] getAcceptedIssuers() {
    return pkixTrustManager.getAcceptedIssuers();
  }
}
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<div class="sect4"><a id="GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702"></a>
<h4 id="JSSEC-GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702" class="sect4">The KeyManager Interface</h4>
<div>
<p>The primary responsibility of the <code class="codeph">KeyManager</code> is to select the authentication credentials that will eventually be sent to the remote host. To authenticate yourself (a local secure socket peer) to a remote peer, you must initialize an <code class="codeph">SSLContext</code> object with one or more <code class="codeph">KeyManager</code> objects. You must pass one <code class="codeph">KeyManager</code> for each different authentication mechanism that will be supported. If null is passed into the <code class="codeph">SSLContext</code> initialization, then an empty <code class="codeph">KeyManager</code> will be created. If the internal default context is used (for example, an <code class="codeph">SSLContext</code> created by <code class="codeph">SSLSocketFactory.getDefault()</code> or <code class="codeph">SSLServerSocketFactory.getDefault()</code>), then a default <code class="codeph">KeyManager</code> is created. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>. Typically, a single key manager supports authentication based on X.509 public key certificates. Some secure socket implementations may also support authentication based on shared secret keys, Kerberos, or other mechanisms.</p>
<p><code class="codeph">KeyManager</code> objects are created either by a <code class="codeph">KeyManagerFactory</code>, or by providing a concrete implementation of the interface.</p>
</div>
</div>
<div class="sect4"><a id="GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F"></a>
<h4 id="JSSEC-GUID-616A7E77-587C-44E0-9F69-92BEDF631D5F" class="sect4">The KeyManagerFactory Class</h4>
<div>
<p>The <code class="codeph">javax.net.ssl.KeyManagerFactory</code> class is an engine class for a provider-based service that acts as a factory for one or more types of <code class="codeph">KeyManager</code> objects. The SunJSSE provider implements a factory that can return a basic X.509 key manager. Because it is provider-based, additional factories can be implemented and configured to provide additional or alternative key managers.</p>
</div>
<div class="sect5"><a id="GUID-65A7A023-AE02-4A95-8210-386AE6F18EB5"></a>
<h5 id="JSSEC-GUID-65A7A023-AE02-4A95-8210-386AE6F18EB5" class="sect5">Creating a KeyManagerFactory</h5>
<div>
<p>You create an instance of this class in a similar manner to <code class="codeph">SSLContext</code>, except for passing an algorithm name string instead of a protocol name to the <code class="codeph">getInstance()</code> method:</p>
<div class="section">
<pre class="codeblock" dir="ltr">
KeyManagerFactory kmf = getInstance(String algorithm);
KeyManagerFactory kmf = getInstance(String algorithm, String provider);
KeyManagerFactory kmf = getInstance(String algorithm, Provider provider);
</pre>
<p>A sample call as follows:</p>
<pre class="codeblock" dir="ltr">
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509", "SunJSSE");
</pre>
<p>The preceding call creates an instance of the SunJSSE provider's default key manager factory, which provides basic X.509-based authentication keys.</p>
<p>A newly created factory should be initialized by calling one of the <code class="codeph">init</code> methods:</p>
<pre class="codeblock" dir="ltr">
public void init(KeyStore ks, char[] password);
public void init(ManagerFactoryParameters spec);
</pre>
<p>Call whichever <code class="codeph">init</code> method is appropriate for the <code class="codeph">KeyManagerFactory</code> you are using. If you are not sure, then ask the provider vendor.</p>
<p>For many factories, such as the default SunX509 <code class="codeph">KeyManagerFactory</code> from the SunJSSE provider, the <code class="codeph">KeyStore</code> and password are the only information required to initialize the <code class="codeph">KeyManagerFactory</code> and thus the first <code class="codeph">init</code> method is the appropriate one to call. The <code class="codeph">KeyManagerFactory</code> will query the <code class="codeph">KeyStore</code> for information about which private key and matching public key certificates should be used for authenticating to a remote socket peer. The password parameter specifies the password that will be used with the methods for accessing keys from the <code class="codeph">KeyStore</code>. All keys in the <code class="codeph">KeyStore</code> must be protected by the same password.</p>
<p>Sometimes initialization parameters other than a <code class="codeph">KeyStore</code> and password are needed by a provider. Users of that provider are expected to pass an implementation of the appropriate <code class="codeph">ManagerFactoryParameters</code> as defined by the provider. The provider can then call the specified methods in the <code class="codeph">ManagerFactoryParameters</code> implementation to obtain the needed information.</p>
<p>Some factories can provide access to authentication material without being initialized with a <code class="codeph">KeyStore</code> object or any other parameters. For example, they may access key material as part of a login mechanism such as one based on JAAS, the Java Authentication and Authorization Service.</p>
<p>As previously indicated, the SunJSSE provider supports a SunX509 factory that must be initialized with a <code class="codeph">KeyStore</code> parameter.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect4"><a id="GUID-9C8442E4-279D-4E60-B4D0-3B1558C99F4F"></a>
<h4 id="JSSEC-GUID-9C8442E4-279D-4E60-B4D0-3B1558C99F4F" class="sect4">The X509KeyManager Interface</h4>
<p>The <code class="codeph">javax.net.ssl.X509KeyManager</code> interface extends the general <code class="codeph">KeyManager</code> interface. It must be implemented by a key manager for X.509-based authentication. To support X.509 authentication to remote socket peers through JSSE, an instance of this interface must be passed to the <code class="codeph">init()</code> method of an <code class="codeph">SSLContext</code> object.</p>
<div class="sect5"><a id="GUID-FEA439FF-8110-4F2D-82AF-54815002805E"></a>
<h5 id="JSSEC-GUID-FEA439FF-8110-4F2D-82AF-54815002805E" class="sect5">Creating an X509KeyManager</h5>
<div>
<p>You can either implement this interface directly yourself or obtain one from a provider-based <code class="codeph">KeyManagerFactory</code> (such as that supplied by the SunJSSE provider). You could also implement your own interface that delegates to a factory-generated key manager. For example, you might do this to filter the resulting keys and query an end-user through a graphical user interface.</p>
</div>
</div>
<div class="sect5"><a id="GUID-E0A44B4B-A888-4997-AB5E-5E0580FF87DE"></a>
<h5 id="JSSEC-GUID-E0A44B4B-A888-4997-AB5E-5E0580FF87DE" class="sect5">Creating Your Own X509KeyManager</h5>
<div>
<div class="section">
<p>If the default <code class="codeph">X509KeyManager</code> behavior is not suitable for your situation, then you can create your own <code class="codeph">X509KeyManager</code> in a way similar to that shown in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" title="If the supplied X509TrustManager behavior is not suitable for your situation, then you can create your own X509TrustManager by either creating and registering your own TrustManagerFactory or by implementing the X509TrustManager interface directly.">Creating Your Own X509TrustManager</a>.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect4"><a id="GUID-5C4AC46A-DE04-4D72-B94A-35C1F1B94A41"></a>
<h4 id="JSSEC-GUID-5C4AC46A-DE04-4D72-B94A-35C1F1B94A41" class="sect4">The X509ExtendedKeyManager Class</h4>
<div>
<p>The <code class="codeph">X509ExtendedKeyManager</code> abstract class is an implementation of the <code class="codeph">X509KeyManager</code> interface that allows for connection-specific key selection. It adds two methods that select a key alias for client or server based on the key type, allowed issuers, and current <code class="codeph">SSLEngine</code>:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">public String chooseEngineClientAlias(String[] keyType, Principal[] issuers, SSLEngine engine)</code></li>
<li><code class="codeph">public String chooseEngineServerAlias(String keyType, Principal[] issuers, SSLEngine engine)</code></li>
</ul>
<p>If a key manager is not an instance of the <code class="codeph">X509ExtendedKeyManager</code> class, then it will not work with the <code class="codeph">SSLEngine</code> class.</p>
<p>For JSSE providers and key manager implementations, the <code class="codeph">X509ExtendedKeyManager</code> class is highly recommended over the legacy <code class="codeph">X509KeyManager</code> interface.</p>
<p>In TLS 1.2 and later, both client and server can specify which hash and signature algorithms they will accept. To pass the authentication required by the remote side, local key selection decisions must be based on both X509 certificates and the remote accepted hash and signature algorithms. The remote accepted hash and signature algorithms can be retrieved using the <code class="codeph">ExtendedSSLSession.getPeerSupportedSignatureAlgorithms()</code> method.</p>
<p>You can create your own <code class="codeph">X509ExtendedKeyManager</code> subclass in a way similar to that shown in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-E1205974-3249-4E40-83C0-5F89C7375CF4" title="If the supplied X509TrustManager behavior is not suitable for your situation, then you can create your own X509TrustManager by either creating and registering your own TrustManagerFactory or by implementing the X509TrustManager interface directly.">Creating Your Own X509TrustManager</a>.</p>
<p>Support for the <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a> on the server side enables the key manager to check the server name and select the appropriate key accordingly. For example, suppose there are three key entries with certificates in the keystore:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">cn=www.example.com</code></li>
<li><code class="codeph">cn=www.example.org</code></li>
<li><code class="codeph">cn=www.example.net</code></li>
</ul>
<p>If the ClientHello message requests to connect to <code class="codeph">www.example.net</code> in the SNI extension, then the server should be able to select the certificate with subject <code class="codeph">cn=www.example.net</code>.</p>
</div>
</div>
<div class="sect4"><a id="GUID-9D7375F9-D688-436D-A214-02653F50ED32"></a>
<h4 id="JSSEC-GUID-9D7375F9-D688-436D-A214-02653F50ED32" class="sect4">Relationship Between a TrustManager and a KeyManager</h4>
<div>
<p>Historically, there has been confusion regarding the functionality of a <code class="codeph">TrustManager</code> and a <code class="codeph">KeyManager</code>.</p>
<p>A <code class="codeph">TrustManager</code> determines whether the remote authentication credentials (and thus the connection) should be trusted.</p>
<p>A <code class="codeph">KeyManager</code> determines which authentication credentials to send to the remote host.</p>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-1B0C19BB-0F27-4757-9CA5-D03037C4E658"></a>
<h3 id="JSSEC-GUID-1B0C19BB-0F27-4757-9CA5-D03037C4E658" class="sect3">Secondary Support Classes and Interfaces</h3>
<div>
<p>These classes are provided as part of the JSSE API to support the creation, use, and management of secure sockets. They are less likely to be used by secure socket applications than are the core and support classes. The secondary support classes and interfaces are part of the <code class="codeph">javax.net.ssl</code> and <code class="codeph">javax.security.cert</code> packages.</p>
</div>
<div class="sect4"><a id="GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D"></a>
<h4 id="JSSEC-GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D" class="sect4">The SSLParameters Class</h4>
<div>
<p>The <code class="codeph">SSLParameters</code> class encapsulates the following parameters that affect a SSL/TLS/DTLS connection:</p>
<ul style="list-style-type: disc;">
<li>The list of cipher suites to be accepted in an SSL/TLS/DTLS handshake</li>
<li>The list of protocols to be allowed</li>
<li>The endpoint identification algorithm during SSL/TLS/DTLS handshaking</li>
<li>The server names and server name matchers (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a>)</li>
<li>The cipher suite preference to be used in an SSL/TLS/DTLS handshake</li>
<li>Algorithm during SSL/TLS/DTLS handshaking</li>
<li>The Server Name Indication (SNI)</li>
<li>The maximum network packet size</li>
<li>The algorithm constraints and whether SSL/TLS/DTLS servers should request or require client authentication</li>
</ul>
<p>You can retrieve the current <code class="codeph">SSLParameters</code> for an <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> by using the following methods:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">getSSLParameters()</code> in an <code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code>, and <code class="codeph">SSLEngine</code></li>
<li><code class="codeph">getDefaultSSLParameters()</code> and <code class="codeph">getSupportedSSLParamters()</code> in an <code class="codeph">SSLContext</code></li>
</ul>
<p>You can assign <code class="codeph">SSLParameters</code> with the <code class="codeph">setSSLParameters()</code> method in an <code class="codeph">SSLSocket</code>, <code class="codeph">SSLServerSocket</code> and <code class="codeph">SSLEngine</code>.</p>
<p>You can explicitly set the server name indication with the <code class="codeph">SSLParameters.setServerNames()</code> method. The server name indication in client mode also affects endpoint identification. In the implementation of <code class="codeph">X509ExtendedTrustManager</code>, it uses the server name indication retrieved by the <code class="codeph">ExtendedSSLSession.getRequestedServerNames()</code> method. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D__SAMPLECODETOSETTHESERVERNAMEINDICAT-6A7C526D">Example 8-14</a>.</p>
<div class="example" id="GUID-BC9AD59B-05B6-4ACA-9CDD-D18ACEA3840D__SAMPLECODETOSETTHESERVERNAMEINDICAT-6A7C526D">
<p class="titleinexample">Example 8-14 Sample Code to Set Server Name Indication</p>
<p>This example uses the host name in the server name indication (<code class="codeph">www.example.com</code>) to make endpoint identification against the peer's identity presented in the end-entity's X.509 certificate.</p>
<pre class="codeblock" dir="ltr">
    SSLSocketFactory factory = ...
    SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
    // SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

    SNIHostName serverName = new SNIHostName("www.example.com");
    List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
    serverNames.add(serverName);
 
    SSLParameters params = sslSocket.getSSLParameters();
    params.setServerNames(serverNames);
    sslSocket.setSSLParameters(params);
    // sslEngine.setSSLParameters(params);
</pre></div>
<!-- class="example" --></div>
<div class="sect5"><a id="GUID-EFC2FACC-680C-42CE-A3A9-E9A6673EA813"></a>
<h5 id="JSSEC-GUID-EFC2FACC-680C-42CE-A3A9-E9A6673EA813" class="sect5">Cipher Suite Preference</h5>
<div>
<p>During TLS handshaking, the client requests to negotiate a cipher suite from a list of cryptographic options that it supports, starting with its first preference. Then, the server selects a single cipher suite from the list of cipher suites requested by the client. Normally, the selection honors the client's preference. However, to mitigate the risks of using weak cipher suites, the server may select cipher suites based on its own preference rather than the client's preference, by invoking the method <code class="codeph">SSLParameters.setUseCipherSuitesOrder(true)</code>.</p>
</div>
</div>
</div>
<div class="sect4"><a id="GUID-4E20A067-B139-4754-B4B3-AAF372F76D02"></a>
<h4 id="JSSEC-GUID-4E20A067-B139-4754-B4B3-AAF372F76D02" class="sect4">The SSLSessionContext Interface</h4>
<div>
<p>The <code class="codeph">javax.net.ssl.SSLSessionContext</code> interface is a grouping of <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="The javax.net.ssl.SSLSession interface represents a security context negotiated between the two peers of an SSLSocket or SSLEngine connection. After a session has been arranged, it can be shared by future SSLSocket or SSLEngine objects connected between the same two peers.">SSLSession</a> objects associated with a single entity. For example, it could be associated with a server or client that participates in many sessions concurrently. The methods in this interface enable the enumeration of all sessions in a context and allow lookup of specific sessions via their session IDs.</p>
<p>An <code class="codeph">SSLSessionContext</code> may optionally be obtained from an <code class="codeph">SSLSession</code> by calling the SSLSession <code class="codeph">getSessionContext()</code> method. The context may be unavailable in some environments, in which case the <code class="codeph">getSessionContext()</code> method returns null.</p>
</div>
</div>
<div class="sect4"><a id="GUID-F2F8AC17-849A-40EE-A385-FD15328999B6"></a>
<h4 id="JSSEC-GUID-F2F8AC17-849A-40EE-A385-FD15328999B6" class="sect4">The SSLSessionBindingListener Interface</h4>
<div>
<p>The <code class="codeph">javax.net.ssl.SSLSessionBindingListener</code> interface is implemented by objects that are notified when they are being bound or unbound from an <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="The javax.net.ssl.SSLSession interface represents a security context negotiated between the two peers of an SSLSocket or SSLEngine connection. After a session has been arranged, it can be shared by future SSLSocket or SSLEngine objects connected between the same two peers.">SSLSession</a>.</p>
</div>
</div>
<div class="sect4"><a id="GUID-C32994C1-0F5E-42D0-9CB6-EF4422024730"></a>
<h4 id="JSSEC-GUID-C32994C1-0F5E-42D0-9CB6-EF4422024730" class="sect4">The SSLSessionBindingEvent Class</h4>
<div>
<p>The <code class="codeph">javax.net.ssl.SSLSessionBindingEvent</code> class defines the event communicated to an <span class="apiname">SSLSessionBindingListener</span> (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-F2F8AC17-849A-40EE-A385-FD15328999B6">The SSLSessionBindingListener Interface</a>) when it is bound or unbound from an <span class="apiname">SSLSession</span> (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B" title="The javax.net.ssl.SSLSession interface represents a security context negotiated between the two peers of an SSLSocket or SSLEngine connection. After a session has been arranged, it can be shared by future SSLSocket or SSLEngine objects connected between the same two peers.">SSLSession and ExtendedSSLSession</a>).</p>
</div>
</div>
<div class="sect4"><a id="GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7"></a>
<h4 id="JSSEC-GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7" class="sect4">The HandShakeCompletedListener Interface</h4>
<div>
<p>The <code class="codeph">javax.net.ssl.HandShakeCompletedListener</code> interface is an interface implemented by any class that is notified of the completion of an SSL protocol handshake on a given <code class="codeph">SSLSocket</code> connection.</p>
</div>
</div>
<div class="sect4"><a id="GUID-F242B876-6932-4B17-A755-1D9AFA25E54B"></a>
<h4 id="JSSEC-GUID-F242B876-6932-4B17-A755-1D9AFA25E54B" class="sect4">The HandShakeCompletedEvent Class</h4>
<div>
<p>The <code class="codeph">javax.net.ssl.HandShakeCompletedEvent</code> class defines the event communicated to a <span class="apiname">HandShakeCompletedListener</span> (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-DFBAA9D1-C08B-48C9-88FE-F88003A6A6C7" title="The javax.net.ssl.HandShakeCompletedListener interface is an interface implemented by any class that is notified of the completion of an SSL protocol handshake on a given SSLSocket connection.">The HandShakeCompletedListener Interface</a>) upon completion of an SSL protocol handshake on a given <code class="codeph">SSLSocket</code> connection.</p>
</div>
</div>
<div class="sect4"><a id="GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587"></a>
<h4 id="JSSEC-GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587" class="sect4">The HostnameVerifier Interface</h4>
<div>
<p>If the SSL/TLS implementation's standard host name verification logic fails, then the implementation calls the <code class="codeph">verify()</code> method of the class that implements this interface and is assigned to this <code class="codeph">HttpsURLConnection</code> instance. If the callback class can determine that the host name is acceptable given the parameters, it reports that the connection should be allowed. An unacceptable response causes the connection to be terminated. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587__SAMPLECODEFORHOSTNAMEVERIFIERINTERF-6A7C5993">Example 8-15</a>.</p>
<p>See <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><code class="codeph">HttpsURLConnection</code></a> for more information about how to assign the <code class="codeph">HostnameVerifier</code> to the <code class="codeph">HttpsURLConnection</code>.</p>
<div class="example" id="GUID-9E46E5AA-FE3E-48D7-B616-98A143F74587__SAMPLECODEFORHOSTNAMEVERIFIERINTERF-6A7C5993">
<p class="titleinexample">Example 8-15 Sample Code for Implementing the HostnameVerifier Interface</p>
<p>The following example illustrates a class that implements <code class="codeph">HostnameVerifier</code> interface:</p>
<pre class="codeblock" dir="ltr">
    public class MyHostnameVerifier implements HostnameVerifier {
    
        public boolean verify(String hostname, SSLSession session) {
            // pop up an interactive dialog box
            // or insert additional matching logic
            if (good_address) {
                return true;
            } else {
                return false;
            }
        }
    }
    
    //...deleted...
    
    HttpsURLConnection urlc = (HttpsURLConnection)
      (new URL("https://www.example.com/")).openConnection();
    urlc.setHostnameVerifier(new MyHostnameVerifier());
</pre></div>
<!-- class="example" --></div>
</div>
<div class="sect4"><a id="GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F"></a>
<h4 id="JSSEC-GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F" class="sect4">The X509Certificate Class</h4>
<div>
<p>Many secure socket protocols perform authentication using public key certificates, also called X.509 certificates. This is the default authentication mechanism for the SSL/TLS protocols.</p>
<p>The <code class="codeph">java.security.cert.X509Certificate</code> abstract class provides a standard way to access the attributes of X.509 certificates.</p>
<div class="infobox-note" id="GUID-1B4C6B3B-CDB3-433D-8F24-41EF5DE2FA5F__GUID-C14C49BA-6583-4041-87ED-DC62E7F52B5F">
<p class="notep1">Note:</p>
The <code class="codeph">javax.security.cert.X509Certificate</code> class is supported only for backward compatibility with previous (1.0.x and 1.1.x) versions of JSSE. New applications should use the <code class="codeph">java.security.cert.X509Certificate</code> class instead.</div>
</div>
</div>
<div class="sect4"><a id="GUID-54BC5FB3-3841-4005-A876-9FA2F49B2D0F"></a>
<h4 id="JSSEC-GUID-54BC5FB3-3841-4005-A876-9FA2F49B2D0F" class="sect4">The AlgorithmConstraints Interface</h4>
<div>
<p>The <code class="codeph">java.security.AlgorithmConstraints</code> interface is used for controlling allowed cryptographic algorithms. <code class="codeph">AlgorithmConstraints</code> defines three <code class="codeph">permits()</code> methods. These methods tell whether an algorithm name or a key is permitted for certain cryptographic functions. Cryptographic functions are represented by a set of <code class="codeph">CryptoPrimitive</code>, which is an enumeration containing fields like <code class="codeph">STREAM_CIPHER</code>, <code class="codeph">MESSAGE_DIGEST</code>, and <code class="codeph">SIGNATURE</code>.</p>
<p>Thus, an <code class="codeph">AlgorithmConstraints</code> implementation can answer questions like: Can I use this key with this algorithm for the purpose of a cryptographic operation?</p>
<p>An <code class="codeph">AlgorithmConstraints</code> object can be associated with an <code class="codeph">SSLParameters</code> object by using the new <code class="codeph">setAlgorithmConstraints()</code> method. The current <code class="codeph">AlgorithmConstraints</code> object for an <code class="codeph">SSLParameters</code> object is retrieved using the <code class="codeph">getAlgorithmConstraints()</code> method.</p>
</div>
</div>
<div class="sect4"><a id="GUID-651B5070-F586-4504-A6CD-8BEB2D928D47"></a>
<h4 id="JSSEC-GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" class="sect4">The StandardConstants Class</h4>
<div>
<p>The <code class="codeph">StandardConstants</code> class is used to represent standard constants definitions in JSSE.</p>
<p><code class="codeph">StandardConstants.SNI_HOST_NAME</code> represents a domain name server (DNS) host name in a <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI)</a> extension, which can be used when instantiating an <code class="codeph">SNIServerName</code> or <code class="codeph">SNIMatcher</code> object.</p>
</div>
</div>
<div class="sect4"><a id="GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B"></a>
<h4 id="JSSEC-GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B" class="sect4">The SNIServerName Class</h4>
<div>
<p>An instance of the abstract <code class="codeph">SNIServerName</code> class represents a server name in the <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI)</a> extension. It is instantiated using the type and encoded value of the specified server name.</p>
<p>You can use the <code class="codeph">getType()</code> and <code class="codeph">getEncoded()</code> methods to return the server name type and a copy of the encoded server name value, respectively. The <code class="codeph">equals()</code> method can be used to check if some other object is "equal" to this server name. The <code class="codeph">hashCode()</code> method returns a hash code value for this server name. To get a string representation of the server name (including the server name type and encoded server name value), use the <code class="codeph">toString()</code> method.</p>
</div>
</div>
<div class="sect4"><a id="GUID-073F0493-3DB8-4388-818B-83E92021EF45"></a>
<h4 id="JSSEC-GUID-073F0493-3DB8-4388-818B-83E92021EF45" class="sect4">The SNIMatcher Class</h4>
<div>
<p>An instance of the abstract <code class="codeph">SNIMatcher</code> class performs match operations on an <code class="codeph">SNIServerName</code> object. Servers can use information from the <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI)</a> extension to decide if a specific <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> should accept a connection. For example, when multiple "virtual" or "name-based" servers are hosted on a single underlying network address, the server application can use SNI information to determine whether this server is the exact server that the client wants to access. Instances of this class can be used by a server to verify the acceptable server names of a particular type, such as host names.</p>
<p>The <code class="codeph">SNIMatcher</code> class is instantiated using the specified server name type on which match operations will be performed. To match a given <code class="codeph">SNIServerName</code>, use the <code class="codeph">matches()</code> method. To return the server name type of the given <code class="codeph">SNIMatcher</code> object, use the <code class="codeph">getType()</code> method.</p>
</div>
</div>
<div class="sect4"><a id="GUID-E10158C4-E808-41B7-9958-A119927743D8"></a>
<h4 id="JSSEC-GUID-E10158C4-E808-41B7-9958-A119927743D8" class="sect4">The SNIHostName Class</h4>
<div>
<p>An instance of the <code class="codeph">SNIHostName</code> class (which extends the <code class="codeph">SNIServerName</code> class) represents a server name of type "host_name" (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" title="The StandardConstants class is used to represent standard constants definitions in JSSE.">The StandardConstants Class</a>) in the <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a>. To instantiate an <code class="codeph">SNIHostName</code>, specify the fully qualified DNS host name of the server (as understood by the client) as a <code class="codeph">String</code> argument. The argument is illegal in the following cases:</p>
<ul style="list-style-type: disc;">
<li>The argument is empty.</li>
<li>The argument ends with a trailing period.</li>
<li>The argument is not a valid Internationalized Domain Name (IDN) compliant with the RFC 3490 specification.</li>
</ul>
<p>You can also instantiate an <code class="codeph">SNIHostName</code> by specifying the encoded host name value as a byte array. This method is typically used to parse the encoded name value in a requested SNI extension. Otherwise, use the <code class="codeph">SNIHostName(String hostname)</code> constructor. The <code class="codeph">encoded</code> argument is illegal in the following cases:</p>
<ul style="list-style-type: disc;">
<li>The argument is empty.</li>
<li>The argument ends with a trailing period.</li>
<li>The argument is not a valid Internationalized Domain Name (IDN) compliant with the RFC 3490 specification.</li>
<li>The argument is not encoded in UTF-8 or US-ASCII.</li>
</ul>
<div class="p">
<div class="infobox-note" id="GUID-E10158C4-E808-41B7-9958-A119927743D8__GUID-7C99C76D-9832-47F9-8FF8-7FD2123DE7EC">
<p class="notep1">Note:</p>
The <code class="codeph">encoded</code> byte array passed in as an argument is cloned to protect against subsequent modification.</div>
</div>
<p>To return the host name of an <code class="codeph">SNIHostName</code> object in US-ASCII encoding, use the <code class="codeph">getAsciiName()</code> method. To compare a server name to another object, use the <code class="codeph">equals()</code> method (comparison is <span class="italic">not</span> case-sensitive). To return a hash code value of an <code class="codeph">SNIHostName</code>, use the <code class="codeph">hashCode()</code> method. To return a string representation of an <code class="codeph">SNIHostName</code>, including the DNS host name, use the <code class="codeph">toString()</code> method.</p>
<p>You can create an <code class="codeph">SNIMatcher</code> object for an <code class="codeph">SNIHostName</code> object by passing a regular expression representing one or more host names to match to the <code class="codeph">createSNIMatcher()</code> method.</p>
</div>
</div>
</div>
</div>
<div class="sect2"><a id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9"></a>
<h2 id="JSSEC-GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" class="sect2">Customizing JSSE</h2>
<div>
<p>JSSE includes a standard implementation that can be customized by plugging in different implementations or specifying the default keystore, and so on.</p>
<div class="section">
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SECURITYPROPERTIESANDCUSTOMIZEITEMS-DCEC7645" title="List of Security Properties and the customizable items.">Table 8-7</a> and <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SYSTEMPROPERTIESANDCUSTOMIZEITEMSIN-DCEEB591" title="List of system properties and customized items.">Table 8-8</a> summarize which aspects can be customized, what the defaults are, and which mechanisms are used to provide customization.</p>
<p>Some of the customizations are done by setting system property or Security Property values. Sections following the table explain how to set such property values.</p>
<div class="p">
<div class="infobox-note" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__GUID-6E3ACF45-C569-4DA9-9905-08713A2D064C">
<p class="notep1">Note:</p>
Many of the properties shown in this table are currently used by the JSSE implementation, but there is no guarantee that they will continue to have the same names and types (system or security) or even that they will exist at all in future releases. All such properties are flagged with an asterisk (*). They are documented here for your convenience for use with the JSSE implementation.</div>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SECURITYPROPERTIESANDCUSTOMIZEITEMS-DCEC7645" title="List of Security Properties and the customizable items.">Table 8-7</a> shows items that are customized by setting the <code class="codeph">java.security.Security</code> property. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">How to Specify a java.security.Security Property</a></p>
<div class="tblformalwide" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SECURITYPROPERTIESANDCUSTOMIZEITEMS-DCEC7645">
<p class="titleintable">Table 8-7 Security Properties and Customized Items</p>
<table class="cellalignment469" title="Security Properties and Customized Items" summary="List of Security Properties and the customizable items.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" id="d108102e6030">Security Property</th>
<th class="cellalignment467" id="d108102e6032">Customized Item</th>
<th class="cellalignment467" id="d108102e6034">Default Value</th>
<th class="cellalignment467" id="d108102e6036">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6040" headers="d108102e6030 d108102e6036"><code class="codeph">cert.provider.x509v1</code></td>
<td class="cellalignment456" headers="d108102e6040 d108102e6032"><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B" title="The X509Certificate implementation returned by the X509Certificate.getInstance() method is by default the implementation from the JSSE implementation.">Customizing the X509Certificate Implementation</a></td>
<td class="cellalignment456" headers="d108102e6040 d108102e6034">X509Certificate implementation from Oracle</td>
<td class="cellalignment456" id="d108102e6054" headers="d108102e6030 d108102e6036">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6058" headers="d108102e6030 d108102e6036"><code class="codeph">jdk.tls.client.cipherSuites</code></td>
<td class="cellalignment456" headers="d108102e6058 d108102e6032">Client-side default enabled cipher suites; see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" title="You can specify the default enabled cipher suites in your application or with the system properties jdk.tls.client.cipherSuites and jdk.tls.server.cipherSuites.">Specifying Default Enabled Cipher Suites</a></td>
<td class="cellalignment456" headers="d108102e6058 d108102e6034"><a href="oracle-providers.htm#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2__CIPHERSUITESSUPPORTEDBYSUNJSSE-29E460FE" title="List of cipher suites supported by SunJSSE, whether they are enabled or disabled by default, and the release in which they were introduced">Table 4-11</a>, Cipher Suites Supported by SunJSSE</td>
<td class="cellalignment456" id="d108102e6080" headers="d108102e6030 d108102e6036"><span class="bold">Caution</span>: These system properties can be used to configure weak cipher suites, or the configured cipher suites may be weak in the future. It is not recommended that you use these system properties without understanding the risks.</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6085" headers="d108102e6030 d108102e6036"><code class="codeph">jdk.tls.server.cipherSuites</code></td>
<td class="cellalignment456" headers="d108102e6085 d108102e6032">Server-side default enabled cipher suites; see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" title="You can specify the default enabled cipher suites in your application or with the system properties jdk.tls.client.cipherSuites and jdk.tls.server.cipherSuites.">Specifying Default Enabled Cipher Suites</a></td>
<td class="cellalignment456" headers="d108102e6085 d108102e6034"><a href="oracle-providers.htm#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2__CIPHERSUITESSUPPORTEDBYSUNJSSE-29E460FE" title="List of cipher suites supported by SunJSSE, whether they are enabled or disabled by default, and the release in which they were introduced">Table 4-11</a>, Cipher Suites Supported by SunJSSE</td>
<td class="cellalignment456" id="d108102e6107" headers="d108102e6030 d108102e6036"><span class="bold">Caution</span>: These system properties can be used to configure weak cipher suites, or the configured cipher suites may be weak in the future. It is not recommended that you use these system properties without understanding the risks.</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6112" headers="d108102e6030 d108102e6036"><code class="codeph">security.provider.<span class="variable">n</span></code></td>
<td class="cellalignment456" headers="d108102e6112 d108102e6032">Cryptographic service provider; see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1" title="The JDK comes with a JSSE Cryptographic Service Provider, or provider for short, named SunJSSE. Providers are essentially packages that implement one or more engine classes for specific cryptographic algorithms.">Customizing the Provider Implementation</a> and <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-316FB978-7588-442E-B829-B4973DB3B584" title="The SunJSSE provider uses the SunJCE implementation for all its cryptographic needs. Although it is recommended that you leave the provider at its regular position, you can use implementations from other JCA or JCE providers by registering them before the SunJCE provider.">Customizing the Encryption Algorithm Providers</a></td>
<td class="cellalignment456" headers="d108102e6112 d108102e6034">The first five providers in order of priority are:
<ol>
<li>SUN</li>
<li>SunRsaSign</li>
<li>SunEC</li>
<li>SunJSSE</li>
<li>SunJCE</li>
</ol>
</td>
<td class="cellalignment456" id="d108102e6150" headers="d108102e6030 d108102e6036">Specify the provider in the <code class="codeph">security.provider.<span class="variable">n</span>=</code> line in security properties file, where <code class="codeph"><span class="variable">n</span></code> is an integer whose value is equal or greater than 1.</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6163" headers="d108102e6030 d108102e6036">*<code class="codeph">ssl.SocketFactory.provider</code></td>
<td class="cellalignment456" headers="d108102e6163 d108102e6032">Default <code class="codeph">SSLSocketFactory</code> implementation</td>
<td class="cellalignment456" headers="d108102e6163 d108102e6034"><code class="codeph">SSLSocketFactory</code> implementation from Oracle</td>
<td class="cellalignment456" id="d108102e6177" headers="d108102e6030 d108102e6036">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6181" headers="d108102e6030 d108102e6036">*<code class="codeph">ssl.ServerSocketFactory.provider</code></td>
<td class="cellalignment456" headers="d108102e6181 d108102e6032">Default <code class="codeph">SSLServerSocketFactory</code> implementation</td>
<td class="cellalignment456" headers="d108102e6181 d108102e6034"><code class="codeph">SSLServerSocketFactory</code> implementation from Oracle</td>
<td class="cellalignment456" id="d108102e6195" headers="d108102e6030 d108102e6036">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6199" headers="d108102e6030 d108102e6036"><code class="codeph">ssl.KeyManagerFactory.algorithm</code></td>
<td class="cellalignment456" headers="d108102e6199 d108102e6032">Default key manager factory algorithm name (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">Customizing the Default Key Managers and Trust Managers</a>)</td>
<td class="cellalignment456" headers="d108102e6199 d108102e6034">SunX509</td>
<td class="cellalignment456" id="d108102e6211" headers="d108102e6030 d108102e6036">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6215" headers="d108102e6030 d108102e6036">*<code class="codeph">jdk.certpath.disabledAlgorithms</code></td>
<td class="cellalignment456" headers="d108102e6215 d108102e6032">Disabled certificate verification cryptographic algorithm (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-0A438179-32A7-4900-A81C-29E3073E1E90" title="In some environments, certain algorithms or key lengths may be undesirable when using SSL/TLS/DTLS. The Oracle JDK uses the jdk.certpath.disabledAlgorithms and jdk.tls.disabledAlgorithm Security Properties to disable algorithms during SSL/TLS/DTLS protocol negotiation, including version negotiation, cipher suites selection, peer authentication, and key exchange mechanisms. Note that these Security Properties are not guaranteed to be used by other JDK implementations. See the &lt;java-home&gt;/conf/security/java.security file for information about the syntax of these Security Properties and their current active values.">Disabled and Restricted Cryptographic Algorithms</a>)</td>
<td class="cellalignment456" headers="d108102e6215 d108102e6034">
<p>MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224<a id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__RESTRICTED_ALGORITHMS_MAY_CHANGE_FOOTNOTE" href="#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__RESTRICTED_ALGORITHMS_MAY_CHANGE_FOOTNOTE" onclick='footdisplay(4,"The list of restricted algorithms specified in these Security Properties may change; see the java.security file in your JDK installation for the latest values.")'><sup>Foot&nbsp;4</sup></a></p>
</td>
<td class="cellalignment456" id="d108102e6247" headers="d108102e6030 d108102e6036">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6251" headers="d108102e6030 d108102e6036"><code class="codeph">ssl.TrustManagerFactory.algorithm</code></td>
<td class="cellalignment456" headers="d108102e6251 d108102e6032">Default trust manager factory algorithm name (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">Customizing the Default Key Managers and Trust Managers</a>)</td>
<td class="cellalignment456" headers="d108102e6251 d108102e6034">PKIX</td>
<td class="cellalignment456" id="d108102e6263" headers="d108102e6030 d108102e6036">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6267" headers="d108102e6030 d108102e6036"><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-316FB978-7588-442E-B829-B4973DB3B584" title="The SunJSSE provider uses the SunJCE implementation for all its cryptographic needs. Although it is recommended that you leave the provider at its regular position, you can use implementations from other JCA or JCE providers by registering them before the SunJCE provider.">JCE encryption algorithms used by the SunJSSE provider</a></td>
<td class="cellalignment456" headers="d108102e6267 d108102e6032">Give alternative JCE algorithm providers a higher preference order than the SunJCE provider</td>
<td class="cellalignment456" headers="d108102e6267 d108102e6034">SunJCE implementations</td>
<td class="cellalignment456" id="d108102e6281" headers="d108102e6030 d108102e6036">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6285" headers="d108102e6030 d108102e6036">
<p>*<code class="codeph">jdk.tls.disabledAlgorithms</code></p>
</td>
<td class="cellalignment456" headers="d108102e6285 d108102e6032"><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-0A438179-32A7-4900-A81C-29E3073E1E90" title="In some environments, certain algorithms or key lengths may be undesirable when using SSL/TLS/DTLS. The Oracle JDK uses the jdk.certpath.disabledAlgorithms and jdk.tls.disabledAlgorithm Security Properties to disable algorithms during SSL/TLS/DTLS protocol negotiation, including version negotiation, cipher suites selection, peer authentication, and key exchange mechanisms. Note that these Security Properties are not guaranteed to be used by other JDK implementations. See the &lt;java-home&gt;/conf/security/java.security file for information about the syntax of these Security Properties and their current active values.">Disabled and Restricted Cryptographic Algorithms</a></td>
<td class="cellalignment456" headers="d108102e6285 d108102e6034">
<p>SSLv3, RC4, MD5withRSA, DH keySize &lt; 1024, EC keySize &lt; 224<a id="fnsrc_d108102e6311" href="#fnsrc_d108102e6311" onclick='footdisplay(4,"The list of restricted algorithms specified in these Security Properties may change; see the java.security file in your JDK installation for the latest values.")'><sup>Footref&nbsp;4</sup></a></p>
</td>
<td class="cellalignment456" id="d108102e6313" headers="d108102e6030 d108102e6036">Disables specific algorithms (protocols versions, cipher suites, key exchange mechanisms, etc.) that will not be negotiated for SSL/TLS/DTLS connections, even if they are enabled explicitly in an application</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6317" headers="d108102e6030 d108102e6036"><code class="codeph">jdk.tls.server.defaultDHEParameters</code></td>
<td class="cellalignment456" headers="d108102e6317 d108102e6032">Diffie-Hellman groups</td>
<td class="cellalignment456" headers="d108102e6317 d108102e6034">Safe prime Diffie-Hellman groups in OpenJDK SSL/TLS/DTLS implementation</td>
<td class="cellalignment456" id="d108102e6324" headers="d108102e6030 d108102e6036">Defines default finite field Diffie-Hellman ephemeral (DHE) parameters for Transport Layer Security (SSL/TLS/DTLS) processing</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;4</sup> The list of restricted algorithms specified in these Security Properties may change; see the <code>java.security</code> file in your JDK installation for the latest values.</p>
<p>* <span>This System Property is currently used by the JSSE implementation, but it is not guaranteed to be examined and used by other implementations. If it <span class="variable">is</span> examined by another implementation, then that implementation should handle it in the same manner as the JSSE implementation does. There is no guarantee the property will continue to exist or be of the same type (system or security) in future releases.</span></p>
</div>
<!-- class="section" -->
<div class="section"><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SYSTEMPROPERTIESANDCUSTOMIZEITEMSIN-DCEEB591" title="List of system properties and customized items.">Table 8-8</a> shows items that are customized by setting <code class="codeph">java.lang.System</code> property. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">How to Specify a java.lang.System Property</a>.
<div class="tblformalwide" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__SYSTEMPROPERTIESANDCUSTOMIZEITEMSIN-DCEEB591">
<p class="titleintable">Table 8-8 System Properties and Customized Items</p>
<table class="cellalignment469" title="System Properties and Customized Items" summary="List of system properties and customized items.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" id="d108102e6359">System Property</th>
<th class="cellalignment467" id="d108102e6361">Customized Item</th>
<th class="cellalignment467" id="d108102e6363">Default</th>
<th class="cellalignment467" id="d108102e6365">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6369" headers="d108102e6359"><code class="codeph">java.protocol.handler.pkgs</code></td>
<td class="cellalignment456" headers="d108102e6369 d108102e6361"><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77" title="You can communicate securely with an SSL-enabled web server by using the HTTPS URL scheme for the java.net.URL class. The JDK provides a default HTTPS URL implementation.">Specifying an Alternative HTTPS Protocol Implementation</a></td>
<td class="cellalignment456" headers="d108102e6369 d108102e6363">Implementation from Oracle</td>
<td class="cellalignment456" headers="d108102e6369 d108102e6365">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6387" headers="d108102e6359">*<code class="codeph">javax.net.ssl.keyStore</code></td>
<td class="cellalignment456" headers="d108102e6387 d108102e6361">Default keystore (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>)</td>
<td class="cellalignment456" headers="d108102e6387 d108102e6363">
<p>None</p>
</td>
<td class="cellalignment456" headers="d108102e6387 d108102e6365">The value <code class="codeph">NONE</code> may be specified. This setting is appropriate if the keystore is not file-based (for example, it resides in a hardware token)</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6408" headers="d108102e6359">*<code class="codeph">javax.net.ssl.keyStorePassword</code></td>
<td class="cellalignment456" headers="d108102e6408 d108102e6361">Default keystore password (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>)</td>
<td class="cellalignment456" headers="d108102e6408 d108102e6363">
<p>None</p>
</td>
<td class="cellalignment456" headers="d108102e6408 d108102e6365">
<p>It is inadvisable to specify the password in a way that exposes it to discovery by other users.</p>
<p>For example, specifying the password on the command line. To keep the password secure, have the application prompt for the password, or specify the password in a properly protected option file</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6428" headers="d108102e6359">*<code class="codeph">javax.net.ssl.keyStoreProvider</code></td>
<td class="cellalignment456" headers="d108102e6428 d108102e6361">Default keystore provider (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>)</td>
<td class="cellalignment456" headers="d108102e6428 d108102e6363">
<p>None</p>
</td>
<td class="cellalignment456" headers="d108102e6428 d108102e6365">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6447" headers="d108102e6359">*<code class="codeph">javax.net.ssl.keyStoreType</code></td>
<td class="cellalignment456" headers="d108102e6447 d108102e6361">Default keystore type (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>)</td>
<td class="cellalignment456" headers="d108102e6447 d108102e6363"><code class="codeph">KeyStore.getDefaultType()</code></td>
<td class="cellalignment456" headers="d108102e6447 d108102e6365">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6466" headers="d108102e6359">*<code class="codeph">javax.net.ssl.trustStore</code></td>
<td class="cellalignment456" headers="d108102e6466 d108102e6361">Default truststore (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>)</td>
<td class="cellalignment456" headers="d108102e6466 d108102e6363"><code class="codeph">jssecacerts</code>, if it exists.
<p>Otherwise, <code class="codeph">cacerts</code></p>
</td>
<td class="cellalignment456" headers="d108102e6466 d108102e6365">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6490" headers="d108102e6359">*<code class="codeph">javax.net.ssl.trustStorePassword</code></td>
<td class="cellalignment456" headers="d108102e6490 d108102e6361">Default truststore password (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>)</td>
<td class="cellalignment456" headers="d108102e6490 d108102e6363">
<p>None</p>
</td>
<td class="cellalignment456" headers="d108102e6490 d108102e6365">
<p>It is inadvisable to specify the password in a way that exposes it to discovery by other users.</p>
<p>For example, specifying the password on the command line. To keep the password secure, have the application prompt for the password, or specify the password in a properly protected option file</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6511" headers="d108102e6359">*<code class="codeph">javax.net.ssl.trustStoreProvider</code></td>
<td class="cellalignment456" headers="d108102e6511 d108102e6361">Default truststore provider (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>)</td>
<td class="cellalignment456" headers="d108102e6511 d108102e6363">
<p>None</p>
</td>
<td class="cellalignment456" headers="d108102e6511 d108102e6365">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6530" headers="d108102e6359">*<code class="codeph">javax.net.ssl.trustStoreType</code></td>
<td class="cellalignment456" headers="d108102e6530 d108102e6361">Default truststore type (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>)</td>
<td class="cellalignment456" headers="d108102e6530 d108102e6363"><code class="codeph">KeyStore.getDefaultType()</code></td>
<td class="cellalignment456" headers="d108102e6530 d108102e6365">The value <code class="codeph">NONE</code> may be specified. This setting is appropriate if the truststore is not file-based (for example, it resides in a hardware token)</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6551" headers="d108102e6359">*<code class="codeph">https.proxyHost</code></td>
<td class="cellalignment456" headers="d108102e6551 d108102e6361">Default proxy host</td>
<td class="cellalignment456" headers="d108102e6551 d108102e6363">
<p>None</p>
</td>
<td class="cellalignment456" headers="d108102e6551 d108102e6365">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6564" headers="d108102e6359">*<code class="codeph">https.proxyPort</code></td>
<td class="cellalignment456" headers="d108102e6564 d108102e6361">Default proxy port</td>
<td class="cellalignment456" headers="d108102e6564 d108102e6363">80</td>
<td class="cellalignment456" headers="d108102e6564 d108102e6365">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6578" headers="d108102e6359">*<code class="codeph">jsse.enableSNIExtension</code></td>
<td class="cellalignment456" headers="d108102e6578 d108102e6361">Server Name Indication option</td>
<td class="cellalignment456" headers="d108102e6578 d108102e6363"><code class="codeph">true</code></td>
<td class="cellalignment456" headers="d108102e6578 d108102e6365">Server Name Indication (SNI) is a TLS extension, defined in <a href="http://www.ietf.org/rfc/rfc6066.txt" target="_blank">RFC 6066</a>. It enables TLS connections to virtual servers, in which multiple servers for different network names are hosted at a single underlying network address. Some very old SSL/TLS vendors may not be able handle SSL/TLS extensions. In this case, set this property to <code class="codeph">false</code> to disable the SNI extension</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6598" headers="d108102e6359">*<code class="codeph">https.cipherSuites</code></td>
<td class="cellalignment456" headers="d108102e6598 d108102e6361">Default cipher suites</td>
<td class="cellalignment456" headers="d108102e6598 d108102e6363">Determined by the socket factory.</td>
<td class="cellalignment456" headers="d108102e6598 d108102e6365">
<p>This contains a comma-separated list of cipher suite names specifying which cipher suites to enable for use on this <code class="codeph">HttpsURLConnection</code>. See the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledCipherSuites(String[])</code></a> method. Note that this method sets the preference order of the ClientHello cipher suites directly from the <span class="apiname">String</span> array passed to it.</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6622" headers="d108102e6359">*<code class="codeph" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__HTTPS.PROTOCOLS_PROPERTY">https.protocols</code></td>
<td class="cellalignment456" headers="d108102e6622 d108102e6361">Default handshaking protocols</td>
<td class="cellalignment456" headers="d108102e6622 d108102e6363">Determined by the socket factory.</td>
<td class="cellalignment456" headers="d108102e6622 d108102e6365">
<p>This contains a comma-separated list of protocol suite names specifying which protocol suites to enable on this <code class="codeph">HttpsURLConnection</code>. See <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledProtocols(String[])</code></a></p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6641" headers="d108102e6359">* Customize via <code class="codeph">port</code> field in the HTTPS URL.</td>
<td class="cellalignment456" headers="d108102e6641 d108102e6361">Default HTTPS port</td>
<td class="cellalignment456" headers="d108102e6641 d108102e6363">443</td>
<td class="cellalignment456" headers="d108102e6641 d108102e6365">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6654" headers="d108102e6359">*<code class="codeph">jsse.SSLEngine.acceptLargeFragments</code></td>
<td class="cellalignment456" headers="d108102e6654 d108102e6361">Default sizing buffers for large SSL/TLS packets</td>
<td class="cellalignment456" headers="d108102e6654 d108102e6363">
<p>None</p>
</td>
<td class="cellalignment456" headers="d108102e6654 d108102e6365">
<p>Setting this system property to <code class="codeph">true</code>, <code class="codeph">SSLSession</code> will size buffers to handle <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AB362290-033A-4D3B-AAF3-1BFEB1CD472B__GUID-17258111-C234-4640-B886-D85221CCE842">large data packets</a> by default. This may cause applications to allocate unnecessarily large <code class="codeph">SSLEngine</code> buffers. Instead, applications should <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AC6700ED-ADC4-41EA-B111-2AEF2CBF7744" title="The status of the SSLEngine is represented by SSLEngineResult.Status.">dynamically check for buffer overflow conditions</a> and resize buffers as appropriate</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6690" headers="d108102e6359">*<code class="codeph">sun.security.ssl.allowUnsafeRenegotiation</code></td>
<td class="cellalignment456" headers="d108102e6690 d108102e6361">Allow unsafe SSL/TLS Renegotaions (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-475E6316-283A-4A59-9B11-2479348C4629" title="The SunJSSE implementation reenables renegotiations by default for connections to peers compliant with RFC 5746. That is, both the client and server must support RFC 5746 in order to securely renegotiate. SunJSSE provides some interoperability modes for connections with peers that have not been upgraded, but users are strongly encouraged to update both their client and server implementations as soon as possible.">Description of the Phase 2 Fix</a>)</td>
<td class="cellalignment456" headers="d108102e6690 d108102e6363"><code class="codeph">false</code></td>
<td class="cellalignment456" headers="d108102e6690 d108102e6365">
<p>Setting this system property to <code class="codeph">true</code> permits full (unsafe) legacy renegotiation.</p>
<p>This system property is <span>deprecated and might be removed in a future JDK release.</span></p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6722" headers="d108102e6359">*<code class="codeph">sun.security.ssl.allowLegacyHelloMessages</code></td>
<td class="cellalignment456" headers="d108102e6722 d108102e6361">Allow legacy Hello messages (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-475E6316-283A-4A59-9B11-2479348C4629" title="The SunJSSE implementation reenables renegotiations by default for connections to peers compliant with RFC 5746. That is, both the client and server must support RFC 5746 in order to securely renegotiate. SunJSSE provides some interoperability modes for connections with peers that have not been upgraded, but users are strongly encouraged to update both their client and server implementations as soon as possible.">Description of the Phase 2 Fix</a>)</td>
<td class="cellalignment456" headers="d108102e6722 d108102e6363"><code class="codeph">true</code></td>
<td class="cellalignment456" headers="d108102e6722 d108102e6365">
<p>Setting this system property to true allows the peer to handshake without requiring the proper RFC 5746 messages.</p>
<p>This system property is <span>deprecated and might be removed in a future JDK release.</span></p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6752" headers="d108102e6359"><code class="codeph" id="GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__JDK.TLS.CLIENT.PROTOCOLS_PROPERTY">jdk.tls.client.protocols</code></td>
<td class="cellalignment456" headers="d108102e6752 d108102e6361"><a href="oracle-providers.htm#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">The SunJSSE Provider</a></td>
<td class="cellalignment456" headers="d108102e6752 d108102e6363">
<p>None</p>
</td>
<td class="cellalignment456" headers="d108102e6752 d108102e6365">
<p>To enable specific <code class="codeph">SunJSSE</code> protocols on the client, specify them in a comma-separated list within quotation marks; all other supported protocols are not enabled on the client</p>
<div class="p">For example,
<ul style="list-style-type: disc;">
<li>
<p>If <code class="codeph">jdk.tls.client.protocols=</code><code class="codeph">"TLSv1,TLSv1.1"</code>, then the default protocol settings on the client for TLSv1 and TLSv1.1 are enabled, while SSLv3, TLSv1.2, and SSLv2Hello are not enabled</p>
</li>
<li>
<p>If <code class="codeph">jdk.tls.client.protocols="DTLSv1.2"</code> , then the protocol setting on the client for DTLS1.2 is enabled, while DTLS1.0 is not enabled</p>
</li>
</ul>
</div>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6786" headers="d108102e6359"><code class="codeph">jdk.tls.ephemeralDHKeySize</code></td>
<td class="cellalignment456" headers="d108102e6786 d108102e6361"><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D" title="In SSL/TLS/DTLS connections, ephemeral Diffie-Hellman (DH) keys may be used internally during the handshaking. The SunJSSE provider provides a flexible approach to customize the strength of the ephemeral DH key size during SSL/TLS/DTLS handshaking.">Customizing Size of Ephemeral Diffie-Hellman Keys</a></td>
<td class="cellalignment456" headers="d108102e6786 d108102e6363">1024 bits</td>
<td class="cellalignment456" headers="d108102e6786 d108102e6365">
<p>None</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e6801" headers="d108102e6359"><code class="codeph">jsse.enableMFLNExtension</code></td>
<td class="cellalignment456" headers="d108102e6801 d108102e6361"><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36" title="In order to negotiate smaller maximum fragment lengths, clients have an option to include an extension of type max_fragment_length in the ClientHello message. A system property jsse.enableMFLNExtension, can be used to enable or disable the MFLN extension for SSL/TLS/DTLS.">Customizing Maximum Fragment Length Negotiation (MFLN) Extension</a></td>
<td class="cellalignment456" headers="d108102e6801 d108102e6363">false</td>
<td class="cellalignment456" headers="d108102e6801 d108102e6365">
<p>None</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>* <span>This system property is currently used by the JSSE implementation, but it is not guaranteed to be examined and used by other implementations. If it <span class="variable">is</span> examined by another implementation, then that implementation should handle it in the same manner as the JSSE implementation does. There is no guarantee the property will continue to exist or be of the same type (system or security) in future releases.</span></p>
</div>
<!-- class="section" --></div>
<div class="sect3"><a id="GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363"></a>
<h3 id="JSSEC-GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363" class="sect3">How to Specify a java.lang.System Property</h3>
<div>
<div class="section">You can customize some aspects of JSSE by setting system properties. There are several ways to set these properties:</div>
<!-- class="section" -->
<ul>
<li class="stepexpand"><span>To set a system property statically, use the <code class="codeph">-D</code> option of the <code class="codeph">java</code> command. For example, to run an application named MyApp and set the <code class="codeph">javax.net.ssl.trustStore</code> system property to specify a truststore named MyCacertsFile. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">truststore</a>. Enter the following:</span>
<div>
<pre class="codeblock" dir="ltr">
        java -Djavax.net.ssl.trustStore=MyCacertsFile MyApp
                
</pre></div>
</li>
<li class="stepexpand"><span>To set a system property dynamically, call the <code class="codeph">java.lang.System.setProperty()</code> method in your code:</span>
<div>
<pre class="codeblock" dir="ltr">
        System.setProperty("<span class="variable">propertyName</span>", "<span class="variable">propertyValue</span>");
                
</pre></div>
<div>For example, a <code class="codeph">setProperty()</code> call corresponding to the previous example for setting the <code class="codeph">javax.net.ssl.trustStore</code> system property to specify a truststore named "<code class="codeph">MyCacertsFile</code>" would be:
<pre class="codeblock" dir="ltr">
        System.setProperty("javax.net.ssl.trustStore", "MyCacertsFile");
                
</pre></div>
</li>
<li class="stepexpand"><span>In the Java Deployment environment (Plug-In/Web Start), there are several ways to set the system properties.</span>
<div>
<ul style="list-style-type: disc;">
<li>
<p>Use the Java Control Panel to set the Runtime Environment Property on a local or per-VM basis. This creates a local <code class="codeph">deployment.properties</code> file. Deployers can also distribute an enterprise wide <code class="codeph">deployment.properties</code> file by using the <code class="codeph">deployment.config</code> mechanism.</p>
</li>
<li>
<p>To set a property for a specific applet, use the HTML subtag <code class="codeph">&lt;PARAM&gt;</code> "java_arguments" within the <code class="codeph">&lt;APPLET&gt;</code> tag.</p>
</li>
<li>
<p>To set the property in a specific Java Web Start application or applet using Plugin2, use the JNLP <code class="codeph">property</code> sub element of the <code class="codeph">resources</code> element. See <a class="olink JSDPG-GUID-F32AB01F-C9AF-4D7B-B9CB-66ACE2771846" target="_blank" href="../deploy/jnlp-file-syntax.htm#JSDPG-GUID-F32AB01F-C9AF-4D7B-B9CB-66ACE2771846">resources Element</a> in the <span><cite>Java Platform, Standard Edition Deployment Guide</cite></span>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3"><a id="GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6"></a>
<h3 id="JSSEC-GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6" class="sect3">How to Specify a java.security.Security Property</h3>
<div>
<div class="section">You can customize some aspects of JSSE by setting Security Properties. You can set a Security Property either statically or dynamically:</div>
<!-- class="section" -->
<ul>
<li class="stepexpand"><span>To set a Security Property statically, add a line to the security properties file. The security properties file is located at <code><span class="variable">java-home</span>/conf/security/java.security</code></span>
<div>
<dl>
<dt class="dlterm"><a id="GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6__GUID-548CD27A-7959-4905-8A44-EA4F9CE36641"><!-- --></a><span class="variable">java-home</span></dt>
<dd>See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329" title="The following are commonly used cryptography terms and their definitions.">Terms and Definitions</a></dd>
</dl>
<p>To specify a Security Property value in the security properties file, you add a line of the following form:</p>
<pre class="codeblock" dir="ltr">
<span class="variable">propertyName</span>=<span class="variable">propertyValue</span>
</pre></div>
<div>
<p>For example, suppose that you want to specify a different key manager factory algorithm name than the default SunX509. You do this by specifying the algorithm name as the value of a Security Property named <code class="codeph">ssl.KeyManagerFactory.algorithm</code>. For example, to set the value to MyX509, add the following line to the security properties file:</p>
<pre class="codeblock" dir="ltr">
ssl.KeyManagerFactory.algorithm=MyX509
</pre></div>
</li>
<li class="stepexpand"><span>To set a Security Property dynamically, call the <code class="codeph">java.security.Security.setProperty</code> method in your code:</span>
<div>
<pre class="codeblock" dir="ltr">
Security.setProperty("<span class="variable">propertyName</span>," "<span class="variable">propertyValue</span>");
</pre></div>
<div>For example, a call to the <code class="codeph">setProperty()</code> method corresponding to the previous example for specifying the key manager factory algorithm name would be:
<pre class="codeblock" dir="ltr">
Security.setProperty("ssl.KeyManagerFactory.algorithm", "MyX509");
</pre></div>
</li>
</ul>
</div>
</div>
<div class="sect3"><a id="GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B"></a>
<h3 id="JSSEC-GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B" class="sect3">Customizing the X509Certificate Implementation</h3>
<div>
<p>The X509Certificate implementation returned by the <code class="codeph">X509Certificate.getInstance()</code> method is by default the implementation from the JSSE implementation.</p>
<div class="section">To cause a different implementation to be returned:</div>
<!-- class="section" -->
<div class="section">Specify the name (and package) of the other implementation's class as the value of a <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">How to Specify a java.security.Security Property</a> named <code class="codeph">cert.provider.x509v1</code>.</div>
<!-- class="section" -->
<div class="example" id="GUID-F196CEDD-DC14-40EA-852A-133DB9BA798B__GUID-79B9F37D-F567-454A-AD1C-7CEDD90571EE">For example, if the class is called <code class="codeph">MyX509CertificateImpl</code> and it appears in the <code class="codeph">com.cryptox</code> package, then you should add the following line to the security properties file:
<pre class="codeblock" dir="ltr">
    cert.provider.x509v1=com.cryptox.MyX509CertificateImpl
</pre></div>
<!-- class="example" --></div>
</div>
<div class="sect3"><a id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB"></a>
<h3 id="JSSEC-GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB" class="sect3">Specifying Default Enabled Cipher Suites</h3>
<div>
<p>You can specify the default enabled cipher suites in your application or with the system properties <code class="codeph">jdk.tls.client.cipherSuites</code> and <code class="codeph">jdk.tls.server.cipherSuites</code>.</p>
<div class="infobox-note" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-02A9D641-DC20-473E-8C89-6BBC11F59960">
<p class="notep1">Note:</p>
The actual use of enabled cipher suites is restricted by algorithm constraints.</div>
<p>The set of cipher suites to enable by default is determined by one of the following ways in this order of preference:</p>
<ol>
<li>Explicitly set by application</li>
<li>Specified by system property</li>
<li>Specified by JSSE provider defaults</li>
</ol>
<p>For example, explicitly setting the default enabled cipher suites in your application overrides settings specified in <code class="codeph">jdk.tls.client.cipherSuites</code> or <code class="codeph">jdk.tls.server.cipherSuites</code> as well as JSSE provider defaults.</p>
<div class="section">
<p class="subhead3">Explicitly Set by Application</p>
<p>You can set which cipher suites are enabled with one of the following methods:</p>
<ul style="list-style-type: disc;">
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLSocket.setEnabledCipherSuites(String[])</span></a></li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLEngine.setEnabledCipherSuites(String[])</span></a></li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLServerSocket.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLServerSocket.setEnabledCipherSuites(String[])</span></a></li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#SSLParameters-java.lang.String:A-" target="_blank"><span class="apiname">SSLParameters(String[] cipherSuites)</span></a></li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#SSLParameters-java.lang.String:A-java.lang.String:A-" target="_blank"><span class="apiname">SSLParameters(String[] cipherSuites, String[] protocols)</span></a></li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setCipherSuites-java.lang.String:A-" target="_blank"><span class="apiname">SSLParameters.setCipherSuites(String[])</span></a></li>
<li><code class="codeph">https.cipherSuites</code> system property for <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><span class="apiname">HttpsURLConnection</span></a></li>
</ul>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Specified by System Property</p>
<p>The system property <code class="codeph">jdk.tls.client.cipherSuites</code> specifies the default enabled cipher suites on the client side; <code class="codeph">jdk.tls.server.cipherSuites</code> specifies those on the server side.</p>
<p>The syntax of the value of these two system properties is a comma-separated list of supported cipher suite names. Unrecognized or unsupported cipher suite names that are specified in these properties are ignored. See <a href="https://docs.oracle.com/javase/10/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithms</a> for standard JSSE cipher suite names.</p>
<div class="infobox-note" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-7976F3A1-6661-423E-9226-61DCF6E45E1F">
<p class="notep1">Note:</p>
These system properties are currently supported by Oracle JDK and OpenJDK. They are not guaranteed to be supported by other JDK implementations.</div>
<div class="infobox-note" id="GUID-D61663E8-2405-4B2D-A1F1-B8C7EA2688DB__GUID-0AD1FE03-21D2-45CF-9E2C-9CC06C8D6F5C">
<p class="notep1">Caution:</p>
These system properties can be used to configure weak cipher suites, or the configured cipher suites may be weak in the future. It is not recommended that you use these system properties without understanding the risks.</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Specified by JSSE Provider Defaults</p>
<p>Each JSSE provider has its own default enabled cipher suites. See <a href="oracle-providers.htm#GUID-7093246A-31A3-4304-AC5F-5FB6400405E2">The SunJSSE Provider</a> in <a href="oracle-providers.htm#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers Documentation</a> for the cipher suite names supported by the SunJSSE provider and which ones that are enabled by default.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77"></a>
<h3 id="JSSEC-GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77" class="sect3">Specifying an Alternative HTTPS Protocol Implementation</h3>
<div>
<p>You can communicate securely with an SSL-enabled web server by using the HTTPS URL scheme for the <code class="codeph">java.net.URL</code> class. The JDK provides a default HTTPS URL implementation.</p>
<p>If you want an alternative HTTPS protocol implementation to be used, set the <code class="codeph">java.protocol.handler.pkgs</code> <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">How to Specify a java.lang.System Property</a> to include the new class name. This action causes the specified classes to be found and loaded before the JDK default classes. See the <a href="https://docs.oracle.com/javase/10/docs/api/java/net/URL.html" target="_blank"><span class="apiname">URL</span></a> class for details.</p>
<div class="p">
<div class="infobox-note" id="GUID-7EBD6A94-9ADE-4321-8915-17B3763F8E77__GUID-E9529FD8-897B-4783-8470-001332442275">
<p class="notep1">Note:</p>
In past JSSE releases, you had to set the <code class="codeph">java.protocol.handler.pkgs</code> system property during JSSE installation. This step is no longer required unless you want to obtain an instance of <code class="codeph">com.sun.net.ssl.HttpsURLConnection</code>.</div>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1"></a>
<h3 id="JSSEC-GUID-8BC473B2-CD64-4E8B-8136-80BB286091B1" class="sect3">Customizing the Provider Implementation</h3>
<div>
<p>The JDK comes with a JSSE Cryptographic Service Provider, or <span class="variable">provider</span> for short, named SunJSSE. Providers are essentially packages that implement one or more engine classes for specific cryptographic algorithms.</p>
<p>The JSSE engine classes are <code class="codeph">SSLContext</code>, <code class="codeph">KeyManagerFactory</code>, and <code class="codeph">TrustManagerFactory</code>. See <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>Java Cryptography Architecture (JCA) Reference Guide</a> to know more about providers and engine classes.</p>
<p>Before it can be used, a provider must be registered, either statically or dynamically. You do not need to register the SunJSSE provider because it is preregistered. If you want to use other providers, read the following sections to see how to register them.</p>
</div>
</div>
<div class="sect3"><a id="GUID-59723547-D466-44C9-B066-EC5098B508E6"></a>
<h3 id="JSSEC-GUID-59723547-D466-44C9-B066-EC5098B508E6" class="sect3">Registering the Cryptographic Provider Statically</h3>
<div>
<div class="section">
<p>Register a provider statically by adding a line of the following form to the security properties file, <code class="codeph"><span class="codeinlineitalic">&lt;java-home&gt;</span>/conf/security/java.security</code>:</p>
<pre class="codeblock" dir="ltr">
security.provider.<span class="variable">n</span>=<span class="variable">provName</span>|<span class="variable">className</span> 
</pre>
<p>This declares a provider, and specifies its preference order <code class="codeph"><span class="variable">n</span></code>. The preference order is the order in which providers are searched for requested algorithms when no specific provider is requested. The order is 1-based; 1 is the most preferred, followed by 2, and so on.</p>
<p><code class="codeph"><span class="variable">provName</span></code> is the provider's name and <code class="codeph"><span class="variable">className</span></code> is the fully qualified class name of the provider.</p>
<p>Standard security providers are automatically registered for you in the <code class="codeph">java.security</code> security properties file.</p>
<p>To use another JSSE provider, add a line registering the other provider, giving it whatever preference order you prefer.</p>
<p>You can have more than one JSSE provider registered at the same time. The registered providers may include different implementations for different algorithms for different engine classes, or they may have support for some or all of the same types of algorithms and engine classes. When a particular engine class implementation for a particular algorithm is searched for, if no specific provider is specified for the search, then the providers are searched in preference order and the implementation from the first provider that supplies an implementation for the specified algorithm is used.</p>
<p>See <a href="howtoimplaprovider.htm#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="Register your provider so that the JCE framework can find your provider, either with the ServiceLoader class or in the class path or module path.">Step 8.1: Configure the Provider</a> in <a href="howtoimplaprovider.htm#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">Steps to Implement and Integrate a Provider</a>.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-D5D3557F-069E-48CE-8586-94BCC2B0203A"></a>
<h3 id="JSSEC-GUID-D5D3557F-069E-48CE-8586-94BCC2B0203A" class="sect3">Registering the Cryptographic Service Provider Dynamically</h3>
<div>
<p>Instead of registering a provider statically, you can add the provider dynamically at runtime by calling either the <span class="apiname">addProvider</span> or <span class="apiname">insertProviderAt</span> method in the <span class="apiname">Security</span> class. Note that this type of registration is not persistent and can only be done by code which is granted the <code class="codeph">insertProvider.<span class="variable">&lt;provider name&gt;</span></code> permission.</p>
<div class="section">See <a href="howtoimplaprovider.htm#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="Register your provider so that the JCE framework can find your provider, either with the ServiceLoader class or in the class path or module path.">Step 8.1: Configure the Provider</a> in <a href="howtoimplaprovider.htm#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">Steps to Implement and Integrate a Provider</a>.</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-9F841002-E08F-48A6-BC57-7D15DE6575DA"></a>
<h3 id="JSSEC-GUID-9F841002-E08F-48A6-BC57-7D15DE6575DA" class="sect3">Provider Configuration</h3>
<div>
<p>Some providers may require configuration. This is done using the <code class="codeph">configure</code> method of the <code class="codeph">Provider</code> class, prior to calling the <code class="codeph">addProvider</code> method of the <code class="codeph">Security</code> class. See <a href="pkcs11-reference-guide1.htm#GUID-C4ABFACB-B2C9-4E71-A313-79F881488BB9">SunPKCS11 Configuration</a> for an example. The <code class="codeph">Provider.configure()</code> method is new to Java SE 9.</p>
</div>
</div>
<div class="sect3"><a id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58"></a>
<h3 id="JSSEC-GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58" class="sect3">Configuring the Preferred Provider for Specific Algorithms</h3>
<div>
<p>Specify the preferred provider for a specific algorithm in the <code class="codeph">jdk.security.provider.preferred</code> Security Property. By specifying a preferred provider you can configure providers that offer performance gains for specific algorithms but are not the best performing provider for other algorithms. The ordered provider list specified using the <code class="codeph">security.provider.n</code> property is not sufficient to order providers that offer performance gains for specific algorithms but are not the best performing provider for other algorithms. More flexibility is required for configuring the ordering of provider list to achieve performance gains.</p>
<div class="section">
<p>The <code class="codeph">jdk.security.provider.preferred</code> Security Property allows specific algorithms, or service types to be selected from a preferred set of providers before accessing the list of registered providers. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">How to Specify a java.security.Security Property</a>.</p>
<p>The <code class="codeph">jdk.security.provider.preferred</code> Security Property does not register the providers. The ordered provider list must be <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-59723547-D466-44C9-B066-EC5098B508E6">Registering the Cryptographic Provider Statically</a> using the <code class="codeph">security.provider.n</code> property. Any provider that is not registered is ignored.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Specifying the Preferred Provider for an Algorithm</p>
<p>The syntax for specifying the preferred providers string in the <code class="codeph">jdk.security.provider.preferred</code> Security Property is a comma-separated list of <code class="codeph">ServiceType.Algorithm:Provider</code></p>
<p>In this syntax:</p>
<dl>
<dt class="dlterm"><a id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-A708BC0D-1E9B-4CA3-B30A-3765E2E886EA"><!-- --></a>ServiceType</dt>
<dd>
<p>The name of the service type. (for example: <code class="codeph">"MessageDigest"</code>)ServiceType is optional. If it isn&rsquo;t specified, the algorithm applies to all service types.</p>
</dd>
<dt class="dlterm"><a id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-B68E7DD5-A337-4754-9BB7-3D4D406A4AC0"><!-- --></a>Algorithm</dt>
<dd>
<p>The standard algorithm name. See <a href="https://docs.oracle.com/javase/10/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names Specification</a>. Algorithms can be specified as full standard name, (AES/CBC/PKCS5Padding) or as partial (AES, AES/CBC, AES//PKCS5Padding).</p>
</dd>
<dt class="dlterm"><a id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-92F5CD6E-C1BC-44A1-996F-9E00A0EDAC23"><!-- --></a>Provider</dt>
<dd>
<p>The name of the provider. Any provider that isn&rsquo;t listed in&nbsp;the registered list will be ignored. See <a href="oracle-providers.htm#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers</a>.</p>
</dd>
</dl>
Entries containing errors such as parsing errors are ignored. Use the command <code class="codeph">java -Djava.security.debug=jca</code> to debug errors.</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Preferred Providers and FIPS</p>
<p>If you add a FIPS provider to the <code class="codeph">security.provider.n</code> property, and specify the preferred provider ordering in the <code class="codeph">jdk.security.provider.preferred</code> property then the preferred providers specified in <code class="codeph">jdk.security.provider.preferred</code> are selected first.</p>
<p>Hence, it is recommended that you don&rsquo;t configure <code class="codeph">jdk.security.provider.preferred</code> property for FIPS provider configurations.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">jdk.security.provider.preferred Default Values</p>
<p>The <code class="codeph">jdk.security.provider.preferred</code> property is not set by default and is used only for application performance tuning.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-A00A625D-2596-41C8-BA38-21C71416A1B2">
<p class="titleinexample">Example 8-16 Sample jdk.security.provider.preferred Property</p>
<p>The syntax for specifying the <code class="codeph">jdk.security.provider.preferred</code> property is as follows:</p>
<p><code class="codeph">jdk.security.provider.preferred=AES/GCM/NoPadding:SunJCE, MessageDigest.SHA-256:SUN</code></p>
<div class="p">In this syntax:
<dl>
<dt class="dlterm"><a id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-28C00AE0-A9A6-45AE-A743-823716638A8D"><!-- --></a>ServiceType</dt>
<dd>MessageDigest</dd>
<dt class="dlterm"><a id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-205A4B26-295A-4488-8B2F-5E47C4219023"><!-- --></a>Algorithm</dt>
<dd>AES/GCM/NoPadding, SHA-256</dd>
<dt class="dlterm"><a id="GUID-C3441400-9D82-4545-ADAE-0C332EA4AC58__GUID-05DD7678-1FFD-425E-AE6E-EAFD4619E880"><!-- --></a>Provider</dt>
<dd>SunJCE, SUN</dd>
</dl>
</div>
</div>
<!-- class="example" --></div>
</div>
<div class="sect3"><a id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150"></a>
<h3 id="JSSEC-GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150" class="sect3">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</h3>
<div>
<div class="section">
<p>Whenever a default <code class="codeph">SSLSocketFactory</code> or <code class="codeph">SSLServerSocketFactory</code> is created (via a call to <code class="codeph">SSLSocketFactory.getDefault</code> or <code class="codeph">SSLServerSocketFactory.getDefault</code>), and this default <code class="codeph">SSLSocketFactory</code> (or <code class="codeph">SSLServerSocketFactory</code>) comes from the JSSE reference implementation, a default <code class="codeph">SSLContext</code> is associated with the socket factory. (The default socket factory will come from the JSSE implementation.)</p>
<p>This default <code class="codeph">SSLContext</code> is initialized with a default <code class="codeph">KeyManager</code> and a default <code class="codeph">TrustManager</code>. If a keystore is specified by the <code class="codeph">javax.net.ssl.keyStore</code> system property and an appropriate <code class="codeph">javax.net.ssl.keyStorePassword</code> system property (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">How to Specify a java.lang.System Property</a>), then the <code class="codeph">KeyManager</code> created by the default <code class="codeph">SSLContext</code> will be a <code class="codeph">KeyManager</code> implementation for managing the specified keystore. (The actual implementation will be as specified in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2">Customizing the Default Key Managers and Trust Managers</a>.) If no such system property is specified, then the keystore managed by the <code class="codeph">KeyManager</code> will be a new empty keystore.</p>
<p>Generally, the peer acting as the server in the handshake will need a keystore for its KeyManager in order to obtain credentials for authentication to the client. However, if one of the anonymous cipher suites is selected, then the server's <code class="codeph">KeyManager</code> keystore is not necessary. And, unless the server requires client authentication, the peer acting as the client does not need a <code class="codeph">KeyManager</code> keystore. Thus, in these situations it may be OK if no <code class="codeph">javax.net.ssl.keyStore</code> system property value is defined.</p>
<p>Similarly, if a truststore is specified by the <code class="codeph">javax.net.ssl.trustStore</code> system property, then the <code class="codeph">TrustManager</code> created by the default <code class="codeph">SSLContext</code> will be a <code class="codeph">TrustManager</code> implementation for managing the specified truststore. In this case, if such a property exists but the file it specifies does not, then no truststore is used. If no <code class="codeph">javax.net.ssl.trustStore</code> property exists, then a default truststore is searched for. If a truststore named <code><span class="variable">java-home</span>/lib/security/jssecacerts</code> is found, it is used. If not, then a truststore named <code><span class="variable">java-home</span>/lib/security/cacerts</code> is searched for and used (if it exists). Finally, if a truststore is still not found, then the truststore managed by the <code class="codeph">TrustManager</code> will be a new empty truststore.</p>
<div class="infobox-note" id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__GUID-D83B4C21-5CFE-4043-B74A-0AE5D5EF9F1A">
<p class="notep1">Note:</p>
<p>The JDK ships with a limited number of trusted root certificates in the <code>java-home/lib/security/cacerts</code> file. As documented in <a class="olink JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank" href="../tools/keytool.htm#JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549">keytool</a> in <span id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__JSWOR"><cite>Java Platform, Standard Edition Tools Reference</cite></span>, it is your responsibility to maintain (that is, add and remove) the certificates contained in this file if you use this file as a truststore.</p>
<p>Depending on the certificate configuration of the servers that you contact, you may need to add additional root certificates. Obtain the needed specific root certificates from the appropriate vendor.</p>
</div>
<p>If the <code class="codeph">javax.net.ssl.keyStoreType</code> and/or <code class="codeph">javax.net.ssl.keyStorePassword</code> system properties are also specified, then they are treated as the default <code class="codeph">KeyManager</code> keystore type and password, respectively. If no type is specified, then the default type is that returned by the <code class="codeph">KeyStore.getDefaultType()</code> method, which is the value of the <code class="codeph">keystore.type</code> Security Property, or "jks" if no such Security Property is specified. If no keystore password is specified, then it is assumed to be a blank string "".</p>
<p>Similarly, if the <code class="codeph">javax.net.ssl.trustStoreType</code> and/or <code class="codeph">javax.net.ssl.trustStorePassword</code> system properties are also specified, then they are treated as the default truststore type and password, respectively. If no type is specified, then the default type is that returned by the <code class="codeph">KeyStore.getDefaultType()</code> method. If no truststore password is specified, then it is assumed to be a blank string "".</p>
<div class="infobox-note" id="GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150__GUID-C6D20FF5-6487-4F16-8A53-FC954900DDD1">
<p class="notep1">Note:</p>
This section describes the current JSSE reference implementation behavior. The system properties described in this section are not guaranteed to continue to have the same names and types (system or security) or even to exist at all in future releases. They are also not guaranteed to be examined and used by any other JSSE implementations. If they <span class="variable">are</span> examined by an implementation, then that implementation should handle them in the same manner as the JSSE reference implementation does, as described herein.</div>
</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2"></a>
<h3 id="JSSEC-GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2" class="sect3">Customizing the Default Key Managers and Trust Managers</h3>
<div>
<div class="section">
<p>As noted in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a>, whenever a default <code class="codeph">SSLSocketFactory</code> or <code class="codeph">SSLServerSocketFactory</code> is created, and this default <code class="codeph">SSLSocketFactory</code> (or <code class="codeph">SSLServerSocketFactory</code>) comes from the JSSE reference implementation, a default <code class="codeph">SSLContext</code> is associated with the socket factory.</p>
<p>This default <code class="codeph">SSLContext</code> is initialized with a <code class="codeph">KeyManager</code> and a <code class="codeph">TrustManager</code>. The <code class="codeph">KeyManager</code> and/or <code class="codeph">TrustManager</code> supplied to the default <code class="codeph">SSLContext</code> will be an implementation for managing the specified keystore or truststore, as described in the aforementioned section.</p>
<p>The <code class="codeph">KeyManager</code> implementation chosen is determined by first examining the <code class="codeph">ssl.KeyManagerFactory.algorithm</code> <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-38CC6235-823B-49D7-A566-4BEA1B64C9C6">Security Property</a>. If such a property value is specified, then a <code class="codeph">KeyManagerFactory</code> implementation for the specified algorithm is searched for. The implementation from the first provider that supplies an implementation is used. Its <code class="codeph">getKeyManagers()</code> method is called to determine the <code class="codeph">KeyManager</code> to supply to the default <code class="codeph">SSLContext</code>. Technically, <code class="codeph">getKeyManagers()</code> returns an array of <code class="codeph">KeyManager</code> objects, one <code class="codeph">KeyManager</code> for each type of key material. If no such Security Property value is specified, then the default value of SunX509 is used to perform the search.</p>
<div class="p">
<div class="infobox-note" id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2__GUID-D15B5C94-B4CF-4B9F-8C02-998660542B84">
<p class="notep1">Note:</p>
A <code class="codeph">KeyManagerFactory</code> implementation for the SunX509 algorithm is supplied by the SunJSSE provider. The <code class="codeph">KeyManager</code> that it specifies is a <code class="codeph">javax.net.ssl.X509KeyManager</code> implementation.</div>
</div>
<p>Similarly, the <code class="codeph">TrustManager</code> implementation chosen is determined by first examining the <code class="codeph">ssl.TrustManagerFactory.algorithm</code> Security Property. If such a property value is specified, then a <code class="codeph">TrustManagerFactory</code> implementation for the specified algorithm is searched for. The implementation from the first provider that supplies an implementation is used. Its <code class="codeph">getTrustManagers()</code> method is called to determine the <code class="codeph">TrustManager</code> to supply to the default <code class="codeph">SSLContext</code>. Technically, <code class="codeph">getTrustManagers()</code> returns an array of <code class="codeph">TrustManager</code> objects, one <code class="codeph">TrustManager</code> for each type of trust material. If no such Security Property value is specified, then the default value of PKIX is used to perform the search.</p>
<div class="p">
<div class="infobox-note" id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2__GUID-F1C8A2E0-258D-4164-8DC7-51E303FD09D9">
<p class="notep1">Note:</p>
A <code class="codeph">TrustManagerFactory</code> implementation for the PKIX algorithm is supplied by the SunJSSE provider. The <code class="codeph">TrustManager</code> that it specifies is a <code class="codeph">javax.net.ssl.X509TrustManager</code> implementation.</div>
</div>
<div class="p">
<div class="infobox-note" id="GUID-0ACD9274-607C-49BE-AED9-BEE2B4F2BEF2__GUID-053952E0-5D14-45BF-897A-9C6A561DE975">
<p class="notep1">Note:</p>
This section describes the current JSSE reference implementation behavior. The system properties described in this section are not guaranteed to continue to have the same names and types (system or security) or even to exist at all in future releases. They are also not guaranteed to be examined and used by any other JSSE implementations. If they <span class="variable">are</span> examined by an implementation, then that implementation should handle them in the same manner as the JSSE reference implementation does, as described herein.</div>
</div>
</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-0A438179-32A7-4900-A81C-29E3073E1E90"></a>
<h3 id="JSSEC-GUID-0A438179-32A7-4900-A81C-29E3073E1E90" class="sect3">Disabled and Restricted Cryptographic Algorithms</h3>
<div>
<p>In some environments, certain algorithms or key lengths may be undesirable when using SSL/TLS/DTLS. The Oracle JDK uses the <code class="codeph">jdk.certpath.disabledAlgorithms</code> and <code class="codeph">jdk.tls.disabledAlgorithm</code> Security Properties to disable algorithms during SSL/TLS/DTLS protocol negotiation, including version negotiation, cipher suites selection, peer authentication, and key exchange mechanisms. Note that these Security Properties are not guaranteed to be used by other JDK implementations. See the <code><span class="variable">&lt;java-home&gt;</span>/conf/security/java.security</code> file for information about the syntax of these Security Properties and their current active values.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li>
<p><span class="bold"><code class="codeph">jdk.certpath.disabledAlgorithms</code> Property</span>: <span class="apiname">CertPath</span> code uses the <code class="codeph">jdk.certpath.disabledAlgorithms</code> Security Property to determine which algorithms should not be allowed during <span class="apiname">CertPath</span> checking. For example, when a TLS Server sends an identifying certificate chain, a client <span class="apiname">TrustManager</span> that uses a <span class="apiname">CertPath</span> implementation to verify the received chain will not allow the stated conditions. For example, the following line blocks any MD2-based certificate, as well as SHA1 TLSServer certificates that chain to trust anchors that are pre-installed in the <code>cacaerts</code> keystore. Likewise, this line blocks any RSA key less than 1024 bits.</p>
<pre dir="ltr">
jdk.certpath.disabledAlgorithms=MD2, SHA1 jdkCA &amp; usage TLSServer, RSA keySize &lt; 1024
</pre></li>
<li>
<p><span class="bold"><code class="codeph">jdk.tls.disabledAlgorithms</code> Property</span>: <span class="apiname">SunJSSE</span> code uses the <code class="codeph">jdk.tls.disabledAlgorithms</code> Security Property to disable SSL/TLS/DTLS protocols, cipher suites, keys, and so on. The syntax is similar to the <code class="codeph">jdk.certpath.disabledAlgorithms</code> Security Property. For example, the following line disables the SSLv3 algorithm and all of the TLS_*_RC4_* cipher suites:</p>
<pre dir="ltr">
jdk.tls.disabledAlgorithms=SSLv3, RC4
</pre></li>
</ul>
<p>If you require a particular condition, you can reactivate it by either removing the associated value in the Security Property in the <code>java.security</code> file or dynamically setting the proper Security Property before JSSE is initialized.</p>
<p>Note that these Security Properties effectively create a third set of cipher suites, Disabled. The following list describes these three sets:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Disabled</span>: If a cipher suite contains any components (for example, RC4) on the disabled list (for example, RC4 is specified in the <code class="codeph">jdk.tls.disabledAlgorithms</code> Security Property), then that cipher suite is disabled and will <span class="bold">not</span> be considered for a connection handshake.</p>
</li>
<li>
<p><span class="bold">Enabled</span>: A list of specific cipher suites that will be considered for a connection.</p>
</li>
<li>
<p><span class="bold">Not Enabled</span>: A list of non-disabled cipher suites that will <span class="bold">not</span> be considered for a connection. To re-enable these cipher suites, call the appropriate <span class="apiname">setEnabledCipherSuites()</span> or <span class="apiname">setSSLParameters()</span> methods.</p>
</li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-316FB978-7588-442E-B829-B4973DB3B584"></a>
<h3 id="JSSEC-GUID-316FB978-7588-442E-B829-B4973DB3B584" class="sect3">Customizing the Encryption Algorithm Providers</h3>
<div>
<p>The SunJSSE provider uses the SunJCE implementation for all its cryptographic needs. Although it is recommended that you leave the provider at its regular position, you can use implementations from other JCA or JCE providers by registering them <span class="italic">before</span> the SunJCE provider.</p>
<div class="section">
<p>The standard JCA mechanism (see <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>) can be used to configure providers, either statically via the security properties file <code class="codeph"><span class="variable">&lt;java-home&gt;</span>/conf/security/java.security</code>, or dynamically via the <code class="codeph">addProvider()</code> or <code class="codeph">insertProviderAt()</code> method in the <code class="codeph">java.security.Security</code> class.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D"></a>
<h3 id="JSSEC-GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D" class="sect3">Customizing Size of Ephemeral Diffie-Hellman Keys</h3>
<div>
<p>In SSL/TLS/DTLS connections, ephemeral Diffie-Hellman (DH) keys may be used internally during the handshaking. The SunJSSE provider provides a flexible approach to customize the strength of the ephemeral DH key size during SSL/TLS/DTLS handshaking.</p>
<div class="section">
<p>Diffie-Hellman (DH) keys of sizes less than 1024 bits have been deprecated because of their insufficient strength. You can customize the ephemeral DH key size with the system property <code class="codeph">jdk.tls.ephemeralDHKeySize</code>. This system property does not impact DH key sizes in <code class="codeph">ServerKeyExchange</code> messages for exportable cipher suites. It impacts only the DHE_RSA, DHE_DSS, and DH_anon-based cipher suites in the JSSE Oracle provider.</p>
<p>You can specify one of the following values for this property:</p>
<ul style="list-style-type: disc;">
<li>Undefined: A DH key of size 1024 bits will be used always for non-exportable cipher suites. This is the default value for this property.</li>
<li><code class="codeph">legacy</code>: The JSSE Oracle provider preserves the legacy behavior (for example, using ephemeral DH keys of sizes 512 bits and 768 bits) of JDK 7 and earlier releases.</li>
<li><code class="codeph">matched</code>: For non-exportable anonymous cipher suites, the DH key size in ServerKeyExchange messages is 1024 bits. For X.509 certificate based authentication (of non-exportable cipher suites), the DH key size matching the corresponding authentication key is used, except that the size must be between 1024 bits and 2048 bits. For example, if the public key size of an authentication certificate is 2048 bits, then the ephemeral DH key size should be 2048 bits unless the cipher suite is exportable. This key sizing scheme keeps the cryptographic strength consistent between authentication keys and key-exchange keys.</li>
<li>A valid integer between 1024 and 2048, inclusively: A fixed ephemeral DH key size of the specified value, in bits, will be used for non-exportable cipher suites.</li>
</ul>
<p>The following table summaries the minimum and maximum acceptable DH key sizes for each of the possible values for the system property <code class="codeph">jdk.tls.ephemeralDHKeySize</code>:</p>
<div class="tblformal" id="GUID-D9B216E8-3EFC-4882-B76E-17A87D8F2F9D__GUID-16528793-4333-4BC2-928E-787DFD2C1BA2">
<p class="titleintable">Table 8-9 DH Key Sizes for the System Property <code class="codeph">jdk.tls.ephemeralDHKeySize</code></p>
<table class="cellalignment466" title="DH Key Sizes for the System Property jdk.tls.ephemeralDHKeySize" summary="The table summaries the minimum and maximum acceptable DH key sizes for each of the possible values for the system property jdk.tls.ephemeralDHKeySize.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8017">Value of jdk.tls.ephemeralDHKeySize</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8019">Undefined</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8021">legacy</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8023">matched</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8025">Integer value (fixed)</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8029" headers="d108102e8017">Exportable DH key size</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8029 d108102e8019">512</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8029 d108102e8021">512</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8029 d108102e8023">512</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8029 d108102e8025">512</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8040" headers="d108102e8017">Non-exportable anonymous cipher suites</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8040 d108102e8019">1024</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8040 d108102e8021">768</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8040 d108102e8023">1024</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8040 d108102e8025">The fixed key size is specified by a valid integer property value, which must be between 1024 and 2048, inclusively.</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8051" headers="d108102e8017">Authentication certificate</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8051 d108102e8019">1024</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8051 d108102e8021">768</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8051 d108102e8023">
<p>The key size is the same as the authentication certificate, but must be between 1024 bits and 2048 bits, inclusively. However, the only DH key size that the SunJCE provider supports that is larger than 1024 bits is 2048 bits.</p>
<p>Consequently, you may use the values 1024 or 2048 only.</p>
</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8051 d108102e8025">The fixed key size is specified by a valid integer property value, which must be between 1024 and 2048, inclusively.</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36"></a>
<h3 id="JSSEC-GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36" class="sect3">Customizing Maximum Fragment Length Negotiation (MFLN) Extension</h3>
<div>
<p>In order to negotiate smaller maximum fragment lengths, clients have an option to include an extension of type <code>max_fragment_length</code> in the ClientHello message. A system property <code class="codeph">jsse.enableMFLNExtension</code>, can be used to enable or disable the MFLN extension for SSL/TLS/DTLS.</p>
<div class="section">
<p class="subhead3">Maximum Fragment Length Negotiation</p>
<p>It may be desirable for constrained SSL/TLS/DTLS clients to negotiate a smaller maximum fragment length due to memory limitations or bandwidth limitations. In order to negotiate smaller maximum fragment lengths, clients have an option to include an extension of type <code>max_fragment_length</code> in the (extended) ClientHello message. See <a href="http://www.rfc-base.org/txt/rfc-6066.txt" target="_blank">RFC 6066</a>.</p>
<p>Once a maximum fragment length has been successfully negotiated, the SSL/TLS/DTLS client and server can immediately begin fragmenting messages (including handshake messages) to ensure that no fragment larger than the negotiated length is sent.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">System Property jsse.enableMFLNExtension</p>
<p>A system property <code class="codeph">jsse.enableMFLNExtension</code> is defined to enable or disable the MFLN extension. The <code class="codeph">jsse.enableMFLNExtension</code> is disabled by default.</p>
<p>The value of the system property can be set as follows:</p>
<div class="tblformal" id="GUID-41D5F11E-81BD-4C03-A315-48016D9B9B36__GUID-A6CDBCFE-D1FB-4CF8-84A4-C764B31CB09F">
<p class="titleintable">Table 8-10 jsse.enableMFLNExtension system property</p>
<table class="cellalignment466" title="jsse.enableMFLNExtension system property" summary="List of possible values provided for the jsse.enableMFLNExtension system property.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" id="d108102e8116">System Property</th>
<th class="cellalignment467" id="d108102e8118">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e8122" headers="d108102e8116"><code class="codeph">jsse.enableMFLNExtension</code>=true</td>
<td class="cellalignment456" headers="d108102e8122 d108102e8118">Enable the MFLN extension. If the returned value of <code class="codeph">SSLParameters.getMaximumPacketSize()</code> is less than (2^12 + header-size) the maximum fragment length negotiation extension would be enabled. &nbsp;</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" id="d108102e8132" headers="d108102e8116"><code class="codeph">jsse.enableMFLNExtension</code>=false</td>
<td class="cellalignment456" headers="d108102e8132 d108102e8118">Disable the MFLN extension.</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-3C9ADC85-E82C-421E-808D-F06028838F47"></a>
<h3 id="JSSEC-GUID-3C9ADC85-E82C-421E-808D-F06028838F47" class="sect3">Configuring the Maximum and Minimum Packet Size</h3>
<div>
<div class="section">
<p>Set the maximum expected network packet size in bytes for a SSL/TLS/DTLS record with the <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setMaximumPacketSize-int-" target="_blank"><span class="apiname">SSLParameters.setMaximumPacketSize</span></a> method.</p>
<p>It is recommended that the packet size should not be less than 256 bytes so that small handshake messages, such as HelloVerifyRequests, are not fragmented.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect2"><a id="GUID-9C767872-3A6C-4AD1-9805-49F112A0FA28"></a>
<h2 id="JSSEC-GUID-9C767872-3A6C-4AD1-9805-49F112A0FA28" class="sect2">Transport Layer Security (TLS) Renegotiation Issue</h2>
<div>
<p>In the fall of 2009, a flaw was discovered in the SSL/TLS protocols. A fix to the protocol was developed by the IETF TLS Working Group, and current versions of the JDK contain this fix. This section describes the situation in much more detail, along with interoperability issues when communicating with older implementations that do not contain this protocol fix.</p>
<p>The vulnerability allowed for man-in-the-middle (MITM) attacks where chosen plain text could be injected as a prefix to a TLS connection. This vulnerability did not allow an attacker to decrypt or modify the intercepted network communication once the client and server have successfully negotiated a session between themselves.</p>
<div class="p">Refer to the following links to know more about the SSL/TLS vulnerability:
<ul style="list-style-type: disc;">
<li>
<p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3555" target="_blank">CVE-2009-3555</a> (posted on Mitre's <a href="http://cve.mitre.org/index.html" target="_blank">Common Vulnerabilities and Exposures List</a>, 2009)</p>
</li>
<li>
<p><a href="http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html" target="_blank">Understanding the TLS Renegotiation Attack</a> (posted on Eric Rescorla's blog, <a href="http://www.educatedguesswork.org/" target="_blank">Educated Guesswork</a>, November 5, 2009).</p>
</li>
</ul>
</div>
</div>
<div class="sect3"><a id="GUID-E41EDAB4-D1D7-4224-B3A4-E08D74E9CE04"></a>
<h3 id="JSSEC-GUID-E41EDAB4-D1D7-4224-B3A4-E08D74E9CE04" class="sect3">Phased Approach to Fixing This Issue</h3>
<div>
<p>The fix for this issue was handled in two phases:</p>
<ul style="list-style-type: disc;">
<li>
<p>Phase 1: Until a protocol fix could be developed, an interim fix that disabled SSL/TLS renegotiations by default was made available in the <a href="http://www.oracle.com/technetwork/topics/security/javacpumar2010-083341.html" target="_blank">March 30, 2010 Java SE and Java for Business Critical Patch Update</a>.</p>
</li>
<li>
<p>Phase 2: The <a href="http://www.ietf.org/" target="_blank">IETF</a> issued <a href="http://www.ietf.org/rfc/rfc5746.txt" target="_blank">RFC 5746</a>, which addresses the renegotiation protocol flaw. The following table lists the JDK and JRE releases that include the fix which implements RFC 5746 and supports secure renegotiation.</p>
<div class="tblformalwide" id="GUID-E41EDAB4-D1D7-4224-B3A4-E08D74E9CE04__GUID-4734C38B-9F4B-4041-B47B-61F7A2B6010E">
<p class="titleintable">Table 8-11 JDK and JRE Releases With Fixes to the TLS Renegotiation Issue</p>
<table class="cellalignment484" title="JDK and JRE Releases With Fixes to the TLS Renegotiation Issue" summary="Releases that include the fix which implements RFC 5746 and supports secure renegotiation">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8233">JDK Family</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8235">Vulnerable Releases</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8237">Phase 1 Fix (Disable Renegotiations)</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8239">Phase 2 Fix (RFC 5746)</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8243" headers="d108102e8233">JDK and JRE 6</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8243 d108102e8235">Update 18 and earlier</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8243 d108102e8237">Updates 19 through 21</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8243 d108102e8239">Update 22</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8252" headers="d108102e8233">JDK and JRE 5.0</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8252 d108102e8235">Update 23 and earlier</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8252 d108102e8237">Updates 24 through 25</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8252 d108102e8239">Update 26</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8261" headers="d108102e8233">JDK and JRE 1.4.2</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8261 d108102e8235">Update 25 and earlier</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8261 d108102e8237">Updates 26 through 27</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8261 d108102e8239">Update 28</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></li>
</ul>
<div class="infobox-note" id="GUID-E41EDAB4-D1D7-4224-B3A4-E08D74E9CE04__GUID-D0A74075-A522-4C5D-A5C7-CDE0FA9B2FA6">
<p class="notep1">Note:</p>
Applications that do not require renegotiations are not affected by the Phase 2 default configuration. However applications that require renegotiations (for example, web servers that initially allow for anonymous client browsing, but later require SSL/TLS authenticated clients):
<ul style="list-style-type: disc;">
<li>Are not affected if the peer is also compliant with RFC 5746</li>
<li>Are affected if the peer has not been upgraded to RFC 5746 (see next section for details)</li>
</ul>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-475E6316-283A-4A59-9B11-2479348C4629"></a>
<h3 id="JSSEC-GUID-475E6316-283A-4A59-9B11-2479348C4629" class="sect3">Description of the Phase 2 Fix</h3>
<div>
<p>The SunJSSE implementation reenables renegotiations by default for connections to peers compliant with RFC 5746. That is, both the client and server <span class="bold">must support RFC 5746</span> in order to securely renegotiate. SunJSSE provides some interoperability modes for connections with peers that have not been upgraded, but users are <span class="bold">strongly encouraged to update both their client and server implementations as soon as possible</span>.</p>
<p>With the Phase 2 fix, SunJSSE has three renegotiation interoperability modes. Each mode fully supports the RFC 5746 secure renegotiation, but has these added semantics when communicating with a peer that has not been upgraded:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Strict mode</span>: Requires both client and server be upgraded to RFC 5746 and to send the proper RFC 5746 messages. If not, the initial (or subsequent) handshaking will fail and the connection will be terminated.</p>
</li>
<li>
<p><span class="bold">Interoperable mode (default)</span>: Use of the proper RFC 5746 messages is optional; however, legacy (original SSL/TLS specifications) renegotiations are disabled if the proper messages are not used. Initial legacy connections are still allowed, but legacy renegotiations are disabled. This is the best mix of security and interoperability, and is the default setting.</p>
</li>
<li>
<p><span class="bold">Insecure mode</span>: Permits full legacy renegotiation. Most interoperable with legacy peers but vulnerable to the original MITM attack.</p>
</li>
</ul>
<p>The three mode distinctions only affect a connection with a peer that has not been upgraded. Ideally, strict (full RFC 5746) mode should be used for all clients and servers; however, it will take some time for all deployed SSL/TLS implementations to support RFC 5746, because the interoperable mode is the current default.</p>
<p>The following table contains interoperability information about the modes for various cases in which the client and/or server are either updated to support RFC 5746 or not.</p>
<div class="tblformal" id="GUID-475E6316-283A-4A59-9B11-2479348C4629__GUID-F981C4B4-2215-4468-B05E-FCACEA0948E5">
<p class="titleintable">Table 8-12 Interoperability Information</p>
<table class="cellalignment466" title="Interoperability Information" summary="Interoperability information about the modes for various cases in which the client and/or server are either updated to support RFC 5746 or not.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8331">Client</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8333">Server</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8335">Mode</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8339" headers="d108102e8331">Updated</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8339 d108102e8333">Updated</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8339 d108102e8335">Secure renegotiation in all modes.</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8346" headers="d108102e8331">Legacy<a id="GUID-475E6316-283A-4A59-9B11-2479348C4629__LEGACYMEANSTHEORIGINALSSLTLSSPECIFI-F2073938" href="#GUID-475E6316-283A-4A59-9B11-2479348C4629__LEGACYMEANSTHEORIGINALSSLTLSSPECIFI-F2073938" onclick='footdisplay(5,"\"Legacy\" means the original SSL/TLS specifications (that is, not RFC 5746).")'><sup>Foot&nbsp;5</sup></a></td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8346 d108102e8333">Updated</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8346 d108102e8335">
<ul style="list-style-type: disc;">
<li><span class="bold">Strict</span> If clients do not send the proper RFC 5746 messages, then initial connections will immediately be terminated by the server (<code class="codeph">SSLHandshakeException</code> or <code class="codeph">handshake_failure</code>).</li>
<li><span class="bold">Interoperable</span> Initial connections from legacy clients are allowed (missing RFC 5746 messages), but renegotiations will not be allowed by the server. <a id="GUID-475E6316-283A-4A59-9B11-2479348C4629__FOOTNOTE2SUNJSSEPHASE1IMPLEMENTATIO-66D60E1C" href="#GUID-475E6316-283A-4A59-9B11-2479348C4629__FOOTNOTE2SUNJSSEPHASE1IMPLEMENTATIO-66D60E1C" onclick='footdisplay(6,"SunJSSE Phase 1 implementations reject renegotiations unless specifically reenabled. If renegotiations are reenabled, then they will be treated as \"Legacy\" by the peer that is compliant with RFC 5746, because they do not send the proper RFC 5746 messages.")'><sup>Foot&nbsp;6</sup></a><a id="GUID-475E6316-283A-4A59-9B11-2479348C4629__FN-13310-F207417D" href="#GUID-475E6316-283A-4A59-9B11-2479348C4629__FN-13310-F207417D" onclick='footdisplay(7,"In SSL/TLS, renegotiations can be initiated by either side. Like the Phase 1 fix, applications communicating with a peer that has not been upgraded in Interoperable mode and that attempt to initiate renegotiation (via SSLSocket.startHandshake() or SSLEngine.beginHandshake()) will receive an SSLHandshakeException (IOException) and the connection will be shut down (handshake_failure). Applications that receive a renegotiation request from a peer that has not been upgraded will respond according to the type of connection in place:TLSv1 A warning alert message of type no_renegotiation(100) will be sent to the peer and the connection will remain open. Older versions of SunJSSE will shut down the connection when a no_renegotiation alert is received. SSLv3 The application will receive an SSLHandshakeException, and the connection will be closed (handshake_failure). The no_renegotiation alert is not defined in the SSLv3 specification. ")'><sup>Foot&nbsp;7</sup></a></li>
<li><span class="bold">Insecure</span> Connections and renegotiations with legacy clients are allowed, but are vulnerable to the original MITM attack.</li>
</ul>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8423" headers="d108102e8331">Updated</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8423 d108102e8333">Legacy <a id="fnsrc_d108102e8427" href="#fnsrc_d108102e8427" onclick='footdisplay(5,"\"Legacy\" means the original SSL/TLS specifications (that is, not RFC 5746).")'><sup>Footref&nbsp;5</sup></a></td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8423 d108102e8335">
<ul style="list-style-type: disc;">
<li><span class="bold">Strict</span> If the server does not respond with the proper RFC 5746 messages, then the client will immediately terminate the connection (<code class="codeph">SSLHandshakeException</code> or <code class="codeph">handshake_failure</code>).</li>
<li><span class="bold">Interoperable</span> Initial connections from legacy servers are allowed (missing RFC 5746 messages), but renegotiations will not be allowed by the server. <a id="fnsrc_d108102e8446" href="#fnsrc_d108102e8446" onclick='footdisplay(6,"SunJSSE Phase 1 implementations reject renegotiations unless specifically reenabled. If renegotiations are reenabled, then they will be treated as \"Legacy\" by the peer that is compliant with RFC 5746, because they do not send the proper RFC 5746 messages.")'><sup>Footref&nbsp;6</sup></a><a id="fnsrc_d108102e8448" href="#fnsrc_d108102e8448" onclick='footdisplay(7,"In SSL/TLS, renegotiations can be initiated by either side. Like the Phase 1 fix, applications communicating with a peer that has not been upgraded in Interoperable mode and that attempt to initiate renegotiation (via SSLSocket.startHandshake() or SSLEngine.beginHandshake()) will receive an SSLHandshakeException (IOException) and the connection will be shut down (handshake_failure). Applications that receive a renegotiation request from a peer that has not been upgraded will respond according to the type of connection in place:TLSv1 A warning alert message of type no_renegotiation(100) will be sent to the peer and the connection will remain open. Older versions of SunJSSE will shut down the connection when a no_renegotiation alert is received. SSLv3 The application will receive an SSLHandshakeException, and the connection will be closed (handshake_failure). The no_renegotiation alert is not defined in the SSLv3 specification. ")'><sup>Footref&nbsp;7</sup></a></li>
<li><span class="bold">Insecure</span> Connections and renegotiations with legacy servers are allowed, but are vulnerable to the original MITM attack.</li>
</ul>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8457" headers="d108102e8331">Legacy <a id="fnsrc_d108102e8459" href="#fnsrc_d108102e8459" onclick='footdisplay(5,"\"Legacy\" means the original SSL/TLS specifications (that is, not RFC 5746).")'><sup>Footref&nbsp;5</sup></a></td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8457 d108102e8333">Legacy <a id="fnsrc_d108102e8463" href="#fnsrc_d108102e8463" onclick='footdisplay(5,"\"Legacy\" means the original SSL/TLS specifications (that is, not RFC 5746).")'><sup>Footref&nbsp;5</sup></a></td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8457 d108102e8335">Existing SSL/TLS behavior, vulnerable to the MITM attack.</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;5</sup> "Legacy" means the original SSL/TLS specifications (that is, <span class="italic">not</span> RFC 5746).</p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;6</sup> SunJSSE Phase 1 implementations reject renegotiations unless specifically reenabled. If renegotiations are reenabled, then they will be treated as "Legacy" by the peer that is compliant with RFC 5746, because they do not send the proper RFC 5746 messages.</p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;7</sup> In SSL/TLS, renegotiations can be initiated by either side. Like the Phase 1 fix, applications communicating with a peer that has not been upgraded in Interoperable mode and that attempt to initiate renegotiation (via <code class="codeph">SSLSocket.startHandshake()</code> or <code class="codeph">SSLEngine.beginHandshake()</code>) will receive an <code class="codeph">SSLHandshakeException</code> (<code class="codeph">IOException</code>) and the connection will be shut down (<code class="codeph">handshake_failure</code>). Applications that receive a renegotiation request from a peer that has not been upgraded will respond according to the type of connection in place:</p>
<ul style="list-style-type: disc;">
<li><span class="bold">TLSv1</span> A warning alert message of type <code class="codeph">no_renegotiation(100)</code> will be sent to the peer and the connection will remain open. Older versions of SunJSSE will shut down the connection when a <code class="codeph">no_renegotiation</code> alert is received.</li>
<li><span class="bold">SSLv3</span> The application will receive an <code class="codeph">SSLHandshakeException</code>, and the connection will be closed (<code class="codeph">handshake_failure</code>). The <code class="codeph">no_renegotiation</code> alert is not defined in the SSLv3 specification.</li>
</ul>
<p>Set the mode with the the following system properties (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">How to Specify a java.lang.System Property</a>):</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">sun.security.ssl.allowUnsafeRenegotiation</code> (introduced in Phase 1) controls whether legacy (unsafe) renegotiations are permitted.</li>
<li><code class="codeph">sun.security.ssl.allowLegacyHelloMessages</code> (introduced in Phase 2) allows the peer to perform the handshake process without requiring the proper RFC 5746 messages.</li>
</ul>
<div class="infobox-note" id="GUID-475E6316-283A-4A59-9B11-2479348C4629__GUID-5FBCCBBE-47BB-41D5-A373-488EBFEA62D1">
<p class="notep1">Note:</p>
<p>The system properties <code class="codeph">sun.security.ssl.allowUnsafeRenegotiation</code> and <code class="codeph">sun.security.ssl.allowLegacyHelloMessages</code> are <span>deprecated and might be removed in a future JDK release.</span></p>
</div>
<div class="tblformalwide" id="GUID-475E6316-283A-4A59-9B11-2479348C4629__GUID-A65FA5E7-2EC9-42E6-8B17-32922AB612EE">
<p class="titleintable">Table 8-13 Values of the System Properties for Setting the Interoperability Mode</p>
<table class="cellalignment469" title="Values of the System Properties for Setting the Interoperability Mode" summary="List of values of the system properties for setting the interoperability mode.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8505">Mode</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8507">allowLegacyHelloMessages</th>
<th class="cellalignment467" rowspan="1" colspan="1" id="d108102e8509">allowUnsafeRenegotiation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8513" headers="d108102e8505">Strict</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8513 d108102e8507">false</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8513 d108102e8509">false</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8520" headers="d108102e8505">Interoperable (default)</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8520 d108102e8507">true</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8520 d108102e8509">false</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment456" rowspan="1" colspan="1" id="d108102e8527" headers="d108102e8505">Insecure</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8527 d108102e8507">true</td>
<td class="cellalignment456" rowspan="1" colspan="1" headers="d108102e8527 d108102e8509">true</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<div class="p">
<div class="infobox-note" id="GUID-475E6316-283A-4A59-9B11-2479348C4629__GUID-52D3E6CB-CD6F-4444-950B-9F06417DE474">
<p class="notep1">Caution:</p>
Do not reenable the insecure SSL/TLS renegotiation, as this would reestablish the vulnerability.</div>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-D2B6262D-B052-4757-9087-3CBD61B3CE8A"></a>
<h3 id="JSSEC-GUID-D2B6262D-B052-4757-9087-3CBD61B3CE8A" class="sect3">Workarounds and Alternatives to SSL/TLS Renegotiation</h3>
<div>
<p>All peers should be updated to RFC 5746-compliant implementation as soon as possible. Even with this RFC 5746 fix, communications with peers that have not been upgraded will be affected if a renegotiation is necessary. Here are a few suggested options:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Restructure the peer to not require renegotiation.</span></p>
<p>Renegotiations are typically used by web servers that initially allow for anonymous client browsing but later require SSL/TLS authenticated clients, or that may initially allow weak cipher suites but later need stronger ones. The alternative is to require client authentication or strong cipher suites during the <span class="italic">initial</span> negotiation. There are a couple of options for doing so:</p>
<ul style="list-style-type: disc;">
<li>
<p>If an application has a browse mode until a certain point is reached and a renegotiation is required, then you can restructure the server to eliminate the browse mode and require all initial connections be strong.</p>
</li>
<li>
<p>Break the server into two entities, with the browse mode occurring on one entity, and using a second entity for the more secure mode. When the renegotiation point is reached, transfer any relevant information between the servers.</p>
</li>
</ul>
<p>Both of these options require a fair amount of work, but will not reopen the original security flaw.</p>
</li>
<li>
<p><span class="bold">Set renegotiation interoperability mode to "insecure" using the system properties.</span></p>
<p>See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-475E6316-283A-4A59-9B11-2479348C4629" title="The SunJSSE implementation reenables renegotiations by default for connections to peers compliant with RFC 5746. That is, both the client and server must support RFC 5746 in order to securely renegotiate. SunJSSE provides some interoperability modes for connections with peers that have not been upgraded, but users are strongly encouraged to update both their client and server implementations as soon as possible.">Description of the Phase 2 Fix</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3"><a id="GUID-7CC1B0FD-BDCB-4F56-847D-D4FDDC7F8747"></a>
<h3 id="JSSEC-GUID-7CC1B0FD-BDCB-4F56-847D-D4FDDC7F8747" class="sect3">TLS Implementation Details</h3>
<div>
<p>RFC 5746 defines two new data structures, which are mentioned here for advanced users</p>
<ul style="list-style-type: disc;">
<li>A pseudo-cipher suite called the Signaling Cipher Suite Value (SCSV), "TLS_EMPTY_RENEGOTIATION_INFO_SCSV"</li>
<li>A TLS extension called the Renegotiation Info (RI).</li>
</ul>
<p>Either of these can be used to signal that an implementation is RFC 5746-compliant and can perform secure renegotiations. See <a href="http://www.ietf.org/mail-archive/web/tls/current/maillist.html" target="_blank">IETF email discussion</a> from November 2009 to February 2010.</p>
<p>RFC 5746 enables clients to send either an SCSV or RI in the first <code class="codeph">ClientHello</code>. For maximum interoperability, SunJSSE uses the SCSV by default, as a few TLS/SSL servers do not handle unknown extensions correctly. The presence of the SCSV in the enabled cipher suites (<code class="codeph">SSLSocket.setEnabledCipherSuites()</code> or <code class="codeph">SSLEngine.setEnabledCipherSuites()</code>) determines whether the SCSV is sent in the initial <code class="codeph">ClientHello</code>, or if an RI should be sent instead.</p>
<p>SSLv2 does not support SSL/TLS extensions. If the <code class="codeph">SSLv2Hello</code> protocol is enabled, then the SCSV is sent in the initial <code class="codeph">ClientHello</code>.</p>
</div>
</div>
<div class="sect3"><a id="GUID-67842028-3E8F-49E0-A0C1-63F480408412"></a>
<h3 id="JSSEC-GUID-67842028-3E8F-49E0-A0C1-63F480408412" class="sect3">Description of the Phase 1 Fix</h3>
<div>
<p>As previously mentioned, the Phase 1 Fix was to disable renegotiations by default until a fix compliant with RFC 5746 could be developed. Renegotiations could be reenabled by setting the <code class="codeph">sun.security.ssl.allowUnsafeRenegotiation</code> system property. The Phase 2 fix uses the same <code class="codeph">sun.security.ssl.allowUnsafeRenegotiation</code> system property, but also requires it to use RFC 5746 messages.</p>
<p>All applications should upgrade to the Phase 2 RFC 5746 fix as soon as possible.</p>
<div class="infobox-note" id="GUID-67842028-3E8F-49E0-A0C1-63F480408412__GUID-6C8C7DEF-DDAA-4FDE-BFC0-541D0A1A57D2">
<p class="notep1">Note:</p>
<p>The system properties <code class="codeph">sun.security.ssl.allowUnsafeRenegotiation</code> and <code class="codeph">sun.security.ssl.allowLegacyHelloMessages</code> are <span>deprecated and might be removed in a future JDK release.</span></p>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-9A577D22-9DED-407E-9F16-5C006E3F3BF3"></a>
<h3 id="JSSEC-GUID-9A577D22-9DED-407E-9F16-5C006E3F3BF3" class="sect3">Allow Unsafe Server Certificate Change in SSL/TLS Renegotiations</h3>
<div>
<p>Server certificate change in an SSL/TLS renegotiation may be unsafe:</p>
<ol>
<li>
<p>If endpoint identification is not enabled in an SSL/TLS handshaking; and</p>
</li>
<li>
<p>If the previous handshake is a session-resumption abbreviated initial handshake; and</p>
</li>
<li>
<p>If the identities represented by both certificates can be regarded as different.</p>
</li>
</ol>
<p>Two certificates can be considered to represent the same identity:</p>
<ol>
<li>
<p>If the subject alternative names of IP address are present in both certificates, they should be identical; otherwise,</p>
</li>
<li>
<p>If the subject alternative names of DNS name are present in both certificates, they should be identical; otherwise,</p>
</li>
<li>
<p>If the subject fields are present in both certificates, the certificate subjects and issuers should be identical.</p>
</li>
</ol>
<p>Starting with JDK 8u25, unsafe server certificate change in SSL/TLS renegotiations is not allowed by default. The new system property <code class="codeph">jdk.tls.allowUnsafeServerCertChange,</code> can be used to define whether unsafe server certificate change in an SSL/TLS renegotiation should be restricted or not.</p>
<p>The default value of this system property is "false".</p>
<div class="infobox-note" id="GUID-9A577D22-9DED-407E-9F16-5C006E3F3BF3__GUID-2F2A46F1-D6DE-4859-9354-2EA1DC375881">
<p class="notep1">Caution:</p>
DO NOT set the system property to "true" unless it is really necessary, as this would re-establish the unsafe server certificate change vulnerability.</div>
</div>
</div>
</div>
<div class="sect2"><a id="GUID-3151D7C3-7CE3-41B6-BF65-295B259C63A6"></a>
<h2 id="JSSEC-GUID-3151D7C3-7CE3-41B6-BF65-295B259C63A6" class="sect2">Hardware Acceleration and Smartcard Support</h2>
<div>
<div class="section">
<p>The Java Cryptography Architecture (JCA) is a set of packages that provides a framework and implementations for encryption, key generation and key agreement, and message authentication code (MAC) algorithms. (See <a href="java-cryptography-architecture-jca-reference-guide.htm#GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" title='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>Java Cryptography Architecture (JCA) Reference Guide</a>.) The SunJSSE provider uses JCA exclusively for all of its cryptographic operations and can automatically take advantage of JCE features and enhancements, including JCA's support for RSA <a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-11-cryptographic-token-interface-standard.htm" target="_blank">PKCS#11</a>. This support enables the SunJSSE provider to use hardware cryptographic accelerators for significant performance improvements and to use smartcards as keystores for greater flexibility in key and trust management. .</p>
<p>Use of hardware cryptographic accelerators is automatic if JCA has been configured to use the Oracle PKCS#11 provider, which in turn has been configured to use the underlying accelerator hardware. The provider must be configured before any other JCA providers in the provider list. For details on how to configure the Oracle PKCS#11 provider, see <a href="pkcs11-reference-guide1.htm#GUID-30E98B63-4910-40A1-A6DD-663EAF466991">PKCS#11 Reference Guide</a>.</p>
</div>
<!-- class="section" --></div>
<div class="sect3"><a id="GUID-3412BD4D-9B6F-4FF0-A11C-ABA5945B40AE"></a>
<h3 id="JSSEC-GUID-3412BD4D-9B6F-4FF0-A11C-ABA5945B40AE" class="sect3">Configuring JSSE to Use Smartcards as Keystores and Truststores</h3>
<div>
<p>Support for PKCS#11 in JCA also enables access to smartcards as a keystore. For details on how to configure the type and location of the keystores to be used by JSSE, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" title="JSSE includes a standard implementation that can be customized by plugging in different implementations or specifying the default keystore, and so on.">Customizing JSSE</a>. To use a smartcard as a keystore or truststore, set the <code class="codeph">javax.net.ssl.keyStoreType</code> and <code class="codeph">javax.net.ssl.trustStoreType</code> system properties, respectively, to <code class="codeph">pkcs11</code>, and set the <code class="codeph">javax.net.ssl.keyStore</code> and <code class="codeph">javax.net.ssl.trustStore</code> system properties, respectively, to <code class="codeph">NONE</code>. To specify the use of a specific provider, use the <code class="codeph">javax.net.ssl.keyStoreProvider</code> and <code class="codeph">javax.net.ssl.trustStoreProvider</code> system properties (for example, set them to <code class="codeph">SunPKCS11-joe</code>). By using these properties, you can configure an application that previously depended on these properties to access a file-based keystore to use a smartcard keystore with no changes to the application.</p>
<p>Some applications request the use of keystores programmatically. These applications can continue to use the existing APIs to instantiate a <code class="codeph">Keystore</code> and pass it to its key manager and trust manager. If the <code class="codeph">Keystore</code> instance refers to a PKCS#11 keystore backed by a Smartcard, then the JSSE application will have access to the keys on the smartcard.</p>
</div>
</div>
<div class="sect3"><a id="GUID-C236C41B-54CA-4095-986B-7C62BBC419FB"></a>
<h3 id="JSSEC-GUID-C236C41B-54CA-4095-986B-7C62BBC419FB" class="sect3">Multiple and Dynamic Keystores</h3>
<div>
<p>Smartcards (and other removable tokens) have additional requirements for an <code class="codeph">X509KeyManager</code>. Different smartcards can be present in a smartcard reader during the lifetime of a Java application, and they can be protected using different passwords.</p>
<p>The <a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyStore.Builder.html" target="_blank"><code class="codeph">KeyStore.Builder</code></a> class abstracts the construction and initialization of a <code class="codeph">KeyStore</code> object. It supports the use of <code class="codeph">CallbackHandler</code> for password prompting, and its subclasses can be used to support additional features as desired by an application. For example, it is possible to implement a <code class="codeph">Builder</code> that allows individual <code class="codeph">KeyStore</code> entries to be protected with different passwords. The <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/KeyStoreBuilderParameters.html" target="_blank"><code class="codeph">KeyStoreBuilderParameters</code></a> class then can be used to initialize a <code class="codeph">KeyManagerFactory</code> using one or more of these <code class="codeph">Builder</code> objects.</p>
<p>A <code class="codeph">X509KeyManager</code> implementation in the SunJSSE provider called NewSunX509 supports these parameters. If multiple certificates are available, it attempts to pick a certificate with the appropriate key usage and prefers valid to expired certificates.</p>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C236C41B-54CA-4095-986B-7C62BBC419FB__IMPORTJAVAX.NET.SSL.IMPORTJAVA.SECU-6B0B77DA">Example 8-17</a> illustrates how to tell JSSE to use both a PKCS#11 keystore (which might in turn use a smartcard) and a PKCS#12 file-based keystore.</p>
<div class="example" id="GUID-C236C41B-54CA-4095-986B-7C62BBC419FB__IMPORTJAVAX.NET.SSL.IMPORTJAVA.SECU-6B0B77DA">
<p class="titleinexample">Example 8-17 Sample Code to Use PKCS#11 and PKCS#12 File-based Keystore</p>
<pre class="codeblock" dir="ltr">
import javax.net.ssl.*;
import java.security.KeyStore.*;
// ...

// Specify keystore builder parameters for PKCS#11 keystores
Builder scBuilder = Builder.newInstance("PKCS11", null,
    new CallbackHandlerProtection(myGuiCallbackHandler));

// Specify keystore builder parameters for a specific PKCS#12 keystore
Builder fsBuilder = Builder.newInstance("PKCS12", null,
    new File(pkcsFileName), new PasswordProtection(pkcsKsPassword));

// Wrap them as key manager parameters
ManagerFactoryParameters ksParams = new KeyStoreBuilderParameters(
    Arrays.asList(new Builder[] { scBuilder, fsBuilder }) );

// Create KeyManagerFactory
KeyManagerFactory factory = KeyManagerFactory.getInstance("NewSunX509");

// Pass builder parameters to factory
factory.init(ksParams);

// Use factory
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(factory.getKeyManagers(), null, null);
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<div class="sect2"><a id="GUID-67227445-EE66-4F33-BEED-535C548BCC73"></a>
<h2 id="JSSEC-GUID-67227445-EE66-4F33-BEED-535C548BCC73" class="sect2">Kerberos Cipher Suites</h2>
<div>
<div class="p">The SunJSSE provider has support for Kerberos cipher suites, as described in <a href="http://www.ietf.org/rfc/rfc2712.txt" target="_blank">RFC 2712</a>. The following cipher suites are supported but not enabled by default:
<div class="infobox-note" id="GUID-67227445-EE66-4F33-BEED-535C548BCC73__GUID-A953A5B9-1424-47E2-AFF0-3D08183C0634">
<p class="notep1">Note:</p>
According to <a href="http://tools.ietf.org/html/rfc4347" target="_blank">DTLS Version 1.0</a> and <a href="http://tools.ietf.org/html/rfc6347" target="_blank">DTLS Version 1.2</a>, RC4 cipher suites must not be used with DTLS.</div>
</div>
<ul style="list-style-type: disc;">
<li>TLS_KRB5_WITH_RC4_128_SHA</li>
<li>TLS_KRB5_WITH_RC4_128_MD5</li>
<li>TLS_KRB5_WITH_3DES_EDE_CBC_SHA</li>
<li>TLS_KRB5_WITH_3DES_EDE_CBC_MD5</li>
<li>TLS_KRB5_WITH_DES_CBC_SHA</li>
<li>TLS_KRB5_WITH_DES_CBC_MD5</li>
<li>TLS_KRB5_EXPORT_WITH_RC4_40_SHA</li>
<li>TLS_KRB5_EXPORT_WITH_RC4_40_MD5</li>
<li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA</li>
<li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5</li>
</ul>
<p>To enable the use of these cipher suites, you must do so explicitly. See the API documentation for <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-" target="_blank"><code class="codeph">SSLEngine.setEnabledCipherSuites(String[])</code></a> and <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledCipherSuites(String[])</code></a> methods. As with all other SSL/TLS/DTLS cipher suites, if a cipher suite is not supported by the peer, then it will not be selected during cipher negotiation. Furthermore, if the application and/or server cannot acquire the necessary Kerberos credentials, then the Kerberos cipher suites also will not be selected.</p>
<p>The following is an example of a TLS client that will only use the <code class="codeph">TLS_KRB5_WITH_DES_CBC_SHA</code> cipher suite:</p>
<pre class="codeblock" dir="ltr">
// Create socket
SSLSocketFactory sslsf = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket sslSocket = (SSLSocket) sslsf.createSocket(tlsServer, serverPort);

// Enable only one cipher suite
String enabledSuites[] = { "TLS_KRB5_WITH_DES_CBC_SHA" };
sslSocket.setEnabledCipherSuites(enabledSuites);
</pre></div>
<div class="sect3"><a id="GUID-2CEBB012-B3E0-44FB-B935-8A95E184AF84"></a>
<h3 id="JSSEC-GUID-2CEBB012-B3E0-44FB-B935-8A95E184AF84" class="sect3">Kerberos Requirements</h3>
<div>
<p>You must have the Kerberos infrastructure set up in your deployment environment before you can use the Kerberos cipher suites with JSSE. In particular, both the TLS client and server must have accounts set up with the Kerberos Key Distribution Center (KDC). At runtime, if one or more of the Kerberos cipher suites have been enabled, then the TLS client and server will acquire their Kerberos credentials associated with their respective account from the KDC. For example, a TLS server running on the machine <code class="codeph">mach1.imc.org</code> in the Kerberos realm <code class="codeph">IMC.ORG</code> must have an account with the name <code class="codeph">host/mach1.imc.org@IMC.ORG</code> and be configured to use the KDC for <code class="codeph">IMC.ORG</code>. See <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/KerberosReq.html" target="_blank">Kerberos Requirements</a>.</p>
<p>An application can acquire its Kerberos credentials by using the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/JAASRefGuide.html" target="_blank">Java Authentication and Authorization Service (JAAS) Reference Guide</a> and a Kerberos login module. The JDK comes with a <a href="https://docs.oracle.com/javase/10/docs/api/com/sun/security/auth/module/Krb5LoginModule.html" target="_blank"><span class="apiname">Krb5LoginModule</span></a>. You can use the Kerberos cipher suites with JSSE with or without JAAS programming, similar to how you can use the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/BasicClientServer.html" target="_blank">JAAS and Java GSS-API Tutorial</a> with or without JAAS programming.</p>
<p>To use the Kerberos cipher suites with JSSE without JAAS programming, you must use the index names <code class="codeph">com.sun.net.ssl.server</code> or <code class="codeph">other</code> for the TLS server JAAS configuration entry, and <code class="codeph">com.sun.net.ssl.client</code> or <code class="codeph">other</code> for the TLS client, and set the <code class="codeph">javax.security.auth.useSubjectCredsOnly</code> system property to false. For example, a TLS server that is not using JAAS programming might have the following JAAS configuration file:</p>
<pre class="codeblock" dir="ltr">
com.sun.net.ssl.server {
  com.sun.security.auth.module.Krb5LoginModule required
    principal="host/mach1.imc.org@IMC.ORG"
    useKeyTab=true
    keyTab=mach1.keytab
    storeKey=true;
};
</pre>
<p>An example of how to use Java GSS and Kerberos without JAAS programming is described in the tutorial <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/BasicClientServer.html" target="_blank">Use of Java GSS-API for Secure Message Exchanges Without JAAS Programming</a> in the JDK 8 documentation. You can adapt it to use JSSE by replacing Java GSS calls with JSSE calls.</p>
<p>To use the Kerberos cipher suites with JAAS programming, you can use any index name because your application is responsible for creating the JAAS <code class="codeph">LoginContext</code> using the index name, and then wrapping the JSSE calls inside of a <code class="codeph">Subject.doAs()</code> or <code class="codeph">Subject.doAsPrivileged()</code> call. An example of how to use JAAS with Java GSS and Kerberos is described in the tutorial <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/ClientServer.html" target="_blank">Use of JAAS Login Utility and Java GSS-API for Secure Message Exchange</a> in the JDK 8 documentation. You can adapt it to use JSSE by replacing Java GSS calls with JSSE calls.</p>
<p>If you have trouble using or configuring the JSSE application to use Kerberos, see <a href="troubleshooting.htm#GUID-2087ADBA-6C36-43D5-8841-C79FCB4F5FBE">Troubleshooting</a> in <a href="introduction-jaas-and-java-gss-api-tutorials1.htm">Introduction to JAAS and Java GSS-API Tutorials</a>.</p>
</div>
</div>
<div class="sect3"><a id="GUID-3D49787E-4D31-4D65-8FFE-CE19B6CAD3E2"></a>
<h3 id="JSSEC-GUID-3D49787E-4D31-4D65-8FFE-CE19B6CAD3E2" class="sect3">Peer Identity Information</h3>
<div>
<p>To determine the identity of the peer of an SSL/TLS/DTLS connection, use the <code class="codeph">getPeerPrincipal()</code> method in the following classes:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">javax.net.ssl.SSLSession</code></li>
<li><code class="codeph">javax.net.ssl.HttpsURLConnection</code></li>
<li><code class="codeph">javax.net.HandshakeCompletedEvent</code></li>
</ul>
<p>Similarly, to get the identity that was sent to the peer (to identify the local entity), use the <code class="codeph">getLocalPrincipal()</code> method in these classes. For X509-based cipher suites, these methods will return an instance of <code class="codeph">javax.security.auth.x500.X500Principal</code>; for Kerberos cipher suites, these methods will return an instance of <code class="codeph">javax.security.auth.kerberos.KerberosPrincipal</code>.</p>
<p>JSSE applications use <code class="codeph">getPeerCertificates()</code> and similar methods in <code class="codeph">javax.net.ssl.SSLSession</code>, <code class="codeph">javax.net.ssl.HttpsURLConnection</code>, and <code class="codeph">javax.net.HandshakeCompletedEvent</code> classes to obtain information about the peer. When the peer does not have any certificates, <code class="codeph">SSLPeerUnverifiedException</code> is thrown.</p>
<p>If the application must determine only the identity of the peer or identity sent to the peer, then it should use the <code class="codeph">getPeerPrincipal()</code> and <code class="codeph">getLocalPrincipal()</code> methods, respectively. It should use <code class="codeph">getPeerCertificates()</code> and <code class="codeph">getLocalCertificates()</code> methods only if it must examine the contents of those certificates. Furthermore, the application must be prepared to handle the case where an authenticated peer might not have any certificate.</p>
</div>
</div>
<div class="sect3"><a id="GUID-B583D760-8D38-4B3F-94FA-66E63AFCE1D1"></a>
<h3 id="JSSEC-GUID-B583D760-8D38-4B3F-94FA-66E63AFCE1D1" class="sect3">Security Manager</h3>
<div>
<p>When the security manager has been enabled, in addition to the <code class="codeph">SocketPermission</code> needed to communicate with the peer, a TLS client application that uses the Kerberos cipher suites also needs the following permission:</p>
<pre class="codeblock" dir="ltr">
javax.security.auth.kerberos.ServicePermission(<span class="variable">serverPrincipal</span>, "initiate");
</pre>
<p>Where,</p>
<dl>
<dt class="dlterm"><a id="GUID-B583D760-8D38-4B3F-94FA-66E63AFCE1D1__GUID-7ACB5C9F-BD18-47F8-AD59-CB37742F880F"><!-- --></a><span class="variable">serverPrincipal</span></dt>
<dd>Indicates the Kerberos principal name of the TLS server that the TLS client will be communicating with (such as <code class="codeph">host/mach1.imc.org@IMC.ORG</code>).</dd>
</dl>
<p>A TLS server application needs the following permission:</p>
<pre class="codeblock" dir="ltr">
javax.security.auth.kerberos.ServicePermission(<span class="variable">serverPrincipal</span>, "accept");
</pre>
<p>Where,</p>
<dl>
<dt class="dlterm"><a id="GUID-B583D760-8D38-4B3F-94FA-66E63AFCE1D1__GUID-94BF5580-BBC5-45C3-AF32-5BFBA7B55261"><!-- --></a><span class="variable">serverPrincipal</span></dt>
<dd>Indicates the Kerberos principal name of the TLS server (such as <code class="codeph">host/mach1.imc.org@IMC.ORG</code>).</dd>
</dl>
<p>If the server or client must contact the KDC (for example, if its credentials are not cached locally), then it also needs the following permission:</p>
<pre class="codeblock" dir="ltr">
javax.security.auth.kerberos.ServicePermission(<span class="variable">tgtPrincipal</span>, "initiate");
</pre>
<p>Where,</p>
<dl>
<dt class="dlterm"><a id="GUID-B583D760-8D38-4B3F-94FA-66E63AFCE1D1__GUID-CDD53994-5190-4630-A507-9F194840954E"><!-- --></a><span class="italic">tgtPrincipal</span></dt>
<dd>Indicates the principal name of the KDC (such as <code class="codeph">krbtgt/IMC.ORG@IMC.ORG</code>).</dd>
</dl>
</div>
</div>
</div>
<div class="sect2"><a id="GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF"></a>
<h2 id="JSSEC-GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF" class="sect2">Additional Keystore Formats (PKCS12)</h2>
<div>
<p>The <a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs12-personal-information-exchange-syntax-standard.htm" target="_blank">PKCS#12 (Personal Information Exchange Syntax Standard)</a> specifies a portable format for storage and/or transport of a user's private keys, certificates, miscellaneous secrets, and other items. The SunJSSE provider supplies a complete implementation of the PKCS12 <code class="codeph">java.security.KeyStore</code> format for reading and writing PKCS12 files. This format is also supported by other toolkits and applications for importing and exporting keys and certificates, such as Mozilla Firefox, Microsoft Internet Explorer, and OpenSSL. For example, these implementations can export client certificates and keys into a file using the .p12 file name extension.</p>
<p>With the SunJSSE provider, you can access PKCS12 keys through the <code class="codeph">KeyStore</code> API with a keystore type of PKCS12. In addition, you can list the installed keys and associated certificates by using the <code class="codeph">keytool</code> command with the <code class="codeph">-storetype</code> option set to <code class="codeph">pkcs12</code>. See <a class="olink JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank" href="../tools/keytool.htm#JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549">keytool</a> in <span id="GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF__JSWOR"><cite>Java Platform, Standard Edition Tools Reference</cite></span>.</p>
</div>
</div>
<div class="sect2"><a id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F"></a>
<h2 id="JSSEC-GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F" class="sect2">Server Name Indication (SNI) Extension</h2>
<div>
<p>The SNI extension is a feature that extends the SSL/TLS/DTLS protocols to indicate what server name the client is attempting to connect to during handshaking. Servers can use server name indication information to decide if specific <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> instances should accept a connection. For example, when multiple virtual or name-based servers are hosted on a single underlying network address, the server application can use SNI information to determine whether this server is the exact server that the client wants to access. Instances of this class can be used by a server to verify the acceptable server names of a particular type, such as host names. See section 3 of <a href="http://www.ietf.org/rfc/rfc6066.txt" target="_blank">TLS Extensions (RFC 6066)</a>.</p>
<p>Developers of client applications can explicitly set the server name indication using the <code class="codeph">SSLParameters.setServerNames(List&lt;SNIServerName&gt; serverNames)</code> method. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-B5160B29-A377-41C0-A60D-4A3E0C89CCAF">Example 8-18</a>.</p>
<p>Developers of server applications can use the <code class="codeph">SNIMatcher</code> class to decide how to recognize server name indication. <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-6EACE6B2-E1A4-4A8B-82B1-7C122495CF0D">Example 8-19</a> and <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-E25CEBA5-2D07-484C-82EB-D280E32F7D08">Example 8-20</a> illustrate this functionality:</p>
<div class="example" id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-B5160B29-A377-41C0-A60D-4A3E0C89CCAF">
<p class="titleinexample">Example 8-18 Sample Code to Set the Server Name Indication</p>
<p>The following code sample illustrates how to set the server name indication using the method <span class="apiname">SSLParameters.setServerNames(List&lt;SNIServerName&gt; serverNames)</span>:</p>
<pre dir="ltr">
SSLSocketFactory factory = ...
SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
// SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

SNIHostName serverName = new SNIHostName("www.example.com");
List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
serverNames.add(serverName);

SSLParameters params = sslSocket.getSSLParameters();
params.setServerNames(serverNames);
sslSocket.setSSLParameters(params);
// sslEngine.setSSLParameters(params);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-6EACE6B2-E1A4-4A8B-82B1-7C122495CF0D">
<p class="titleinexample">Example 8-19 Sample Code Using SSLSocket Class to Recognize SNI</p>
<p>The following code sample illustrates how the server applications can use the <code class="codeph">SNIMatcher</code> class to decide how to recognize server name indication:</p>
<pre class="codeblock" dir="ltr">
SSLSocket sslSocket = sslServerSocket.accept();

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslSocket.setSSLParameters(params);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F__GUID-E25CEBA5-2D07-484C-82EB-D280E32F7D08">
<p class="titleinexample">Example 8-20 Sample Code Using SSLServerSocket Class to Recognize SNI</p>
<p>The following code sample illustrates how the server applications can use the <code class="codeph">SNIMatcher</code> class to decide how to recognize server name indication:</p>
<pre class="codeblock" dir="ltr">
 
SSLServerSocket sslServerSocket = ...;

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslServerSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslServerSocket.setSSLParameters(params);

SSLSocket sslSocket = sslServerSocket.accept();
</pre></div>
<!-- class="example" -->
<div class="section">
<p>The following list provides examples for the behavior of the <code class="codeph">SNIMatcher</code> when receiving various server name indication requests in the ClientHello message:</p>
<ul style="list-style-type: disc;">
<li>
<p>Matcher configured to <code class="codeph">www\\.example\\.com</code>:</p>
<ul style="list-style-type: disc;">
<li>If the requested host name is <code class="codeph">www.example.com</code>, then it will be accepted and a confirmation will be sent in the ServerHello message.</li>
<li>If the requested host name is <code class="codeph">www.example.org</code>, then it will be rejected with an <code class="codeph">unrecognized_name</code> fatal error.</li>
<li>If there is no requested host name or it is empty, then the request will be accepted but no confirmation will be sent in the ServerHello message.</li>
</ul>
</li>
<li>
<p>Matcher configured to <code class="codeph">www\\.invalid\\.com</code>:</p>
<ul style="list-style-type: disc;">
<li>If the requested host name is <code class="codeph">www.example.com</code>, then it will be rejected with an <code class="codeph">unrecognized_name</code> fatal error.</li>
<li>If the requested host name is <code class="codeph">www.example.org</code>, then it will be accepted and a confirmation will be sent in the ServerHello message.</li>
<li>If there is no requested host name or it is empty, then the request will be accepted but no confirmation will be sent in the ServerHello message.</li>
</ul>
</li>
<li>
<p>Matcher is not configured:</p>
<p>Any requested host name will be accepted but no confirmation will be sent in the ServerHello message.</p>
</li>
</ul>
<p>For descriptions of new classes that implement the SNI extension, see:</p>
<ul style="list-style-type: disc;">
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-651B5070-F586-4504-A6CD-8BEB2D928D47" title="The StandardConstants class is used to represent standard constants definitions in JSSE.">The StandardConstants Class</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-ADD484B7-244A-4FBC-AEF0-96873890CD6B">The SNIServerName Class</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-073F0493-3DB8-4388-818B-83E92021EF45">The SNIMatcher Class</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-E10158C4-E808-41B7-9958-A119927743D8">The SNIHostName Class</a></li>
</ul>
<p>For examples, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-63945B45-E909-483F-B3A9-E26586737383">Using the Server Name Indication (SNI) Extension</a>.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect2"><a id="GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3"></a>
<h2 id="JSSEC-GUID-DC583ED6-06AD-435C-BC9C-763F4642B2B3" class="sect2">TLS Application Layer Protocol Negotiation</h2>
<div>
<p>Negotiate an application protocol for a TLS connection with Application Layer Protocol Negotiation (ALPN).</p>
<div class="section">
<p class="subhead2">What is ALPN?</p>
<p>Some applications might want or need to negotiate a shared application level value before a TLS handshake has completed. For example, HTTP/2 uses the Application Layer Protocol Negotiation mechanism to help establish which HTTP version ("h2", "spdy/3", "http/1.1") can or will be used on a particular TCP or UDP port. ALPN (<a href="https://www.rfc-editor.org/rfc/rfc7301.txt" target="_blank">RFC 7301</a>) does this without adding network round-trips between the client and the server. In the case of HTTP/2 the protocol must be established before the connection is negotiated, as client and server need to know what version of HTTP to use before they start communicating. Without ALPN it would not be possible to have application protocols HTTP/1 and HTTP/2 on the same port.</p>
<p>The client uses the ALPN extension at the beginning of the TLS handshake to send a list of supported application protocols to the server as part of the <code class="codeph">ClientHello</code>. The server reads the list of supported application protocols in the <code class="codeph">ClientHello</code>, and determines which of the supported protocols it prefers. It then sends a <code class="codeph">ServerHello</code> message back to the client with the negotiation result. The message may contain either the name of the protocol that has been chosen or that no protocol has been chosen.</p>
<p>The application protocol negotiation can thus be accomplished within the TLS handshake, without adding network round-trips, and allows the server to associate a different certificate with each application protocol, if desired.</p>
<p>Unlike many other TLS extensions, this extension does not establish properties of the session, only of the connection. That's why you'll find the negotiated values in the <code class="codeph">SSLSocket</code>/<code class="codeph">SSLEngine</code>, not the <code class="codeph">SSLSession</code>. When session resumption or session tickets are used (see <a href="http://www.rfc-editor.org/rfc/rfc5077.txt" target="_blank">TLS Session Resumption without Server-Side State</a>), the previously negotiated values are irrelevant, and only the values in the new handshake messages are considered.</p>
</div>
<!-- class="section" --></div>
<div class="sect3"><a id="GUID-CBFA212F-C726-4D58-A520-A4BE147D1290"></a>
<h3 id="JSSEC-GUID-CBFA212F-C726-4D58-A520-A4BE147D1290" class="sect3">Setting up ALPN on the Client</h3>
<div>
<p>Set the Application Layer Protocol Negotiation (ALPN) values supported by the client. During the handshake with the server, the server will read the client&rsquo;s list of application protocols and will determine which is most suitable.</p>
<div class="section">
<p>For the client, use the <code class="codeph">SSLParameters.setApplicationProtocols(String[])</code> method, followed by the <code class="codeph">setSSLParameters</code> method of either <code class="codeph">SSLSocket</code> or <code class="codeph">SSLEngine</code> to set up the application protocols to send to the server.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-CBFA212F-C726-4D58-A520-A4BE147D1290__GUID-B3161CAE-62B4-48EE-A432-163199F08491">
<p class="titleinexample">Example 8-21 Sample Code for Setting and Getting ALPN Values in a Java Client</p>
<p>For example, here are the steps to set ALPN values of <code class="codeph">"three"</code> and <code class="codeph">"two"</code>, on the client.</p>
<p>To run the code the property <code class="codeph">javax.net.ssl.trustStore</code> must be set to a valid root certificate. (This can be done on the command line).</p>
<pre dir="ltr">
import java.io.*; 
import java.util.*;
import javax.net.ssl.*; 
public class SSLClient {
    public static void main(String[] args) throws Exception {

        // Code for creating a client side SSLSocket
        SSLSocketFactory sslsf = (SSLSocketFactory) SSLSocketFactory.getDefault();
        SSLSocket sslSocket = (SSLSocket) sslsf.createSocket("localhost", 9999);

        // Get an SSLParameters object from the SSLSocket
        SSLParameters sslp = sslSocket.getSSLParameters();

        // Populate SSLParameters with the ALPN values
        // On the client side the order doesn't matter as
        // when connecting to a JDK server, the server's list takes priority
        String[] clientAPs = {"three", "two"};
        sslp.setApplicationProtocols(clientAPs);

        // Populate the SSLSocket object with the SSLParameters object
        // containing the ALPN values
        sslSocket.setSSLParameters(sslp);

        sslSocket.startHandshake();

        // After the handshake, get the application protocol that has been negotiated
        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol client side: \"" + ap + "\"");

        // Do simple write/read
        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslOS.write(280);
        sslOS.flush();
        sslIS.read();
        sslSocket.close();
    }
}
</pre>
<div class="p">When this code is run and sends a <code class="codeph">ClientHello</code> to a Java server that has set the ALPN values <code class="codeph">one</code>, <code class="codeph">two</code>, and <code class="codeph">three</code>, the output will be:
<pre dir="ltr">
Application Protocol client side: two
</pre>
See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7FCC21CB-158B-440C-B5E4-E4E5A2D7352B">The SSL Handshake</a> for further details on handshaking. It is also possible to check the results of the negotiation during handshaking. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" title="To determine the ALPN value that has been negotiated during the handshaking, create a custom KeyManager or TrustManager class, and include in this custom class a call to the getHandshakeApplicationProtocol method.">Determining Negotiated ALPN Value during Handshaking</a>.</div>
</div>
<!-- class="example" --></div>
</div>
<div class="sect3"><a id="GUID-59618539-24AD-431E-84E3-585C4C4BF4E5"></a>
<h3 id="JSSEC-GUID-59618539-24AD-431E-84E3-585C4C4BF4E5" class="sect3">Setting up Default ALPN on the Server</h3>
<div>
<p>Use the default ALPN mechanism to determine a suitable application protocol by setting ALPN values on the server.</p>
<div class="section">To use the default mechanism for ALPN on the server, populate an <code class="codeph">SSLParameters</code> object with the ALPN values you wish to set, and then use this <code class="codeph">SSLParameters</code> object to populate either the <code class="codeph">SSLSocket</code> object or the <code class="codeph">SSLEngine</code> object with these parameters as you have done when you set up ALPN on the client (see the section <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-CBFA212F-C726-4D58-A520-A4BE147D1290" title="Set the Application Layer Protocol Negotiation (ALPN) values supported by the client. During the handshake with the server, the server will read the client&rsquo;s list of application protocols and will determine which is most suitable.">Setting up ALPN on the Client</a>). The first value of the ALPN values set on the server that matches any of the ALPN values contained in the <code class="codeph">ClientHello</code> will be chosen and returned to the client as part of the <code class="codeph">ServerHello</code>.</div>
<!-- class="section" -->
<div class="example" id="GUID-59618539-24AD-431E-84E3-585C4C4BF4E5__GUID-DE951D27-9578-429C-84F8-DED2C5A91DD3">
<p class="titleinexample">Example 8-22 Sample Code for Default ALPN Value Negotiation on the Server</p>
<p>Here is the code for a Java server that uses the default approach for protocol negotiation. To run the code the property <code class="codeph">javax.net.ssl.keyStore</code> must be set to a valid keystore. (This can be done on the command line, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" title="The procedure as to how you can use the keytool utility to create a simple PKCS12 keystore suitable for use with JSSE.">Creating a Keystore to Use with JSSE</a>).</p>
<pre dir="ltr">
import java.util.*; 
import javax.net.ssl.*; 
public class SSLServer {
    public static void main(String[] args) throws Exception {

        // Code for creating a server side SSLSocket
        SSLServerSocketFactory sslssf = 
            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
        SSLServerSocket sslServerSocket = 
            (SSLServerSocket) sslssf.createServerSocket(9999);
        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();

        // Get an SSLParameters object from the SSLSocket
        SSLParameters sslp = sslSocket.getSSLParameters();

        // Populate SSLParameters with the ALPN values
        // As this is server side, put them in order of preference
        String[] serverAPs ={ "one", "two", "three" };
        sslp.setApplicationProtocols(serverAPs);

        // If necessary at any time, get the ALPN values set on the 
        // SSLParameters object with:
        // String serverAPs = sslp.setApplicationProtocols();

        // Populate the SSLSocket object with the ALPN values
        sslSocket.setSSLParameters(sslp);

        sslSocket.startHandshake();

        // After the handshake, get the application protocol that 
        // has been negotiated

        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol server side: \"" + ap + "\"");

        // Continue with the work of the server
        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslIS.read();
        sslOS.write(85);
        sslOS.flush();
        sslSocket.close();
    }
}
</pre>
<div class="p">When this code is run and a Java client sends a <code class="codeph">ClientHello</code> with ALPN values <code class="codeph">three</code> and <code class="codeph">two</code>, the output is:
<pre dir="ltr">
Application Protocol server side: two
</pre>
See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7FCC21CB-158B-440C-B5E4-E4E5A2D7352B">The SSL Handshake</a> for further details on handshaking. It is also possible to check the results of the negotiation during handshaking. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" title="To determine the ALPN value that has been negotiated during the handshaking, create a custom KeyManager or TrustManager class, and include in this custom class a call to the getHandshakeApplicationProtocol method.">Determining Negotiated ALPN Value during Handshaking</a>.</div>
</div>
<!-- class="example" --></div>
</div>
<div class="sect3"><a id="GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8"></a>
<h3 id="JSSEC-GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8" class="sect3">Setting up Custom ALPN on the Server</h3>
<div>
<p>Use the custom ALPN mechanism to determine a suitable application protocol by setting up a callback method.</p>
<div class="section">
<p>If you do not want to use the server&rsquo;s default negotiation protocol, you can use the <code class="codeph">setHandshakeApplicationProtocolSelector</code> method of <code class="codeph">SSLEngine</code> or <code class="codeph">SSLSocket</code> to register a <code class="codeph">BiFunction</code> (lambda) callback that can examine the handshake state so far, and then make your selection based on the client&rsquo;s list of application protocols and any other relevant information. For example, you may consider using the cipher suite suggested, or the Server Name Indication (SNI) or any other data you can obtain in making the choice. If custom negotiation is used, the values set by the <code class="codeph">setApplicationProtocols</code> method (default negotiation) will be ignored.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8__GUID-DE951D27-9578-429C-84F8-DED2C5A91DD3">
<p class="titleinexample">Example 8-23 Sample Code for Custom ALPN Value Negotiation on the Server</p>
<p>Here is the code for a Java server that uses the custom mechanism for protocol negotiation. To run the code the property <code class="codeph">javax.net.ssl.keyStore</code> must be set to a valid certificate. (This can be done on the command line, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" title="The procedure as to how you can use the keytool utility to create a simple PKCS12 keystore suitable for use with JSSE.">Creating a Keystore to Use with JSSE</a>).</p>
<pre dir="ltr">
import java.util.*; 
import javax.net.ssl.*; 
public class SSLServer {
    public static void main(String[] args) throws Exception {

        // Code for creating a server side SSLSocket
        SSLServerSocketFactory sslssf =
            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
        SSLServerSocket sslServerSocket = 
            (SSLServerSocket) sslssf.createServerSocket(9999);
        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();

        // Code to set up a callback function
        // Pass in the current SSLSocket to be inspected and client AP values
        sslSocket.setHandshakeApplicationProtocolSelector(
            (serverSocket, clientProtocols) -&gt; {
                SSLSession handshakeSession = serverSocket.getHandshakeSession();
                // callback function called with current SSLSocket and client AP values
                // plus any other useful information to help determine appropriate
                // application protocol. Here the protocol and ciphersuite are also
                // passed to the callback function.
                return chooseApplicationProtocol(
                    serverSocket,
                    clientProtocols,
                    handshakeSession.getProtocol(),
                    handshakeSession.getCipherSuite());
         }); 

        sslSocket.startHandshake();

        // After the handshake, get the application protocol that has been
        // returned from the callback method.

        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol server side: \"" + ap + "\"");

        // Continue with the work of the server
        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslIS.read();
        sslOS.write(85);
        sslOS.flush();
        sslSocket.close();
    }

    // The callback method. Note how the parameters match the call within 
    // the setHandshakeApplicationProtocolSelector method above.
    public static String chooseApplicationProtocol(SSLSocket serverSocket,
            List&lt;String&gt; clientProtocols, String protocol, String cipherSuite ) {
        // For example, check the cipher suite and return an application protocol
        // value based on that.
        if (cipherSuite.equals("&lt;--a_particular_ciphersuite--&gt;")) { 
            return "three";
        } else {
            return "";
        }
    } 
}
</pre>
<p>If the cipher suite matches the one you specify in the condition statement when this code is run , then the value <code class="codeph">three</code> will be returned. Otherwise an empty string will be returned.</p>
<p>Note that the <code class="codeph">BiFunction</code> object&rsquo;s return value is a <code class="codeph">String</code>, which will be the application protocol name, or null to indicate that none of the advertised names are acceptable. If the return value is an empty&nbsp;<code class="codeph">String</code>&nbsp;then application protocol indications will not be used. If the return value is null (no value chosen) or is a value that was not advertised by the peer, the underlying protocol will determine what action to take. (For example, the server code will send a "no_application_protocol" alert and terminate the connection.)</p>
<p>After handshaking completes on both client and server, you can check the result of the negotiation by calling the <code class="codeph">getApplicationProtocol</code> method on either the <code class="codeph">SSLSocket</code> object or the <code class="codeph">SSLEngine</code> object. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7FCC21CB-158B-440C-B5E4-E4E5A2D7352B">The SSL Handshake</a> for further details on handshaking.</p>
</div>
<!-- class="example" --></div>
</div>
<div class="sect3"><a id="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9"></a>
<h3 id="JSSEC-GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" class="sect3">Determining Negotiated ALPN Value during Handshaking</h3>
<div>
<p>To determine the ALPN value that has been negotiated during the handshaking, create a custom <code class="codeph">KeyManager</code> or <code class="codeph">TrustManager</code> class, and include in this custom class a call to the <code class="codeph">getHandshakeApplicationProtocol</code> method.</p>
<div class="section">
<p>There are some use cases where the selected ALPN and SNI values will affect the choices made by a <code class="codeph">KeyManager</code> or <code class="codeph">TrustManager</code>. For example, an application might want to select different certificate/private key sets depending on the attributes of the server and the chosen ALPN/SNI/ciphersuite values.</p>
<p>The sample code given illustrates how to call the <code class="codeph">getHandshakeApplicationProtocol</code> method from within a custom <code class="codeph">X509ExtendedKeyManager</code> that you create and register as the <code class="codeph">KeyManager</code> object.</p>
</div>
<!-- class="section" -->
<div class="example" id="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9__GUID-57D815A8-4BF8-4F9F-9735-9240C4E6D718">
<p class="titleinexample">Example 8-24 Sample Code for a Custom KeyManager</p>
<p>This example shows the entire code for a custom <code class="codeph">KeyManager</code> that extends <code class="codeph">X509ExtendedKeyManager</code>. Most methods simply return the value returned from the <code class="codeph">KeyManager</code> class that is being wrapped by this <code class="codeph">MyX509ExtendedKeyManager</code> class. However the <code class="codeph">chooseServerAlias</code> method calls the <code class="codeph">getHandshakeApplicationProtocol</code> on the <code class="codeph">SSLSocket</code> object and therefore can determine the current negotiated ALPN value.</p>
<pre dir="ltr">

import java.net.Socket;
import java.security.*;
import javax.net.ssl.*;

public class MyX509ExtendedKeyManager extends X509ExtendedKeyManager {

    // X509ExtendedKeyManager is an abstract class so your new class 
    // needs to implement all the abstract methods in this class. 
    // The easiest way to do this is to wrap an existing KeyManager
    // and call its methods for each of the methods you need to implement.   

    X509ExtendedKeyManager akm;
    
    public MyX509ExtendedKeyManager(X509ExtendedKeyManager akm) {
        this.akm = akm;
    }

    @Override
    public String[] getClientAliases(String keyType, Principal[] issuers) {
        return akm.getClientAliases(keyType, issuers);
    }

    @Override
    public String chooseClientAlias(String[] keyType, Principal[] issuers, 
        Socket socket) {
        return akm.chooseClientAlias(keyType, issuers, socket);
    }

    @Override
    public String chooseServerAlias(String keyType, Principal[] issuers, 
        Socket socket) {
        
        // This method has access to a Socket, so it is possible to call the
        // getHandshakeApplicationProtocol method here. Note the cast from 
        // a Socket to an SSLSocket
        String ap = ((SSLSocket) socket).getHandshakeApplicationProtocol();
        System.out.println("In chooseServerAlias, ap is: " + ap);
        return akm.chooseServerAlias(keyType, issuers, socket);
    }

    @Override
    public String[] getServerAliases(String keyType, Principal[] issuers) {
        return akm.getServerAliases(keyType, issuers);
    }

    @Override
    public X509Certificate[] getCertificateChain(String alias) {
        return akm.getCertificateChain(alias);
    }

    @Override
    public PrivateKey getPrivateKey(String alias) {
        return akm.getPrivateKey(alias);
    }
}
</pre>
<div class="p">When this code is registered as the <code class="codeph">KeyManager</code> for a Java server and a Java client sends a <code class="codeph">ClientHello</code> with ALPN values, the output will be:
<pre dir="ltr">
    In chooseServerAlias, ap is: &lt;negotiated value&gt;
</pre></div>
</div>
<!-- class="example" -->
<div class="example" id="GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9__GUID-264BBD9E-71BA-412C-AA77-EF0EC265D42B">
<p class="titleinexample">Example 8-25 Sample Code for Using a Custom KeyManager in a Java Server</p>
<p>This example shows a simple Java server that uses the default ALPN negotiation strategy and the custom <code class="codeph">KeyManager</code>, <code class="codeph">MyX509ExtendedKeyManager</code>, shown in the prior code sample.</p>
<pre dir="ltr">
import java.io.*;
import java.util.*;
import javax.net.ssl.*;
import java.security.KeyStore;

public class SSLServerHandshake {
    
    public static void main(String[] args) throws Exception {
        SSLContext ctx = SSLContext.getInstance("TLS");

        // You need to explicitly create a create a custom KeyManager

        // Keystores
        KeyStore keyKS = KeyStore.getInstance("PKCS12");
        keyKS.load(new FileInputStream("serverCert.p12"), 
            "password".toCharArray());

        // Generate KeyManager
        KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
        kmf.init(keyKS, "password".toCharArray());
        KeyManager[] kms = kmf.getKeyManagers();

        // Code to substitute MyX509ExtendedKeyManager
        if (!(kms[0] instanceof X509ExtendedKeyManager)) {
            throw new Exception("kms[0] not X509ExtendedKeyManager");
        }

        // Create a new KeyManager array and set the first index 
        // of the array to an instance of MyX509ExtendedKeyManager.
        // Notice how creating this object is done by passing in the 
        // existing default X509ExtendedKeyManager 
        kms = new KeyManager[] { 
            new MyX509ExtendedKeyManager((X509ExtendedKeyManager) kms[0])};

        // Initialize SSLContext using the new KeyManager
        ctx.init(kms, null, null);

        // Instead of using SSLServerSocketFactory.getDefault(), 
        // get a SSLServerSocketFactory based on the SSLContext
        SSLServerSocketFactory sslssf = ctx.getServerSocketFactory();
        SSLServerSocket sslServerSocket = 
            (SSLServerSocket) sslssf.createServerSocket(9999);
        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();
        SSLParameters sslp = sslSocket.getSSLParameters();
        String[] serverAPs ={"one","two","three"};
        sslp.setApplicationProtocols(serverAPs);
        sslSocket.setSSLParameters(sslp);
        sslSocket.startHandshake();

        String ap = sslSocket.getApplicationProtocol();
        System.out.println("Application Protocol server side: \"" + ap + "\"");

        InputStream sslIS = sslSocket.getInputStream();
        OutputStream sslOS = sslSocket.getOutputStream();
        sslIS.read();
        sslOS.write(85);
        sslOS.flush();

        sslSocket.close();
        sslServerSocket.close();
    }
}
</pre>
<p>With the custom <code class="codeph">X509ExtendedKeyManager</code> in place, when <code class="codeph">chooseServerAlias</code> is called during handshaking the <code class="codeph">KeyManager</code> has the opportunity to examine the negotiated application protocol value. In the case of the example shown, this value is output to the console.</p>
<div class="p">For example, when this code is run and a Java client sends a <code class="codeph">ClientHello</code> with ALPN values <code class="codeph">three</code> and <code class="codeph">two</code>, the output will be:
<pre dir="ltr">
Application Protocol server side: two
</pre></div>
</div>
<!-- class="example" --></div>
</div>
<div class="sect3"><a id="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742"></a>
<h3 id="JSSEC-GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742" class="sect3">ALPN Related Classes and Methods</h3>
<div>
<p>These classes and methods are used when working with Application Layer Protocol Negotiation (ALPN).</p>
<div class="section">
<p class="subhead3">Classes and Methods to Use</p>
<p><code class="codeph">SSLEngine</code> and <code class="codeph">SSLSocket</code> contain the same ALPN related methods and they have the same functionality.</p>
<div class="tblformalwide" id="GUID-6D774DB6-FD5C-4066-B144-C1F10E2DD742__GUID-FE0C995B-14C9-493B-8716-D66B3FDD990A">
<table class="cellalignment469" summary="These methods enable the setting and getting of ALPN values.">
<thead>
<tr class="cellalignment456">
<th class="cellalignment471" id="d108102e9779">Class</th>
<th class="cellalignment482" id="d108102e9781">Method</th>
<th class="cellalignment482" id="d108102e9783">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment476" id="d108102e9787" headers="d108102e9779"><code class="codeph">SSLParameters</code></td>
<td class="cellalignment483" headers="d108102e9787 d108102e9781"><code class="codeph">public String[] getApplicationProtocols();</code></td>
<td class="cellalignment483" headers="d108102e9787 d108102e9783"><span class="bold">Client-side and server-side</span>: use the method to return a <code class="codeph">String</code> array containing each protocol set.</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment476" id="d108102e9801" headers="d108102e9779"><code class="codeph">SSLParameters</code></td>
<td class="cellalignment483" headers="d108102e9801 d108102e9781"><code class="codeph">public void setApplicationProtocols([]&nbsp;protocols);</code></td>
<td class="cellalignment483" headers="d108102e9801 d108102e9783">
<p><span class="bold">Client-side</span>: use the method to set the protocols that can be chosen by the server.</p>
<p><span class="bold">Server-side</span>: use the method to set the protocols that the server can use. The String array should contain the protocols in order of preference.</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment476" id="d108102e9817" headers="d108102e9779"><code class="codeph">SSLEngine</code>
<p><code class="codeph">SSLSocket</code></p>
</td>
<td class="cellalignment483" headers="d108102e9817 d108102e9781"><code class="codeph">public String getApplicationProtocol();</code></td>
<td class="cellalignment483" headers="d108102e9817 d108102e9783"><span class="bold">Client-side and server-side</span>: use the method <span class="italic">after</span> TLS protocol negotiation has completed to return a <code class="codeph">String</code> containing the protocol that has been chosen for the connection.</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment476" id="d108102e9837" headers="d108102e9779"><code class="codeph">SSLEngine</code>
<p><code class="codeph">SSLSocket</code></p>
</td>
<td class="cellalignment483" headers="d108102e9837 d108102e9781"><code class="codeph">public String getHandshakeApplicationProtocol();</code></td>
<td class="cellalignment483" headers="d108102e9837 d108102e9783"><span class="bold">Client-side and server-side</span>: use the method <span class="italic">during</span> handshaking to return a <code class="codeph">String</code> containing the protocol that has been chosen for the connection. If this method is called before or after handshaking, it will return null. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-BB4A54B3-FBC2-4B32-91CA-A16F91467ED9" title="To determine the ALPN value that has been negotiated during the handshaking, create a custom KeyManager or TrustManager class, and include in this custom class a call to the getHandshakeApplicationProtocol method.">Determining Negotiated ALPN Value during Handshaking</a> for instructions on how to call this method.</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment476" id="d108102e9873" headers="d108102e9779"><code class="codeph">SSLEngine</code>
<p><code class="codeph">SSLSocket</code></p>
</td>
<td class="cellalignment483" headers="d108102e9873 d108102e9781"><code class="codeph">public void setHandshakeApplicationProtocolSelector(BiFunction,String&gt; selector)</code></td>
<td class="cellalignment483" headers="d108102e9873 d108102e9783"><span class="bold">Server-side</span>: use the method to register a callback function. The application protocol value can then be set in the callback based on any information available, for example the protocol or cipher suite. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-B17DF013-83BD-4A00-BF91-D9E1E0BE70D8" title="Use the custom ALPN mechanism to determine a suitable application protocol by setting up a callback method.">Setting up Custom ALPN on the Server</a> for instructions on how to use this method.</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect2"><a id="GUID-D8F6E432-12F2-47B8-9FD0-CE57A4A4F2E1"></a>
<h2 id="JSSEC-GUID-D8F6E432-12F2-47B8-9FD0-CE57A4A4F2E1" class="sect2">Troubleshooting JSSE</h2>
<div>
<p>This section contains information for troubleshooting JSSE. It provides solutions to common configuration problem.</p>
<p>First, it provides some common <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D" title="Solutions to some common configuration problems.">Configuration Problems</a> and ways to solve them, and then it describes helpful <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF">Debugging Utilities</a>.</p>
</div>
<div class="sect3"><a id="GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D"></a>
<h3 id="JSSEC-GUID-E8E3C6C4-5B7E-466F-B11C-35BF3B9F454D" class="sect3">Configuration Problems</h3>
<div>
<p>Solutions to some common configuration problems.</p>
</div>
<div class="sect4"><a id="GUID-E87F514E-A7E8-4E79-90DE-D375FF64A908"></a>
<h4 id="JSSEC-GUID-E87F514E-A7E8-4E79-90DE-D375FF64A908" class="sect4">CertificateException While Handshaking</h4>
<div>
<p><span class="bold">Problem:</span> When negotiating an SSL/TLS/DTLS connection, the client or server throws a <code class="codeph">CertificateException</code>.</p>
<p><span class="bold">Cause 1:</span> This is generally caused by the remote side sending a certificate that is unknown to the local side.</p>
<p><span class="bold">Solution 1:</span> The best way to debug this type of problem is to turn on debugging (see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF">Debugging Utilities</a>) and watch as certificates are loaded and when certificates are received via the network connection. Most likely, the received certificate is unknown to the trust mechanism because the wrong trust file was loaded.</p>
<p>Refer to the following sections:</p>
<ul style="list-style-type: disc;">
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC">JSSE Classes and Interfaces</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-42CA1099-42AD-4772-BC4A-29C2A78E3EC9" title="The primary responsibility of the TrustManager is to determine whether the presented authentication credentials should be trusted. If the credentials are not trusted, then the connection will be terminated. To authenticate the remote identity of a secure socket peer, you must initialize an SSLContext object with one or more TrustManager objects. You must pass one TrustManager for each authentication mechanism that is supported. If null is passed into the SSLContext initialization, then a trust manager will be created for you. Typically, a single trust manager supports authentication based on X.509 public key certificates (for example, X509TrustManager). Some secure socket implementations may also support authentication based on shared secret keys, Kerberos, or other mechanisms.">The TrustManager Interface</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-997AB098-DDD7-40E2-9FD0-5AA3C83E1702">The KeyManager Interface</a></li>
</ul>
<p><span class="bold">Cause 2:</span> The system clock is not set correctly. In this case, the perceived time may be outside the validity period on one of the certificates, and unless the certificate can be replaced with a valid one from a truststore, the system must assume that the certificate is invalid, and therefore throw the exception.</p>
<p><span class="bold">Solution 2:</span> Correct the system clock time.</p>
</div>
</div>
<div class="sect4"><a id="GUID-48170215-4EF1-4653-B58F-81572E9FE23F"></a>
<h4 id="JSSEC-GUID-48170215-4EF1-4653-B58F-81572E9FE23F" class="sect4">Runtime Exception: SSL Service Not Available</h4>
<div>
<div class="section">
<p><span class="bold">Problem:</span> When running a program that uses JSSE, an exception occurs indicating that an SSL service is not available. For example, an exception similar to one of the following is thrown:</p>
<pre class="codeblock" dir="ltr">
    Exception in thread "main" java.net.SocketException:
        no SSL Server Sockets
    
    Exception in thread "main":
        SSL implementation not available
</pre>
<p><span class="bold">Cause:</span> There was a problem with <code class="codeph">SSLContext</code> initialization, for example, due to an incorrect password on a keystore or a corrupted keystore (a JDK vendor once shipped a keystore in an unknown format, and that caused this type of error).</p>
<p><span class="bold">Solution:</span> Check initialization parameters. Ensure that any keystores specified are valid and that the passwords specified are correct. One way that you can check this is by trying to use <code class="codeph">keytool</code> to examine the keystores and the relevant contents. See <a class="olink JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank" href="../tools/keytool.htm#JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549">keytool</a> in <span id="GUID-48170215-4EF1-4653-B58F-81572E9FE23F__JSWOR"><cite>Java Platform, Standard Edition Tools Reference</cite></span>.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-92715704-80F4-431A-BF99-D583EE61C4AB"></a>
<h4 id="JSSEC-GUID-92715704-80F4-431A-BF99-D583EE61C4AB" class="sect4">Runtime Exception: "No available certificate corresponding to the SSL cipher suites which are enabled"</h4>
<div>
<div class="section">
<p><span class="bold">Problem:</span> When trying to run a simple SSL server program, the following exception is thrown:</p>
<pre class="codeblock" dir="ltr">
    Exception in thread "main" javax.net.ssl.SSLException:
        No available certificate corresponding to the SSL cipher suites which are enabled...
</pre>
<p><span class="bold">Cause:</span> Various cipher suites require certain types of key material. For example, if an RSA cipher suite is enabled, then an RSA <code class="codeph">keyEntry</code> must be available in the keystore. If no such key is available, then this cipher suite cannot be used. This exception is thrown if there are no available key entries for all of the cipher suites enabled.</p>
<p><span class="bold">Solution:</span> Create key entries for the various cipher suite types, or use an anonymous suite. Anonymous cipher suites are inherently dangerous because they are vulnerable to MITM (man-in-the-middle) attacks. See <a href="http://www.ietf.org/rfc/rfc2246.txt?number=2246" target="_blank">RFC 2246</a>.</p>
<p>Refer to the following sections to learn how to pass the correct keystore and certificates:</p>
<ul style="list-style-type: disc;">
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-B7AB25FA-7F0C-4EFA-A827-813B2CE7FBDC">JSSE Classes and Interfaces</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-7D9F43B8-AABF-4C5B-93E6-3AFB18B66150">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-93EBE6F4-1460-450A-8D9C-AF086C233BDF">Additional Keystore Formats (PKCS12)</a></li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-1409C7FD-0E15-4367-93F5-EB327099D8B5"></a>
<h4 id="JSSEC-GUID-1409C7FD-0E15-4367-93F5-EB327099D8B5" class="sect4">Runtime Exception: No Cipher Suites in Common</h4>
<div>
<div class="section">
<p><span class="bold">Problem 1:</span> When handshaking, the client and/or server throw this exception.</p>
<p><span class="bold">Cause 1:</span> Both sides of an SSL connection must agree on a common cipher suite. If the intersection of the client's cipher suite set with the server's cipher suite set is empty, then you will see this exception.</p>
<p><span class="bold">Solution 1:</span> Configure the enabled cipher suites to include common cipher suites, and be sure to provide an appropriate <code class="codeph">keyEntry</code> for asymmetric cipher suites. Also see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-92715704-80F4-431A-BF99-D583EE61C4AB">Runtime Exception: "No available certificate corresponding to the SSL cipher suites which are enabled"</a> in this section.)</p>
<p><span class="bold">Problem 2:</span> When using Mozilla Firefox or Microsoft Internet Explorer to access files on a server that only has DSA-based certificates, a runtime exception occurs indicating that there are no cipher suites in common.</p>
<p><span class="bold">Cause 2:</span> By default, <code class="codeph">keyEntries</code> created with <code class="codeph">keytool</code> use DSA public keys. If only DSA <code class="codeph">keyEntries</code> exist in the keystore, then only DSA-based cipher suites can be used. By default, Navigator and Internet Explorer send only RSA-based cipher suites. Because the intersection of client and server cipher suite sets is empty, this exception is thrown.</p>
<p><span class="bold">Solution 2:</span> To interact with Navigator or Internet Explorer, you should create certificates that use RSA-based keys. To do this, specify the <code class="codeph">-keyalg</code> RSA option when using keytool. For example:</p>
<pre class="codeblock" dir="ltr">
keytool -genkeypair -alias duke -keystore testkeys -keyalg rsa
</pre></div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7"></a>
<h4 id="JSSEC-GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7" class="sect4">Socket Disconnected After Sending ClientHello Message</h4>
<div>
<div class="section">
<p><span class="bold">Problem:</span> A socket attempts to connect, sends a ClientHello message, and is immediately disconnected.</p>
<p><span class="bold">Cause:</span> Some SSL/TLS servers will disconnect if a ClientHello message is received in a format they do not understand or with a protocol version number that they do not support.</p>
<p><span class="bold">Solution</span>: Try adjusting the enabled protocols on the client side. This involves modifying or invoking some of the following system properties and methods:</p>
<ul style="list-style-type: disc;">
<li>System property <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__HTTPS.PROTOCOLS_PROPERTY"><code class="codeph">https.protocols</code></a> for the <code class="codeph"><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/HttpsURLConnection.html" target="_blank"><code class="codeph">HttpsURLConnection</code></a></code> class</li>
<li>System property <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9__JDK.TLS.CLIENT.PROTOCOLS_PROPERTY"><span class="apiname">jdk.tls.client.protocols</span></a></li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLContext.html#getInstance-java.lang.String-" target="_blank"><code class="codeph">SSLContext.getInstance</code></a> method</li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLEngine.setEnabledProtocols</code></a> method</li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setEnabledProtocols</code></a> method</li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLParameters.setProtocols</code></a> and <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLEngine.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLEngine.setSSLParameters</code></a> methods</li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLParameters.setProtocols</code></a> and <a href="https://docs.oracle.com/javase/10/docs/api/javax/net/ssl/SSLSocket.html#setProtocols-java.lang.String:A-" target="_blank"><code class="codeph">SSLSocket.setSSLParameters</code></a> methods</li>
</ul>
<p>For backwards compatibility, some SSL/TLS implementations (such as SunJSSE) can send SSL/TLS ClientHello messages encapsulated in the SSLv2 ClientHello format. The SunJSSE provider supports this feature. If you want to use this feature, add the "SSLv2Hello" protocol to the enabled protocol list, if necessary. (See Protocols in the <a href="oracle-providers.htm#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers</a>, which lists the protocols that are enabled by default for the SunJSSE provider.)</p>
<p>The SSL/TLS RFC standards require that implementations negotiate to the latest version both sides speak, but some non-conforming implementation simply hang up if presented with a version they don't understand. For example, some older server implementations that speak only SSLv3 will shutdown if TLSv1.2 is requested. In this situation, consider using a SSL/TLS version fallback scheme:</p>
<ol>
<li>Fall back from TLSv1.2 to TLSv1.1 if the server does not understand TLSv1.2.</li>
<li>Fall back from TLSv1.1 to TLSv1.0 if the previous step does not work.</li>
</ol>
<p>For example, if the enabled protocol list on the client is TLSv1, TLSv1.1, and TLSv1.2, a typical SSL/TLS version fallback scheme may look like:</p>
<ol>
<li>Try to connect to server. If server rejects the SSL/TLS connection request immediately, go to step 2.</li>
<li>Try the version fallback scheme by removing the highest protocol version (for example, TLSv1.2 for the first failure) in the enabled protocol list.</li>
<li>Try to connect to the server again. If server rejects the connection, go to step 2 unless there is no version to which the server can fall back.</li>
<li>If the connection fails and SSLv2Hello is not on the enabled protocol list, restore the enable protocol list and enable SSLv2Hello. (For example, the enable protocol list should be SSLv2Hello, TLSv1, TLSv1.1, and TLSv1.2.) Start again from step 1.</li>
</ol>
<div class="p">
<div class="infobox-note" id="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7__GUID-879D0C74-6202-47A4-A56F-1A971ABD230D">
<p class="notep1">Note:</p>
A fallback to a previous version normally means security strength downgrading to a weaker protocol. It is not suggested to use a fallback scheme unless it is really necessary, and you clearly know that the server does not support a higher protocol version.</div>
</div>
<div class="infobox-note" id="GUID-B20D551B-9558-43C5-94D8-BF5464C8F2B7__GUID-FF293B29-F33E-41EF-909A-6350B9D35E23">
<p class="notep1">Note:</p>
As part of disabling SSLv3, some servers have also disabled SSLv2Hello, which means communications with SSLv2Hello-active clients (JDK 6u95) will fail. Starting with JDK 7, SSLv2Hello default to disabled on clients, enabled on servers.</div>
</div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-85667451-803E-4E07-B366-00E19790595B"></a>
<h4 id="JSSEC-GUID-85667451-803E-4E07-B366-00E19790595B" class="sect4">SunJSSE Cannot Find a JCA Provider That Supports a Required Algorithm and Causes a NoSuchAlgorithmException</h4>
<div>
<div class="section">
<p><span class="bold">Problem:</span> A handshake is attempted and fails when it cannot find a required algorithm. Examples might include:</p>
<pre class="codeblock" dir="ltr">
Exception in thread ...deleted...
    ...deleted...
    Caused by java.security.NoSuchAlgorithmException: Cannot find any
        provider supporting RSA/ECB/PKCS1Padding
</pre>
<p>or</p>
<pre class="codeblock" dir="ltr">
Caused by java.security.NoSuchAlgorithmException: Cannot find any
    provider supporting AES/CBC/NoPadding
</pre>
<p><span class="bold">Cause:</span> SunJSSE uses JCE for all its cryptographic algorithms. If the SunJCE provider has been deregistered from the <code class="codeph">Provider</code> mechanism and an alternative implementation from JCE is not available, then this exception will be thrown.</p>
<p><span class="bold">Solution:</span> Ensure that the SunJCE is available by checking that the provider is registered with the <code class="codeph">Provider</code> interface. Try to run the following code in the context of your SSL connection:</p>
<pre class="codeblock" dir="ltr">
import javax.crypto.*;

System.out.println("=====Where did you get AES=====");
Cipher c = Cipher.getInstance("AES/CBC/NoPadding");
System.out.println(c.getProvider());
</pre></div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-BEA0A351-848D-4E0E-9B96-48B27FDED1BA"></a>
<h4 id="JSSEC-GUID-BEA0A351-848D-4E0E-9B96-48B27FDED1BA" class="sect4">FailedDownloadException Thrown When Trying to Obtain Application Resources from Web Server over SSL</h4>
<div>
<div class="section">
<p><span class="bold">Problem:</span> If you receive a <code class="codeph">com.sun.deploy.net.FailedDownloadException</code> when trying to obtain application resources from your web server over SSL, and your web server uses the virtual host with Server Name Indication (SNI) extension (such as Apache HTTP Server), then you may have not configured your web server correctly.</p>
<p><span class="bold">Cause:</span> Because Java SE 7 supports the SNI extension in the JSSE client, the requested host name of the virtual server is included in the first message sent from the client to the server during the SSL handshake. The server may deny the client's request for a connection if the requested host name (the server name indication) does not match the expected server name, which should be specified in the virtual host's configuration. This triggers an SSL handshake unrecognized name alert, which results in a <code class="codeph">FailedDownloadException</code> being thrown.</p>
<p><span class="bold">Solution:</span> To better diagnose the problem, enable tracing through the Java Console. See <a class="olink JSDPG-GUID-11D4AE7F-84C4-4D2D-9665-2D3929BB4387" target="_blank" href="../deploy/java-control-panel.htm#JSDPG-GUID-11D4AE7F-84C4-4D2D-9665-2D3929BB4387">Debugging</a> and <a class="olink JSDPG-GUID-8B1B0E20-8550-4A11-8327-297C06134D48" target="_blank" href="../deploy/java-control-panel.htm#JSDPG-GUID-8B1B0E20-8550-4A11-8327-297C06134D48">Java Console</a> in <span id="GUID-BEA0A351-848D-4E0E-9B96-48B27FDED1BA__JSDAP"><cite>Java Platform, Standard Edition Deployment Guide</cite></span>. If the cause of the problem is <code class="codeph">javax.net.ssl.SSLProtocolException: handshake alert: unrecognized_name</code>, it is likely that the virtual host configuration for SNI is incorrect. If you are using Apache HTTP Server, see <a href="https://httpd.apache.org/docs/trunk/vhosts/name-based.html" target="_blank">Name-based Virtual Host Support</a> about configuring virtual hosts. In particular, ensure that the <code class="codeph">ServerName</code> directive is configured properly in a <code class="codeph">&lt;VirtualHost&gt;</code> block.</p>
<p>See the following:</p>
<ul style="list-style-type: disc;">
<li><a href="https://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI" target="_blank">SSL with Virtual Hosts Using SNI</a> from <a href="https://wiki.apache.org/httpd/FrontPage" target="_blank">Apache HTTP Server Wiki</a></li>
<li><a href="https://httpd.apache.org/docs/trunk/ssl/ssl_faq.html" target="_blank">SSL/TLS Strong Encryption: FAQ</a> from <a href="https://httpd.apache.org/docs/" target="_blank">Apache HTTP Server Documentation</a></li>
<li><a href="https://www.ietf.org/rfc/rfc3546.txt" target="_blank">RFC 3546, Transport Layer Security (TLS) Extensions</a></li>
<li><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7194590" target="_blank">Bug 7194590: SSL handshaking error caused by virtual server misconfiguration</a></li>
</ul>
</div>
<!-- class="section" --></div>
</div>
<div class="sect4"><a id="GUID-001B7524-87A4-4085-B8EF-929E0503DBEC"></a>
<h4 id="JSSEC-GUID-001B7524-87A4-4085-B8EF-929E0503DBEC" class="sect4">IllegalArgumentException When RC4 Cipher Suites are Configured for DTLS</h4>
<div>
<div class="section">
<p><span class="bold">Problem:</span> An <code class="codeph">IllegalArgumentException</code> exception is thrown when RC4 cipher suite algorithm is specified in <code class="codeph">SSLEngine.setEnabledCipherSuites(String[] suites)</code> method and the <span class="apiname">SSLEngine</span> is a DTLS engine.</p>
<pre class="codeblock" dir="ltr">
sslContext = SSLContext.getInstance("DTLS");

// Create the engine
SSLEngine engine = sslContext.createSSLengine(hostname, port);

String enabledSuites[] = { "SSL_RSA_WITH_RC4_128_SHA" };
engine.setEnabledCipherSuites(enabledSuites);
</pre>
<p><span class="bold">Cause:</span> According to <a href="http://tools.ietf.org/html/rfc4347" target="_blank">DTLS Version 1.0</a> and <a href="http://tools.ietf.org/html/rfc6347" target="_blank">DTLS Version 1.2</a>, RC4 cipher suites must not be used with DTLS.</p>
<p><span class="bold">Solution:</span> Do not use RC4 based cipher suites for DTLS connections. See <span class="q">"JSSE Cipher Suite Names"</span> in <a href="https://docs.oracle.com/javase/10/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names Specification</a>.</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<div class="sect3"><a id="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF"></a>
<h3 id="JSSEC-GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF" class="sect3">Debugging Utilities</h3>
<div>
<div class="section">
<p>JSSE provides dynamic debug tracing support. This is similar to the support used for debugging access control failures in the Java SE platform. The generic Java dynamic debug tracing support is accessed with the <code class="codeph">java.security.debug</code> system property, whereas the JSSE-specific dynamic debug tracing support is accessed with the <code class="codeph">javax.net.debug</code> system property.</p>
<div class="p">
<div class="infobox-note" id="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF__GUID-0889B6AB-3EA2-4B6B-844D-652AFF24B968">
<p class="notep1">Note:</p>
The <code class="codeph">debug</code> utility is not an officially supported feature of JSSE.</div>
</div>
<p>To view the options of the JSSE dynamic debug utility, use the following command-line option on the <code class="codeph">java</code> command:</p>
<pre class="codeblock" dir="ltr">
-Djavax.net.debug=help
</pre>
<div class="infobox-note" id="GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF__GUID-E45A25FE-5D18-4728-9014-F977BD07BE7D">
<p class="notep1">Note:</p>
If you specify the value <code class="codeph">help</code> with either dynamic debug utility when running a program that does not use any classes that the utility was designed to debug, you will not get the debugging options.</div>
<p>The following complete example shows how to get a list of the debug options for an application named <code class="codeph">MyApp</code> that uses some of the JSSE classes:</p>
<pre class="codeblock" dir="ltr">
java -Djavax.net.debug=help MyApp
</pre>
<p>The <code class="codeph">MyApp</code> application will not run after the debug help information is printed, as the help code causes the application to exit.</p>
<p>Current options are:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">all</code>: Turn on all debugging</li>
<li><code class="codeph">ssl</code>: Turn on SSL debugging</li>
</ul>
<p>The following can be used with the <code class="codeph">ssl</code> option:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">record</code>: Enable per-record tracing</li>
<li><code class="codeph">handshake</code>: Print each handshake message</li>
<li><code class="codeph">keygen</code>: Print key generation data</li>
<li><code class="codeph">session</code>: Print session activity</li>
<li><code class="codeph">defaultctx</code>: Print default SSL initialization</li>
<li><code class="codeph">sslctx</code>: Print <code class="codeph">SSLContext</code> tracing</li>
<li><code class="codeph">sessioncache</code>: Print session cache tracing</li>
<li><code class="codeph">keymanager</code>: Print key manager tracing</li>
<li><code class="codeph">trustmanager</code>: Print trust manager tracing</li>
</ul>
<p>Messages generated from the <code class="codeph">handshake</code> option can be widened with these options:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">data</code>: Hex dump of each handshake message</li>
<li><code class="codeph">verbose</code>: Verbose handshake message printing</li>
</ul>
<p>Messages generated from the <code class="codeph">record</code> option can be widened with these options:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">plaintext</code>: Hex dump of record plaintext</li>
<li><code class="codeph">packet</code>: Print raw SSL/TLS packets</li>
</ul>
<p>The <code class="codeph">javax.net.debug</code> property value must be either <code class="codeph">all</code> or <code class="codeph">ssl</code>, optionally followed by debug specifiers. You can use one or more options. You do <span class="variable">not</span> have to have a separator between options, although a separator such as a colon (:) or a comma (,) helps readability. It does not matter what separators you use, and the ordering of the option keywords is also not important.</p>
<p>For an introduction to reading this debug information, see the guide, <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6" title="Understanding SSL/TLS connection problems can sometimes be difficult, especially when it is not clear what messages are actually being sent and received. JSSE has a built-in debug facility and is activated by the System property javax.net.debug.">Debugging SSL/TLS Connections</a>.</p>
<p>The following are examples of using the <code class="codeph">javax.net.debug</code> property:</p>
<ul style="list-style-type: disc;">
<li>
<p>To view all debugging messages:</p>
<pre class="codeblock" dir="ltr">
java -Djavax.net.debug=all MyApp        
</pre></li>
<li>
<p>To view the hexadecimal dumps of each handshake message, enter the following (the colons are optional):</p>
<pre class="codeblock" dir="ltr">
java -Djavax.net.debug=ssl:handshake:data MyApp
</pre></li>
<li>
<p>To view the hexadecimal dumps of each handshake message, and to print trust manager tracing, enter the following (the commas are optional):</p>
<pre class="codeblock" dir="ltr">
java -Djavax.net.debug=SSL,handshake,data,trustmanager MyApp
</pre></li>
</ul>
</div>
<!-- class="section" --></div>
<div class="sect4"><a id="GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6"></a>
<h4 id="JSSEC-GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6" class="sect4">Debugging SSL/TLS Connections</h4>
<div>
<p>Understanding SSL/TLS connection problems can sometimes be difficult, especially when it is not clear what messages are actually being sent and received. JSSE has a built-in debug facility and is activated by the System property <code class="codeph">javax.net.debug</code>.</p>
<div class="section">
<p>To know more about <code class="codeph">javax.net.debug</code> System property, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-31B7E142-B874-46E9-8DD0-4E18EC0EB2CF">Debugging Utilities</a>.</p>
<p>What follows is a brief example how to read the debug output. Please be aware that the output is non-standard, and may change from release to release. We are using the default JSSE X509KeyManager and X509TrustManager which prints debug information.</p>
<p>This example assumes a basic understanding of the SSL/TLS protocol. To know more about protocols (handshake messages, etc.), see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-69ECD56C-3B20-47F4-AEF0-A06EFA13A61D" title="Secure Sockets Layer (SSL) is the most widely used protocol for implementing cryptography on the web. SSL uses a combination of cryptographic processes to provide secure communication over a network. This section provides an introduction to SSL and the cryptographic processes it uses.">Secure Sockets Layer (SSL) Protocol Overview</a>.</p>
<p>In this example, we first run the <code class="codeph">ClassFileServer</code> sample application from <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span>. This is a simple HTTPS server that requires client authentication. This example runs <code class="codeph">ClassFileServer</code> on the host <code class="codeph">myremoteserver.example.com</code>:</p>
<p><code class="codeph">java -Djavax.net.ssl.trustStore=/<span class="variable">my_home_directory</span>/jssesamples/samples/samplecacerts -Djavax.net.ssl.trustStorePassword=changeit ClassFileServer 2002 /<span class="variable">my_home_directory</span>/jssesamples/samples/ TLS true</code></p>
<p>Then, we connect to this HTTPS server using the <code class="codeph">SSLSocketClientWithClientAuth</code> sample application from <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> (on a host other than <code class="codeph">myremoteserver.example.com</code>), which sends an HTTPS request and receives the reply:</p>
<p><code class="codeph">java SSLSocketClientWithClientAuth <span class="bold">-Djavax.nex.debug=all</span> -Djavax.net.ssl.trustStore=/<span class="variable">my_home_directory</span>/jssesamples/samples/samplecacerts myremoteserver.example.com 2002 /index.html</code></p>
<p>First, the X509KeyManager is initialized and discovers there is one keyEntry in the supplied KeyStore for a subject called "duke". If a server requests a client to authenticate itself, the X509KeyManager will search its list of keyEntries for an appropriate credential.</p>
<pre dir="ltr">
***
<span class="bold">found key for : duke
</span>chain [0] = [
[
  Version: V1
  Subject: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US
  Signature Algorithm: MD5withRSA, OID = 1.2.840.113549.1.1.4

  Key:  Sun RSA public key, 1024 bits
  modulus: 134968166047563266914058280571444028986498087544923991226919517667593269213420979048109900052353578998293280426361122296881234393722020704208851688212064483570055963805034839797994154526862998272017486468599962268346037652120279791547218281230795146025359480589335682217749874703510467348902637769973696151441
  public exponent: 65537
  Validity: [From: Tue May 22 19:46:46 EDT 2001,
               To: Sun May 22 19:46:46 EDT 2011]
  Issuer: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US
  SerialNumber: [    3b0afa66]

]
  Algorithm: [MD5withRSA]
  Signature:
0000: 5F B5 62 E9 A0 26 1D 8E   A2 7E 7C 02 08 36 3A 3E  _.b..&amp;.......6:&gt;
0010: C9 C2 45 03 DD F9 BC 06   FC 25 CF 30 92 91 B1 4E  ..E......%.0...N
0020: 62 17 08 48 14 68 80 CF   DD 89 11 EA 92 7F CE DD  b..H.h..........
0030: B4 FD 12 A8 71 C7 9E D7   C3 D0 E3 BD BB DE 20 92  ....q......... .
0040: C2 3B C8 DE CB 25 23 C0   8B B6 92 B9 0B 64 80 63  .;...%#......d.c
0050: D9 09 25 2D 7A CF 0A 31   B6 E9 CA C1 37 93 BC 0D  ..%-z..1....7...
0060: 4E 74 95 4F 58 31 DA AC   DF D8 BD 89 BD AF EC C8  Nt.OX1..........
0070: 2D 18 A2 BC B2 15 4F B7   28 6F D3 00 E1 72 9B 6C  -.....O.(o...r.l

]
***
</pre>
<p>The X509TrustManager is next initialized, and finds several certificates for a Certificate Authority (CA), including one named "localhost". Any server presenting <span class="bold">valid</span> credentials signed by these CAs will be trusted.</p>
<pre dir="ltr">
***
trustStore is: /<span class="variable">my_home_directory</span>/jssesamples/samples/samplecacerts
trustStore type is: pkcs12
trustStore provider is: 
the last modified time is: Tue Dec 11 06:43:38 EST 2012
Reload the trust store
Reload trust certs
Reloaded 32 trust certs

...

adding as trusted cert:
  Subject: CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US
  Issuer:  CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US
  Algorithm: RSA; Serial number: 0x41004446
  Valid from Thu Jul 22 18:48:38 EDT 2004 until Sun May 22 18:48:38 EDT 2011

...
</pre>
<p>We finish some additional initialization code, and after this, we are now finally ready to make the connection to the server.</p>
<pre dir="ltr">
trigger seeding of SecureRandom
done seeding SecureRandom
Allow unsafe renegotiation: false
Allow legacy hello messages: true
Is initial handshake: true
Is secure renegotiation: false
Ignoring unsupported cipher suite: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 for TLSv1
Ignoring unsupported cipher suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 for TLSv1
Ignoring unsupported cipher suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 for TLSv1
...
Ignoring unsupported cipher suite: TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 for TLSv1.1
Ignoring unsupported cipher suite: TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 for TLSv1.1
Ignoring unsupported cipher suite: TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 for TLSv1.1
%% No cached client session
update handshake state: client_hello[1]
upcoming handshake states: server_hello[2]
</pre>
<p>The connection to the server is made, and we see the initial ClientHello message, which contains:</p>
<ul style="list-style-type: disc;">
<li>random information to initialize the cryptographic routines,</li>
<li>the SessionID, which if non-null, would be used in reestablishing a previous session,</li>
<li>the list of ciphersuites that the client requests,</li>
<li>and no compression algorithms.</li>
</ul>
<p>This is followed by the output of various filters, such as encapsulating the TLSv1.2 header into the SSLv2Hello header format (See setEnabledProtocols()).</p>
<pre dir="ltr">
update handshake state: client_hello[1]
upcoming handshake states: server_hello[2]
<span class="bold">*** ClientHello, TLSv1.2
</span>RandomCookie:  random_bytes = {BA FA 1D F1 56 A3 7C FF B9 43 76 71 98 F5 A9 B4 0E 6B DF 7B 52 B8 F3 92 CC F4 C1 8A AA 71 8A 3F}
Session ID:  {}
Cipher Suites: [TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384, TLS_DHE_DSS_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_DSS_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_RSA_WITH_AES_256_CBC_SHA256, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384, TLS_DHE_RSA_WITH_AES_256_CBC_SHA256, TLS_DHE_DSS_WITH_AES_256_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256, TLS_DHE_RSA_WITH_AES_128_CBC_SHA256, TLS_DHE_DSS_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, SSL_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA, SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA, SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA, TLS_EMPTY_RENEGOTIATION_INFO_SCSV]
Compression Methods:  { 0 }
Extension elliptic_curves, curve names: {secp256r1, secp384r1, secp521r1, sect283k1, sect283r1, sect409k1, sect409r1, sect571k1, sect571r1, secp256k1}
Extension ec_point_formats, formats: [uncompressed]
Extension signature_algorithms, signature_algorithms: SHA512withECDSA, SHA512withRSA, SHA384withECDSA, SHA384withRSA, SHA256withECDSA, SHA256withRSA, SHA256withDSA, SHA1withECDSA, SHA1withRSA, SHA1withDSA
Extension server_name, server_name: [type=host_name (0), value=sc11152716.us.oracle.com]
Extension status_request_v2
CertStatusReqItemV2: ocsp_multi, OCSPStatusRequest
    ResponderIds: &lt;EMPTY&gt;
    Extensions: &lt;EMPTY&gt;
CertStatusReqItemV2: ocsp, OCSPStatusRequest
    ResponderIds: &lt;EMPTY&gt;
    Extensions: &lt;EMPTY&gt;
Extension status_request: ocsp, OCSPStatusRequest
    ResponderIds: &lt;EMPTY&gt;
    Extensions: &lt;EMPTY&gt;
***
<span class="bold">main, WRITE: TLSv1.2 Handshake, length = 265
</span>
</pre>
<p>Section labeled "[Raw write]" represent the actual data sent to the raw output object (in this case, an OutputStream).</p>
<pre dir="ltr">
[<span class="bold">Raw write</span>]: length = 270
0000: 16 03 03 01 09 01 00 01   05 03 03 BA FA 1D F1 56  ...............V
0010: A3 7C FF B9 43 76 71 98   F5 A9 B4 0E 6B DF 7B 52  ....Cvq.....k..R
0020: B8 F3 92 CC F4 C1 8A AA   71 8A 3F 00 00 64 C0 2C  ........q.?..d.,
...
</pre>
<p>After sending the initial ClientHello, we wait for the server's response, a ServerHello. "[Raw read]" displays the raw data read from the input device (InputStream), before any processing has been performed.</p>
<pre dir="ltr">
[<span class="bold">Raw read</span>]: length = 5
0000: 16 03 03 16 A5                                     .....
[<span class="bold">Raw read</span>]: length = 1024
0000: 02 00 00 4D 03 03 5A 4E   F9 E3 0C C5 C3 FE B6 50  ...M..ZN.......P
0010: ED 3E 40 2D 5D 75 27 12   B7 C0 FB CA C5 DD 6E 79  .&gt;@-]u'.......ny
0020: DB FF AE C8 32 63 20 5A   4E F9 E3 35 7F A1 8D A1  ....2c ZN..5....
...
<span class="bold">main, READ: TLSv1.2 Handshake, length = 5797</span>
</pre>
<p>The data is unpackaged, and if the message is in the SSL/TLS format, it is parsed into a ServerHello. If you connected to a non-SSL/TLS socket (plaintext?), the received data will not be in SSL/TLS format, and you'll have problems connecting.</p>
<p>The ServerHello specifies several things:</p>
<ul style="list-style-type: disc;">
<li>The server's random data, also used to initialize the cryptographic algorithms,</li>
<li>the identifier of this session (if the client wants to try to rejoin this session using a different connection, it can send this ID in its ClientHello. If the client session ID equals the server session ID, an abbreviated handshake takes place, and the previously established parameters are used),</li>
<li>the selected cipher suite,</li>
<li>and the compression method (none in this case).</li>
</ul>
<p>Lastly note that the ServerHello has specified that the connection should use "TLSv1.2", rather than "SSLv3."</p>
<pre dir="ltr">
check handshake state: server_hello[2]
<span class="bold">*** ServerHello, TLSv1.2</span>
RandomCookie:  random_bytes = {5A 4E F9 E3 0C C5 C3 FE B6 50 ED 3E 40 2D 5D 75 27 12 B7 C0 FB CA C5 DD 6E 79 DB FF AE C8 32 63}
Session ID:  {90, 78, 249, 227, 53, 127, 161, 141, 161, 33, 124, 107, 167, 128, 131, 252, 2, 170, 193, 168, 50, 40, 183, 150, 161, 217, 57, 214, 248, 78, 138, 158}
Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
Compression Method: 0
Extension renegotiation_info, renegotiated_connection: &lt;empty&gt;
***
%% Initialized:  [Session-2, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256]
** TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
update handshake state: server_hello[2]
upcoming handshake states: server certificate[11]
upcoming handshake states: server_key_exchange[12](optional)
upcoming handshake states: certificate_request[13](optional)
upcoming handshake states: server_hello_done[14]
upcoming handshake states: client certificate[11](optional)
upcoming handshake states: client_key_exchange[16]
upcoming handshake states: certificate_verify[15](optional)
upcoming handshake states: client change_cipher_spec[-1]
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
check handshake state: certificate[11]
update handshake state: certificate[11]
upcoming handshake states: server_key_exchange[12](optional)
upcoming handshake states: certificate_request[13](optional)
upcoming handshake states: server_hello_done[14]
upcoming handshake states: client certificate[11](optional)
upcoming handshake states: client_key_exchange[16]
upcoming handshake states: certificate_verify[15](optional)
upcoming handshake states: client change_cipher_spec[-1]
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
</pre>
<p>The server next identifies itself to the client by passing a Certificate chain. In this example, we have a certificate for the subject "localhost", signed by the issuer "Ficticious Widgets, Inc.". We know that "Ficticious Widgets, Inc." is a trusted CA, so if the certificate chain verifies correctly by our X509TrustManager, we can accept this connection.</p>
<p>There are many different ways of establishing trust, so if the default X509TrustManager is not doing the types of trust management you need, you can supply your own X509TrustManager to the SSLContext.</p>
<pre dir="ltr">
*** Certificate chain
<span class="bold">chain [0]</span> = [
[
  Version: V1
  <span class="bold">Subject: CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US</span>
  Signature Algorithm: MD5withRSA, OID = 1.2.840.113549.1.1.4

  Key:  Sun RSA public key, 1024 bits
  modulus: 143033747930138472247486887271140056230073515145002178273967677351609615363370290762769276637999437478831560066065849659757291378862662902990827165994331807749557591488695685710009935444457827978925129834206313905790623318272163063103561366855275108040861594659236689181320854743400330625121610498756440722549
  public exponent: 65537
  Validity: [From: Thu Jul 22 18:48:38 EDT 2004,
               To: Sun May 22 18:48:38 EDT 2011]
  <span class="bold">Issuer: CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US</span>
  SerialNumber: [    41004446]

]
  Algorithm: [MD5withRSA]
  Signature:
0000: BB 83 25 91 F3 8F 20 B5   C3 BD E4 FE B1 AB E8 CD  ..%... .........
0010: 6F 5C C4 13 86 E9 AB 3E   97 DC AC BF D6 5A 38 42  o\.....&gt;.....Z8B
0020: 39 70 CD 56 F8 82 7B B7   D7 9F 2C 40 52 2B 32 37  9p.V......,@R+27
0030: 5E B0 ED 50 5D D4 F2 5A   80 C6 8D FD 01 FA 8E 2B  ^..P]..Z.......+
0040: 4E 4E DB D8 96 75 CC BE   B7 69 49 22 EC 8A B1 58  NN...u...iI"...X
0050: E6 7E A9 9F 0B 4F 77 4E   EF 89 B0 8D 98 B9 2E E0  .....OwN........
0060: 4D 08 26 13 C5 2E 12 6B   7D 64 4A C9 89 C5 A6 D9  M.&amp;....k.dJ.....
0070: CF 85 AB 27 D3 C9 CE 4C   85 0A 5E B7 B8 0E B1 63  ...'...L..^....c

]
</pre>
<p>We recognize this cert! We can trust it, and continue on with the handshake.</p>
<pre dir="ltr">
***
Found trusted certificate:
[
[
  Version: V1
  Subject: CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US
  Signature Algorithm: MD5withRSA, OID = 1.2.840.113549.1.1.4

  Key:  Sun RSA public key, 1024 bits
  modulus: 143033747930138472247486887271140056230073515145002178273967677351609615363370290762769276637999437478831560066065849659757291378862662902990827165994331807749557591488695685710009935444457827978925129834206313905790623318272163063103561366855275108040861594659236689181320854743400330625121610498756440722549
  public exponent: 65537
  Validity: [From: Thu Jul 22 18:48:38 EDT 2004,
               To: Sun May 22 18:48:38 EDT 2011]
  Issuer: CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US
  SerialNumber: [    41004446]

]
  Algorithm: [MD5withRSA]
  Signature:
0000: BB 83 25 91 F3 8F 20 B5   C3 BD E4 FE B1 AB E8 CD  ..%... .........
0010: 6F 5C C4 13 86 E9 AB 3E   97 DC AC BF D6 5A 38 42  o\.....&gt;.....Z8B
0020: 39 70 CD 56 F8 82 7B B7   D7 9F 2C 40 52 2B 32 37  9p.V......,@R+27
0030: 5E B0 ED 50 5D D4 F2 5A   80 C6 8D FD 01 FA 8E 2B  ^..P]..Z.......+
0040: 4E 4E DB D8 96 75 CC BE   B7 69 49 22 EC 8A B1 58  NN...u...iI"...X
0050: E6 7E A9 9F 0B 4F 77 4E   EF 89 B0 8D 98 B9 2E E0  .....OwN........
0060: 4D 08 26 13 C5 2E 12 6B   7D 64 4A C9 89 C5 A6 D9  M.&amp;....k.dJ.....
0070: CF 85 AB 27 D3 C9 CE 4C   85 0A 5E B7 B8 0E B1 63  ...'...L..^....c

]
check handshake state: server_key_exchange[12]
update handshake state: server_key_exchange[12]
upcoming handshake states: certificate_request[13](optional)
upcoming handshake states: server_hello_done[14]
upcoming handshake states: client certificate[11](optional)
upcoming handshake states: client_key_exchange[16]
upcoming handshake states: certificate_verify[15](optional)
upcoming handshake states: client change_cipher_spec[-1]
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
*** ECDH ServerKeyExchange
Signature Algorithm SHA512withRSA
Server key: Sun EC public key, 256 bits
  public x coord: 63946569761028817730470946709618245239665208702310658540834640572976024458986
  public y coord: 95117373197468111348087774631874920178563710193262620110729461870051247081115
  parameters: secp256r1 [NIST P-256, X9.62 prime256v1] (1.2.840.10045.3.1.7)
check handshake state: certificate_request[13]
</pre>
<p>The server is asking the client to identify itself with a X509 certificate subject having the common name (CN=) "Duke". The server's X509TrustManager has the option of rejecting any credentials provided by the client (or lack thereof). In a real-world situation, you'd probably use a certificate signed by a CA, and the list of trusted CA's would be included in this message instead.</p>
<pre dir="ltr">
*** CertificateRequest
Cert Types: RSA, DSS, ECDSA
Supported Signature Algorithms: SHA512withECDSA, SHA512withRSA, SHA384withECDSA, SHA384withRSA, SHA256withECDSA, SHA256withRSA, Unknown (hash:0x3, signature:0x3), Unknown (hash:0x3, signature:0x1), SHA1withECDSA, SHA1withRSA, SHA1withDSA, MD5withRSA
Cert Authorities:
&lt;CN=VeriSign Class 3 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US&gt;
&lt;CN=VeriSign Class 2 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US&gt;
&lt;OU=Equifax Secure eBusiness CA-2, O=Equifax Secure, C=US&gt;
&lt;CN=Equifax Secure eBusiness CA-1, O=Equifax Secure Inc., C=US&gt;
&lt;EMAILADDRESS=server-certs@thawte.com, CN=Thawte Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA&gt;
&lt;CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US&gt;
&lt;CN=VeriSign Class 1 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc. - For authorized use only", OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US&gt;
&lt;OU=Class 2 Public Primary Certification Authority, O="VeriSign, Inc.", C=US&gt;
&lt;CN=Baltimore CyberTrust Code Signing Root, OU=CyberTrust, O=Baltimore, C=IE&gt;
&lt;EMAILADDRESS=personal-freemail@thawte.com, CN=Thawte Personal Freemail CA, OU=Certification Services Division, O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA&gt;
&lt;OU=VeriSign Trust Network, OU="(c) 1998 VeriSign, Inc. - For authorized use only", OU=Class 3 Public Primary Certification Authority - G2, O="VeriSign, Inc.", C=US&gt;
&lt;CN=Equifax Secure Global eBusiness CA-1, O=Equifax Secure Inc., C=US&gt;
&lt;EMAILADDRESS=personal-premium@thawte.com, CN=Thawte Personal Premium CA, OU=Certification Services Division, O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA&gt;
&lt;EMAILADDRESS=personal-basic@thawte.com, CN=Thawte Personal Basic CA, OU=Certification Services Division, O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA&gt;
&lt;CN=GTE CyberTrust Root, O=GTE Corporation, C=US&gt;
&lt;OU=Class 3 Public Primary Certification Authority, O="VeriSign, Inc.", C=US&gt;
&lt;CN=localhost, OU=Widget Development Group, O="Ficticious Widgets, Inc.", L=Sunnyvale, ST=CA, C=US&gt;
&lt;CN=Entrust.net Client Certification Authority, OU=(c) 2000 Entrust.net Limited, OU=www.entrust.net/GCCA_CPS incorp. by ref. (limits liab.), O=Entrust.net&gt;
&lt;CN=GTE CyberTrust Global Root, OU="GTE CyberTrust Solutions, Inc.", O=GTE Corporation, C=US&gt;
&lt;CN=Entrust.net Client Certification Authority, OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/Client_CA_Info/CPS incorp. by ref. limits liab., O=Entrust.net, C=US&gt;
&lt;OU=Equifax Secure Certificate Authority, O=Equifax, C=US&gt;
&lt;CN=Entrust.net Secure Server Certification Authority, OU=(c) 2000 Entrust.net Limited, OU=www.entrust.net/SSL_CPS incorp. by ref. (limits liab.), O=Entrust.net&gt;
&lt;OU=Secure Server Certification Authority, O="RSA Data Security, Inc.", C=US&gt;
&lt;OU=VeriSign Trust Network, OU="(c) 1998 VeriSign, Inc. - For authorized use only", OU=Class 2 Public Primary Certification Authority - G2, O="VeriSign, Inc.", C=US&gt;
&lt;EMAILADDRESS=premium-server@thawte.com, CN=Thawte Premium Server CA, OU=Certification Services Division, O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA&gt;
&lt;CN=GeoTrust Global CA, O=GeoTrust Inc., C=US&gt;
&lt;OU=VeriSign Trust Network, OU="(c) 1998 VeriSign, Inc. - For authorized use only", OU=Class 1 Public Primary Certification Authority - G2, O="VeriSign, Inc.", C=US&gt;
&lt;CN=Baltimore CyberTrust Root, OU=CyberTrust, O=Baltimore, C=IE&gt;
&lt;CN=Entrust.net Secure Server Certification Authority, OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS incorp. by ref. (limits liab.), O=Entrust.net, C=US&gt;
&lt;OU=Class 1 Public Primary Certification Authority, O="VeriSign, Inc.", C=US&gt;
&lt;CN=Entrust.net Certification Authority (2048), OU=(c) 1999 Entrust.net Limited, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), O=Entrust.net&gt;
&lt;CN=GTE CyberTrust Root 5, OU="GTE CyberTrust Solutions, Inc.", O=GTE Corporation, C=US&gt;
update handshake state: certificate_request[13]
upcoming handshake states: server_hello_done[14]
upcoming handshake states: client certificate[11](optional)
upcoming handshake states: client_key_exchange[16]
upcoming handshake states: certificate_verify[15](optional)
upcoming handshake states: client change_cipher_spec[-1]
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
check handshake state: server_hello_done[14]
update handshake state: server_hello_done[14]
upcoming handshake states: client certificate[11](optional)
upcoming handshake states: client_key_exchange[16]
upcoming handshake states: certificate_verify[15](optional)
upcoming handshake states: client change_cipher_spec[-1]
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
*** ServerHelloDone
</pre>
<p>We need to send client credentials back to the server, so the client's X509KeyManager is now consulted. We look for a match between the list of accepted issuers (above), and the certificates we have in our KeyStore. In this case (luckily?), there is a match: we have credentials for "duke". It's now up to the server's X509TrustManager to decide whether to accept these credentials.</p>
<pre dir="ltr">
<span class="bold">matching alias: duke
</span>*** Certificate chain
chain [0] = [
[
  Version: V1
  <span class="bold">Subject: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US</span>
  Signature Algorithm: MD5withRSA, OID = 1.2.840.113549.1.1.4

  Key:  Sun RSA public key, 1024 bits
  modulus: 134968166047563266914058280571444028986498087544923991226919517667593269213420979048109900052353578998293280426361122296881234393722020704208851688212064483570055963805034839797994154526862998272017486468599962268346037652120279791547218281230795146025359480589335682217749874703510467348902637769973696151441
  public exponent: 65537
  Validity: [From: Tue May 22 19:46:46 EDT 2001,
               To: Sun May 22 19:46:46 EDT 2011]
  Issuer: CN=Duke, OU=Java Software, O="Sun Microsystems, Inc.", L=Cupertino, ST=CA, C=US
  SerialNumber: [    3b0afa66]

]
  Algorithm: [MD5withRSA]
  Signature:
0000: 5F B5 62 E9 A0 26 1D 8E   A2 7E 7C 02 08 36 3A 3E  _.b..&amp;.......6:&gt;
0010: C9 C2 45 03 DD F9 BC 06   FC 25 CF 30 92 91 B1 4E  ..E......%.0...N
0020: 62 17 08 48 14 68 80 CF   DD 89 11 EA 92 7F CE DD  b..H.h..........
0030: B4 FD 12 A8 71 C7 9E D7   C3 D0 E3 BD BB DE 20 92  ....q......... .
0040: C2 3B C8 DE CB 25 23 C0   8B B6 92 B9 0B 64 80 63  .;...%#......d.c
0050: D9 09 25 2D 7A CF 0A 31   B6 E9 CA C1 37 93 BC 0D  ..%-z..1....7...
0060: 4E 74 95 4F 58 31 DA AC   DF D8 BD 89 BD AF EC C8  Nt.OX1..........
0070: 2D 18 A2 BC B2 15 4F B7   28 6F D3 00 E1 72 9B 6C  -.....O.(o...r.l

]
***
update handshake state: certificate[11]
upcoming handshake states: client_key_exchange[16]
upcoming handshake states: certificate_verify[15](optional)
upcoming handshake states: client change_cipher_spec[-1]
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
*** ECDHClientKeyExchange
ECDH Public value:  { 4, 122, 237, 144, 182, 238, 209, 254, 65, 55, 177, 247, 57, 161, 72, 21, 29, 94, 215, 195, 63, 129, 193, 247, 74, 136, 229, 16, 8, 243, 189, 119, 9, 138, 167, 148, 227, 237, 217, 160, 220, 105, 193, 152, 164, 23, 104, 56, 164, 67, 49, 118, 182, 237, 49, 113, 35, 239, 236, 170, 58, 208, 168, 84, 90 }
update handshake state: client_key_exchange[16]
upcoming handshake states: certificate_verify[15](optional)
upcoming handshake states: client change_cipher_spec[-1]
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
</pre>
<p>In the case of this particular cipher suite, we must now pass a message called a ECDHClientKeyExchange, which helps establish a shared secret between the two parties.</p>
<p>All of this data is eventually collected and written to the raw device.</p>
<pre dir="ltr">
<span class="bold">*** ECDHClientKeyExchange</span>
ECDH Public value:  { 4, 122, 237, 144, 182, 238, 209, 254, 65, 55, 177, 247, 57, 161, 72, 21, 29, 94, 215, 195, 63, 129, 193, 247, 74, 136, 229, 16, 8, 243, 189, 119, 9, 138, 167, 148, 227, 237, 217, 160, 220, 105, 193, 152, 164, 23, 104, 56, 164, 67, 49, 118, 182, 237, 49, 113, 35, 239, 236, 170, 58, 208, 168, 84, 90 }
update handshake state: client_key_exchange[16]
upcoming handshake states: certificate_verify[15](optional)
upcoming handshake states: client change_cipher_spec[-1]
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
main, WRITE: TLSv1.2 Handshake, length = 690
[Raw write]: length = 695
0000: 16 03 03 02 B2 0B 00 02   68 00 02 65 00 02 62 30  ........h..e..b0
0010: 82 02 5E 30 82 01 C7 02   04 3B 0A FA 66 30 0D 06  ..^0.....;..f0..
0020: 09 2A 86 48 86 F7 0D 01   01 04 05 00 30 76 31 0B  .*.H........0v1.
...
</pre>
<p>At this point, we have everything we need to generate the actual secrets.</p>
<pre dir="ltr">
SESSION KEYGEN:
PreMaster Secret:
0000: 7B 30 E5 1B 16 56 24 A8   48 A1 14 22 18 80 6B 37  .0...V$.H.."..k7
0010: 33 87 5B AC 88 7E 3A AF   75 62 30 48 DA 6F 52 4E  3.[...:.ub0H.oRN
CONNECTION KEYGEN:
Client Nonce:
0000: BA FA 1D F1 56 A3 7C FF   B9 43 76 71 98 F5 A9 B4  ....V....Cvq....
0010: 0E 6B DF 7B 52 B8 F3 92   CC F4 C1 8A AA 71 8A 3F  .k..R........q.?
Server Nonce:
0000: 5A 4E F9 E3 0C C5 C3 FE   B6 50 ED 3E 40 2D 5D 75  ZN.......P.&gt;@-]u
0010: 27 12 B7 C0 FB CA C5 DD   6E 79 DB FF AE C8 32 63  '.......ny....2c
<span class="bold">Master Secret:</span>
0000: A0 DD C7 3A 6C CD CF 01   9E 8D 38 E6 74 D0 93 51  ...:l.....8.t..Q
0010: CD E4 DB AE 3C BB 64 5D   3D 9D 1C 24 14 A0 9E B8  ....&lt;.d]=..$....
0020: 97 6B 8E 74 C5 6A 07 53   8D B0 5F CE 63 E6 2A B2  .k.t.j.S.._.c.*.
... no MAC keys used for this cipher
Client write key:
0000: 03 81 01 4E 4B 73 AC 71   A7 FC EF 32 99 11 39 D7  ...NKs.q...2..9.
Server write key:
0000: C0 41 60 66 69 0A E0 62   AE CC CA 59 55 84 13 BE  .A`fi..b...YU...
Client write IV:
0000: 92 A8 F6 29                                        ...)
Server write IV:
0000: A3 81 9D 8A           
</pre>
<p>Send a quick confirmation to the server verifying that we know the private key corresponding to the client certificate we just sent.</p>
<pre dir="ltr">
<span class="bold">*** CertificateVerify</span>
Signature Algorithm SHA512withRSA
update handshake state: certificate_verify[15]
upcoming handshake states: client change_cipher_spec[-1]
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
main, WRITE: TLSv1.2 Handshake, length = 136
[Raw write]: length = 141
0000: 16 03 03 00 88 0F 00 00   84 06 01 00 80 21 D7 EB  .............!..
0010: 85 55 D2 18 10 34 4A 67   62 35 67 E0 FD D7 76 0F  .U...4Jgb5g...v.
0020: 72 4D 12 C5 9D 9D 2A DF   AD 61 8D 8E E0 4D 20 47  rM....*..a...M G
0030: F9 19 D5 AC A8 40 25 8E   C3 71 E9 07 E1 04 C8 A8  .....@%..q......
0040: 42 20 2D 9C EB 4A 64 8B   20 BD 72 B5 BB 75 88 8B  B -..Jd. .r..u..
0050: FF 63 13 B5 20 8B F3 93   3C 55 BD A0 E4 9B B1 C0  .c.. ...&lt;U......
0060: 26 14 32 79 29 C9 C4 63   4F 95 F5 8F B5 56 B6 96  &amp;.2y)..cO....V..
0070: B3 E3 72 CC 6A A2 C7 3F   7D DD 54 9B FF 1E 66 2D  ..r.j..?..T...f-
0080: 2C 8F 87 3E 6D 95 A0 61   B3 72 6B C9 36           ,..&gt;m..a.rk.6
update handshake state: change_cipher_spec
upcoming handshake states: client finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
</pre>
<p>Almost finished! Tell the server we're changing to the newly established cipher suite. All further messages will be encrypted using the parameters we just established. We send an encrypted Finished message to verify everything worked.</p>
<pre dir="ltr">
<span class="bold">main, WRITE: TLSv1.2 Change Cipher Spec, length = 1</span>
[Raw write]: length = 6
0000: 14 03 03 00 01 01                                  ......
<span class="bold"><span class="italic">*** Finished
verify_data:  { 203, 239, 43, 159, 111, 5, 204, 127, 182, 48, 181, 121 }</span></span>
***
update handshake state: finished[20]
upcoming handshake states: server change_cipher_spec[-1]
upcoming handshake states: server finished[20]
main, WRITE: TLSv1.2 Handshake, length = 24
<span class="bold">Padded plaintext before ENCRYPTION:  len = 16</span>
0000: 14 00 00 0C CB EF 2B 9F   6F 05 CC 7F B6 30 B5 79  ......+.o....0.y
</pre>
<p>Note next that when the message above is actually written to the raw output device (following the 5 bytes of header information), the message is now encrypted.</p>
<pre dir="ltr">
<span class="bold">[Raw write]: length = 45</span>
0000: 16 03 03 00 28 <span class="bold">00 00 00   00 00 00 00 00 A9 56 B7  ....(.........V.
0010: 91 8D A5 4E 3E AD 9F 68   7D 8F 5D 69 C3 B6 63 C9  ...N&gt;..h..]i..c.
0020: 83 CC D5 1C 1E A2 09 A4   5F 19 38 2B 35           ........_.8+5</span>
</pre>
<p>We now wait for the server to send the same (Change Cipher Spec/Finshed), so we can know it completed negotiations successfully.</p>
<pre dir="ltr">
[Raw read]: length = 5
0000: 14 03 03 00 01                                     .....
[Raw read]: length = 1
0000: 01                                                 .
<span class="bold">main, READ: TLSv1.2 Change Cipher Spec, length = 1
</span>update handshake state: change_cipher_spec
upcoming handshake states: server finished[20]
[Raw read]: length = 5
0000: 16 03 03 00 28                                     ....(
[Raw read]: length = 40
0000: 00 00 00 00 00 00 00 00   7C 67 B6 32 AC 15 50 98  .........g.2..P.
0010: FE A6 4E E1 A0 4B E8 D3   84 DE 82 02 32 DF 54 13  ..N..K......2.T.
0020: 57 24 66 55 4D 49 92 FB                            W$fUMI..
main, READ: TLSv1.2 Handshake, length = 40
Padded plaintext after DECRYPTION:  len = 16
0000: 14 00 00 0C 3A 78 03 E5   A4 9A 9D ED 9D 0E 78 55  ....:x........xU
check handshake state: finished[20]
update handshake state: finished[20]
<span class="bold">*** Finished
</span>verify_data:  { 58, 120, 3, 229, 164, 154, 157, 237, 157, 14, 120, 85 }
***
</pre>
<p>Everything completed successfully! Let's cache the established session in case we want to reestablish this session after this connection is dropped.</p>
<p>At this point, a SSL/TLS client should examine the credentials of the peer to make sure that it is communicating with the expected server. A HttpsURLConnection would check the hostname and call HostnameVerifier if there was a problem, but the raw SSLSocket doesn't. This verification should be done by hand, but we're ignoring this for now.</p>
<p>So, after all that, we're finally ready to exchange application data. We send a "GET /index.html HTTP1.0" command.</p>
<pre dir="ltr">
<span class="bold">%% Cached client session: [Session-2, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256]</span>
main, WRITE: TLSv1.2 Application Data, length = 36
Padded plaintext before ENCRYPTION:  len = 28
0000: <span class="bold">47 45 54 20 2F 69 6E 64   65 78 2E 68 74 6D 6C 20  GET /index.html</span> 
0010: <span class="bold">48 54 54 50 2F 31 2E 30   0D 0A 0D 0A</span>              <span class="bold">HTTP/1.0</span>....
</pre>
<p>Note again the data over the wire is encrypted (skipping the 5 header bytes).</p>
<pre dir="ltr">
[Raw write]: length = 57
0000: 17 03 03 00 34 <span class="bold">00 00 00   00 00 00 00 01 62 BA 68  ....4........b.h
0010: 66 BB 0E FC 6D C4 13 43   C5 98 A1 EC 73 96 0C 28  f...m..C....s..(
0020: 72 4F BB FD 44 85 D5 03   40 82 0B F8 D3 9B B2 4A  rO..D...@......J
0030: 07 6B 0A B8 90 8F DC 82   41                       .k......A
</span>
</pre>
<p>We get the application data back. First the HTTPS header, then the actual data.</p>
<pre dir="ltr">
[Raw read]: length = 5
0000: 17 03 03 00 5A                                     ....Z
[Raw read]: length = 90
0000: 00 00 00 00 00 00 00 01   C4 87 18 10 4F 64 C2 B0  ............Od..
0010: A3 CE 53 C6 3D 0C 0C 5E   E6 FE D2 05 64 39 C6 5C  ..S.=..^....d9.\
0020: BC BE 1B B2 C3 5D E0 5C   B9 34 AD B7 E3 2D 79 08  .....].\.4...-y.
0030: B0 88 D6 33 89 46 23 4C   4D A0 9D 6C AA 79 3C 61  ...3.F#LM..l.y&lt;a
0040: 27 39 65 7D 91 6C 08 C4   FB DD 1F 27 3D 3F 53 D1  '9e..l.....'=?S.
0050: 2A 7C 26 5F 6A 11 05 F4   FF 6B                    *.&amp;_j....k
main, READ: TLSv1.2 Application Data, length = 90
Padded plaintext after DECRYPTION:  len = 66
0000: 48 54 54 50 2F 31 2E 30   20 32 30 30 20 4F 4B 0D  <span class="bold">HTTP/1.0 200 OK.</span>
0010: 0A 43 6F 6E 74 65 6E 74   2D 4C 65 6E 67 74 68 3A  <span class="bold">.Content-Length:</span>
0020: 20 32 35 37 37 0D 0A 43   6F 6E 74 65 6E 74 2D 54  <span class="bold"> 2577..Content-T</span>
0030: 79 70 65 3A 20 74 65 78   74 2F 68 74 6D 6C 0D 0A  <span class="bold">ype: text/html..</span>
0040: 0D 0A                                              ..
<span class="bold">HTTP/1.0 200 OK</span>
<span class="bold">Content-Length: 2577</span>
<span class="bold">Content-Type: text/html</span>

[Raw read]: length = 5
0000: 17 03 03 0A 29                                     ....)
[Raw read]: length = 1024
...
[Raw read]: length = 1024
...
[Raw read]: length = 553
...
main, READ: TLSv1.2 Application Data, length = 2601
<span class="bold">Padded plaintext after DECRYPTION:  len = 2577
</span>
0000: 3C 21 44 4F 43 54 59 50   45 20 68 74 6D 6C 20 50  &lt;!DOCTYPE html P
0010: 55 42 4C 49 43 20 22 2D   2F 2F 57 33 43 2F 2F 44  UBLIC "-//W3C//D
0020: 54 44 20 58 48 54 4D 4C   20 31 2E 30 20 54 72 61  TD XHTML 1.0 Tra
0030: 6E 73 69 74 69 6F 6E 61   6C 2F 2F 45 4E 22 0A 20  nsitional//EN". 
0040: 20 20 20 22 68 74 74 70   3A 2F 2F 77 77 77 2E 77     "http://www.w
0050: 33 2E 6F 72 67 2F 54 52   2F 78 68 74 6D 6C 31 2F  3.org/TR/xhtml1/
0060: 44 54 44 2F 78 68 74 6D   6C 31 2D 74 72 61 6E 73  DTD/xhtml1-trans
0070: 69 74 69 6F 6E 61 6C 2E   64 74 64 22 3E 0A 3C 68  itional.dtd"&gt;.&lt;h
0080: 74 6D 6C 20 6C 61 6E 67   3D 22 65 6E 2D 55 53 22  tml lang="en-US"
0090: 20 78 6D 6C 6E 73 3D 22   68 74 74 70 3A 2F 2F 77   xmlns="http://w
00A0: 77 77 2E 77 33 2E 6F 72   67 2F 31 39 39 39 2F 78  ww.w3.org/1999/x
00B0: 68 74 6D 6C 22 20 78 6D   6C 3A 6C 61 6E 67 3D 0A  html" xml:lang=.
00C0: 22 65 6E 2D 55 53 22 3E   0A 3C 68 65 61 64 3E 0A  "en-US"&gt;.&lt;head&gt;.
00D0: 3C 74 69 74 6C 65 3E 4A   53 53 45 20 53 61 6D 70  <span class="bold">&lt;title&gt;JSSE Samp</span>
00E0: 6C 65 20 43 6F 64 65 3C   2F 74 69 74 6C 65 3E 0A  <span class="bold">le Code&lt;/title&gt;.</span>
...
0A00: 0A 3C 2F 62 6F 64 79 3E   0A 3C 2F 68 74 6D 6C 3E  <span class="bold">.&lt;/body&gt;.&lt;/html&gt;</span>
0A10: 0A                                                 .
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US"&gt;
&lt;head&gt;
<span class="bold">&lt;title&gt;JSSE Sample Code&lt;/title&gt;
</span>&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;
&lt;h1&gt;JSSE Sample Code&lt;/h1&gt;
&lt;/center&gt;
&lt;p&gt;This directory contains subdirectories with JSSE sample files.&lt;/p&gt;
...
<span class="bold">&lt;/body&gt;</span>
<span class="bold">&lt;/html&gt;</span>
</pre>
<p>Read from the socket again to see if there is any more data. We get a close_notify message, which means this connection is shutting down properly. We send our own in turn, then close the socket.</p>
<pre dir="ltr">
[Raw read]: length = 5
0000: 15 03 03 00 1A                                     .....
[Raw read]: length = 26
0000: 00 00 00 00 00 00 00 03   6E D8 FA E8 B7 A7 01 7F  ........n.......
0010: EB C1 88 DC 30 34 BC 57   31 6D                    ....04.W1m
main, READ: TLSv1.2 Alert, length = 26
Padded plaintext after DECRYPTION:  len = 2
0000: 01 00                                              ..
<span class="bold">main, RECV TLSv1.2 ALERT:  warning, close_notify</span>
main, called closeInternal(false)
<span class="bold">main, SEND TLSv1.2 ALERT:  warning, description = close_notify</span>
main, WRITE: TLSv1.2 Alert, length = 10
Padded plaintext before ENCRYPTION:  len = 2
0000: 01 00                                              ..
[Raw write]: length = 31
0000: 15 03 03 00 1A 00 00 00   00 00 00 00 02 AA B8 0A  ................
0010: A1 3F 72 58 22 71 07 0B   83 DD 65 8B 6F 78 3B     .?rX"q....e.ox;
main, called closeSocket(false)
main, called close()
main, called closeInternal(true)
main, called close()
main, called closeInternal(true)
main, called close()
main, called closeInternal(true)
</pre></div>
<!-- class="section" --></div>
</div>
</div>
</div>
<div class="sect2"><a id="GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4"></a>
<h2 id="JSSEC-GUID-0573BCE4-05C4-429C-8ECC-3D3D8CA807F4" class="sect2">Code Examples</h2>
<div>
<p>The following code examples are included in this section:</p>
<div class="section">
<p class="subhead2">Topics</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD" title="Code examples that illustrate how to use JSSE to convert an unsecure socket connection to a secure socket connection. The code samples are excerpted from the book Java SE 6 Network Security by Marco Pistoia, et. al.">Converting an Unsecure Socket to a Secure Socket</a></p>
</li>
<li>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA" title="The JSSE sample programs illustrate how to use JSSE.">Running the JSSE Sample Code</a></p>
</li>
<li>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" title="The procedure as to how you can use the keytool utility to create a simple PKCS12 keystore suitable for use with JSSE.">Creating a Keystore to Use with JSSE</a></p>
</li>
<li>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-63945B45-E909-483F-B3A9-E26586737383">Using the Server Name Indication (SNI) Extension</a></p>
</li>
</ul>
</div>
<!-- class="section" --></div>
<div class="sect3"><a id="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD"></a>
<h3 id="JSSEC-GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD" class="sect3">Converting an Unsecure Socket to a Secure Socket</h3>
<div>
<p>Code examples that illustrate how to use JSSE to convert an unsecure socket connection to a secure socket connection. The code samples are excerpted from the book Java SE 6 Network Security by Marco Pistoia, et. al.</p>
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHOUTSSL-6B1057A9">Example 8-26</a> shows sample code that can be used to set up communication between a client and a server using unsecure sockets. This code is then modified in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHSSL-6B10547E">Example 8-27</a> to use JSSE to set up secure socket communication.</p>
<div class="example" id="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHOUTSSL-6B1057A9">
<p class="titleinexample">Example 8-26 Socket Example Without SSL</p>
<p>The following examples demonstrates server-side and client-side code for setting up an unsecure socket connection.</p>
<p>In a Java program that acts as a server and communicates with a client using sockets, the socket communication is set up with code similar to the following:</p>
<pre class="codeblock" dir="ltr">
    import java.io.*;
    import java.net.*;
    
    . . .
    
    int port = availablePortNumber;
    
    ServerSocket s;
    
    try {
        s = new ServerSocket(port);
        Socket c = s.accept();
    
        OutputStream out = c.getOutputStream();
        InputStream in = c.getInputStream();
    
        // Send messages to the client through
        // the OutputStream
        // Receive messages from the client
        // through the InputStream
    } catch (IOException e) { }
</pre>
<p>The client code to set up communication with a server using sockets is similar to the following:</p>
<pre class="codeblock" dir="ltr">
    import java.io.*;
    import java.net.*;
    
    . . .
    
    int port = availablePortNumber;
    String host = "hostname";
    
    try {
        s = new Socket(host, port);
    
        OutputStream out = s.getOutputStream();
        InputStream in = s.getInputStream();
    
        // Send messages to the server through
        // the OutputStream
        // Receive messages from the server
        // through the InputStream
    } catch (IOException e) { }
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-AB802E5F-07CE-468D-AC7C-7EBCAAE119AD__SOCKETEXAMPLEWITHSSL-6B10547E">
<p class="titleinexample">Example 8-27 Socket Example with SSL</p>
<p>The following examples demonstrate server-side and client-side code for setting up a secure socket connection.</p>
<p>In a Java program that acts as a server and communicates with a client using secure sockets, the socket communication is set up with code similar to the following. Differences between this program and the one for communication using unsecure sockets are highlighted in bold.</p>
<pre class="codeblock" dir="ltr">
    import java.io.*;
    import <span class="bold">javax.net.ssl.*</span>;
    
    . . .
    
    int port = availablePortNumber;
    
    <span class="bold">SSLServerSocket</span> s;
    
    try {
        <span class="bold">SSLServerSocketFactory sslSrvFact =
            (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
        s = (SSLServerSocket)sslSrvFact.createServerSocket(port);</span>
    
        <span class="bold">SSLSocket</span> c = <span class="bold">(SSLSocket)</span>s.accept();
    
        OutputStream out = c.getOutputStream();
        InputStream in = c.getInputStream();
    
        // Send messages to the client through
        // the OutputStream
        // Receive messages from the client
        // through the InputStream
    }
    
    catch (IOException e) {
    }
</pre>
<p>The client code to set up communication with a server using secure sockets is similar to the following, where differences with the unsecure version are highlighted in bold:</p>
<pre class="codeblock" dir="ltr">
    import java.io.*;
    import <span class="bold">javax.net.ssl.*</span>;
    
    . . .
    
    int port = availablePortNumber;
    String host = "hostname";
    
    try {
        <span class="bold">SSLSocketFactory sslFact =
            (SSLSocketFactory)SSLSocketFactory.getDefault();
        SSLSocket s = (SSLSocket)sslFact.createSocket(host, port);</span>
    
        OutputStream out = s.getOutputStream();
        InputStream in = s.getInputStream();
    
        // Send messages to the server through
        // the OutputStream
        // Receive messages from the server
        // through the InputStream
    }
    
    catch (IOException e) {
    }
</pre></div>
<!-- class="example" --></div>
</div>
<div class="sect3"><a id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA"></a>
<h3 id="JSSEC-GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA" class="sect3">Running the JSSE Sample Code</h3>
<div>
<p>The JSSE sample programs illustrate how to use JSSE.</p>
<div class="section">
<ul style="list-style-type: disc;">
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURESOCKET-82CE8421">Sample Code Illustrating a Secure Socket Connection Between a Client and a Server</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">Sample Code Illustrating HTTPS Connections</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURERMICON-F9A2C933">Sample Code Illustrating a Secure RMI Connection</a></li>
<li><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGTHEUSEOFANSSL-7D23A601">Sample Code Illustrating the Use of an SSLEngine</a></li>
</ul>
<p>When you use the sample code, be aware that the sample programs are designed to illustrate how to use JSSE. They are not designed to be robust applications.</p>
<div class="p">
<div class="infobox-note" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-D989BF26-8A0F-46AD-A2E6-83C41C9642B3">
<p class="notep1">Note:</p>
Setting up secure communications involves complex algorithms. The sample programs provide no feedback during the setup process. When you run the programs, be patient: you may not see any output for a while. If you run the programs with the <code class="codeph">javax.net.debug</code> system property set to <code class="codeph">all</code>, you will see more feedback. For an introduction to reading this debug information, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6" title="Understanding SSL/TLS connection problems can sometimes be difficult, especially when it is not clear what messages are actually being sent and received. JSSE has a built-in debug facility and is activated by the System property javax.net.debug.">Debugging SSL/TLS Connections</a>.</div>
</div>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Where to Find the Sample Code</p>
<p><span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> lists all the sample code files and text files. That page also provides a link to a ZIP file that you can download to obtain all the sample code files.</p>
<p>The following sections describe the samples.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURESOCKET-82CE8421">
<p class="subhead3">Sample Code Illustrating a Secure Socket Connection Between a Client and a Server</p>
<p>The sample programs in the <code class="codeph">samples/sockets</code> directory illustrate how to set up a secure socket connection between a client and a server.</p>
<p>When running the sample client programs, you can communicate with an existing server, such as a web server, or you can communicate with the sample server program, <code class="codeph">ClassFileServer</code>. You can run the sample client and the sample server programs on different machines connected to the same network, or you can run them both on one machine but from different terminal windows.</p>
<p>All the sample <code class="codeph">SSLSocketClient*</code> programs in the samples/sockets/client directory (and <code class="codeph">URLReader*</code> programs described in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">Sample Code Illustrating HTTPS Connections</a>) can be run with the <code class="codeph">ClassFileServer</code> sample server program. An example of how to do this is shown in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23BC0C">Running SSLSocketClientWithClientAuth with ClassFileServer</a>. You can make similar changes to run <code class="codeph">URLReader</code>, <code class="codeph">SSLSocketClient</code>, or <code class="codeph">SSLSocketClientWithTunneling</code> with <code class="codeph">ClassFileServer</code>.</p>
<p>If an authentication error occurs during communication between the client and the server (whether using a web server or <code class="codeph">ClassFileServer</code>), it is most likely because the necessary keys are not in the truststore (trust key database). See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329" title="The following are commonly used cryptography terms and their definitions.">Terms and Definitions</a>. For example, the <code class="codeph">ClassFileServer</code> uses a keystore called <code class="codeph">testkeys</code> containing the private key for <code class="codeph">localhost</code> as needed during the SSL handshake. The <code class="codeph">testkeys</code> keystore is included in the same samples/sockets/server directory as the <code class="codeph">ClassFileServer</code> source. If the client cannot find a certificate for the corresponding public key of <code class="codeph">localhost</code> in the truststore it consults, then an authentication error will occur. Be sure to use the <code class="codeph">samplecacerts</code> truststore (which contains the public key and certificate of the <code class="codeph">localhost</code>), as described in the next section.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__CONFIGURATIONREQUIREMENTS-82CE87BD">
<p class="subhead3">Configuration Requirements</p>
<p>When running the sample programs that create a secure socket connection between a client and a server, you will need to make the appropriate certificates file (truststore) available. For both the client and the server programs, you should use the certificates file <code class="codeph">samplecacerts</code> from the <code class="codeph">samples</code> directory. Using this certificates file will allow the client to authenticate the server. The file contains all the common Certificate Authority (CA) certificates shipped with the JDK (in the cacerts file), plus a certificate for <code class="codeph">localhost</code> needed by the client to authenticate <code class="codeph">localhost</code> when communicating with the sample server <code class="codeph">ClassFileServer</code>. The <code class="codeph">ClassFileServer</code> uses a keystore containing the private key for <code class="codeph">localhost</code> that corresponds to the public key in <code class="codeph">samplecacerts</code>.</p>
<p>To make the <code class="codeph">samplecacerts</code> file available to both the client and the server, you can either copy it to the file <code>java-home/lib/security/jssecacerts</code>, rename it to cacerts, and use it to replace the <code>java-home/lib/security/cacerts</code> file, or add the following option to the command line when running the <code class="codeph">java</code> command for both the client and the server:</p>
<pre class="codeblock" dir="ltr">
-Djavax.net.ssl.trustStore=<span class="variable">path_to_samplecacerts_file</span>
</pre>
<p>To know more about <span class="variable">java-home</span>, see <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329" title="The following are commonly used cryptography terms and their definitions.">Terms and Definitions</a>.</p>
<p>The password for the <code class="codeph">samplecacerts</code> truststore is <code class="codeph">changeit</code>. You can substitute your own certificates in the samples by using the <code class="codeph">keytool</code> utility.</p>
<p>If you use a browser, such as Mozilla Firefox or Microsoft Internet Explorer, to access the sample SSL server provided in the <code class="codeph">ClassFileServer</code> example, then a dialog box may pop up with the message that it does not recognize the certificate. This is normal because the certificate used with the sample programs is self-signed and is for testing only. You can accept the certificate for the current session. After testing the SSL server, you should exit the browser, which deletes the test certificate from the browser's namespace.</p>
<p>For client authentication, a separate <code class="codeph">duke</code> certificate is available in the appropriate directories. The public key and certificate is also stored in the <code class="codeph">samplecacerts</code> file.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENT-82CE8C59">
<p class="subhead3">Running SSLSocketClient</p>
<p>The <code class="codeph">SSLSocketClient.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> demonstrates how to create a client that uses an <code class="codeph">SSLSocket</code> to send an HTTP request and to get a response from an HTTPS server. The output of this program is the HTML source for <code class="codeph">https://www.verisign.com/index.html</code>.</p>
<p>You must not be behind a firewall to run this program as provided. If you run it from behind a firewall, you will get an <code class="codeph">UnknownHostException</code> because JSSE cannot find a path through your firewall to <code class="codeph">www.verisign.com</code>. To create an equivalent client that can run from behind a firewall, set up proxy tunneling as illustrated in the sample program <code class="codeph">SSLSocketClientWithTunneling</code>.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHTUNNELING-82CE8F98">
<p class="subhead3">Running SSLSocketClientWithTunneling</p>
<p>The <code class="codeph">SSLSocketClientWithTunneling.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> illustrates how to do proxy tunneling to access a secure web server from behind a firewall. To run this program, you must set the following Java system properties to the appropriate values:</p>
<pre class="codeblock" dir="ltr">
java -Dhttps.proxyHost=<span class="variable">webproxy</span>
-Dhttps.proxyPort=<span class="variable">ProxyPortNumber</span>
SSLSocketClientWithTunneling
</pre>
<div class="p">
<div class="infobox-note" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-12EDAEC4-5DE4-4BD8-A68C-E096E92AE49B">
<p class="notep1">Note:</p>
Proxy specifications with the <code class="codeph">-D</code> options are optional. Replace <span class="variable">webproxy</span> with the name of your proxy host and <span class="variable">ProxyPortNumber</span> with the appropriate port number.</div>
</div>
<p>The program will return the HTML source file from <code class="codeph">https://www.verisign.com/index.html</code>.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23C25E">
<p class="subhead3">Running SSLSocketClientWithClientAuth</p>
<p>The <code>SSLSocketClientWithClientAuth.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> shows how to set up a key manager to do client authentication if required by a server. This program also assumes that the client is not outside a firewall. You can modify the program to connect from inside a firewall by following the example in <code class="codeph">SSLSocketClientWithTunneling</code>.</p>
<p>To run this program, you must specify three parameters: host, port, and requested file path. To mirror the previous examples, you can run this program without client authentication by setting the host to <code class="codeph">www.verisign.com</code>, the port to <code class="codeph">443</code>, and the requested file path to <code class="codeph">https://www.verisign.com/</code>. The output when using these parameters is the HTML for the website <code class="codeph">https://www.verisign.com/</code>.</p>
<p>To run <code class="codeph">SSLSocketClientWithClientAuth</code> to do client authentication, you must access a server that requests client authentication. You can use the sample program <code class="codeph">ClassFileServer</code> as this server. This is described in the following sections.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGCLASSFILESERVER-7D23BEFC">
<p class="subhead3">Running ClassFileServer</p>
<p>The program referred to herein as <code class="codeph">ClassFileServer</code> is made up of two files: <code>ClassFileServer.java</code> and <code>ClassServer.java</code> in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span>.</p>
<p>To execute them, run <code class="codeph">ClassFileServer.class</code>, which requires the following parameters:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">port</code> can be any available unused port number, for example, you can use the number <code class="codeph">2001</code>.</li>
<li><code class="codeph">docroot</code> indicates the directory on the server that contains the file you want to retrieve. For example, on Solaris, you can use /home/<span class="variable">userid</span>/ (where <span class="variable">userid</span> refers to your particular UID), whereas on Microsoft Windows systems, you can use c:\.</li>
<li><code class="codeph">TLS</code> is an optional parameter that indicates that the server is to use SSL or TLS.</li>
<li><code class="codeph">true</code> is an optional parameter that indicates that client authentication is required. This parameter is only consulted if the TLS parameter is set.</li>
</ul>
<div class="infobox-note" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-4635E921-C2B5-4FD5-9480-6478D6C33FC0">
<p class="notep1">Note:</p>
The <code class="codeph">TLS</code> and <code class="codeph">true</code> parameters are optional. If you omit them, indicating that an ordinary (not TLS) file server should be used, without authentication, then nothing happens. This is because one side (the client) is trying to negotiate with TLS, while the other (the server) is not, so they cannot communicate.</div>
<div class="infobox-note" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-F17E9E88-69BB-4873-AC14-BA2B42917D05">
<p class="notep1">Note:</p>
The server expects GET requests in the form <code class="codeph">GET /<span class="variable">path_to_file</span></code>.</div>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23BC0C">
<p class="subhead3">Running SSLSocketClientWithClientAuth with ClassFileServer</p>
<p>You can use the sample programs <code>SSLSocketClientWithClientAuth.java</code> and <code class="codeph">ClassFileServer</code> in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> to set up authenticated communication, where the client and server are authenticated to each other. You can run both sample programs on different machines connected to the same network, or you can run them both on one machine but from different terminal windows or command prompt windows. To set up both the client and the server, do the following:</p>
<ol>
<li>Run the program <code class="codeph">ClassFileServer</code> from one machine or terminal window.
<p>See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGCLASSFILESERVER-7D23BEFC">Running ClassFileServer</a>.</p>
</li>
<li>Run the program <code class="codeph">SSLSocketClientWithClientAuth</code> on another machine or terminal window. <code class="codeph">SSLSocketClientWithClientAuth</code> requires the following parameters:
<ul style="list-style-type: disc;">
<li><code class="codeph">host</code> is the host name of the machine that you are using to run <code class="codeph">ClassFileServer</code>.</li>
<li><code class="codeph">port</code> is the same port that you specified for <code class="codeph">ClassFileServer</code>.</li>
<li>
<p><code class="codeph">requestedfilepath</code> indicates the path to the file that you want to retrieve from the server. You must give this parameter as <code class="codeph">/filepath</code>. Forward slashes are required in the file path because it is used as part of a GET statement, which requires forward slashes regardless of what type of operating system you are running. The statement is formed as follows:</p>
<pre class="codeblock" dir="ltr">
"GET " + requestedfilepath + " HTTP/1.0"
</pre></li>
</ul>
</li>
</ol>
<div class="infobox-note" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-80571B4D-FD52-412D-80AF-BB6FF98147C3">
<p class="notep1">Note:</p>
You can modify the other <code class="codeph">SSLClient*</code> applications' <code class="codeph">GET</code> commands to connect to a local machine running <code class="codeph">ClassFileServer</code>.</div>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">
<p class="subhead3">Sample Code Illustrating HTTPS Connections</p>
<p>There are two primary APIs for accessing secure communications through JSSE. One way is through a socket-level API that can be used for arbitrary secure communications, as illustrated by the <code class="codeph">SSLSocketClient</code>, <code class="codeph">SSLSocketClientWithTunneling</code>, and <code class="codeph">SSLSocketClientWithClientAuth</code> (with and without <code class="codeph">ClassFileServer</code>) sample programs.</p>
<p>A second, and often simpler, way is through the standard Java URL API. You can communicate securely with an SSL-enabled web server by using the HTTPS URL protocol or scheme using the <code class="codeph">java.net.URL</code> class.</p>
<p>Support for HTTPS URL schemes is implemented in many of the common browsers, which allows access to secured communications without requiring the socket-level API provided with JSSE.</p>
<p>An example URL is <code class="codeph">https://www.verisign.com</code>.</p>
<p>The trust and key management for the HTTPS URL implementation is environment-specific. The JSSE implementation provides an HTTPS URL implementation. To use a different HTTPS protocol implementation, set the <code class="codeph">java.protocol.handler.pkgs</code>. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-460C3E5A-A373-4742-9E84-EB42A7A3C363">How to Specify a java.lang.System Property</a> to the package name. See the <code class="codeph">java.net.URL</code> class documentation for details.</p>
<p>The samples that you can download with JSSE include two sample programs that illustrate how to create an HTTPS connection. Both of these sample programs (<code>URLReader.java</code> and <code>URLReaderWithOptions.java</code> ) are in the <code class="codeph">samples/urls</code> directory.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGURLREADER-7D238A63">
<p class="subhead3">Running URLReader</p>
<p>The <code>URLReader.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> illustrates using the URL class to access a secure site. The output of this program is the HTML source for <code class="codeph">https://www.verisign.com/</code>. By default, the HTTPS protocol implementation included with JSSE is used. To use a different implementation, set the system property <code class="codeph">java.protocol.handler.pkgs</code> value to be the name of the package containing the implementation.</p>
<p>If you are running the sample code behind a firewall, then you must set the <code class="codeph">https.proxyHost</code> and <code class="codeph">https.proxyPort</code> system properties. For example, to use the proxy host "webproxy" on port 8080, you can use the following options for the <code class="codeph">java</code> command:</p>
<pre class="codeblock" dir="ltr">
-Dhttps.proxyHost=webproxy
-Dhttps.proxyPort=8080
</pre>
<p>Alternatively, you can set the system properties within the source code with the <code class="codeph">java.lang.System</code> method <code class="codeph">setProperty()</code>. For example, instead of using the command-line options, you can include the following lines in your program:</p>
<pre class="codeblock" dir="ltr">
System.setProperty("java.protocol.handler.pkgs", "com.ABC.myhttpsprotocol");
System.setProperty("https.proxyHost", "webproxy");
System.setProperty("https.proxyPort", "8080");
</pre></div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGURLREADERWITHOPTIONS-7D238F45">
<p class="subhead3">Running URLReaderWithOptions</p>
<p>The <code>URLReaderWithOptions.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> is essentially the same as the <code class="codeph">URLReader.java</code> program, except that it allows you to optionally input any or all of the following system properties as arguments to the program when you run it:</p>
<ul style="list-style-type: disc;">
<li><code class="codeph">java.protocol.handler.pkgs</code></li>
<li><code class="codeph">https.proxyHost</code></li>
<li><code class="codeph">https.proxyPort</code></li>
<li><code class="codeph">https.cipherSuites</code></li>
</ul>
<p>To run <code class="codeph">URLReaderWithOptions</code>, enter the following command:</p>
<pre class="codeblock" dir="ltr">
java URLReaderWithOptions [-h <span class="variable">proxyhost</span> -p <span class="variable">proxyport</span>] [-k <span class="variable">protocolhandlerpkgs</span>] [-c <span class="variable">ciphersarray</span>]
</pre>
<div class="infobox-note" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-91B04C04-7256-438A-8976-CFF5EC570A16">
<p class="notep1">Note:</p>
Multiple protocol handlers can be included in the <code class="codeph">protocolhandlerpkgs</code> argument as a list with items separated by vertical bars. Multiple SSL cipher suite names can be included in the <code class="codeph">ciphersarray</code> argument as a list with items separated by commas. The possible cipher suite names are the same as those returned by the <code class="codeph">SSLSocket.getSupportedCipherSuites()</code> method. The suite names are taken from the SSL and TLS protocol specifications.</div>
<p>You need a <code class="codeph">protocolhandlerpkgs</code> argument only if you want to use an HTTPS protocol handler implementation other than the default one provided by Oracle.</p>
<p>If you are running the sample code behind a firewall, then you must include arguments for the proxy host and the proxy port. Additionally, you can include a list of cipher suites to enable.</p>
<p>Here is an example of running <code class="codeph">URLReaderWithOptions</code> and specifying the proxy host "webproxy" on port 8080:</p>
<pre class="codeblock" dir="ltr">
java URLReaderWithOptions -h webproxy -p 8080
</pre></div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGASECURERMICON-F9A2C933">
<p class="subhead3">Sample Code Illustrating a Secure RMI Connection</p>
<p>The sample code in the <code>samples/rmi</code> directory illustrates how to create a secure Java Remote Method Invocation (RMI) connection. The sample code is basically a "Hello World" example modified to install and use a custom RMI socket factory.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGTHEUSEOFANSSL-7D23A601">
<p class="subhead3">Sample Code Illustrating the Use of an SSLEngine</p>
<p><code class="codeph">SSLEngine</code> gives application developers flexibility when choosing I/O and compute strategies. Rather than tie the SSL/TLS implementation to a specific I/O abstraction (such as single-threaded <code class="codeph">SSLSockets</code>), <code class="codeph">SSLEngine</code> removes the I/O and compute constraints from the SSL/TLS implementation.</p>
<p>As mentioned earlier, <code class="codeph">SSLEngine</code> is an advanced API, and is not appropriate for casual use. Some introductory sample code is provided here that helps illustrate its use. The first demo removes most of the I/O and threading issues, and focuses on many of the SSLEngine methods. The second demo is a more realistic example showing how <code class="codeph">SSLEngine</code> might be combined with Java NIO to create a rudimentary HTTP/HTTPS server.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLENGINESIMPLEDEMO-7D240794">
<p class="subhead3">Running SSLEngineSimpleDemo</p>
<p>The <code>SSLEngineSimpleDemo.java</code> program in <span><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/index.html" target="_blank">JSSE Sample Code</a> in the JDK 8 documentation</span> is a very simple application that focuses on the operation of the <code class="codeph">SSLEngine</code> while simplifying the I/O and threading issues. This application creates two <code class="codeph">SSLEngine</code> objects that exchange SSL/TLS messages via common <code class="codeph">ByteBuffer</code> objects. A single loop serially performs all of the engine operations and demonstrates how a secure connection is established (handshaking), how application data is transferred, and how the engine is closed.</p>
<p>The <code class="codeph">SSLEngineResult</code> provides a great deal of information about the current state of the <code class="codeph">SSLEngine</code>. This example does not examine all of the states. It simplifies the I/O and threading issues to the point that this is not a good example for a production environment; nonetheless, it is useful to demonstrate the overall function of the <code class="codeph">SSLEngine</code>.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGTHENIO-BASEDSERVER-7D23AE05">
<p class="subhead3">Running the NIO-Based Server</p>
<p>To fully exploit the flexibility provided by <code class="codeph">SSLEngine</code>, you must first understand complementary APIs, such as I/O and threading models.</p>
<p>An I/O model that large-scale application developers find of use is the NIO <code class="codeph">SocketChannel</code>. NIO was introduced in part to solve some of the scaling problem inherent in the <code class="codeph">java.net.Socket</code> API. <code class="codeph">SocketChannel</code> has many different modes of operation including:</p>
<ul style="list-style-type: disc;">
<li>Blocking</li>
<li>Nonblocking</li>
<li>Nonblocking with selectors</li>
</ul>
<p>Sample code for a basic HTTP server is provided that not only demonstrates many of the new NIO APIs, but also shows how <code class="codeph">SSLEngine</code> can be employed to create a secure HTTPS server. The server is not production quality, but does show many of these new APIs in action.</p>
<p>Inside the samples directory is a <code>README.txt</code> file that introduces the server, explains how to build and configure the server, and provides a brief overview of the code layout. The files of most interest for <code class="codeph">SSLEngine</code> users are <code>ChannelIO.java</code> and <code>ChannelIOSecure.java</code>.</p>
<div class="infobox-note" id="GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__GUID-EE5A58AA-A4BC-44CE-8ED0-63D0F3B86E0A">
<p class="notep1">Note:</p>
The server example discussed in this section is included in the JDK. You can find the code bundled in the <code class="codeph"><span class="variable">jdk-home</span>/samples/nio/server</code> directory.</div>
</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F"></a>
<h3 id="JSSEC-GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F" class="sect3">Creating a Keystore to Use with JSSE</h3>
<div>
<p>The procedure as to how you can use the <code class="codeph">keytool</code> utility to create a simple PKCS12 keystore suitable for use with JSSE.</p>
<div class="section">
<p>First you make a <code class="codeph">keyEntry</code> (with public and private keys) in the keystore, and then you make a corresponding <code class="codeph">trustedCertEntry</code> (public keys only) in a truststore. For client authentication, you follow a similar process for the client's certificates.</p>
<div class="p">
<div class="infobox-note" id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F__GUID-9D016F06-C132-4185-83B2-B1EB279D05F0">
<p class="notep1">Note:</p>
Storing trust anchors and secret keys in PKCS12 is supported since JDK 8.</div>
</div>
<div class="p">
<div class="infobox-note" id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F__GUID-5FE9AE11-8CB4-4B6C-8BA9-D17AB01633BC">
<p class="notep1">Note:</p>
It is beyond the scope of this example to explain each step in detail. See <a class="olink JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank" href="../tools/keytool.htm#JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549">keytool</a>.</div>
</div>
<p>User input is shown in bold.</p>
<ol>
<li>
<p>Create a new keystore and self-signed certificate with corresponding public and private keys.</p>
<pre class="codeblock" dir="ltr">
    % <span class="bold">keytool -genkeypair -alias duke -keyalg RSA -validity 7 -keystore keystore </span>
    
    Enter keystore password:  <span class="variable">&lt;password&gt;</span>
    What is your first and last name?
    [Unknown]:  <span class="bold">Duke</span>
    What is the name of your organizational unit?
    [Unknown]:  <span class="bold">Java Software</span>
    What is the name of your organization?
    [Unknown]:  <span class="bold">Oracle, Inc.</span>
    What is the name of your City or Locality?
    [Unknown]:  <span class="bold">Palo Alto</span>
    What is the name of your State or Province?
    [Unknown]:  <span class="bold">CA</span>
    What is the two-letter country code for this unit?
    [Unknown]:  <span class="bold">US</span>
    Is CN=Duke, OU=Java Software, O="Oracle, Inc.",
    L=Palo Alto, ST=CA, C=US correct?
    [no]:  <span class="bold">yes</span>
</pre></li>
<li>
<p>Examine the keystore. Notice that the entry type is <code class="codeph">PrivatekeyEntry</code>, which means that this entry has a private key associated with it).</p>
<pre class="codeblock" dir="ltr">
    % <span class="bold">keytool -list -v -keystore keystore</span>
    
    Enter keystore password:  <span class="variable">&lt;password&gt;</span>
    
    Keystore type: PKCS12
    Keystore provider: SUN

    Your keystore contains 1 entry

    Alias name: duke
    Creation date: Jul 25, 2016
    Entry type: PrivateKeyEntry
    Certificate chain length: 1
    Certificate[1]:
    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 210cccfc
    Valid from: Mon Jul 25 10:33:27 IST 2016 until: Mon Aug 01 10:33:27 IST 2016
    Certificate fingerprints:
         SHA1: 80:E5:8A:47:7E:4F:5A:70:83:97:DD:F4:DA:29:3D:15:6B:2A:45:1F
         SHA256: ED:3C:70:68:4E:86:35:9C:63:CC:B9:59:35:58:94:1F:7E:B8:B0:EE:D2:
    4B:9D:80:31:67:8A:D4:B4:7A:B5:12
    Signature algorithm name: SHA256withRSA
    Subject Public Key Algorithm: RSA (2048)
    Version: 3

    Extensions:

   #1: ObjectId: 2.5.29.14 Criticality=false
   SubjectKeyIdentifier [
   KeyIdentifier [
   0000: 7F C9 95 48 42 8D 68 91   BA 1E E6 5C 2C 6B FF 75  ...HB.h....\,k.u
   0010: 5F 19 78 43                                        _.xC
   ]
   ]
</pre></li>
<li>
<p>Export and examine the self-signed certificate.</p>
<pre class="codeblock" dir="ltr">
    % <span class="bold">keytool -export -alias duke -keystore keystore -rfc -file duke.cer</span>
    Enter keystore password:  <span class="variable">&lt;password&gt;</span>
    Certificate stored in file &lt;duke.cer&gt;
    % <span class="bold">cat duke.cer</span>
    -----BEGIN CERTIFICATE-----
    MIIDdzCCAl+gAwIBAgIEIQzM/DANBgkqhkiG9w0BAQsFADBsMQswCQYDVQQGEwJV
    UzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVBhbG8gQWx0bzEVMBMGA1UEChMMT3Jh
    Y2xlLCBJbmMuMRYwFAYDVQQLEw1KYXZhIFNvZnR3YXJlMQ0wCwYDVQQDEwREdWtl
    MB4XDTE2MDcyNTA1MDMyN1oXDTE2MDgwMTA1MDMyN1owbDELMAkGA1UEBhMCVVMx
    CzAJBgNVBAgTAkNBMRIwEAYDVQQHEwlQYWxvIEFsdG8xFTATBgNVBAoTDE9yYWNs
    ZSwgSW5jLjEWMBQGA1UECxMNSmF2YSBTb2Z0d2FyZTENMAsGA1UEAxMERHVrZTCC
    ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJ7+Yeu6HDZgWwkGlG4iKH9w
    vGKrxXVR57FaFyheMevrgj1ovVnQVFhfdMvjPkjWmpqLg6rfTqU4bKbtoMWV6+Rn
    uQrCw2w9xNC93hX9PxRa20UKrSRDKnUSvi1wjlaxfj0KUKuMwbbY9S8x/naYGeTL
    lwbHiiMvkoFkP2kzhVgeqHjIwSz4HRN8vWHCwgIDFWX/ZlS+LbvB4TSZkS0ZcQUV
    vJWTocOd8RB90W3bkibWkWq166XYGE1Nq1L4WIhrVJwbav6ual69yJsEpVcshVkx
    E1WKzJg7dGb03to4agbReb6+aoCUwb2vNUudNWasSrxoEFArVFGD/ZkPT0esfqEC
    AwEAAaMhMB8wHQYDVR0OBBYEFH/JlUhCjWiRuh7mXCxr/3VfGXhDMA0GCSqGSIb3
    DQEBCwUAA4IBAQAmcTm2ahsIJLayajsvm8yPzQsHA7kIwWfPPHCoHmNbynG67oHB
    fleaNvrgm/raTT3TrqQkg0525qI6Cqaoyy8JA2fAp3i+hmyoGHaIlo14bKazaiPS
    RCCqk0J8vwY3CY9nVal1XlHJMEcYV7X1sxKbuAKFoAJ29E/p6ie0JdHtQe31M7X9
    FNLYzt8EpJYUtWo13B9Oufz/Guuex9PQ7aC93rbO32MxtnnCGMxQHlaHLLPygc/x
    cffGz5Xe5s+NEm78CY7thgN+drI7icBYmv4navsnr2OQaD3AfnJ4WYSQyyUUCPxN
    zuk+B0fbLn7PCCcQspmqfgzIpgbEM9M1/yav
    -----END CERTIFICATE-----    
</pre>
<p>Alternatively, you could generate a Certificate Signing Request (CSR) with <code class="codeph">-certreq</code> and send that to a Certificate Authority (CA) for signing, but that is beyond the scope of this example.</p>
</li>
<li>
<p>Import the certificate into a new truststore.</p>
<pre class="codeblock" dir="ltr">
    % <span class="bold">keytool -import -alias dukecert -file duke.cer -keystore truststore</span>
    Enter keystore password:  <span class="variable">&lt;password&gt;</span>
    Re-enter new password:
    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 210cccfc
    Valid from: Mon Jul 25 10:33:27 IST 2016 until: Mon Aug 01 10:33:27 IST 2016
    Certificate fingerprints:
         SHA1: 80:E5:8A:47:7E:4F:5A:70:83:97:DD:F4:DA:29:3D:15:6B:2A:45:1F
         SHA256: ED:3C:70:68:4E:86:35:9C:63:CC:B9:59:35:58:94:1F:7E:B8:B0:EE:D2:
    4B:9D:80:31:67:8A:D4:B4:7A:B5:12
    Signature algorithm name: SHA256withRSA
    Subject Public Key Algorithm: RSA (2048)
    Version: 3

    Extensions:

    #1: ObjectId: 2.5.29.14 Criticality=false
    SubjectKeyIdentifier [
    KeyIdentifier [
    0000: 7F C9 95 48 42 8D 68 91   BA 1E E6 5C 2C 6B FF 75  ...HB.h....\,k.u
    0010: 5F 19 78 43                                        _.xC
    ]
    ]

    Trust this certificate? [no]:  yes
    Certificate was added to keystore

    
</pre></li>
<li>
<p>Examine the truststore. Note that the entry type is <code class="codeph">trustedCertEntry</code>, which means that a private key is not available for this entry. It also means that this file is not suitable as a keystore of the <code class="codeph">KeyManager</code>.</p>
<pre class="codeblock" dir="ltr">
    % <span class="bold">keytool -list -v -keystore truststore</span>
    Enter keystore password:  <span class="variable">&lt;password&gt;</span>
    
    Keystore type: PKCS12
    Keystore provider: SUN
    
    Your keystore contains 1 entry

    Alias name: dukecert
    Creation date: Jul 25, 2016
    Entry type: trustedCertEntry

    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 210cccfc
    Valid from: Mon Jul 25 10:33:27 IST 2016 until: Mon Aug 01 10:33:27 IST 2016
    Certificate fingerprints:
         SHA1: 80:E5:8A:47:7E:4F:5A:70:83:97:DD:F4:DA:29:3D:15:6B:2A:45:1F
         SHA256: ED:3C:70:68:4E:86:35:9C:63:CC:B9:59:35:58:94:1F:7E:B8:B0:EE:D2:
    4B:9D:80:31:67:8A:D4:B4:7A:B5:12
    Signature algorithm name: SHA256withRSA
    Subject Public Key Algorithm: RSA (2048)
    Version: 3

    Extensions:

    #1: ObjectId: 2.5.29.14 Criticality=false
    SubjectKeyIdentifier [
    KeyIdentifier [
    0000: 7F C9 95 48 42 8D 68 91   BA 1E E6 5C 2C 6B FF 75  ...HB.h....\,k.u
    0010: 5F 19 78 43                                        _.xC
    ]
    ]



    *******************************************
    *******************************************
</pre></li>
<li>
<p>Now run your applications with the appropriate keystores. Because this example assumes that the default <code class="codeph">X509KeyManager</code> and <code class="codeph">X509TrustManager</code> are used, you select the keystores using the system properties described in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-A41282C3-19A3-400A-A40F-86F4DA22ABA9" title="JSSE includes a standard implementation that can be customized by plugging in different implementations or specifying the default keystore, and so on.">Customizing JSSE</a>.</p>
<pre class="codeblock" dir="ltr">
    % java -Djavax.net.ssl.keyStore=keystore -Djavax.net.ssl.keyStorePassword=password Server
    
    % java -Djavax.net.ssl.trustStore=truststore -Djavax.net.ssl.trustStorePassword=trustword Client
    
</pre></li>
</ol>
<div class="p">
<div class="infobox-note" id="GUID-3D26386B-BC7A-41BB-AC70-80E6CD147D6F__GUID-3E0172AD-F4CF-44DD-BEFF-4EFE7006F0E5">
<p class="notep1">Note:</p>
This example authenticated the server only. For client authentication, provide a similar keystore for the client's keys and an appropriate truststore for the server.</div>
</div>
</div>
<!-- class="section" --></div>
</div>
<div class="sect3"><a id="GUID-63945B45-E909-483F-B3A9-E26586737383"></a>
<h3 id="JSSEC-GUID-63945B45-E909-483F-B3A9-E26586737383" class="sect3">Using the Server Name Indication (SNI) Extension</h3>
<div>
<div class="section">
<p>These examples illustrate how you can use the <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-82B884DF-AA3D-4FE1-8991-9C3F14044C4F">Server Name Indication (SNI) Extension</a> for client-side and server-side applications, and how it can be applied to a virtual infrastructure.</p>
<p>For all examples in this section, to apply the parameters after you set them, call the <code class="codeph">setSSLParameters(SSLParameters)</code> method on the corresponding <code class="codeph">SSLSocket</code>, <code class="codeph">SSLEngine</code>, or <code class="codeph">SSLServerSocket</code> object.</p>
</div>
<!-- class="section" --></div>
<div class="sect4"><a id="GUID-BCCE0D1F-08D8-4608-8A5A-5BFA54FED2C0"></a>
<h4 id="JSSEC-GUID-BCCE0D1F-08D8-4608-8A5A-5BFA54FED2C0" class="sect4">Typical Client-Side Usage Examples</h4>
<div>
<p>The following is a list of use cases that require understanding of the SNI extension for developing a client application:</p>
<ul style="list-style-type: disc;">
<li>
<p>Case 1. The client wants to access <code class="codeph">www.example.com</code>.</p>
<p>Set the host name explicitly:</p>
<pre class="codeblock" dir="ltr">
    SNIHostName serverName = new SNIHostName("www.example.com");
    sslParameters.setServerNames(Collections.singletonList(serverName)); 
</pre>
<p>The client should always specify the host name explicitly.</p>
</li>
<li>
<p>Case 2. The client does not want to use SNI because the server does not support it.</p>
<p>Disable SNI with an empty server name list:</p>
<pre class="codeblock" dir="ltr">
    sslParameters.setServerNames(Collections.emptyList());        
</pre></li>
<li>
<p>Case 3. The client wants to access URL <code class="codeph">https://www.example.com</code>.</p>
<p>Oracle providers will set the host name in the SNI extension by default, but third-party providers may not support the default server name indication. To keep your application provider-independent, always set the host name explicitly.</p>
</li>
<li>
<p>Case 4. The client wants to switch a socket from server mode to client mode.</p>
<p>First switch the mode with the following method: <code class="codeph">sslSocket.setUseClientMode(true)</code>. Then reset the server name indication parameters on the socket.</p>
</li>
</ul>
</div>
</div>
<div class="sect4"><a id="GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2"></a>
<h4 id="JSSEC-GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2" class="sect4">Typical Server-Side Usage Examples</h4>
<div>
<p>The following is a list of use cases that require understanding of the SNI extension for developing a server application:</p>
<ul style="list-style-type: disc;">
<li>
<p>Case 1. The server wants to accept all server name indication types.</p>
<p>If you do not have any code dealing with the SNI extension, then the server ignores all server name indication types.</p>
</li>
<li>
<p>Case 2. The server wants to deny all server name indications of type <code class="codeph">host_name</code>.</p>
<p>Set an invalid server name pattern for <code class="codeph">host_name</code>:</p>
<pre class="codeblock" dir="ltr">
    SNIMatcher matcher = SNIHostName.createSNIMatcher("");
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);        
</pre>
<p>Another way is to create an <code class="codeph">SNIMatcher</code> subclass with a <code class="codeph">matches()</code> method that always returns <code class="codeph">false</code>:</p>
<pre class="codeblock" dir="ltr">
    class DenialSNIMatcher extends SNIMatcher {
        DenialSNIMatcher() {
            super(StandardConstants.SNI_HOST_NAME);
        }
    
        @Override
        public boolean matches(SNIServerName serverName) {
            return false;
        }
    }
    
    SNIMatcher matcher = new DenialSNIMatcher();
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);        
</pre></li>
<li>
<p>Case 3. The server wants to accept connections to any host names in the <code class="codeph">example.com</code> domain.</p>
<p>Set the recognizable server name for <code class="codeph">host_name</code> as a pattern that includes all <code class="codeph">*.example.com</code> addresses:</p>
<pre class="codeblock" dir="ltr">
    SNIMatcher matcher = SNIHostName.createSNIMatcher("(.*\\.)*example\\.com");
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);
</pre></li>
<li>
<p>Case 4. The server wants to switch a socket from client mode to server mode.</p>
<p>First switch the mode with the following method: <code class="codeph">sslSocket.setUseClientMode(false)</code>. Then reset the server name indication parameters on the socket.</p>
</li>
</ul>
</div>
</div>
<div class="sect4"><a id="GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445"></a>
<h4 id="JSSEC-GUID-0D1E93B9-F63F-46E6-B8A9-0E3AF3207445" class="sect4">Working with Virtual Infrastructures</h4>
<div>
<p>This section describes how to use the Server Name Indication (SNI) extension from within a virtual infrastructure. It illustrates how to create a parser for ClientHello messages from a socket, provides examples of virtual server dispatchers using <code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code>, describes what happens when the SNI extension is not available, and demonstrates how to create a failover <code class="codeph">SSLContext</code>.</p>
<div class="section">
<p class="subhead3">Preparing the ClientHello Parser</p>
<p>Applications must implement an API to parse the ClientHello messages from a socket. The following examples illustrate the <code class="codeph">SSLCapabilities</code> and <code class="codeph">SSLExplorer</code> classes that can perform these functions.</p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/sockets/client/SSLSocketClient.java" target="_blank">SSLSocketClient.java</a> encapsulates the SSL/TLS/DTLS security capabilities during handshaking (that is, the list of cipher suites to be accepted in an SSL/TLS/DTLS handshake, the record version, the hello version, and the server name indication). It can be retrieved by exploring the network data of an SSL/TLS/DTLS connection via the <code class="codeph">SSLExplorer.explore()</code> method.</p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/samples/sni/SSLExplorer.java" target="_blank">SSLExplorer.java</a> explores the initial ClientHello message from a TLS client, but it does not initiate handshaking or consume network data. The <code class="codeph">SSLExplorer.explore()</code> method parses the ClientHello message, and retrieves the security parameters into <code class="codeph">SSLCapabilities</code>. The method must be called before handshaking occurs on any TLS connections.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Virtual Server Dispatcher Based on SSLSocket</p>
<p>This section describes the procedure for using a virtual server dispatcher based on <code class="codeph">SSLSocket</code>.</p>
<ol>
<li>
<p><span class="bold">Register the server name handler.</span></p>
<p>At this step, the application may create different <code class="codeph">SSLContext</code> objects for different server name indications, or link a certain server name indication to a specified virtual machine or distributed system.</p>
<p>For example, if the server name is <code class="codeph">www.example.org</code>, then the registered server name handler may be for a local virtual hosting web service. The local virtual hosting web service will use the specified <code class="codeph">SSLContext</code>. If the server name is <code class="codeph">www.example.com</code>, then the registered server name handler may be for a virtual machine hosting on <code class="codeph">10.0.0.36</code>. The handler may map this connection to the virtual machine.</p>
</li>
<li>
<p><span class="bold">Create a <code class="codeph">ServerSocket</code> and accept the new connection.</span></p>
<pre class="codeblock" dir="ltr">
ServerSocket serverSocket = new ServerSocket(serverPort);
Socket socket = serverSocket.accept();
</pre></li>
<li>
<p><span class="bold">Read and buffer bytes from the socket input stream, and then explore the buffered bytes.</span></p>
<pre class="codeblock" dir="ltr">
InputStream ins = socket.getInputStream();
byte[] buffer = new byte[0xFF];
int position = 0;
SSLCapabilities capabilities = null;
    
// Read the header of TLS record
while (position &lt; SSLExplorer.RECORD_HEADER_SIZE) {
    int count = SSLExplorer.RECORD_HEADER_SIZE - position;
    int n = ins.read(buffer, position, count);
    if (n &lt; 0) {
        throw new Exception("unexpected end of stream!");
    }
    position += n;
}
    
// Get the required size to explore the SSL capabilities
int recordLength = SSLExplorer.getRequiredSize(buffer, 0, position);
if (buffer.length &lt; recordLength) {
    buffer = Arrays.copyOf(buffer, recordLength);
}
    
while (position &lt; recordLength) {
    int count = recordLength - position;
    int n = ins.read(buffer, position, count);
    if (n &lt; 0) {
        throw new Exception("unexpected end of stream!");
    }
    position += n;
}
    
// Explore
capabilities = SSLExplorer.explore(buffer, 0, recordLength);
if (capabilities != null) {
    System.out.println("Record version: " + capabilities.getRecordVersion());
    System.out.println("Hello version: " + capabilities.getHelloVersion());
}
</pre></li>
<li>
<p><span class="bold">Get the requested server name from the explored capabilities.</span></p>
<pre class="codeblock" dir="ltr">
List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();
</pre></li>
<li>
<p><span class="bold">Look for the registered server name handler for this server name indication.</span></p>
<p>If the service of the host name is resident in a virtual machine or another distributed system, then the application must forward the connection to the destination. The application will need to read and write the raw internet data, rather then the SSL application from the socket stream.</p>
<pre class="codeblock" dir="ltr">
Socket destinationSocket = new Socket(serverName, 443);
// Forward buffered bytes and network data from the current socket to the destinationSocket.
</pre>
<p>If the service of the host name is resident in the same process, and the host name service can use the <code class="codeph">SSLSocket</code> directly, then the application will need to set the <code class="codeph">SSLSocket</code> instance to the server:</p>
<pre class="codeblock" dir="ltr">
// Get service context from registered handler
// or create the context
SSLContext serviceContext = ...

SSLSocketFactory serviceSocketFac = serviceContext.getSSLSocketFactory();

// wrap the buffered bytes
ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
SSLSocket serviceSocket = (SSLSocket)serviceSocketFac.createSocket(socket, bais, true);

// Now the service can use serviceSocket as usual.
</pre></li>
</ol>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Virtual Server Dispatcher Based on SSLEngine</p>
<p>This section describes the procedure for using a virtual server dispatcher based on <code class="codeph">SSLEngine</code>.</p>
<ol>
<li>
<p><span class="bold">Register the server name handler.</span></p>
<p>At this step, the application may create different <code class="codeph">SSLContext</code> objects for different server name indications, or link a certain server name indication to a specified virtual machine or distributed system.</p>
<p>For example, if the server name is <code class="codeph">www.example.org</code>, then the registered server name handler may be for a local virtual hosting web service. The local virtual hosting web service will use the specified <code class="codeph">SSLContext</code>. If the server name is <code class="codeph">www.example.com</code>, then the registered server name handler may be for a virtual machine hosting on <code class="codeph">10.0.0.36</code>. The handler may map this connection to the virtual machine.</p>
</li>
<li>
<p><span class="bold">Create a <code class="codeph">ServerSocket</code> or <code class="codeph">ServerSocketChannel</code> and accept the new connection.</span></p>
<pre class="codeblock" dir="ltr">
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.bind(...);
...
SocketChannel socketChannel = serverSocketChannel.accept();
</pre></li>
<li>
<p><span class="bold">Read and buffer bytes from the socket input stream, and then explore the buffered bytes.</span></p>
<pre class="codeblock" dir="ltr">
ByteBuffer buffer = ByteBuffer.allocate(0xFF);
SSLCapabilities capabilities = null;
while (true) {
    // ensure the capacity
    if (buffer.remaining() == 0) {
        ByteBuffer oldBuffer = buffer;
        buffer = ByteBuffer.allocate(buffer.capacity() + 0xFF);
        buffer.put(oldBuffer);
    }

    int n = sc.read(buffer);
    if (n &lt; 0) {
        throw new Exception("unexpected end of stream!");
    }

    int position = buffer.position();
    buffer.flip();
    capabilities = explorer.explore(buffer);
    buffer.rewind();
    buffer.position(position);
    buffer.limit(buffer.capacity());
    if (capabilities != null) {
        System.out.println("Record version: " +
            capabilities.getRecordVersion());
        System.out.println("Hello version: " +
            capabilities.getHelloVersion());
        break;
    }
}

buffer.flip();  // reset the buffer position and limitation 
</pre></li>
<li>
<p><span class="bold">Get the requested server name from the explored capabilities.</span></p>
<pre class="codeblock" dir="ltr">
List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();
</pre></li>
<li>
<p><span class="bold">Look for the registered server name handler for this server name indication.</span></p>
<p>If the service of the host name is resident in a virtual machine or another distributed system, then the application must forward the connection to the destination. The application will need to read and write the raw internet data, rather then the SSL application from the socket stream.</p>
<pre class="codeblock" dir="ltr">
Socket destinationSocket = new Socket(serverName, 443);
// Forward buffered bytes and network data from the current socket to the destinationSocket.
</pre>
<p>If the service of the host name is resident in the same process, and the host name service can use the <code class="codeph">SSLEngine</code> directly, then the application will simply feed the net data to the <code class="codeph">SSLEngine</code> instance:</p>
<pre class="codeblock" dir="ltr">
// Get service context from registered handler
// or create the context
SSLContext serviceContext = ...
    
SSLEngine serviceEngine = serviceContext.createSSLEngine();
// Now the service can use the buffered bytes and other byte buffer as usual.
</pre></li>
</ol>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">No SNI Extension Available</p>
<p>If there is no server name indication in a ClientHello message, then there is no way to select the proper service according to SNI. For such cases, the application may need to specify a default service, so that the connection can be delegated to it if there is no server name indication.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Failover SSLContext</p>
<p>The <code class="codeph">SSLExplorer.explore()</code> method does not check the validity of SSL/TLS/DTLS contents. If the record format does not comply with SSL/TLS/DTLS specification, or the <code class="codeph">explore()</code> method is invoked after handshaking has started, then the method may throw an <code class="codeph">IOException</code> and be unable to produce network data. In such cases, handle the exception thrown by <code class="codeph">SSLExplorer.explore()</code> by using a failover <code class="codeph">SSLContext</code>, which is not used to negotiate an SSL/TLS/DTLS connection, but to close the connection with the proper alert message. The following example illustrates a failover <code class="codeph">SSLContext</code>. You can find an example of the <code class="codeph">DenialSNIMatcher</code> class in Case 2 in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-FA9C8332-B6D9-48E6-AF66-700E00B829D2">Typical Server-Side Usage Examples</a>.</p>
<pre class="codeblock" dir="ltr">
byte[] buffer = ...       // buffered network data
boolean failed = true;    // SSLExplorer.explore() throws an exception

SSLContext context = SSLContext.getInstance("TLS");
// the failover SSLContext
    
context.init(null, null, null);
SSLSocketFactory sslsf = context.getSocketFactory();
ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
SSLSocket sslSocket = (SSLSocket)sslsf.createSocket(socket, bais, true);

SNIMatcher matcher = new DenialSNIMatcher();
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);
SSLParameters params = sslSocket.getSSLParameters();
params.setSNIMatchers(matchers);    // no recognizable server name
sslSocket.setSSLParameters(params);

try {
    InputStream sslIS = sslSocket.getInputStream();
    sslIS.read();
} catch (Exception e) {
    System.out.println("Server exception " + e);
} finally {
    sslSocket.close();
}
</pre></div>
<!-- class="section" --></div>
</div>
</div>
</div>
<div class="sect2"><a id="GUID-847CA40C-F439-4A31-A7FA-C37B4DEC2190"></a>
<h2 id="JSSEC-GUID-847CA40C-F439-4A31-A7FA-C37B4DEC2190" class="sect2">Standard Names</h2>
<div>
<div class="section">The JDK Security API requires and uses a set of standard names for algorithms, certificates and keystore types. See <a href="https://docs.oracle.com/javase/10/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names Specification</a>. Find specific provider information in <a href="oracle-providers.htm#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers Documentation</a>.</div>
<!-- class="section" --></div>
</div>
<div class="sect2"><a id="GUID-08173142-567C-495C-A48F-32D0FCED466B"></a>
<h2 id="JSSEC-GUID-08173142-567C-495C-A48F-32D0FCED466B" class="sect2">Provider Pluggability</h2>
<div>
<p>JSSE is fully pluggable and does not restrict the use of third-party JSSE providers in any way.</p>
</div>
</div>
<div class="sect2"><a id="GUID-09C3A453-AAAB-4D8B-830A-558B3F30BDF3"></a>
<h2 id="JSSEC-GUID-09C3A453-AAAB-4D8B-830A-558B3F30BDF3" class="sect2">JSSE Cipher Suite Parameters</h2>
<div>
<div class="section">
<p><a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-09C3A453-AAAB-4D8B-830A-558B3F30BDF3__GUID-BB21E6D0-F0C1-4C70-8D6C-F3E56009C51C" title="List of JSSE Cipher Suite Parameters">Table 8-14</a> contains a list of additional JSSE cipher suite names related parameters. See <a href="https://docs.oracle.com/javase/10/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a>.</p>
</div>
<!-- class="section" -->
<div class="section">
<div class="tblformalwide" id="GUID-09C3A453-AAAB-4D8B-830A-558B3F30BDF3__GUID-BB21E6D0-F0C1-4C70-8D6C-F3E56009C51C">
<p class="titleintable">Table 8-14 JSSE Cipher Suite Parameters</p>
<table class="cellalignment469" title="JSSE Cipher Suite Parameters" summary="List of JSSE Cipher Suite Parameters">
<thead>
<tr class="cellalignment456">
<th class="cellalignment482" id="d108102e12456">Standard Name (IANA name if different)</th>
<th class="cellalignment471" id="d108102e12458">Key Exchange Algorithm</th>
<th class="cellalignment471" id="d108102e12460">Bulk Cipher Algorithm</th>
<th class="cellalignment471" id="d108102e12462">Message Authentication Code Algorithm</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12466" headers="d108102e12456">
<p>SSL_NULL_WITH_NULL_NULL</p>
<p>IANA: TLS_NULL_WITH_NULL_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e12466 d108102e12458">
<p>K_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e12466 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e12466 d108102e12462">
<p>M_NULL</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12481" headers="d108102e12456">
<p>SSL_RSA_WITH_NULL_MD5</p>
<p>IANA: TLS_RSA_WITH_NULL_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12481 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12481 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e12481 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12496" headers="d108102e12456">
<p>SSL_RSA_WITH_NULL_SHA</p>
<p>IANA: TLS_RSA_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12496 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12496 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e12496 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12511" headers="d108102e12456">
<p>SSL_RSA_EXPORT_WITH_RC4_40_MD5</p>
<p>IANA: TLS_RSA_EXPORT_WITH_RC4_40_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12511 d108102e12458">
<p>RSA_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e12511 d108102e12460">
<p>RC4_40</p>
</td>
<td class="cellalignment476" headers="d108102e12511 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12526" headers="d108102e12456">
<p>SSL_RSA_WITH_RC4_128_MD5</p>
<p>IANA: TLS_RSA_WITH_RC4_128_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12526 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12526 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e12526 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12541" headers="d108102e12456">
<p>SSL_RSA_WITH_RC4_128_SHA</p>
<p>IANA: TLS_RSA_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12541 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12541 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e12541 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12556" headers="d108102e12456">
<p>SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5</p>
<p>IANA: TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12556 d108102e12458">
<p>RSA_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e12556 d108102e12460">
<p>RC2_CBC_40</p>
</td>
<td class="cellalignment476" headers="d108102e12556 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12571" headers="d108102e12456">
<p>SSL_RSA_WITH_IDEA_CBC_SHA</p>
<p>IANA: TLS_RSA_WITH_IDEA_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12571 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12571 d108102e12460">
<p>IDEA_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12571 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12586" headers="d108102e12456">
<p>SSL_RSA_EXPORT_WITH_DES40_CBC_SHA</p>
<p>IANA: TLS_RSA_EXPORT_WITH_DES40_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12586 d108102e12458">
<p>RSA_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e12586 d108102e12460">
<p>DES40_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12586 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12601" headers="d108102e12456">
<p>SSL_RSA_WITH_DES_CBC_SHA</p>
<p>IANA: TLS_RSA_WITH_DES_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12601 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12601 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12601 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12616" headers="d108102e12456">
<p>SSL_RSA_WITH_3DES_EDE_CBC_SHA</p>
<p>IANA: TLS_RSA_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12616 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12616 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12616 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12632" headers="d108102e12456">
<p>SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</p>
<p>IANA: TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12632 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e12632 d108102e12460">
<p>DES40_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12632 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12647" headers="d108102e12456">
<p>SSL_DH_DSS_WITH_DES_CBC_SHA</p>
<p>IANA: TLS_DH_DSS_WITH_DES_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12647 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e12647 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12647 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12662" headers="d108102e12456">
<p>SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA</p>
<p>IANA: TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12662 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e12662 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12662 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12677" headers="d108102e12456">
<p>SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</p>
<p>IANA: TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12677 d108102e12458">
<p>DH_RSA_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e12677 d108102e12460">
<p>DES40_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12677 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12692" headers="d108102e12456">
<p>SSL_DH_RSA_WITH_DES_CBC_SHA</p>
<p>IANA: TLS_DH_RSA_WITH_DES_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12692 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12692 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12692 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12707" headers="d108102e12456">
<p>SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA</p>
<p>IANA: TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12707 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12707 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12707 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12722" headers="d108102e12456">
<p>SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</p>
<p>IANA: TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12722 d108102e12458">
<p>DHE_DSS_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e12722 d108102e12460">
<p>DES40_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12722 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12737" headers="d108102e12456">
<p>SSL_DHE_DSS_WITH_DES_CBC_SHA</p>
<p>IANA: TLS_DHE_DSS_WITH_DES_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12737 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e12737 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12737 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12752" headers="d108102e12456">
<p>SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA</p>
<p>IANA: TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12752 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e12752 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12752 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12767" headers="d108102e12456">
<p>SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</p>
<p>IANA: TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12767 d108102e12458">
<p>DHE_RSA_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e12767 d108102e12460">
<p>DES40_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12767 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12782" headers="d108102e12456">
<p>SSL_DHE_RSA_WITH_DES_CBC_SHA</p>
<p>IANA: TLS_DHE_RSA_WITH_DES_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12782 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12782 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12782 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12798" headers="d108102e12456">
<p>SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA</p>
<p>IANA: TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12798 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e12798 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12798 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12813" headers="d108102e12456">
<p>SSL_DH_anon_EXPORT_WITH_RC4_40_MD5</p>
<p>IANA: TLS_DH_anon_EXPORT_WITH_RC4_40_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12813 d108102e12458">
<p>DH_anon_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e12813 d108102e12460">
<p>RC4_40</p>
</td>
<td class="cellalignment476" headers="d108102e12813 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12828" headers="d108102e12456">
<p>SSL_DH_anon_WITH_RC4_128_MD5</p>
<p>IANA: TLS_DH_anon_WITH_RC4_128_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12828 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e12828 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e12828 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12843" headers="d108102e12456">
<p>SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA</p>
<p>IANA: TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12843 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e12843 d108102e12460">
<p>DES40_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12843 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12858" headers="d108102e12456">
<p>SSL_DH_anon_WITH_DES_CBC_SHA</p>
<p>IANA: TLS_DH_anon_WITH_DES_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12858 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e12858 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12858 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12873" headers="d108102e12456">
<p>SSL_DH_anon_WITH_3DES_EDE_CBC_SHA</p>
<p>IANA: TLS_DH_anon_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12873 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e12873 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12873 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12888" headers="d108102e12456">
<p>TLS_KRB5_WITH_DES_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12888 d108102e12458">
<p>KRB5</p>
</td>
<td class="cellalignment476" headers="d108102e12888 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12888 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12901" headers="d108102e12456">
<p>TLS_KRB5_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12901 d108102e12458">
<p>KRB5</p>
</td>
<td class="cellalignment476" headers="d108102e12901 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12901 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12914" headers="d108102e12456">
<p>TLS_KRB5_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12914 d108102e12458">
<p>KRB5</p>
</td>
<td class="cellalignment476" headers="d108102e12914 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e12914 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12927" headers="d108102e12456">
<p>TLS_KRB5_WITH_IDEA_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12927 d108102e12458">
<p>KRB5</p>
</td>
<td class="cellalignment476" headers="d108102e12927 d108102e12460">
<p>IDEA_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12927 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12940" headers="d108102e12456">
<p>TLS_KRB5_WITH_DES_CBC_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12940 d108102e12458">
<p>KRB5</p>
</td>
<td class="cellalignment476" headers="d108102e12940 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12940 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12954" headers="d108102e12456">
<p>TLS_KRB5_WITH_3DES_EDE_CBC_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12954 d108102e12458">
<p>KRB5</p>
</td>
<td class="cellalignment476" headers="d108102e12954 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12954 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12967" headers="d108102e12456">
<p>TLS_KRB5_WITH_RC4_128_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12967 d108102e12458">
<p>KRB5</p>
</td>
<td class="cellalignment476" headers="d108102e12967 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e12967 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12980" headers="d108102e12456">
<p>TLS_KRB5_WITH_IDEA_CBC_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e12980 d108102e12458">
<p>KRB5</p>
</td>
<td class="cellalignment476" headers="d108102e12980 d108102e12460">
<p>IDEA_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12980 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e12993" headers="d108102e12456">
<p>TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e12993 d108102e12458">
<p>KRB5_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e12993 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e12993 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13006" headers="d108102e12456">
<p>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13006 d108102e12458">
<p>KRB5_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e13006 d108102e12460">
<p>RC2_CBC_40</p>
</td>
<td class="cellalignment476" headers="d108102e13006 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13019" headers="d108102e12456">
<p>TLS_KRB5_EXPORT_WITH_RC4_40_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13019 d108102e12458">
<p>KRB5_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e13019 d108102e12460">
<p>RC4_40</p>
</td>
<td class="cellalignment476" headers="d108102e13019 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13032" headers="d108102e12456">
<p>TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e13032 d108102e12458">
<p>KRB5_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e13032 d108102e12460">
<p>DES_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13032 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13045" headers="d108102e12456">
<p>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e13045 d108102e12458">
<p>KRB5_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e13045 d108102e12460">
<p>RC2_CBC_40</p>
</td>
<td class="cellalignment476" headers="d108102e13045 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13058" headers="d108102e12456">
<p>TLS_KRB5_EXPORT_WITH_RC4_40_MD5</p>
</td>
<td class="cellalignment476" headers="d108102e13058 d108102e12458">
<p>KRB5_EXPORT</p>
</td>
<td class="cellalignment476" headers="d108102e13058 d108102e12460">
<p>RC4_40</p>
</td>
<td class="cellalignment476" headers="d108102e13058 d108102e12462">
<p>MD5</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13071" headers="d108102e12456">
<p>TLS_PSK_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13071 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13071 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e13071 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13084" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13084 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13084 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e13084 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13098" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13098 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13098 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e13098 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13111" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13111 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13111 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13111 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13124" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13124 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13124 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13124 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13137" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13137 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13137 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13137 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13150" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13150 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13150 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13150 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13163" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13163 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13163 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13163 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13176" headers="d108102e12456">
<p>TLS_DH_anon_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13176 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e13176 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13176 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13189" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13189 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13189 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13189 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13202" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13202 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13202 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13202 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13215" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13215 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13215 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13215 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13228" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13228 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13228 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13228 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13242" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13242 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13242 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13242 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13255" headers="d108102e12456">
<p>TLS_DH_anon_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13255 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e13255 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13255 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13268" headers="d108102e12456">
<p>TLS_RSA_WITH_NULL_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13268 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13268 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e13268 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13281" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13281 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13281 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13281 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13294" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13294 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13294 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13294 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13307" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13307 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13307 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13307 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13320" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13320 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13320 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13320 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13333" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13333 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13333 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13333 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13346" headers="d108102e12456">
<p>TLS_RSA_WITH_CAMELLIA_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13346 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13346 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13346 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13359" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13359 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13359 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13359 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13372" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13372 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13372 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13372 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13386" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13386 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13386 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13386 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13399" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13399 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13399 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13399 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13412" headers="d108102e12456">
<p>TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13412 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e13412 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13412 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13425" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13425 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13425 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13425 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13438" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_AES_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13438 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13438 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13438 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13451" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_AES_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13451 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13451 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13451 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13464" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_AES_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13464 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13464 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13464 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13477" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13477 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13477 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13477 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13490" headers="d108102e12456">
<p>TLS_DH_anon_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13490 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e13490 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13490 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13503" headers="d108102e12456">
<p>TLS_DH_anon_WITH_AES_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13503 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e13503 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13503 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13516" headers="d108102e12456">
<p>TLS_RSA_WITH_CAMELLIA_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13516 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13516 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13516 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13530" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13530 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13530 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13530 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13543" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13543 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13543 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13543 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13556" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13556 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13556 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13556 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13569" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13569 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13569 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13569 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13582" headers="d108102e12456">
<p>TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13582 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e13582 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13582 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13595" headers="d108102e12456">
<p>TLS_PSK_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13595 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13595 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e13595 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13608" headers="d108102e12456">
<p>TLS_PSK_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13608 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13608 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13608 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13621" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13621 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13621 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13621 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13634" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13634 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13634 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13634 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13647" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13647 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13647 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e13647 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13660" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13660 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13660 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13660 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13674" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13674 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13674 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13674 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13687" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13687 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13687 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13687 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13700" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13700 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13700 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e13700 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13713" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13713 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13713 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13713 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13726" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13726 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13726 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13726 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13739" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13739 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13739 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13739 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13752" headers="d108102e12456">
<p>TLS_RSA_WITH_SEED_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13752 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13752 d108102e12460">
<p>SEED_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13752 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13765" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_SEED_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13765 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13765 d108102e12460">
<p>SEED_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13765 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13778" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_SEED_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13778 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13778 d108102e12460">
<p>SEED_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13778 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13791" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_SEED_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13791 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13791 d108102e12460">
<p>SEED_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13791 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13804" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_SEED_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13804 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13804 d108102e12460">
<p>SEED_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13804 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13818" headers="d108102e12456">
<p>TLS_DH_anon_WITH_SEED_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e13818 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e13818 d108102e12460">
<p>SEED_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e13818 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13831" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13831 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13831 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13831 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13844" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e13844 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13844 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13844 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13857" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13857 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13857 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13857 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13870" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e13870 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13870 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13870 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13883" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13883 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13883 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13883 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13896" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e13896 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e13896 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13896 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13909" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13909 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13909 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13909 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13922" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e13922 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13922 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13922 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13935" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13935 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13935 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13935 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13948" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e13948 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e13948 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13948 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13962" headers="d108102e12456">
<p>TLS_DH_anon_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13962 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e13962 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13962 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13975" headers="d108102e12456">
<p>TLS_DH_anon_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e13975 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e13975 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13975 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e13988" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e13988 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e13988 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e13988 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14001" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14001 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14001 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e14001 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14014" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14014 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14014 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e14014 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14027" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14027 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14027 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e14027 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14040" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14040 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14040 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e14040 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14053" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14053 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14053 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e14053 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14066" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14066 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14066 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14066 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14079" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14079 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14079 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14079 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14092" headers="d108102e12456">
<p>TLS_PSK_WITH_NULL_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14092 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14092 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14092 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14106" headers="d108102e12456">
<p>TLS_PSK_WITH_NULL_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14106 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14106 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14106 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14119" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14119 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14119 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14119 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14132" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14132 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14132 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14132 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14145" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_NULL_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14145 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14145 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14145 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14158" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_NULL_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14158 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14158 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14158 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14171" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14171 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14171 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14171 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14184" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_AES_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14184 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14184 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14184 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14197" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_NULL_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14197 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14197 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14197 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14210" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_NULL_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14210 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e14210 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14210 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14223" headers="d108102e12456">
<p>TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14223 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14223 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14223 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14236" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14236 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e14236 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14236 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14250" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14250 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14250 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14250 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14263" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14263 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e14263 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14263 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14276" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14276 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14276 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14276 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14289" headers="d108102e12456">
<p>TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14289 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e14289 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14289 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14302" headers="d108102e12456">
<p>TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14302 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14302 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14302 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14315" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14315 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e14315 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14315 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14328" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14328 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14328 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14328 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14341" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14341 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e14341 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14341 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14354" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14354 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14354 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14354 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14367" headers="d108102e12456">
<p>TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14367 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e14367 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14367 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14380" headers="d108102e12456">
<p>TLS_EMPTY_RENEGOTIATION_INFO_SCSV</p>
</td>
<td class="cellalignment476" headers="d108102e14380 d108102e12458">
<p>Not applicable</p>
</td>
<td class="cellalignment476" headers="d108102e14380 d108102e12460">
<p>Not applicable</p>
</td>
<td class="cellalignment476" headers="d108102e14380 d108102e12462">
<p>Not applicable</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14394" headers="d108102e12456">
<p>TLS_FALLBACK_SCSV</p>
</td>
<td class="cellalignment476" headers="d108102e14394 d108102e12458">
<p>Not applicable</p>
</td>
<td class="cellalignment476" headers="d108102e14394 d108102e12460">
<p>Not applicable</p>
</td>
<td class="cellalignment476" headers="d108102e14394 d108102e12462">
<p>Not applicable</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14407" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14407 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14407 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14407 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14420" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14420 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14420 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e14420 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14433" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14433 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14433 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14433 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14446" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14446 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14446 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14446 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14459" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14459 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14459 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14459 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14472" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14472 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14472 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14472 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14485" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14485 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14485 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e14485 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14498" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14498 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14498 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14498 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14511" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14511 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14511 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14511 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14524" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14524 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14524 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14524 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14538" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14538 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14538 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14538 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14551" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14551 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14551 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e14551 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14564" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14564 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14564 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14564 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14577" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14577 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14577 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14577 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14590" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14590 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14590 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14590 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14603" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14603 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14603 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14603 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14616" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14616 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14616 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e14616 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14629" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14629 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14629 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14629 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14642" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14642 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14642 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14642 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14655" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14655 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14655 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14655 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14668" headers="d108102e12456">
<p>TLS_ECDH_anon_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14668 d108102e12458">
<p>ECDH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e14668 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e14668 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14682" headers="d108102e12456">
<p>TLS_ECDH_anon_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14682 d108102e12458">
<p>ECDH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e14682 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e14682 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14695" headers="d108102e12456">
<p>TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14695 d108102e12458">
<p>ECDH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e14695 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14695 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14708" headers="d108102e12456">
<p>TLS_ECDH_anon_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14708 d108102e12458">
<p>ECDH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e14708 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14708 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14721" headers="d108102e12456">
<p>TLS_ECDH_anon_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14721 d108102e12458">
<p>ECDH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e14721 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14721 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14734" headers="d108102e12456">
<p>TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14734 d108102e12458">
<p>SRP_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14734 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14734 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14747" headers="d108102e12456">
<p>TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14747 d108102e12458">
<p>SRP_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14747 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14747 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14760" headers="d108102e12456">
<p>TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14760 d108102e12458">
<p>SRP_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14760 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14760 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14773" headers="d108102e12456">
<p>TLS_SRP_SHA_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14773 d108102e12458">
<p>SRP_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14773 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14773 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14786" headers="d108102e12456">
<p>TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14786 d108102e12458">
<p>SRP_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14786 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14786 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14799" headers="d108102e12456">
<p>TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14799 d108102e12458">
<p>SRP_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14799 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14799 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14812" headers="d108102e12456">
<p>TLS_SRP_SHA_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14812 d108102e12458">
<p>SRP_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14812 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14812 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14826" headers="d108102e12456">
<p>TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14826 d108102e12458">
<p>SRP_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14826 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14826 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14839" headers="d108102e12456">
<p>TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14839 d108102e12458">
<p>SRP_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e14839 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14839 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14852" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14852 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14852 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14852 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14865" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14865 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14865 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14865 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14878" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14878 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14878 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14878 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14891" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14891 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14891 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14891 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14904" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14904 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14904 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14904 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14917" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14917 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14917 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14917 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14930" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14930 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14930 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14930 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14943" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14943 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e14943 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e14943 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14956" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14956 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14956 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e14956 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14970" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14970 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14970 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e14970 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14983" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e14983 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14983 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e14983 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e14996" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e14996 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e14996 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e14996 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15009" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15009 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15009 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15009 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15022" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15022 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15022 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15022 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15035" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15035 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15035 d108102e12460">
<p>AES_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15035 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15048" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15048 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15048 d108102e12460">
<p>AES_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15048 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15061" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_RC4_128_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e15061 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15061 d108102e12460">
<p>RC4</p>
</td>
<td class="cellalignment476" headers="d108102e15061 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15074" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e15074 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15074 d108102e12460">
<p>3DES_EDE_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15074 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15087" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e15087 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15087 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15087 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15100" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e15100 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15100 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15100 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15114" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15114 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15114 d108102e12460">
<p>AES_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15114 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15127" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15127 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15127 d108102e12460">
<p>AES_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15127 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15140" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_NULL_SHA</p>
</td>
<td class="cellalignment476" headers="d108102e15140 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15140 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e15140 d108102e12462">
<p>SHA-1</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15153" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_NULL_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15153 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15153 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e15153 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15166" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_NULL_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15166 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15166 d108102e12460">
<p>B_NULL</p>
</td>
<td class="cellalignment476" headers="d108102e15166 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15179" headers="d108102e12456">
<p>TLS_RSA_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15179 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15179 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15179 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15192" headers="d108102e12456">
<p>TLS_RSA_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15192 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15192 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15192 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15205" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15205 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e15205 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15205 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15218" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15218 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e15218 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15218 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15231" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15231 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15231 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15231 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15244" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15244 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15244 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15244 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15258" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15258 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e15258 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15258 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15271" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15271 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e15271 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15271 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15284" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15284 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15284 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15284 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15297" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15297 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15297 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15297 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15310" headers="d108102e12456">
<p>TLS_DH_anon_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15310 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e15310 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15310 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15323" headers="d108102e12456">
<p>TLS_DH_anon_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15323 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e15323 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15323 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15336" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15336 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15336 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15336 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15349" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15349 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15349 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15349 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15362" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15362 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15362 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15362 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15375" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15375 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15375 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15375 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15388" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15388 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15388 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15388 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15402" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15402 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15402 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15402 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15415" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15415 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15415 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15415 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15428" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15428 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15428 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15428 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15441" headers="d108102e12456">
<p>TLS_RSA_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15441 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15441 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15441 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15454" headers="d108102e12456">
<p>TLS_RSA_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15454 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15454 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15454 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15467" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15467 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15467 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15467 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15480" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15480 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15480 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15480 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15493" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15493 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15493 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15493 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15506" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15506 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15506 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15506 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15519" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15519 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e15519 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15519 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15532" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15532 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e15532 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15532 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15546" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15546 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e15546 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15546 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15559" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15559 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e15559 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15559 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15572" headers="d108102e12456">
<p>TLS_DH_anon_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15572 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e15572 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15572 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15585" headers="d108102e12456">
<p>TLS_DH_anon_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15585 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e15585 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15585 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15598" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15598 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15598 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15598 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15611" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15611 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15611 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15611 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15624" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15624 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15624 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15624 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15637" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15637 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15637 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15637 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15650" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15650 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15650 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15650 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15663" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15663 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15663 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15663 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15676" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15676 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15676 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15676 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15690" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15690 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15690 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15690 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15703" headers="d108102e12456">
<p>TLS_PSK_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15703 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15703 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15703 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15716" headers="d108102e12456">
<p>TLS_PSK_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15716 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15716 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15716 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15729" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15729 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15729 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15729 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15742" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15742 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15742 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15742 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15755" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15755 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15755 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15755 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15768" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15768 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15768 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15768 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15781" headers="d108102e12456">
<p>TLS_PSK_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15781 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15781 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15781 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15794" headers="d108102e12456">
<p>TLS_PSK_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15794 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15794 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15794 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15807" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15807 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15807 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15807 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15820" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15820 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15820 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15820 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15834" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15834 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15834 d108102e12460">
<p>ARIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15834 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15847" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15847 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15847 d108102e12460">
<p>ARIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15847 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15860" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15860 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15860 d108102e12460">
<p>ARIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15860 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15873" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15873 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e15873 d108102e12460">
<p>ARIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15873 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15886" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15886 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15886 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15886 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15899" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15899 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15899 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15899 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15912" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15912 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15912 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15912 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15925" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15925 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e15925 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15925 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15938" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15938 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15938 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15938 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15951" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15951 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15951 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15951 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15964" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15964 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15964 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15964 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15978" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e15978 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15978 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e15978 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e15991" headers="d108102e12456">
<p>TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e15991 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e15991 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e15991 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16004" headers="d108102e12456">
<p>TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16004 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16004 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16004 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16017" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16017 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16017 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16017 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16030" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16030 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16030 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16030 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16043" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16043 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16043 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16043 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16056" headers="d108102e12456">
<p>TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16056 d108102e12458">
<p>DH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16056 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16056 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16069" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16069 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e16069 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16069 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16082" headers="d108102e12456">
<p>TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16082 d108102e12458">
<p>DHE_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e16082 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16082 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16095" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16095 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e16095 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16095 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16108" headers="d108102e12456">
<p>TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16108 d108102e12458">
<p>DH_DSS</p>
</td>
<td class="cellalignment476" headers="d108102e16108 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16108 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16122" headers="d108102e12456">
<p>TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16122 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e16122 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16122 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16135" headers="d108102e12456">
<p>TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16135 d108102e12458">
<p>DH_anon</p>
</td>
<td class="cellalignment476" headers="d108102e16135 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16135 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16148" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16148 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e16148 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16148 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16161" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16161 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e16161 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16161 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16174" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16174 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e16174 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16174 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16187" headers="d108102e12456">
<p>TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16187 d108102e12458">
<p>ECDH_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e16187 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16187 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16200" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16200 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16200 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16200 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16213" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16213 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16213 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16213 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16226" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16226 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16226 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16226 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16239" headers="d108102e12456">
<p>TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16239 d108102e12458">
<p>ECDH_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16239 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16239 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16252" headers="d108102e12456">
<p>TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16252 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16252 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16252 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16266" headers="d108102e12456">
<p>TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16266 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16266 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16266 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16279" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16279 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16279 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16279 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16292" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16292 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16292 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16292 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16305" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16305 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16305 d108102e12460">
<p>CAMELLIA_128_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16305 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16318" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16318 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16318 d108102e12460">
<p>CAMELLIA_256_GCM</p>
</td>
<td class="cellalignment476" headers="d108102e16318 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16331" headers="d108102e12456">
<p>TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16331 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16331 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e16331 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16344" headers="d108102e12456">
<p>TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16344 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16344 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e16344 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16357" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16357 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16357 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e16357 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16370" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16370 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16370 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e16370 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16383" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16383 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16383 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e16383 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16396" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16396 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16396 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e16396 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16410" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16410 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16410 d108102e12460">
<p>CAMELLIA_128_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e16410 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16423" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</p>
</td>
<td class="cellalignment476" headers="d108102e16423 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16423 d108102e12460">
<p>CAMELLIA_256_CBC</p>
</td>
<td class="cellalignment476" headers="d108102e16423 d108102e12462">
<p>SHA-384</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16436" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16436 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16436 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16436 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16449" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16449 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16449 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16449 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16462" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16462 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16462 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16462 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16475" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16475 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16475 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16475 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16488" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_128_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16488 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16488 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16488 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16501" headers="d108102e12456">
<p>TLS_RSA_WITH_AES_256_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16501 d108102e12458">
<p>RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16501 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16501 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16514" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_128_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16514 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16514 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16514 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16527" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_AES_256_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16527 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16527 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16527 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16540" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16540 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16540 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16540 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16554" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16554 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16554 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16554 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16567" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16567 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16567 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16567 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16580" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16580 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16580 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16580 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16593" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_128_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16593 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16593 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16593 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16606" headers="d108102e12456">
<p>TLS_PSK_WITH_AES_256_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16606 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16606 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16606 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16619" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_128_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16619 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16619 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16619 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16632" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_AES_256_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16632 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16632 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16632 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16645" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16645 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e16645 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16645 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16658" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16658 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e16658 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16658 d108102e12462">
<p>CCM</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16671" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16671 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e16671 d108102e12460">
<p>AES_128_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16671 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16684" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8</p>
</td>
<td class="cellalignment476" headers="d108102e16684 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e16684 d108102e12460">
<p>AES_256_CCM</p>
</td>
<td class="cellalignment476" headers="d108102e16684 d108102e12462">
<p>CCM_8</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16698" headers="d108102e12456">
<p>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16698 d108102e12458">
<p>ECDHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16698 d108102e12460">
<p>AEAD_CHACHA20_POLY1305</p>
</td>
<td class="cellalignment476" headers="d108102e16698 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16711" headers="d108102e12456">
<p>TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16711 d108102e12458">
<p>ECDHE_ECDSA</p>
</td>
<td class="cellalignment476" headers="d108102e16711 d108102e12460">
<p>AEAD_CHACHA20_POLY1305</p>
</td>
<td class="cellalignment476" headers="d108102e16711 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16724" headers="d108102e12456">
<p>TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16724 d108102e12458">
<p>DHE_RSA</p>
</td>
<td class="cellalignment476" headers="d108102e16724 d108102e12460">
<p>AEAD_CHACHA20_POLY1305</p>
</td>
<td class="cellalignment476" headers="d108102e16724 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16737" headers="d108102e12456">
<p>TLS_PSK_WITH_CHACHA20_POLY1305_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16737 d108102e12458">
<p>PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16737 d108102e12460">
<p>AEAD_CHACHA20_POLY1305</p>
</td>
<td class="cellalignment476" headers="d108102e16737 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16750" headers="d108102e12456">
<p>TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16750 d108102e12458">
<p>ECDHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16750 d108102e12460">
<p>AEAD_CHACHA20_POLY1305</p>
</td>
<td class="cellalignment476" headers="d108102e16750 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16763" headers="d108102e12456">
<p>TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16763 d108102e12458">
<p>DHE_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16763 d108102e12460">
<p>AEAD_CHACHA20_POLY1305</p>
</td>
<td class="cellalignment476" headers="d108102e16763 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
<tr class="cellalignment456">
<td class="cellalignment483" id="d108102e16776" headers="d108102e12456">
<p>TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256</p>
</td>
<td class="cellalignment476" headers="d108102e16776 d108102e12458">
<p>RSA_PSK</p>
</td>
<td class="cellalignment476" headers="d108102e16776 d108102e12460">
<p>AEAD_CHACHA20_POLY1305</p>
</td>
<td class="cellalignment476" headers="d108102e16776 d108102e12462">
<p>SHA-256</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" --></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment455">
<tr>
<td class="cellalignment462">
<table class="cellalignment460">
<tr>
<td class="cellalignment459"><a href="kerberos-5-gss-api-mechanism.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment459"><a href="running-jsse-sample-code1.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment464">
<table class="cellalignment458">
<tr>
<td class="cellalignment459"><a href="http://docs.oracle.com/javase/10/index.html"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment459"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment459"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
