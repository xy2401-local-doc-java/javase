<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Use of Java GSS-API for Secure Message Exchanges Without JAAS Programming</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="dcterms.created" content="2018-03-13T07:25:33Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Java Platform, Standard Edition Security Developer&rsquo;s Guide" />
<meta name="dcterms.identifier" content="E91076-01" />
<meta name="dcterms.isVersionOf" content="JSSEC" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1993, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="http://docs.oracle.com/javase/10/index.html" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="when-use-java-gss-api-vs-jsse.htm" title="Previous" type="text/html" />
<link rel="Next" href="jaas-authentication.htm" title="Next" type="text/html" />
<link rel="alternate" href="JSSEC.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-42A2B80C-90CD-4C7A-8EED-8BFFE83CAF56"></a> <span id="PAGE" style="display:none;">24/59</span> <!-- End Header -->
<h1 id="JSSEC-GUID-42A2B80C-90CD-4C7A-8EED-8BFFE83CAF56" class="sect1">Use of Java GSS-API for Secure Message Exchanges Without JAAS Programming</h1>
<div>
<p>This tutorial presents two sample applications demonstrating the use of the Java GSS-API for secure exchanges of messages between communicating applications, in this case a client application and a server application.</p>
<p>Java GSS-API uses what is called a "security mechanism" to provide these services. The GSS-API implementation contains support for the Kerberos V5 mechanism in addition to any other vendor-specific choices. The Kerberos V5 mechanism is used for this tutorial.</p>
<p>In order to perform authentication between the client and server and to establish cryptographic keys for secure communication, a GSS-API mechanism needs access to certain credentials for the local entity on each side of the connection. In our case, the credential used on the client side consists of a Kerberos ticket, and on the server side, it consists of a long-term Kerberos secret key. Kerberos tickets can optionally include the host address and IPv4 and IPv6 host addresses are both supported. Java GSS-API requires that the mechanism obtain these credentials from the Subject associated with the thread's access control context.</p>
<p>To populate a Subject with such credentials, client and server applications typically will first perform JAAS authentication using a Kerberos <span class="apiname">LoginModule</span>. The <a href="jaas-authentication.htm#GUID-0C6EB04B-D203-4688-A3E2-A7D442334623">JAAS Authentication</a> tutorial demonstrates how to do this. The <a href="jaas-authorization.htm#GUID-69241059-CCD0-49F6-838F-DDC752F9F19F">JAAS Authorization</a> tutorial then demonstrates how to associate the authenticated Subject with the thread's access control context. A utility has also been written as a convenience to automatically perform those operations on your behalf. The <a href="use-jaas-login-utility.htm#GUID-F41E74DF-EE54-4EB1-8609-49C6D324ADF5">Use of JAAS Login Utility</a> tutorial demonstrates how to use the Login utility.</p>
<p>For this tutorial, we will not have the client and server perform JAAS authentication, nor will we have them use the Login utility. Instead, we will rely on setting the system property <code class="codeph">javax.security.auth.useSubjectCredsOnly</code> to <code class="codeph">false</code>, which allows us to relax the restriction of requiring a GSS mechanism to obtain necessary credentials from an existing <a href="java-authentication-and-authorization-service-jaas-reference-guide.htm#GUID-804BDE80-9E66-421C-BF0A-A96FBE7DE4E3">Subject</a>, set up by JAAS. See <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-841EB74E-3B52-4421-BC10-FE3C8511E007">The useSubjectCredsOnly System Property</a>.</p>
<div class="infobox-note" id="GUID-42A2B80C-90CD-4C7A-8EED-8BFFE83CAF56__GUID-C1D390A1-E212-48D7-BB3D-B117D67BD365">
<p class="notep1">Note:</p>
<p>This is a simplified introductory tutorial. For example, we do not include any policy files or run the sample code using a security manager. In real life, code using Java GSS-API should be run with a security manager, so that security-sensitive operations would not be allowed unless the required permissions were explicitly granted.</p>
</div>
<p>There is another tutorial, <a href="use-jaas-login-utility-and-java-gss-api-secure-message-exchanges.htm#GUID-C1DFED9D-D3A1-4C11-95D8-3543935E87C8">Use of JAAS Login Utility and Java GSS-API for Secure Message Exchanges</a>, that is just like the tutorial you are reading except that it utilizes the Login utility, policy files, and a more complex login configuration file. A login configuration file (see <a href="appendix-b-jaas-login-configuration-file.htm#GUID-7EB80FA5-3C16-4016-AED6-0FC619F86F8E">Appendix B: JAAS Login Configuration File</a>), required whenever JAAS authentication is done, specifies the desired authentication module.</p>
<p>As with all tutorials in this series, the underlying technology used to support authentication and secure communication for the applications in this tutorial is Kerberos V5. See <a href="kerberos-requirements1.htm#GUID-EAA2758B-3071-4CDA-AEF1-D76F5271E998">Kerberos Requirements</a>.</p>
<ul style="list-style-type: disc;">
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-BEDCBE80-87A3-4124-B891-DF15C55301A5">Overview of the Client and Server Applications</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-0DDC8ACE-7398-41C6-B061-CF3DEAB7AC86">The SampleClient and SampleServer Code</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos User and Service Principal Names</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-2ED6C724-87F1-49EB-9015-32E6E74E3C6A">The Login Configuration File</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-841EB74E-3B52-4421-BC10-FE3C8511E007">The useSubjectCredsOnly System Property</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-DC1FCD2D-101C-4EF2-8034-387CBE66FA3E">Running the SampleClient and SampleServer Programs</a></li>
</ul>
<p>If you want to first see the tutorial code in action, you can skip directly to <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-DC1FCD2D-101C-4EF2-8034-387CBE66FA3E">Running the SampleClient and SampleServer Programs</a> and then go back to the other sections to learn more.</p>
</div>
<div class="sect2"><a id="GUID-BEDCBE80-87A3-4124-B891-DF15C55301A5"></a>
<h2 id="JSSEC-GUID-BEDCBE80-87A3-4124-B891-DF15C55301A5" class="sect2">Overview of the Client and Server Applications</h2>
<div>
<p>The applications for this tutorial are named <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code>.</p>
<p>Here is a summary of execution of the <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> applications:</p>
<ol>
<li>Run the <code class="codeph">SampleServer</code> application. <code class="codeph">SampleServer</code>
<ol>
<li>Reads its argument, the port number that it should listen on for client connections.</li>
<li>Creates a <span class="apiname">ServerSocket</span> for listening for client connections on that port.</li>
<li>Listens for a connection.</li>
</ol>
</li>
<li>Run the <code class="codeph">SampleClient</code> application (possibly on a different machine). <code class="codeph">SampleClient</code>
<ol>
<li>Reads its arguments: (1) The name of the Kerberos principal that represents <code class="codeph">SampleServer</code> (see <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos User and Service Principal Names</a>), (2) the name of the host (machine) on which <code class="codeph">SampleServer</code> is running, and (3) the port number on which <code class="codeph">SampleServer</code> listens for client connections.</li>
<li>Attempts a socket connection with the <code class="codeph">SampleServer</code>, using the host and port it was passed as arguments.</li>
</ol>
</li>
<li>The socket connection is accepted by <code class="codeph">SampleServer</code> and both applications initialize a <span class="apiname">DataInputStream</span> and a <span class="apiname">DataOutputStream</span> from the socket input and output streams, to be used for future data exchanges.</li>
<li><code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> each instantiate a <span class="apiname">GSSContext</span> and follow a protocol for establishing a shared context that will enable subsequent secure data exchanges.</li>
<li><code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> can now securely exchange messages.</li>
<li>When <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> are done exchanging messages, they perform clean-up operations.</li>
</ol>
<p>The actual code and further details are presented in the following sections.</p>
</div>
</div>
<div class="sect2"><a id="GUID-0DDC8ACE-7398-41C6-B061-CF3DEAB7AC86"></a>
<h2 id="JSSEC-GUID-0DDC8ACE-7398-41C6-B061-CF3DEAB7AC86" class="sect2">The SampleClient and SampleServer Code</h2>
<div>
<p>The entire code for both the <a href="source-code-jaas-and-java-gss-api-tutorials.htm#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLECLIENT.JAVA-338923E1"><code>SampleClient.java</code></a> and <a href="source-code-jaas-and-java-gss-api-tutorials.htm#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLESERVER.JAVA-33891DED"><code>SampleServer.java</code></a> programs resides in their <code class="codeph">main</code> methods and can be broken down into the following subparts:</p>
<ol>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-50F25F90-A350-4A21-A06E-44E33209D542">Obtaining the Command-Line Arguments</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-04BC81DE-98D3-42CA-9AC0-45CB4ECEC0BB">Establishing a Socket Connection for Message Exchanges</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-3619B5FA-76CA-4445-8770-8D56CEBA967B">Establishing a Security Context</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-39585A77-5CF3-4122-B4EC-3D778392370D">Exchanging Messages Securely</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-DA54B317-30B2-4666-86B6-B1AD4D627002">Clean Up</a></li>
</ol>
<div class="infobox-note" id="GUID-0DDC8ACE-7398-41C6-B061-CF3DEAB7AC86__GUID-39A47901-8887-47B3-BDCC-CDA90803FABF">
<p class="notep1">Note:</p>
<p>The Java GSS-API classes utilized by these programs (<span class="apiname">GSSManager</span>, <span class="apiname">GSSContext</span>, <span class="apiname">GSSName</span>, <span class="apiname">GSSCredential</span>, <span class="apiname">MessageProp</span>, and <span class="apiname">Oid</span>) are found in the <a href="https://docs.oracle.com/javase/10/docs/api/org/ietf/jgss/package-summary.html" target="_blank"><span class="apiname">org.ietf.jgss</span></a> package.</p>
</div>
</div>
<div class="sect3"><a id="GUID-50F25F90-A350-4A21-A06E-44E33209D542"></a>
<h3 id="JSSEC-GUID-50F25F90-A350-4A21-A06E-44E33209D542" class="sect3">Obtaining the Command-Line Arguments</h3>
<div>
<p>The first thing both our client and server <code class="codeph">main</code> methods do is read the command-line arguments.</p>
</div>
<div class="sect4"><a id="GUID-E4E494AB-4273-4C46-B172-D0DBBF010903"></a>
<h4 id="JSSEC-GUID-E4E494AB-4273-4C46-B172-D0DBBF010903" class="sect4">Arguments Read by SampleClient</h4>
<div>
<p><code class="codeph">SampleClient</code> expects three arguments:</p>
<ol>
<li>A service principal name &ndash; The name of the Kerberos principal that represents <code class="codeph">SampleServer</code> (see <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos User and Service Principal Names</a>).</li>
<li>A host name &ndash; The machine on which <code class="codeph">SampleServer</code> is running.</li>
<li>A port number &ndash; The port number of the port on which <code class="codeph">SampleServer</code> listens for connections.</li>
</ol>
<p>Here is the code for reading the command-line arguments:</p>
<pre dir="ltr">
if (args.length &lt; 3) {
    System.out.println("Usage: java &lt;options&gt; Login SampleClient "
       + " &lt;servicePrincipal&gt; &lt;hostName&gt; &lt;port&gt;");
    System.exit(-1);
}

String server = args[0];
String hostName = args[1];
int port = Integer.parseInt(args[2]);
</pre></div>
</div>
<div class="sect4"><a id="GUID-3E0915A3-9B41-4CA4-90D6-1A039A8B54C0"></a>
<h4 id="JSSEC-GUID-3E0915A3-9B41-4CA4-90D6-1A039A8B54C0" class="sect4">Argument Read by SampleServer</h4>
<div>
<p><code class="codeph">SampleServer</code> expects just one argument:</p>
<ul style="list-style-type: disc;">
<li>A local port number &ndash; The port number used by <code class="codeph">SampleServer</code> for listening for connections with clients. This number should be the same as the port number specified when running the <code class="codeph">SampleClient</code> program.</li>
</ul>
<p>Here is the code for reading the command-line argument:</p>
<pre dir="ltr">
if (args.length != 1) {
    System.out.println(
        "Usage: java &lt;options&gt; Login SampleServer &lt;localPort&gt;");
    System.exit(-1);
}

int localPort = Integer.parseInt(args[0]);
</pre></div>
</div>
</div>
<div class="sect3"><a id="GUID-04BC81DE-98D3-42CA-9AC0-45CB4ECEC0BB"></a>
<h3 id="JSSEC-GUID-04BC81DE-98D3-42CA-9AC0-45CB4ECEC0BB" class="sect3">Establishing a Socket Connection for Message Exchanges</h3>
<div>
<p>Java GSS-API provides methods for creating and interpreting tokens (opaque byte data). The tokens contain messages to be securely exchanged between two peers, but the method of actual token transfer is up to the peers. For our <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> applications, we establish a socket connection between the client and server and exchange data using the socket input and output streams.</p>
</div>
<div class="sect4"><a id="GUID-17E54F39-2231-4271-BBDB-AF72D3D75FF3"></a>
<h4 id="JSSEC-GUID-17E54F39-2231-4271-BBDB-AF72D3D75FF3" class="sect4">SampleClient Code for Socket Connection</h4>
<div>
<p><code class="codeph">SampleClient</code> was passed as arguments the name of the host machine <code class="codeph">SampleServer</code> is running on, as well as the port number on which <code class="codeph">SampleServer</code> will be listening for connections, so <code class="codeph">SampleClient</code> has all it needs to establish a socket connection with <code class="codeph">SampleServer</code>. It uses the following code to set up the connection and initialize a <span class="apiname">DataInputStream</span> and a <span class="apiname">DataOutputStream</span> for future data exchanges:</p>
<pre dir="ltr">
Socket socket = new Socket(hostName, port);

DataInputStream inStream = 
  new DataInputStream(socket.getInputStream());
DataOutputStream outStream = 
  new DataOutputStream(socket.getOutputStream());

System.out.println("Connected to server " 
   + socket.getInetAddress());
</pre></div>
</div>
<div class="sect4"><a id="GUID-6E59BA99-675F-4937-88BB-89268949B356"></a>
<h4 id="JSSEC-GUID-6E59BA99-675F-4937-88BB-89268949B356" class="sect4">SampleServer Code for Socket Connection</h4>
<div>
<p>The <code class="codeph">SampleServer</code> application was passed as an argument the port number to be used for listening for connections from clients. It creates a <code class="codeph">ServerSocket</code> for listening on that port:</p>
<pre dir="ltr">
ServerSocket ss = new ServerSocket(localPort);
</pre>
<p>The <code class="codeph">ServerSocket</code> can then wait for and accept a connection from a client, and then initialize a <span class="apiname">DataInputStream</span> and a <span class="apiname">DataOutputStream</span> for future data exchanges with the client :</p>
<pre dir="ltr">
Socket socket = ss.accept();

DataInputStream inStream =
    new DataInputStream(socket.getInputStream());
DataOutputStream outStream = 
    new DataOutputStream(socket.getOutputStream());

System.out.println("Got connection from client "
    + socket.getInetAddress());
</pre>
<p>The <code class="codeph">accept</code> method waits until a client (in our case, <code class="codeph">SampleClient</code>) requests a connection on the host and port of the <code class="codeph">SampleServer</code>, which <code class="codeph">SampleClient</code> does via</p>
<pre dir="ltr">
Socket socket = new Socket(hostName, port);
</pre>
<p>When the connection is requested and established, the <code class="codeph">accept</code> method returns a new <span class="apiname">Socket</span> object bound to a new port. The server can communicate with the client over this new socket and continue to listen for other client connection requests on the <code class="codeph">ServerSocket</code> bound to the original port. Thus, a server program typically has a loop which can handle multiple connection requests.</p>
<p>The basic loop structure for our <code class="codeph">SampleServer</code> is the following:</p>
<pre dir="ltr">
while (true) {

    Socket socket = ss.accept();

    <span class="italic">&lt;Establish input and output streams for the connection&gt;</span>; 
    <span class="italic">&lt;Establish a context with the client&gt;</span>; 
    <span class="italic">&lt;Exchange messages with the client&gt;</span>;
    <span class="italic">&lt;Clean up&gt;</span>;
}
</pre>
<p>Client connections are queued at the original port, so with this program structure used by <code class="codeph">SampleServer</code>, the interaction with the first client making a connection has to complete before the next connection can be accepted. The server could actually service multiple clients simultaneously through the use of threads &ndash; one thread per client connection, as in</p>
<pre dir="ltr">
while (true) {
    <span class="italic">&lt;accept a connection&gt;</span>;
    <span class="italic">&lt;create a thread to handle the client&gt;</span>;
}
</pre></div>
</div>
</div>
<div class="sect3"><a id="GUID-3619B5FA-76CA-4445-8770-8D56CEBA967B"></a>
<h3 id="JSSEC-GUID-3619B5FA-76CA-4445-8770-8D56CEBA967B" class="sect3">Establishing a Security Context</h3>
<div>
<p>Before two applications can use Java GSS-API to securely exchange messages between them, they must establish a joint security context using their credentials. (Note: In the case of <code class="codeph">SampleClient</code>, the credentials were established when the Login utility authenticated the user on whose behalf the <code class="codeph">SampleClient</code> was run, and similarly for <code class="codeph">SampleServer</code>.) The security context encapsulates shared state information that might include, for example, cryptographic keys. One use of such keys might be to encrypt messages to be exchanged, if encryption is requested.</p>
<p>As part of the security context establishment, the context initiator (in our case, <code class="codeph">SampleClient</code>) is authenticated to the acceptor (<code class="codeph">SampleServer</code>), and may require that the acceptor also be authenticated back to the initiator, in which case we say that "mutual authentication" took place.</p>
<p>Both applications create and use a <span class="apiname">GSSContext</span> object to establish and maintain the shared information that makes up the security context.</p>
<p>The instantiation of the context object is done differently by the context initiator and the context acceptor. After the initiator instantiates a <span class="apiname">GSSContext</span>, it may choose to set various context options that will determine the characteristics of the desired security context, for example, specifying whether or not mutual authentication should take place. After all the desired characteristics have been set, the initiator calls the <code class="codeph">initSecContext</code> method, which produces a token required by the acceptor's <code class="codeph">acceptSecContext</code> method.</p>
<p>While Java GSS-API methods exist for preparing tokens to be exchanged between applications, <span class="variable">it is the responsibility of the applications to actually transfer the tokens between them.</span> So after the initiator has received a token from its call to <code class="codeph">initSecContext</code>, it sends that token to the acceptor. The acceptor calls <code class="codeph">acceptSecContext</code>, passing it the token. The <code class="codeph">acceptSecContext</code> method may in turn return a token. If it does, the acceptor should send that token to the initiator, which should then call <code class="codeph">initSecContext</code> again and pass it this token. Each time <code class="codeph">initSecContext</code> or <code class="codeph">acceptSecContext</code> returns a token, the application that called the method should send the token to its peer and that peer should pass the token to its appropriate method (<code class="codeph">acceptSecContext</code> or <code class="codeph">initSecContext</code>). This continues until the context is fully established (which is the case when the context's <code class="codeph">isEstablished</code> method returns <code class="codeph">true</code>).</p>
<p>The context establishment code for our sample applications is described in the following:</p>
<ul style="list-style-type: disc;">
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-3C5C1A0A-83D7-4AF8-94EC-EEA8112DEBAC">Context Establishment by SampleClient</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-7466BDBC-CB41-4287-802A-C3426B14304A">Context Establishment by SampleServer</a></li>
</ul>
</div>
<div class="sect4"><a id="GUID-3C5C1A0A-83D7-4AF8-94EC-EEA8112DEBAC"></a>
<h4 id="JSSEC-GUID-3C5C1A0A-83D7-4AF8-94EC-EEA8112DEBAC" class="sect4">Context Establishment by SampleClient</h4>
<div>
<p>In our client/server scenario, SampleClient is the context initiator. Here are the basic steps it takes to establish a security context:</p>
<ol>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-5E314B25-F3EF-4F40-BB32-678F9DD71D3B">SampleClient GSSContext Instantiation</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-4D05D762-CD29-4A82-B773-5652A4754BF5">SampleClient Setting of Desired Options</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-AB3C68A2-4E5E-42B2-96C1-C8BDAB5058A7">SampleClient Context Establishment Loop</a>: Loops while the context is not yet established, each time calling <code class="codeph">initSecContext</code>, sending any returned token to <code class="codeph">SampleServer</code>, and receiving a token (if any) from <code class="codeph">SampleServer</code>.</li>
</ol>
</div>
<div class="sect5"><a id="GUID-5E314B25-F3EF-4F40-BB32-678F9DD71D3B"></a>
<h5 id="JSSEC-GUID-5E314B25-F3EF-4F40-BB32-678F9DD71D3B" class="sect5">SampleClient GSSContext Instantiation</h5>
<div>
<p>A <span class="apiname">GSSContext</span> is created by instantiating a <span class="apiname">GSSContext</span> and then calling one of its <code class="codeph">createContext</code> methods. The <span class="apiname">GSSManager</span> class serves as a factory for other important GSS API classes. It can create instances of classes implementing the <span class="apiname">GSSContext</span>, <span class="apiname">GSSCredential</span>, and <span class="apiname">GSSName</span> interfaces.</p>
<p><code class="codeph">SampleClient</code> obtains an instance of the default <span class="apiname">GSSManager</span> subclass by calling the <span class="apiname">GSSManager</span> static method <code class="codeph">getInstance</code>:</p>
<pre dir="ltr">
GSSManager manager = GSSManager.getInstance();
</pre>
<p>The default <span class="apiname">GSSManager</span> subclass is one whose <code class="codeph">create*</code> methods (<code class="codeph">createContext</code>, etc.) return classes whose implementations support Kerberos as the underlying technology.</p>
<p>The <span class="apiname">GSSManager</span> factory method for creating a context on the initiator's side has the following signature:</p>
<pre dir="ltr">
GSSContext createContext(GSSName peer, Oid mech, 
            GSSCredential myCred, int lifetime);
</pre>
<p>The arguments are described below, followed by the complete call to <code class="codeph">createContext</code>.</p>
</div>
<div class="sect6"><a id="GUID-4C2BEA87-066F-4910-B09B-CB9C9B65D896"></a>
<h6 id="JSSEC-GUID-4C2BEA87-066F-4910-B09B-CB9C9B65D896" class="sect6">The GSSName peer Argument</h6>
<div>
<p>The peer in our client/server paradigm is the server. For the <code class="codeph">peer</code> argument, we need a <span class="apiname">GSSName</span> for the service principal representing the server. (See <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos User and Service Principal Names</a>.) A <span class="apiname">String</span> for the service principal name is passed as the first argument to <code class="codeph">SampleClient</code>, which places the argument into its local <span class="apiname">String</span> variable named <code class="codeph">server</code>. The <span class="apiname">GSSManager</span> <code class="codeph">manager</code> is used to instantiate a <span class="apiname">GSSName</span> by calling one of its <code class="codeph">createName</code> methods. <code class="codeph">SampleClient</code> calls the <code class="codeph">createName</code> method with the following signature:</p>
<pre dir="ltr">
GSSName createName(String nameStr, Oid nameType);
</pre>
<p><code class="codeph">SampleClient</code> passes the <code class="codeph">server</code> <span class="apiname">String</span> for the <code class="codeph">nameStr</code> argument.</p>
<p>The second argument is an <span class="apiname">Oid</span>. An <span class="apiname">Oid</span> represents a Universal Object Identifier. Oids are hierarchically globally-interpretable identifiers used within the GSS-API framework to identify mechanisms and name types. The structure and encoding of Oids is defined in the ISOIEC-8824 and ISOIEC-8825 standards. The <span class="apiname">Oid</span> passed to the <code class="codeph">createName</code> method is specifically a name type <span class="apiname">Oid</span> (not a mechanism Oid).</p>
<p>In GSS-API, string names are often mapped from a mechanism-independent format into a mechanism-specific format. Usually, an Oid specifies what name format the string is in so that the mechanism knows how to do this mapping. Passing in a <code class="codeph">null</code> <span class="apiname">Oid</span> indicates that the name is already in a native format that the mechanism uses. This is the case for the <code class="codeph">server</code> String; it is in the appropriate format for a Kerberos Version 5 name. Thus, <code class="codeph">SampleClient</code> passes a <code class="codeph">null</code> for the <span class="apiname">Oid</span>. Here is the call:</p>
<pre dir="ltr">
GSSName serverName = manager.createName(server, null);
</pre></div>
</div>
<div class="sect6"><a id="GUID-25214B28-5B08-4173-874B-7A2CEDDE55FB"></a>
<h6 id="JSSEC-GUID-25214B28-5B08-4173-874B-7A2CEDDE55FB" class="sect6">The Oid mech Argument</h6>
<div>
<p>The second argument to the <span class="apiname">GSSManager</span> <code class="codeph">createContext</code> method is an Oid representing the mechanism to be used for the authentication between the client and the server during context establishment and for subsequent secure communication between them.</p>
<p>Our tutorial will use Kerberos V5 as the security mechanism. The Oid for the Kerberos V5 mechanism is defined in <a href="http://www.ietf.org/rfc/rfc1964.txt" target="_blank">RFC 1964</a> as "1.2.840.113554.1.2.2" so we create such an <span class="apiname">Oid</span>:</p>
<pre dir="ltr">
Oid krb5Oid = new Oid("1.2.840.113554.1.2.2");
</pre>
<p><code class="codeph">SampleClient</code> passes <code class="codeph">krb5Oid</code> as the second argument to <code class="codeph">createContext</code>.</p>
</div>
</div>
<div class="sect6"><a id="GUID-AA193F7A-9EAB-4A3B-88DC-104EA28DB05D"></a>
<h6 id="JSSEC-GUID-AA193F7A-9EAB-4A3B-88DC-104EA28DB05D" class="sect6">The GSSCredential myCred Argument</h6>
<div>
<p>The third argument to the <span class="apiname">GSSManager</span> <code class="codeph">createContext</code> method is a <span class="apiname">GSSCredential</span> representing the caller's credentials. If you pass <code class="codeph">null</code> for this argument, as <span class="apiname">SampleClient</span> does, the default credentials are used.</p>
</div>
</div>
<div class="sect6"><a id="GUID-8728175F-7265-40E3-A10B-82EC27FDEA84"></a>
<h6 id="JSSEC-GUID-8728175F-7265-40E3-A10B-82EC27FDEA84" class="sect6">The int lifetime Argument</h6>
<div>
<p>The final argument to the <span class="apiname">GSSManager</span> <code class="codeph">createContext</code> method is an <code class="codeph">int</code> specifying the desired lifetime, in seconds, for the context that is created. <code class="codeph">SampleClient</code> passes <code class="codeph">GSSContext.DEFAULT_LIFETIME</code> to request a default lifetime.</p>
</div>
</div>
<div class="sect6"><a id="GUID-6DA100F6-33D3-479F-AFB2-1DC61EE2F127"></a>
<h6 id="JSSEC-GUID-6DA100F6-33D3-479F-AFB2-1DC61EE2F127" class="sect6">The Complete createContext Call</h6>
<div>
<p>Now that we have all the required arguments, here is the call <code class="codeph">SampleClient</code> makes to create a <span class="apiname">GSSContext</span>:</p>
<pre dir="ltr">
GSSContext context = 
    manager.createContext(serverName,
                          krb5Oid,
                          null,
                          GSSContext.DEFAULT_LIFETIME);
</pre></div>
</div>
</div>
<div class="sect5"><a id="GUID-4D05D762-CD29-4A82-B773-5652A4754BF5"></a>
<h5 id="JSSEC-GUID-4D05D762-CD29-4A82-B773-5652A4754BF5" class="sect5">SampleClient Setting of Desired Options</h5>
<div>
<p>After instantiating a context, and prior to actually establishing the context with the context acceptor, the context initiator may choose to set various options that determine the desired security context characteristics. Each such option is set by calling a <code class="codeph">request</code> method on the instantiated context. Most <code class="codeph">request</code> methods take a <code class="codeph">boolean</code> argument for indicating whether or not the feature is requested. It is not always possible for a request to be satisfied, so whether or not it was can be determined after context establishment by calling one of the <code class="codeph">get</code> methods.</p>
<p><code class="codeph">SampleClient</code> requests the following:</p>
<ol>
<li><span class="bold">Mutual authentication</span>. The context initiator is always authenticated to the acceptor. If the initiator requests mutual authentication, then the acceptor is also authenticated to the initiator.</li>
<li><span class="bold">Confidentiality</span>. Requesting confidentiality means that you request the <span class="variable">enabling</span> of encryption for the context method named <code class="codeph">wrap</code>. Encryption is actually used only if the <span class="apiname">MessageProp</span> object passed to the <code class="codeph">wrap</code> method requests privacy.</li>
<li><span class="bold">Integrity</span>. This requests integrity for the <code class="codeph">wrap</code> and <code class="codeph">getMIC</code> methods. When integrity is requested, a cryptographic tag known as a Message Integrity Code (MIC) will be generated when calling those methods. When <code class="codeph">getMIC</code> is called, the generated MIC appears in the returned token. When <code class="codeph">wrap</code> is called, the MIC is packaged together with the message (the original message or the result of encrypting the message, depending on whether confidentiality was applied) all as part of one token. You can subsequently verify the MIC against the message to ensure that the message has not been modified in transit.</li>
</ol>
<p>The <code class="codeph">SampleClient</code> code for making these requests on the <code class="codeph">GSSException</code> <code class="codeph">context</code> is the following:</p>
<pre dir="ltr">
context.requestMutualAuth(true);  // Mutual authentication
context.requestConf(true);  // Will use encryption later
context.requestInteg(true); // Will use integrity later
</pre>
<p>After the context is established, the client must explicitly check the context states by calling the accesor methods, like <span class="apiname">getMutualAuthState</span>, <span class="apiname">getConfState</span>, or <span class="apiname">getIntegState</span>, and destroy the security context if any of them do not match the desired state.</p>
<div class="infobox-note" id="GUID-4D05D762-CD29-4A82-B773-5652A4754BF5__GUID-5D58F826-9EF4-432F-8A87-EA1B00074217">
<p class="notep1">Note:</p>
<p>When using the default <span class="apiname">GSSManager</span> implementation and the Kerberos mechanism, these requests will always be granted.</p>
</div>
</div>
</div>
<div class="sect5"><a id="GUID-AB3C68A2-4E5E-42B2-96C1-C8BDAB5058A7"></a>
<h5 id="JSSEC-GUID-AB3C68A2-4E5E-42B2-96C1-C8BDAB5058A7" class="sect5">SampleClient Context Establishment Loop</h5>
<div>
<p>After <code class="codeph">SampleClient</code> has instantiated a <span class="apiname">GSSContext</span> and specified the desired context options, it can actually establish the security context with <code class="codeph">SampleServer</code>. To do so, <code class="codeph">SampleClient</code> has a loop. Each loop iteration</p>
<ol>
<li>Calls the context's <code class="codeph">initSecContext</code> method. If this is the first call, the method is passed a <code class="codeph">null</code> token. Otherwise, it is passed the token most recently sent to <code class="codeph">SampleClient</code> by <code class="codeph">SampleServer</code> (a token generated by a <code class="codeph">SampleServer</code> call to <code class="codeph">acceptSecContext</code>).</li>
<li>Sends the token returned by <code class="codeph">initSecContext</code> (if any) to <code class="codeph">SampleServer</code>. The first call to <code class="codeph">initSecContext</code> always produces a token. The last call might not return a token.</li>
<li>Checks to see if the context is established. If not, <code class="codeph">SampleClient</code> receives another token from <code class="codeph">SampleServer</code> and then starts the next loop iteration.</li>
</ol>
<p>The tokens returned by <code class="codeph">initSecContext</code> or received from <code class="codeph">SampleServer</code> are placed in a byte array. Tokens should be treated by <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> as opaque data to be passed between them and interpreted by Java GSS-API methods.</p>
<p>The <code class="codeph">initSecContext</code> arguments are a byte array containing a token, the starting offset into that array of where the token begins, and the token length. For the first call, <code class="codeph">SampleClient</code> passes a null token, since no token has yet been received from <code class="codeph">SampleServer</code>.</p>
<p>To exchange tokens with <code class="codeph">SampleServer</code>, <code class="codeph">SampleClient</code> uses the <span class="apiname">DataInputStream</span> <code class="codeph">inStream</code> and <span class="apiname">DataOutputStream</span> <code class="codeph">outStream</code> it previously set up using the input and output streams for the socket connection made with <code class="codeph">SampleServer</code>. Note that whenever a token is written, the number of bytes in the token is written first, followed by the token itself. The reasons are discussed in the introduction to the <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-D929F2E0-8AD5-46A3-8A1F-7C30ACE5675B">The SampleClient and SampleServer Message Exchanges</a> section.</p>
<p>Here is the <code class="codeph">SampleClient</code> context establishment loop, followed by code displaying information about who the client and server are and whether or not mutual authentication actually took place:</p>
<pre dir="ltr">
byte[] token = new byte[0];

while (!context.isEstablished()) {

    // token is ignored on the first call
    token = context.<span class="bold">initSecContext</span>(token, 0, token.length);

    // Send a token to the server if one was generated by
    // initSecContext
    if (token != null) {
        System.out.println("Will send token of size "
                   + token.length + " from initSecContext.");
        outStream.writeInt(token.length);
        outStream.write(token);
        outStream.flush();
    }

    // If the client is done with context establishment
    // then there will be no more tokens to read in this loop
    if (!context.isEstablished()) {
        token = new byte[inStream.readInt()];
        System.out.println("Will read input token of size "
                   + token.length
                   + " for processing by initSecContext");
        inStream.readFully(token);
    }
}

System.out.println("Context Established! ");
System.out.println("Client is " + context.getSrcName());
System.out.println("Server is " + context.getTargName());
if (context.getMutualAuthState())
    System.out.println("Mutual authentication took place!");
</pre></div>
</div>
</div>
<div class="sect4"><a id="GUID-7466BDBC-CB41-4287-802A-C3426B14304A"></a>
<h4 id="JSSEC-GUID-7466BDBC-CB41-4287-802A-C3426B14304A" class="sect4">Context Establishment by SampleServer</h4>
<div>
<p>In our client/server scenario, <code class="codeph">SampleServer</code> is the context acceptor. Here are the basic steps it takes to establish a security context:</p>
<ol>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-528478D5-A436-4539-9994-F6F338B02910">SampleServer GSSContext Instantiation</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-AB3C68A2-4E5E-42B2-96C1-C8BDAB5058A7">SampleClient Context Establishment Loop</a>: Loops while the context is not yet established, each time receiving a token from <code class="codeph">SampleClient</code>, calling <code class="codeph">acceptSecContext</code> and passing it the token, and sending any returned token to <code class="codeph">SampleClient</code>.</li>
</ol>
</div>
<div class="sect5"><a id="GUID-528478D5-A436-4539-9994-F6F338B02910"></a>
<h5 id="JSSEC-GUID-528478D5-A436-4539-9994-F6F338B02910" class="sect5">SampleServer GSSContext Instantiation</h5>
<div>
<p>As described in <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-5E314B25-F3EF-4F40-BB32-678F9DD71D3B">SampleClient GSSContext Instantiation</a>, a <span class="apiname">GSSContext</span> is created by instantiating a <span class="apiname">GSSManager</span> and then calling one of its <code class="codeph">createContext</code> methods.</p>
<p>Like <code class="codeph">SampleClient</code>, <code class="codeph">SampleServer</code> obtains an instance of the default <span class="apiname">GSSManager</span> subclass by calling the <span class="apiname">GSSManager</span> static method <code class="codeph">getInstance</code>:</p>
<pre dir="ltr">
GSSManager manager = GSSManager.getInstance();
</pre>
<p>The <span class="apiname">GSSManager</span> factory method for creating a context on the acceptor's side has the following signature:</p>
<pre dir="ltr">
GSSContext createContext(GSSCredential myCred);
</pre>
<p>If you pass <code class="codeph">null</code> for the <span class="apiname">GSSCredential</span> argument, as <code class="codeph">SampleServer</code> does, the default credentials are used. The context is instantiated via the following:</p>
<pre dir="ltr">
GSSContext context = manager.createContext((GSSCredential)null);
</pre></div>
</div>
<div class="sect5"><a id="GUID-0DCD04B3-6461-4F0E-B160-2560909F22CA"></a>
<h5 id="JSSEC-GUID-0DCD04B3-6461-4F0E-B160-2560909F22CA" class="sect5">SampleServer Context Establishment Loop</h5>
<div>
<p>After SampleServer has instantiated a GSSContext, it can establish the security context with SampleClient. To do so, SampleServer has a loop that continues until the context is established. Each loop iteration does the following:</p>
<ol>
<li>Receives a token from SampleClient. This token is the result of a SampleClient <code class="codeph">initSecContext</code> call.</li>
<li>Calls the context's <code class="codeph">acceptSecContext</code> method, passing it the token just received.</li>
<li>If <code class="codeph">acceptSecContext</code> returns a token, then SampleServer sends this token to SampleClient and then starts the next loop iteration if the context is not yet established.</li>
</ol>
<p>The tokens returned by <code class="codeph">acceptSecContext</code> or received from SampleClient are placed in a byte array.</p>
<p>The <code class="codeph">acceptSecContext</code> arguments are a byte array containing a token, the starting offset into that array of where the token begins, and the token length.</p>
<p>To exchange tokens with SampleClient, SampleServer uses the DataInputStream <code class="codeph">inStream</code> and DataOutputStream <code class="codeph">outStream</code> it previously set up using the input and output streams for the socket connection made with SampleClient.</p>
<p>Here is the SampleServer context establishment loop:</p>
<pre dir="ltr">
byte[] token = null;

while (!context.isEstablished()) {

    token = new byte[inStream.readInt()];
    System.out.println("Will read input token of size "
       + token.length
       + " for processing by acceptSecContext");
    inStream.readFully(token);
    
    token = context.<span class="bold">acceptSecContext</span>(token, 0, token.length);
    
    // Send a token to the peer if one was generated by
    // acceptSecContext
    if (token != null) {
        System.out.println("Will send token of size "
           + token.length
           + " from acceptSecContext.");
        outStream.writeInt(token.length);
        outStream.write(token);
        outStream.flush();
    }
}

System.out.print("Context Established! ");
System.out.println("Client is " + context.getSrcName());
System.out.println("Server is " + context.getTargName());
if (context.getMutualAuthState())
    System.out.println("Mutual authentication took place!");
</pre></div>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-39585A77-5CF3-4122-B4EC-3D778392370D"></a>
<h3 id="JSSEC-GUID-39585A77-5CF3-4122-B4EC-3D778392370D" class="sect3">Exchanging Messages Securely</h3>
<div>
<p>Once a security context has been established between <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code>, they can use the context to securely exchange messages.</p>
<ul style="list-style-type: disc;">
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-683071BD-5FAB-4392-BABD-A5A68C145120">GSSContext Methods for Message Exchange</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-D929F2E0-8AD5-46A3-8A1F-7C30ACE5675B">The SampleClient and SampleServer Message Exchanges</a></li>
</ul>
</div>
<div class="sect4"><a id="GUID-683071BD-5FAB-4392-BABD-A5A68C145120"></a>
<h4 id="JSSEC-GUID-683071BD-5FAB-4392-BABD-A5A68C145120" class="sect4">GSSContext Methods for Message Exchange</h4>
<div>
<p>Two types of methods exist for preparing messages for secure exchange: <code class="codeph">wrap</code> and <code class="codeph">getMIC</code>. There are actually two <code class="codeph">wrap</code> methods (and two <code class="codeph">getMIC</code> methods), where the differences between the two are the indication of where the input message is (a byte array or an input stream) and where the output should go (to a byte array return value or to an output stream).</p>
<p>These methods for preparing messages for exchange, and the corresponding methods for interpretation by the peer of the resulting tokens, are described below.</p>
</div>
<div class="sect5"><a id="GUID-F034E83C-1CA8-49E5-8BA7-AD25EFC6A8CD"></a>
<h5 id="JSSEC-GUID-F034E83C-1CA8-49E5-8BA7-AD25EFC6A8CD" class="sect5">wrap</h5>
<div>
<p>The <code class="codeph">wrap</code> method is the primary method for message exchanges.</p>
<p>The signature for the <code class="codeph">wrap</code> method called by <code class="codeph">SampleClient</code> is the following:</p>
<pre dir="ltr">
byte[] wrap (byte[] inBuf, int offset, interface len, 
                MessageProp msgProp)
</pre>
<p>You pass <code class="codeph">wrap</code> a message (in <code class="codeph">inBuf</code>), the offset into <code class="codeph">inBuf</code> where the message begins (<code class="codeph">offset</code>), and the length of the message (<code class="codeph">len</code>). You also pass a <span class="apiname">MessageProp</span>, which is used to indicate the desired QOP (Quality-of-Protection) and to specify whether or not privacy (encryption) is desired. A QOP value selects the cryptographic integrity and encryption (if requested) algorithm(s) to be used. The algorithms corresponding to various QOP values are specified by the provider of the underlying mechanism. For example, the values for Kerberos V5 are defined in <a href="http://www.ietf.org/rfc/rfc1964.txt" target="_blank">RFC 1964</a> in section 4.2. It is common to specify 0 as the QOP value to request the default QOP.</p>
<p>The <code class="codeph">wrap</code> method returns a token containing the message and a cryptographic Message Integrity Code (MIC) over it. The message placed in the token will be encrypted if the <span class="apiname">MessageProp</span> indicates privacy is desired. You do not need to know the format of the returned token; it should be treated as opaque data. You send the returned token to your peer application, which calls the <code class="codeph">unwrap</code> method to "unwrap" the token to get the original message and to verify its integrity.</p>
</div>
</div>
<div class="sect5"><a id="GUID-A722F5F0-0B1D-43DE-A65B-0830999C89D0"></a>
<h5 id="JSSEC-GUID-A722F5F0-0B1D-43DE-A65B-0830999C89D0" class="sect5">getMIC</h5>
<div>
<p>If you simply want to get a token containing a cryptographic Message Integrity Code (MIC) for a supplied message, you call <code class="codeph">getMIC</code>. A sample reason you might want to do this is to confirm with your peer that you both have the same data, by just transporting a MIC for that data without incurring the cost of transporting the data itself to each other.</p>
<p>The signature for the <code class="codeph">getMIC</code> method called by <code class="codeph">SampleServer</code> is the following:</p>
<pre dir="ltr">
byte[] getMIC (byte[] inMsg, int offset, int len,
            MessageProp msgProp)
</pre>
<p>You pass <code class="codeph">getMIC</code> a message (in <code class="codeph">inMsg</code>), the offset into <code class="codeph">inMsg</code> where the message begins (<code class="codeph">offset</code>), and the length of the message (<code class="codeph">len</code>). You also pass a <span class="apiname">MessageProp</span>, which is used to indicate the desired QOP (Quality-of-Protection). It is common to specify 0 as the QOP value to request the default QOP.</p>
<p>If you have a token created by <code class="codeph">getMIC</code> and the message used to calculate the MIC (or a message purported to be the message on which the MIC was calculated), you can call the <code class="codeph">verifyMIC</code> method to verify the MIC for the message. If the verification is successful (that is, if a <span class="apiname">GSSException</span> is not thrown), it proves that the message is exactly the same as it was when the MIC was calculated. A peer receiving a message from an application typically expects a MIC as well, so that they can verify the MIC and be assured the message has not been modified or corrupted in transit. Note: If you know ahead of time that you will want the MIC as well as the message then it is more convenient to use the <code class="codeph">wrap</code> and <code class="codeph">unwrap</code> methods. But there could be situations where the message and the MIC are received separately.</p>
<p>The signature for the <code class="codeph">verifyMIC</code> corresponding to the <code class="codeph">getMIC</code> shown above is the following:</p>
<pre dir="ltr">
void verifyMIC (byte[] inToken, int tokOffset, int tokLen,
        byte[] inMsg, int msgOffset, int msgLen,
        MessageProp msgProp);
</pre>
<p>This verifies the MIC contained in the <code class="codeph">inToken</code> (of length <code class="codeph">tokLen</code>, starting at offset <code class="codeph">tokOffset</code>) over the message contained in <code class="codeph">inMsg</code> (of length <code class="codeph">msgLen</code>, starting at offset <code class="codeph">msgOffset</code>). The <span class="apiname">MessageProp</span> is used by the underlying mechanism to return information to the caller, such as the QOP indicating the strength of protection that was applied to the message.</p>
</div>
</div>
</div>
<div class="sect4"><a id="GUID-D929F2E0-8AD5-46A3-8A1F-7C30ACE5675B"></a>
<h4 id="JSSEC-GUID-D929F2E0-8AD5-46A3-8A1F-7C30ACE5675B" class="sect4">The SampleClient and SampleServer Message Exchanges</h4>
<div>
<p>The message exchanges between SampleClient and SampleServer are summarized below, followed by the coding details.</p>
<p>These steps are the "standard" steps used for verifying a GSS-API client and server. A group at MIT has written a GSS-API client and a GSS-API server that have become fairly popular test programs for checking interoperability between different implementations of the GSS-API library. (These GSS-API sample applications can be downloaded as a part of the Kerberos distribution available from MIT at <a href="http://web.mit.edu/kerberos/" target="_blank">http://web.mit.edu/kerberos</a>.) This client and server from MIT follow the protocol that once the context is established, the client sends a message across and it expects back the MIC on that message. If you implement a GSS-API library, it is common practice to test it by running either the client or server using your library implementation against a corresponding peer server or client that uses another GSS-API library implementation. If both library implementations conform to the standards, then the two peers will be able to communicate successfully.</p>
<p>One implication of testing your client or server against ones written in C (like the MIT ones) is the way tokens must be exchanged. C implementations of GSS-API do not include stream-based methods. In the absence of stream-based methods on your peer, when you write a token you must first write the number of bytes and then write the token. Similarly, when you are reading a token, you first read the number of bytes and then read the token. This is what <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> do.</p>
<p>Here is the summary of the <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> message exchanges:</p>
<ol>
<li><code class="codeph">SampleClient</code> calls <code class="codeph">wrap</code> to encrypt and calculate a MIC for a message.</li>
<li><code class="codeph">SampleClient</code> sends the token returned from <code class="codeph">wrap</code> to <code class="codeph">SampleServer</code>.</li>
<li><code class="codeph">SampleServer</code> calls <code class="codeph">unwrap</code> to obtain the original message and verify its integrity.</li>
<li><code class="codeph">SampleServer</code> calls <code class="codeph">getMIC</code> to calculate a MIC on the decrypted message.</li>
<li><code class="codeph">SampleServer</code> sends the token returned by <code class="codeph">getMIC</code> (which contains the MIC) to <code class="codeph">SampleClient</code>.</li>
<li><code class="codeph">SampleClient</code> calls <code class="codeph">verifyMIC</code> to verify that the MIC sent by <code class="codeph">SampleServer</code> is a valid MIC for the original message.</li>
</ol>
</div>
<div class="sect5"><a id="GUID-BDB7693C-A999-4CDC-BEF1-9D3A207085F9"></a>
<h5 id="JSSEC-GUID-BDB7693C-A999-4CDC-BEF1-9D3A207085F9" class="sect5">SampleClient Code to Encrypt the Message and Send It</h5>
<div>
<p>The <code class="codeph">SampleClient</code> code for encrypting a message, calculating a MIC for it, and sending the result to <code class="codeph">SampleServer</code> is the following:</p>
<pre dir="ltr">
byte[] messageBytes = "Hello There!\0".getBytes();

/*
 * The first MessageProp argument is 0 to request
 * the default Quality-of-Protection.
 * The second argument is true to request
 * privacy (encryption of the message).
 */
MessageProp prop =  new MessageProp(0, true);

/*
 * Encrypt the data and send it across. Integrity protection
 * is always applied, irrespective of encryption.
 */
token = context.<span class="bold">wrap</span>(messageBytes, 0, messageBytes.length, 
    prop);
System.out.println("Will send wrap token of size " 
    + token.length);
outStream.writeInt(token.length);
outStream.write(token);
outStream.flush();
</pre></div>
</div>
<div class="sect5"><a id="GUID-39C5FDB4-97B8-4132-9197-9C58F838F4C9"></a>
<h5 id="JSSEC-GUID-39C5FDB4-97B8-4132-9197-9C58F838F4C9" class="sect5">SampleServer Code to Unwrap Token, Calculate MIC, and Send It</h5>
<div>
<p>The following <code class="codeph">SampleServer</code> code reads the wrapped token sent by <code class="codeph">SampleClient</code> and "unwraps" it to obtain the original message and have its integrity verified. The unwrapping in this case includes decryption since the message was encrypted.</p>
<div class="infobox-note" id="GUID-39C5FDB4-97B8-4132-9197-9C58F838F4C9__GUID-B372F294-8EDD-481C-A627-E64C7D79147F">
<p class="notep1">Note:</p>
<p>Here, the integrity check is expected to succeed. But note that in general if an integrity check fails, it signifies that the message was changed in transit. If the <code class="codeph">unwrap</code> method encounters an integrity check failure, it throws a <span class="apiname">GSSException</span> with major error code <span class="apiname">GSSException.BAD_MIC</span>.</p>
</div>
<pre dir="ltr">
/*
 * Create a MessageProp which unwrap will use to return 
 * information such as the Quality-of-Protection that was 
 * applied to the wrapped token, whether or not it was 
 * encrypted, etc. Since the initial MessageProp values
 * are ignored, it doesn't matter what they are set to.
 */
MessageProp prop = new MessageProp(0, false);

/* 
 * Read the token. This uses the same token byte array 
 * as that used during context establishment.
 */
token = new byte[inStream.readInt()];
System.out.println("Will read token of size " 
    + token.length);
inStream.readFully(token);

byte[] bytes = context.<span class="bold">unwrap</span>(token, 0, token.length, prop);
String str = new String(bytes);
System.out.println("Received data \""
    + str + "\" of length " + str.length());
System.out.println("Encryption applied: "
    + prop.getPrivacy());
</pre>
<p>Next, <code class="codeph">SampleServer</code> generates a MIC for the decrypted message and sends it to <code class="codeph">SampleClient</code>. This is not really necessary but simply illustrates generating a MIC on the decrypted message, which should be exactly the same as the original message <code class="codeph">SampleClient</code> wrapped and sent to <code class="codeph">SampleServer</code>. When <code class="codeph">SampleServer</code> generates this and sends it to <code class="codeph">SampleClient</code>, and <code class="codeph">SampleClient</code> verifies it, this proves to <code class="codeph">SampleClient</code> that the decrypted message <code class="codeph">SampleServer</code> has is in fact exactly the same as the original message from <code class="codeph">SampleClient</code>.</p>
<pre dir="ltr">
/*
 * First reset the QOP of the MessageProp to 0
 * to ensure the default Quality-of-Protection
 * is applied.
 */
prop.setQOP(0);

token = context.<span class="bold">getMIC</span>(bytes, 0, bytes.length, prop);

System.out.println("Will send MIC token of size " 
                   + token.length);
outStream.writeInt(token.length);
outStream.write(token);
outStream.flush();
</pre></div>
</div>
<div class="sect5"><a id="GUID-FF93FB73-B91B-489A-807F-577939ACE8A6"></a>
<h5 id="JSSEC-GUID-FF93FB73-B91B-489A-807F-577939ACE8A6" class="sect5">SampleClient Code to Verify the MIC</h5>
<div>
<p>The following <code class="codeph">SampleClient</code> code reads the MIC calculated by <code class="codeph">SampleServer</code> on the decrypted message and then verifies that the MIC is a MIC for the original message, proving that the decrypted message <code class="codeph">SampleServer</code> has is the same as the original message:</p>
<pre dir="ltr">
token = new byte[inStream.readInt()];
System.out.println("Will read token of size " + token.length);
inStream.readFully(token);

/* 
 * Recall messageBytes is the byte array containing
 * the original message and prop is the MessageProp 
 * already instantiated by SampleClient.
 */
context.<span class="bold">verifyMIC</span>(token, 0, token.length, 
          messageBytes, 0, messageBytes.length,
          prop);

System.out.println("Verified received MIC for message.");
</pre></div>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-DA54B317-30B2-4666-86B6-B1AD4D627002"></a>
<h3 id="JSSEC-GUID-DA54B317-30B2-4666-86B6-B1AD4D627002" class="sect3">Clean Up</h3>
<div>
<p>When <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> have finished exchanging messages, they need to perform cleanup operations. Both contain the following code to</p>
<ul style="list-style-type: disc;">
<li>
<p>close the socket connection and</p>
</li>
<li>
<p>release system resources and cryptographic information stored in the context object and then invalidate the context.</p>
<pre dir="ltr">
socket.close();
context.dispose();
</pre></li>
</ul>
</div>
</div>
</div>
<div class="sect2"><a id="GUID-6D82A7D2-C406-40F4-838A-42ED61194182"></a>
<h2 id="JSSEC-GUID-6D82A7D2-C406-40F4-838A-42ED61194182" class="sect2">Kerberos User and Service Principal Names</h2>
<div>
<p>Since the underlying authentication and secure communication technology used by this tutorial is Kerberos V5, we use Kerberos-style principal names wherever a user or service is called for (see <a href="java-authentication-and-authorization-service-jaas-reference-guide.htm#GUID-8FAF9739-CD62-4A47-9582-884DBF3081F0">Principals</a>).</p>
<p>For example, when you run <code class="codeph">SampleClient</code> you are asked to provide your <span class="bold">user name</span>. Your Kerberos-style user name is simply the user name you were assigned for Kerberos authentication. It consists of a base user name (like <code class="codeph">mjones</code>) followed by an "<code class="codeph">@</code>" and your realm (like <code class="codeph">mjones@KRBNT-OPERATIONS.EXAMPLE.COM</code>).</p>
<p>A server program like <code class="codeph">SampleServer</code> is typically considered to offer a "service" and to be run on behalf of a particular "<span class="bold">service principal</span>." A service principal name for <code class="codeph">SampleServer</code> is needed in several places:</p>
<ul style="list-style-type: disc;">
<li>When you run <code class="codeph">SampleServer</code>, and <code class="codeph">SampleClient</code> attempts a connection to it, the underlying Kerberos mechanism will attempt to authenticate to the Kerberos KDC. It prompts you to log in. You should log in as the appropriate service principal.</li>
<li>When you run <code class="codeph">SampleClient</code>, one of the arguments is the service principal name. This is needed so <code class="codeph">SampleClient</code> can initiate establishment of a security context with the appropriate service.</li>
<li>If the <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> programs were run with a security manager (they're not for this tutorial), the client and server policy files would each require a <span class="apiname">ServicePermission</span> with name equal to the service principal name and action equal to "initiate" or "accept" (for initiating or accepting establishment of a security context).</li>
</ul>
<p>Throughout this document, and in the accompanying login configuration file, <code class="codeph">service_principal@your_realm</code>, is used as a placeholder to be replaced by the actual name to be used in your environment. <span class="italic">Any</span> Kerberos principal can actually be used for the service principal name. So <span class="bold">for the purposes of trying out this tutorial, you could use your user name as both the client user name and the service principal name.</span></p>
<p>In a production environment, system administrators typically like servers to be run as specific principals only and may assign a particular name to be used. Often the Kerberos-style service principal name assigned is of the form</p>
<pre dir="ltr">
service_name/machine_name@realm;
</pre>
<p>For example, an nfs service run on a machine named <code class="codeph">raven</code> in the realm named <code class="codeph">KRBNT-OPERATIONS.EXAMPLE.COM</code> could have the service principal name</p>
<pre dir="ltr">
nfs/raven@KRBNT-OPERATIONS.EXAMPLE.COM
</pre>
<p>Such multi-component names are not required, however. Single-component names, just like those of user principals, can be used. For example, an installation might use the same ftp service principal <code class="codeph">ftp@realm</code> for all ftp servers in that realm, while another installation might have different ftp principals for different ftp servers, such as <code class="codeph">ftp/host1@realm</code> and <code class="codeph">ftp/host2@realm</code> on machines <code class="codeph">host1</code> and <code class="codeph">host2</code>, respectively.</p>
</div>
<div class="sect3"><a id="GUID-B2F0BDD6-C35F-4B99-8AC3-60F0FCD351DF"></a>
<h3 id="JSSEC-GUID-B2F0BDD6-C35F-4B99-8AC3-60F0FCD351DF" class="sect3">When the Realm Is Required in Principal Names</h3>
<div>
<p>If the realm of a user or service principal name is the default realm (see <a href="kerberos-requirements1.htm#GUID-EAA2758B-3071-4CDA-AEF1-D76F5271E998">Kerberos Requirements</a>), you can leave off the realm when you are logging into Kerberos (that is, when you are prompted for your user name). Thus, for example, if your user name is <code class="codeph">mjones@KRBNT-OPERATIONS.EXAMPLE.COM</code>, and you run <code class="codeph">SampleClient</code>, when it requests your user name you could just specify <code class="codeph">mjones</code>, leaving off the realm. The name is interpreted in the context of being a Kerberos principal name and the default realm is appended, as needed.</p>
<p>You can also leave off the realm if a principal name will be converted to a <span class="apiname">GSSName</span> by a <span class="apiname">GSSManager</span> <code class="codeph">createName</code> method. For example, when you run <code class="codeph">SampleClient</code>, one of the arguments is the server service principal name. You can specify the name without including the realm, because <code class="codeph">SampleClient</code> passes the name to such a <code class="codeph">createName</code> method, which appends the default realm as needed.</p>
<p>It is recommended that you always include realms when principal names are used in login configuration files and policy files, because the behavior of the parsers for such files may be implementation-dependent; they may or may not append the default realm before such names are utilized and subsequent actions may fail if there is no realm in the name.</p>
</div>
</div>
</div>
<div class="sect2"><a id="GUID-2ED6C724-87F1-49EB-9015-32E6E74E3C6A"></a>
<h2 id="JSSEC-GUID-2ED6C724-87F1-49EB-9015-32E6E74E3C6A" class="sect2">The Login Configuration File</h2>
<div>
<p>For this tutorial, we are letting the underlying Kerberos mechanism obtain credentials of the users running <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code>, rather than invoking JAAS methods directly (as in the <a href="jaas-authentication.htm#GUID-0C6EB04B-D203-4688-A3E2-A7D442334623">JAAS Authentication</a> and <a href="jaas-authorization.htm#GUID-69241059-CCD0-49F6-838F-DDC752F9F19F">JAAS Authorization</a> tutorials) or indirectly (for example, via the Login utility described in the <a href="use-jaas-login-utility.htm#GUID-F41E74DF-EE54-4EB1-8609-49C6D324ADF5">Use of JAAS Login Utility</a> tutorial and in the <a href="use-jaas-login-utility-and-java-gss-api-secure-message-exchanges.htm#GUID-C1DFED9D-D3A1-4C11-95D8-3543935E87C8">Use of JAAS Login Utility and Java GSS-API for Secure Message Exchanges</a> tutorial).</p>
<p>The default Kerberos mechanism implementation supplied by Oracle actually prompts for a Kerberos name and password and authenticates the specified user (or service) to the Kerberos KDC. The mechanism relies on JAAS to perform this authentication.</p>
<p>JAAS supports a pluggable authentication framework, meaning that any type of authentication module can be plugged under a calling application. A login configuration specifies the login module to be used for a particular application. The default JAAS implementation from Oracle requires that the login configuration information be specified in a file. (Note: Some other vendors might not have file-based implementations.) See <a href="appendix-b-jaas-login-configuration-file.htm#GUID-7EB80FA5-3C16-4016-AED6-0FC619F86F8E">Appendix B: JAAS Login Configuration File</a> for information as to what a login configuration file is, what it contains, and how to specify which login configuration file should be used.</p>
<p>For this tutorial, the Kerberos login module <code class="codeph">com.sun.security.auth.module.Krb5LoginModule</code> is specified in the configuration file. This login module prompts for a Kerberos name and password and attempts to authenticate to the Kerberos KDC.</p>
<p>Both <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> can use the same login configuration file, if that file contains two entries, one entry for the client side and one for the server side.</p>
<p>The <a href="source-code-jaas-and-java-gss-api-tutorials.htm#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__BCSLOGIN.CONF-3389212B"><code>bcsLogin.conf</code></a> login configuration file used for this tutorial is the following:</p>
<pre dir="ltr">
<span class="bold">com.sun.security.jgss.initiate</span>  {
  com.sun.security.auth.module.Krb5LoginModule required;
};

<span class="bold">com.sun.security.jgss.accept</span>  {
  com.sun.security.auth.module.Krb5LoginModule required storeKey=true 
};
</pre>
<p>Entries with these two names (<code class="codeph">com.sun.security.jgss.initiate</code> and <code class="codeph">com.sun.security.jgss.accept</code>) are used by Oracle implementations of GSS-API mechanisms when they need new credentials. Since the mechanism used in this tutorial is the Kerberos V5 mechanism, a Kerberos login module will need to be invoked in order to obtain these credentials. Thus we list <a href="https://docs.oracle.com/javase/10/docs/api/com/sun/security/auth/module/Krb5LoginModule.html" target="_blank"><span class="apiname">Krb5LoginModule</span></a> as a required module in these entries. The <code class="codeph">com.sun.security.jgss.initiate</code> entry specifies the configuration for the client side and the <code class="codeph">com.sun.security.jgss.accept</code> entry for the server side.</p>
<p>The <span class="apiname">Krb5LoginModule</span> succeeds only if the attempt to log in to the Kerberos KDC as a specified entity is successful. When running <code class="codeph">SampleClient</code> or <code class="codeph">SampleServer</code>, the user will be prompted for a name and password.</p>
<p>The <code class="codeph">SampleServer</code> entry <span class="bold"><code class="codeph">storeKey=true</code></span> indicates that a secret key should be calculated from the password provided during login and it should be stored in the private credentials of the <span class="apiname">Subject</span> created as a result of login. This key is subsequently utilized during mutual authentication when establishing a security context between <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code>.</p>
<p>The <a href="https://docs.oracle.com/javase/10/docs/api/com/sun/security/auth/module/Krb5LoginModule.html" target="_blank"><span class="apiname">Krb5LoginModule</span></a> Javadoc API documentation describes the configuration options that the <span class="apiname">Krb5LoginModule</span> class supports.</p>
</div>
</div>
<div class="sect2"><a id="GUID-841EB74E-3B52-4421-BC10-FE3C8511E007"></a>
<h2 id="JSSEC-GUID-841EB74E-3B52-4421-BC10-FE3C8511E007" class="sect2">The useSubjectCredsOnly System Property</h2>
<div>
<p>For this tutorial, we set the system property <code class="codeph">javax.security.auth.useSubjectCredsOnly</code> to <code class="codeph">false</code>, which allows us to relax the usual restriction of requiring a GSS mechanism to obtain necessary credentials from an existing <a href="java-authentication-and-authorization-service-jaas-reference-guide.htm#GUID-804BDE80-9E66-421C-BF0A-A96FBE7DE4E3">Subject</a>, set up by JAAS. When this restriction is relaxed, it allows the mechanism to obtain credentials from some vendor-specific location. For example, some vendors might choose to use the operating system's cache if one exists, while others might choose to read from a protected file on disk.</p>
<p>When this restriction is relaxed, Oracle's Kerberos mechanism still looks for the credentials in the Subject associated with the thread's access control context, but if it doesn't find any there, it performs JAAS authentication using a Kerberos module to obtain new ones. The Kerberos module prompts you for a Kerberos principal name and password. Note that Kerberos mechanism implementations from other vendors may behave differently when this property is set to <code class="codeph">false</code>. Consult their documentation to determine their implementation's behavior.</p>
</div>
</div>
<div class="sect2"><a id="GUID-DC1FCD2D-101C-4EF2-8034-387CBE66FA3E"></a>
<h2 id="JSSEC-GUID-DC1FCD2D-101C-4EF2-8034-387CBE66FA3E" class="sect2">Running the SampleClient and SampleServer Programs</h2>
<div>
<p>To execute the <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> programs, do the following:</p>
<ul style="list-style-type: disc;">
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-758C5F29-2F6A-420B-9BFA-FA741149F3B6">Prepare SampleServer for Execution</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-2D1E8C81-221C-44CC-9B86-7A41C7DCA44B">Prepare SampleClient for Execution</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-9D61C2A9-1E0D-4701-8FBF-F5D31AA4BB2C">Execute SampleServer</a></li>
<li><a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-9AF3C84A-CB43-4F4B-A09D-445D8741FE59">Execute SampleClient</a></li>
</ul>
</div>
<div class="sect3"><a id="GUID-758C5F29-2F6A-420B-9BFA-FA741149F3B6"></a>
<h3 id="JSSEC-GUID-758C5F29-2F6A-420B-9BFA-FA741149F3B6" class="sect3">Prepare SampleServer for Execution</h3>
<div>
<p>To prepare <code class="codeph">SampleServer</code> for execution, do the following:</p>
<ol>
<li>Copy the following files into a directory accessible by the machine on which you will run <code class="codeph">SampleServer</code>:
<ul style="list-style-type: disc;">
<li>The <a href="source-code-jaas-and-java-gss-api-tutorials.htm#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLESERVER.JAVA-33891DED"><code>SampleServer.java</code></a> source file.</li>
<li>The <a href="source-code-jaas-and-java-gss-api-tutorials.htm#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__BCSLOGIN.CONF-3389212B"><code>bcsLogin.conf</code></a> login configuration file.</li>
</ul>
</li>
<li>Compile <code class="codeph">SampleServer.java</code>:
<pre dir="ltr">
javac SampleServer.java
</pre></li>
</ol>
</div>
</div>
<div class="sect3"><a id="GUID-2D1E8C81-221C-44CC-9B86-7A41C7DCA44B"></a>
<h3 id="JSSEC-GUID-2D1E8C81-221C-44CC-9B86-7A41C7DCA44B" class="sect3">Prepare SampleClient for Execution</h3>
<div>
<p>To prepare <code class="codeph">SampleClient</code> for execution, do the following:</p>
<ol>
<li>Copy the following files into a directory accessible by the machine on which you will run <code class="codeph">SampleClient</code>:
<ul style="list-style-type: disc;">
<li>The <a href="source-code-jaas-and-java-gss-api-tutorials.htm#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__SAMPLECLIENT.JAVA-338923E1"><code>SampleClient.java</code></a> source file.</li>
<li>The <a href="source-code-jaas-and-java-gss-api-tutorials.htm#GUID-09D4192C-D855-49D6-BC62-E08F49ADB4F8__BCSLOGIN.CONF-3389212B"><code>bcsLogin.conf</code></a> login configuration file.</li>
</ul>
</li>
<li>Compile <code class="codeph">SampleClient.java</code>:
<pre dir="ltr">
javac SampleClient.java
</pre></li>
</ol>
</div>
</div>
<div class="sect3"><a id="GUID-9D61C2A9-1E0D-4701-8FBF-F5D31AA4BB2C"></a>
<h3 id="JSSEC-GUID-9D61C2A9-1E0D-4701-8FBF-F5D31AA4BB2C" class="sect3">Execute SampleServer</h3>
<div>
<p>It is important to execute <code class="codeph">SampleServer</code> before <code class="codeph">SampleClient</code> because <code class="codeph">SampleClient</code> will try to make a socket connection to <code class="codeph">SampleServer</code> and that will fail if <code class="codeph">SampleServer</code> is not yet running and accepting socket connections.</p>
<p>To execute <code class="codeph">SampleServer</code>, be sure to run it on the machine it is expected to be run on. This machine name (host name) is specified as an argument to <code class="codeph">SampleClient</code>. The service principal name appears in several places, including the login configuration file and the policy files.</p>
<p>Go to the directory in which you have prepared <code class="codeph">SampleServer</code> for execution. Execute <code class="codeph">SampleServer</code>, specifying</p>
<ul style="list-style-type: disc;">
<li>
<p>by <code class="codeph">-Djava.security.krb5.realm=<span class="variable">&lt;your_realm&gt;</span></code> that your Kerberos realm is the one specified.</p>
<p>For example, if your realm is <code class="codeph">KRBNT-OPERATIONS.EXAMPLE.COM</code> you'd put <code class="codeph">-Djava.security.krb5.realm=KRBNT-OPERATIONS.EXAMPLE.COM</code>.</p>
</li>
<li>
<p>by <code class="codeph">-Djava.security.krb5.kdc=<span class="variable">&lt;your_kdc&gt;</span></code> that your Kerberos KDC is the one specified.</p>
<p>For example, if your KDC is <code class="codeph">samplekdc.example.com</code>you'd put <code class="codeph">-Djava.security.krb5.kdc=samplekdc.example.com</code>.</p>
</li>
<li>
<p>by <code class="codeph">-Djavax.security.auth.useSubjectCredsOnly=false</code> that the underlying mechanism can decide how to get credentials. See <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-841EB74E-3B52-4421-BC10-FE3C8511E007">The useSubjectCredsOnly System Property</a>.</p>
</li>
<li>
<p>by <code class="codeph">-Djava.security.auth.login.config=bcsLogin.conf</code> that the login configuration file to be used is <code class="codeph">bcsLogin.conf</code>.</p>
</li>
</ul>
<p>The only argument required by <code class="codeph">SampleServer</code> is one specifying the port number to be used for listening for client connections. Choose a high port number unlikely to be used for anything else. An example would be something like 4444.</p>
<p>Below is the full command to use for both Microsoft Windows and Solaris, Linux, and macOS systems.</p>
<div class="infobox-note" id="GUID-9D61C2A9-1E0D-4701-8FBF-F5D31AA4BB2C__GUID-ADC9E59B-57DF-47DA-890F-4DCC371D84D1">
<p class="notep1">Note:</p>
<p><span class="bold">Important: In this command, you must replace <code class="codeph"><span class="variable">&lt;port_number&gt;</span></code> with an appropriate port number, <code class="codeph"><span class="variable">&lt;your_realm&gt;</span></code> with your Kerberos realm, and <code class="codeph"><span class="variable">&lt;your_kdc&gt;</span></code> with your Kerberos KDC.</span></p>
<p>The <code class="codeph">java.security.krb5.kdc</code> system property interprets the ":" symbol as a separation character for multiple KDCs. If the KDC is not listening on the default port (88), you must provide the default realm and its KDC(s) in a <code>krb5.conf</code> file, then set the system property <code class="codeph">java.security.krb5.kdc.conf</code> with the name of this file:</p>
<pre dir="ltr">
-Djava.security.krb5.conf=<span class="variable">&lt;your_krb5.conf_file&gt;</span>
</pre></div>
<p>Here is the command:</p>
<pre dir="ltr">
java -Djava.security.krb5.realm=<span class="variable">&lt;your_realm&gt;</span> 
 -Djava.security.krb5.kdc=<span class="variable">&lt;your_kdc&gt;</span> 
 -Djavax.security.auth.useSubjectCredsOnly=false
 -Djava.security.auth.login.config=bcsLogin.conf 
 SampleServer <span class="variable">&lt;port_number&gt;</span>
</pre>
<p>The full command should appear on one line (or, on Solaris, Linux, or macOS, on multiple lines where each line but the last is terminated with " \" indicating that there is more to come). Multiple lines are used here just for legibility. Since this command is very long, you may need to place it in a .bat file (for Windows) or a .sh file (for Solaris, Linux, or macOS) and then run that file to execute the command.</p>
<p>The <code class="codeph"><code class="codeph">SampleServer</code></code> code will listen for socket connections on the specified port. When prompted, type the Kerberos name and password for the service principal. The underlying Kerberos authentication mechanism specified in the login configuration file will log the service principal into Kerberos.</p>
<p>For login troubleshooting suggestions, see <a href="troubleshooting.htm#GUID-2087ADBA-6C36-43D5-8841-C79FCB4F5FBE">Troubleshooting</a>.</p>
</div>
</div>
<div class="sect3"><a id="GUID-9AF3C84A-CB43-4F4B-A09D-445D8741FE59"></a>
<h3 id="JSSEC-GUID-9AF3C84A-CB43-4F4B-A09D-445D8741FE59" class="sect3">Execute SampleClient</h3>
<div>
<p>To execute <code class="codeph">SampleClient</code>, first go to the directory in which you have prepared <code class="codeph">SampleClient</code> for execution. Execute <code class="codeph">SampleClient</code>, specifying</p>
<ul style="list-style-type: disc;">
<li>by <code class="codeph">-Djava.security.krb5.realm=<span class="variable">&lt;your_realm&gt;</span></code> that your Kerberos realm is the one specified.</li>
<li>by <code class="codeph">-Djava.security.krb5.kdc=<span class="variable">&lt;your_kdc&gt;</span></code> that your Kerberos KDC is the one specified.</li>
<li>by <code class="codeph">-Djavax.security.auth.useSubjectCredsOnly=false</code> that the underlying mechanism can decide how to get credentials.</li>
<li>by <code class="codeph">-Djava.security.auth.login.config=bcsLogin.conf</code> that the login configuration file to be used is <code class="codeph">bcsLogin.conf</code>.</li>
</ul>
<p>The <code class="codeph">SampleClient</code> arguments are (1) the Kerberos name of the service principal that represents <code class="codeph">SampleServer</code> (see <a href="use-java-gss-api-secure-message-exchanges-jaas-programming.htm#GUID-6D82A7D2-C406-40F4-838A-42ED61194182">Kerberos User and Service Principal Names</a>, (2) the name of the host (machine) on which <code class="codeph">SampleServer</code> is running, and (3) the port number on which <code class="codeph">SampleServer</code> is listening for client connections.</p>
<p>Below is the full command to use for both Windows and Solaris, Linux, and macOS systems.</p>
<div class="infobox-note" id="GUID-9AF3C84A-CB43-4F4B-A09D-445D8741FE59__GUID-AC5953E8-06A3-4527-97BA-108C746A6B98">
<p class="notep1">Note:</p>
<p><span class="bold">Important: In this command, you must replace <code class="codeph"><span class="variable">&lt;service_principal&gt;</span></code>, <code class="codeph"><span class="variable">&lt;host&gt;</span></code>, <code class="codeph"><span class="variable">&lt;port_number&gt;</span></code>, <code class="codeph"><span class="variable">&lt;your_realm&gt;</span></code>, and <code class="codeph"><span class="variable">&lt;your_kdc&gt;</span></code> with appropriate values</span> (and note that the port number must be the same as the port number passed as an argument to <code class="codeph">SampleServer</code>). These values need not be placed in quotes.</p>
</div>
<p>Here is the command:</p>
<pre dir="ltr">
java -Djava.security.krb5.realm=<span class="variable">&lt;your_realm&gt;</span> 
 -Djava.security.krb5.kdc=<span class="variable">&lt;your_kdc&gt;</span> 
 -Djavax.security.auth.useSubjectCredsOnly=false
 -Djava.security.auth.login.config=bcsLogin.conf 
 SampleClient <span class="variable">&lt;service_principal&gt;</span> <span class="variable">&lt;host&gt;</span> <span class="variable">&lt;port_number&gt;</span>
</pre>
<p>Type the full command on one line. Multiple lines are used here for legibility. As with the command for executing <code class="codeph">SampleServer</code>, if the command is too long to type directly into your command window, place it in a .bat file (Windows) or a .sh file (Solaris, Linux, and macOS) and then execute that file.</p>
<p>When prompted, type your Kerberos user name and password. The underlying Kerberos authentication mechanism specified in the login configuration file will log you into Kerberos. The <code class="codeph">SampleClient</code> code requests a socket connection with <code class="codeph">SampleServer</code>. Once <code class="codeph">SampleServer</code> accepts the connection, <code class="codeph">SampleClient</code> and <code class="codeph">SampleServer</code> establish a shared context and then exchange messages as described in this tutorial.</p>
<p>For login troubleshooting suggestions, see <a href="troubleshooting.htm#GUID-2087ADBA-6C36-43D5-8841-C79FCB4F5FBE">Troubleshooting</a>.</p>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment455">
<tr>
<td class="cellalignment462">
<table class="cellalignment460">
<tr>
<td class="cellalignment459"><a href="when-use-java-gss-api-vs-jsse.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment459"><a href="jaas-authentication.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment464">
<table class="cellalignment458">
<tr>
<td class="cellalignment459"><a href="http://docs.oracle.com/javase/10/index.html"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment459"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment459"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
