<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Sample Code Illustrating a Secure Socket Connection Between a Client and a Server</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="description" content="These samples illustrate how to set up a secure socket connection between a client and a server." />
<meta name="dcterms.created" content="2018-03-13T07:25:33Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Java Platform, Standard Edition Security Developer&rsquo;s Guide" />
<meta name="dcterms.identifier" content="E91076-01" />
<meta name="dcterms.isVersionOf" content="JSSEC" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1993, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="http://docs.oracle.com/javase/10/index.html" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="sample-truststores.htm" title="Previous" type="text/html" />
<link rel="Next" href="sample-code-illustrating-https-connections.htm" title="Next" type="text/html" />
<link rel="alternate" href="JSSEC.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-A4D59ABB-62AF-4FC0-900E-A795FDC84E41"></a> <span id="PAGE" style="display:none;">48/59</span> <!-- End Header -->
<h1 id="JSSEC-GUID-A4D59ABB-62AF-4FC0-900E-A795FDC84E41" class="sect1">Sample Code Illustrating a Secure Socket Connection Between a Client and a Server</h1>
<div>
<p>These samples illustrate how to set up a secure socket connection between a client and a server.</p>
<p>When running the sample client programs, you can communicate with an existing server, such as a web server, or you can communicate with the sample server program, <code class="codeph">ClassFileServer</code>. You can run the sample client and the sample server programs on different machines connected to the same network, or you can run them both on one machine but from different terminal windows.</p>
<p>All the sample <code class="codeph">SSLSocketClient*</code> programs in the samples/sockets/client directory (and <code class="codeph">URLReader*</code> programs described in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__SAMPLECODEILLUSTRATINGHTTPSCONNECTI-7D238310">Sample Code Illustrating HTTPS Connections</a>) can be run with the <code class="codeph">ClassFileServer</code> sample server program. An example of how to do this is shown in <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGSSLSOCKETCLIENTWITHCLIENTAUT-7D23BC0C">Running SSLSocketClientWithClientAuth with ClassFileServer</a>. You can make similar changes to run <code class="codeph">URLReader</code>, <code class="codeph">SSLSocketClient</code>, or <code class="codeph">SSLSocketClientWithTunneling</code> with <code class="codeph">ClassFileServer</code>.</p>
<p>If an authentication error occurs during communication between the client and the server (whether using a web server or <code class="codeph">ClassFileServer</code>), it is most likely because the necessary keys are not in the truststore (trust key database). See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-C7BB21C7-E19E-4DE4-8494-CB43F957C329" title="The following are commonly used cryptography terms and their definitions.">Terms and Definitions</a>. For example, the <code class="codeph">ClassFileServer</code> uses a keystore called <code class="codeph">testkeys</code> containing the private key for <code class="codeph">localhost</code> as needed during the SSL handshake. The <code class="codeph">testkeys</code> keystore is included in the same samples/sockets/server directory as the <code class="codeph">ClassFileServer</code> source. If the client cannot find a certificate for the corresponding public key of <code class="codeph">localhost</code> in the truststore it consults, then an authentication error will occur. Be sure to use the <code class="codeph">samplecacerts</code> truststore (which contains the public key and certificate of the <code class="codeph">localhost</code>), as described in <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-B1060A74-9BAE-40F1-AB2B-C8D83812A4C7">Configuration Requirements for SSL Socket Samples</a>.</p>
</div>
<div class="sect2"><a id="GUID-B1060A74-9BAE-40F1-AB2B-C8D83812A4C7"></a>
<h2 id="JSSEC-GUID-B1060A74-9BAE-40F1-AB2B-C8D83812A4C7" class="sect2">Configuration Requirements for SSL Socket Samples</h2>
<div>
<p>When running the sample programs that create a secure socket connection between a client and a server, you will need to make the appropriate certificates file (truststore) available. For both the client and the server programs, you should use the certificates file <code class="codeph">samplecacerts</code> from the <code class="codeph">samples</code> directory. Using this certificates file will allow the client to authenticate the server. The file contains all the common Certificate Authority (CA) certificates shipped with the JDK (in the cacerts file), plus a certificate for <code class="codeph">localhost</code> needed by the client to authenticate <code class="codeph">localhost</code> when communicating with the sample server <code class="codeph">ClassFileServer</code>. The <code class="codeph">ClassFileServer</code> uses a keystore containing the private key for <code class="codeph">localhost</code> that corresponds to the public key in <code class="codeph">samplecacerts</code>.</p>
<p>To make the <code class="codeph">samplecacerts</code> file available to both the client and the server, you can either copy it to the file <code>java-home/lib/security/jssecacerts</code>, rename it to <code>cacerts</code>, and use it to replace the <code>java-home/lib/security/cacerts</code> file, or add the following option to the command line when running the <code class="codeph">java</code> command for both the client and the server:</p>
<pre class="codeblock" dir="ltr">
-Djavax.net.ssl.trustStore=<span class="variable">path_to_samplecacerts_file</span>
</pre>
<p>The password for the <code class="codeph">samplecacerts</code> truststore is <code class="codeph">changeit</code>. You can substitute your own certificates in the samples by using the <code class="codeph">keytool</code> utility.</p>
<p>If you use a browser to access the sample SSL server provided in the <code class="codeph">ClassFileServer</code> example, then a dialog box may pop up with the message that it does not recognize the certificate. This is normal because the certificate used with the sample programs is self-signed and is for testing only. You can accept the certificate for the current session. After testing the SSL server, you should exit the browser, which deletes the test certificate from the browser's namespace.</p>
<p>For client authentication, a separate <code class="codeph">duke</code> certificate is available in the appropriate directories. The public key and certificate is also stored in the <code class="codeph">samplecacerts</code> file.</p>
</div>
</div>
<div class="sect2"><a id="GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666"></a>
<h2 id="JSSEC-GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666" class="sect2">Running SSLSocketClient</h2>
<div>
<p>The example <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666__SSLSOCKETCLIENT.JAVA-32CFECE1"><code>SSLSocketClient.java</code></a> demonstrates how to create a client that uses an <code class="codeph">SSLSocket</code> to send an HTTP request and to get a response from an HTTPS server. By default, this example connects to <code class="codeph">www.verisign.com</code>, but it can easily be adapted to connect to <code>ClassFileServer</code> (see <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C">Running ClassFileServer</a>). The output of this program is the HTML source for <code class="codeph">https://www.verisign.com/index.html</code>.</p>
<p>You must not be behind a firewall to run this program as provided. If you run it from behind a firewall, you will get an <code class="codeph">UnknownHostException</code> because JSSE cannot find a path through your firewall to <code class="codeph">www.verisign.com</code>. To create an equivalent client that can run from behind a firewall, set up proxy tunneling as illustrated in the sample program <code>SSLSocketClientWithTunneling</code>.</p>
<div class="infobox-note" id="GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666__GUID-50A25A9C-8F31-43ED-A0A4-04AE3227AB3E">
<p class="notep1">Note:</p>
<p>The GET request must be slightly modified so that a file is specified.</p>
</div>
<div class="section">
<p class="subhead2">Usage</p>
<pre dir="ltr">
java SSLSocketClient
</pre></div>
<!-- class="section" -->
<div class="section" id="GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666__SSLSOCKETCLIENT.JAVA-32CFECE1">
<p class="subhead2">SSLSocketClient.java</p>
<pre dir="ltr">
import java.net.*;
import java.io.*;
import javax.net.ssl.*;

/*
 * This example demostrates how to use a SSLSocket as client to
 * send a HTTP request and get response from an HTTPS server.
 * It assumes that the client is not behind a firewall
 */

public class SSLSocketClient {

    public static void main(String[] args) throws Exception {
        try {
            SSLSocketFactory factory =
                (SSLSocketFactory)SSLSocketFactory.getDefault();
            SSLSocket socket =
                (SSLSocket)factory.createSocket("www.verisign.com", 443);

            /*
             * send http request
             *
             * Before any application data is sent or received, the
             * SSL socket will do SSL handshaking first to set up
             * the security attributes.
             *
             * SSL handshaking can be initiated by either flushing data
             * down the pipe, or by starting the handshaking by hand.
             *
             * Handshaking is started manually in this example because
             * PrintWriter catches all IOExceptions (including
             * SSLExceptions), sets an internal error flag, and then
             * returns without rethrowing the exception.
             *
             * Unfortunately, this means any error messages are lost,
             * which caused lots of confusion for others using this
             * code.  The only way to tell there was an error is to call
             * PrintWriter.checkError().
             */
            socket.startHandshake();

            PrintWriter out = new PrintWriter(
                                  new BufferedWriter(
                                  new OutputStreamWriter(
                                  socket.getOutputStream())));

            out.println("GET / HTTP/1.0");
            out.println();
            out.flush();

            /*
             * Make sure there were no surprises
             */
            if (out.checkError())
                System.out.println(
                    "SSLSocketClient:  java.io.PrintWriter error");

            /* read response */
            BufferedReader in = new BufferedReader(
                                    new InputStreamReader(
                                    socket.getInputStream()));

            String inputLine;
            while ((inputLine = in.readLine()) != null)
                System.out.println(inputLine);

            in.close();
            out.close();
            socket.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</pre></div>
<!-- class="section" --></div>
</div>
<div class="sect2"><a id="GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9"></a>
<h2 id="JSSEC-GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9" class="sect2">Running SSLSocketClientWithTunnelling</h2>
<div>
<p>The example <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9__SSLSOCKETCLIENTWITHTUNNELING.JAVA-32D03DB5"><code>SSLSocketClientWithTunneling.java</code></a> illustrates how to do proxy tunneling to access a secure web server from behind a firewall.</p>
<p>The program will return the HTML source file from <code class="codeph">https://www.verisign.com/index.html</code>.</p>
<div class="section">
<p class="subhead2">Usage</p>
<p><code class="codeph">java -Dhttps.proxyHost=<span class="variable">webproxy</span> -Dhttps.proxyPort=<span class="variable">ProxyPortNumber</span> SSLSocketClientWithTunneling</code></p>
<p>Replace <code class="codeph"><span class="variable">webproxy</span></code> with the name of your proxy host and <code class="codeph"><span class="variable">ProxyPortNumber</span></code> with the appropriate port number.</p>
<p>The system properties <code class="codeph">https.proxyHost</code> and <code class="codeph">https.proxyPort</code> are used to make a socket connection to the proxy host, and then the <span class="apiname">SSLSocket</span> is layered on top of that <span class="apiname">Socket</span>.</p>
<pre dir="ltr">
</pre></div>
<!-- class="section" -->
<div class="section" id="GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9__SSLSOCKETCLIENTWITHTUNNELING.JAVA-32D03DB5">
<p class="subhead2">SSLSocketClientWithTunneling.java</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
import java.net.*;
import java.io.*;
import javax.net.ssl.*;

/*
 * This example illustrates how to do proxy Tunneling to access a
 * secure web server from behind a firewall.
 *
 * Please set the following Java system properties
 * to the appropriate values:
 *
 *   https.proxyHost = &lt;secure proxy server hostname&gt;
 *   https.proxyPort = &lt;secure proxy server port&gt;
 */

public class SSLSocketClientWithTunneling {

    public static void main(String[] args) throws Exception {
        new SSLSocketClientWithTunneling().doIt("www.verisign.com", 443);
    }

    String tunnelHost;
    int tunnelPort;

    public void doIt(String host, int port) {
        try {

            /*
             * Let's setup the SSLContext first, as there's a lot of
             * computations to be done.  If the socket were created
             * before the SSLContext, the server/proxy might timeout
             * waiting for the client to actually send something.
             */
            SSLSocketFactory factory =
                (SSLSocketFactory)SSLSocketFactory.getDefault();

            /*
             * Set up a socket to do tunneling through the proxy.
             * Start it off as a regular socket, then layer SSL
             * over the top of it.
             */
            tunnelHost = System.getProperty("https.proxyHost");
            tunnelPort = Integer.getInteger("https.proxyPort").intValue();

            Socket tunnel = new Socket(tunnelHost, tunnelPort);
            doTunnelHandshake(tunnel, host, port);

            /*
             * Ok, let's overlay the tunnel socket with SSL.
             */
            SSLSocket socket =
                (SSLSocket)factory.createSocket(tunnel, host, port, true);

            /*
             * register a callback for handshaking completion event
             */
            socket.addHandshakeCompletedListener(
                new HandshakeCompletedListener() {
                    public void handshakeCompleted(
                            HandshakeCompletedEvent event) {
                        System.out.println("Handshake finished!");
                        System.out.println(
                            "\t CipherSuite:" + event.getCipherSuite());
                        System.out.println(
                            "\t SessionId " + event.getSession());
                        System.out.println(
                            "\t PeerHost " + event.getSession().getPeerHost());
                    }
                }
            );

            /*
             * send http request
             *
             * See SSLSocketClient.java for more information about why
             * there is a forced handshake here when using PrintWriters.
             */
            socket.startHandshake();

            PrintWriter out = new PrintWriter(
                                  new BufferedWriter(
                                  new OutputStreamWriter(
                                  socket.getOutputStream())));

            out.println("GET / HTTP/1.0");
            out.println();
            out.flush();

            /*
             * Make sure there were no surprises
             */
            if (out.checkError())
                System.out.println(
                    "SSLSocketClient:  java.io.PrintWriter error");

            /* read response */
            BufferedReader in = new BufferedReader(
                                    new InputStreamReader(
                                    socket.getInputStream()));

            String inputLine;

            while ((inputLine = in.readLine()) != null)
                System.out.println(inputLine);

            in.close();
            out.close();
            socket.close();
            tunnel.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /*
     * Tell our tunnel where we want to CONNECT, and look for the
     * right reply.  Throw IOException if anything goes wrong.
     */
    private void doTunnelHandshake(Socket tunnel, String host, int port)
    throws IOException
    {
        OutputStream out = tunnel.getOutputStream();
        String msg = "CONNECT " + host + ":" + port + " HTTP/1.0\n"
                     + "User-Agent: "
                     + sun.net.www.protocol.http.HttpURLConnection.userAgent
                     + "\r\n\r\n";
        byte b[];
        try {
            /*
             * We really do want ASCII7 -- the http protocol doesn't change
             * with locale.
             */
            b = msg.getBytes("ASCII7");
        } catch (UnsupportedEncodingException ignored) {
            /*
             * If ASCII7 isn't there, something serious is wrong, but
             * Paranoia Is Good (tm)
             */
            b = msg.getBytes();
        }
        out.write(b);
        out.flush();

        /*
         * We need to store the reply so we can create a detailed
         * error message to the user.
         */
        byte            reply[] = new byte[200];
        int             replyLen = 0;
        int             newlinesSeen = 0;
        boolean         headerDone = false;     /* Done on first newline */

        InputStream     in = tunnel.getInputStream();
        boolean         error = false;

        while (newlinesSeen &lt; 2) {
            int i = in.read();
            if (i &lt; 0) {
                throw new IOException("Unexpected EOF from proxy");
            }
            if (i == '\n') {
                headerDone = true;
                ++newlinesSeen;
            } else if (i != '\r') {
                newlinesSeen = 0;
                if (!headerDone &amp;&amp; replyLen &lt; reply.length) {
                    reply[replyLen++] = (byte) i;
                }
            }
        }

        /*
         * Converting the byte array to a string is slightly wasteful
         * in the case where the connection was successful, but it's
         * insignificant compared to the network overhead.
         */
        String replyStr;
        try {
            replyStr = new String(reply, 0, replyLen, "ASCII7");
        } catch (UnsupportedEncodingException ignored) {
            replyStr = new String(reply, 0, replyLen);
        }

        /* We asked for HTTP/1.0, so we should get that back */
        if (!replyStr.startsWith("HTTP/1.0 200")) {
            throw new IOException("Unable to tunnel through "
                    + tunnelHost + ":" + tunnelPort
                    + ".  Proxy returns \"" + replyStr + "\"");
        }

        /* tunneling Handshake was successful! */
    }
}
</pre></div>
</div>
<div class="sect2"><a id="GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B"></a>
<h2 id="JSSEC-GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B" class="sect2">Running SSLSocketClientWithClientAuth</h2>
<div>
<p>The example <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__SSLSOCKETCLIENTWITHCLIENTAUTH.JAVA-32D0CA6C"><code>SSLSocketClientWithClientAuth.java</code></a> is similar to <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-AA1C27A1-2CA8-4309-B281-D6199F60E666">Running SSLSocketClient</a>, but this shows how to set up a key manager to do client authentication if required by a server. This program also assumes that the client is not outside a firewall. You can modify the program to connect from inside a firewall by following the example in <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-B9103D0C-3E6A-4301-B558-461E4CB23DC9">Running SSLSocketClientWithTunnelling</a>.</p>
<p>To run this program, you must specify three parameters: host, port, and requested file path. To mirror the previous examples, you can run this program without client authentication by setting the host to <code class="codeph">www.verisign.com</code>, the port to <code class="codeph">443</code>, and the requested file path to <code class="codeph">https://www.verisign.com/</code>. The output when using these parameters is the HTML for the website <code class="codeph">https://www.verisign.com/</code>.</p>
<p>To run <code class="codeph">SSLSocketClientWithClientAuth</code> to do client authentication, you must access a server that requests client authentication. You can use the sample program <code class="codeph">ClassFileServer</code> as this server. See <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-1B7038DC-7564-4EE6-A1DF-6B1445077E2E">Running SSLSocketClientWithClientAuth with ClassFileServer</a>.</p>
<div class="section">
<p class="subhead2">Usage</p>
<pre dir="ltr">
java SSLSocketClientWithClientAuth <span class="variable">host</span> <span class="variable">port</span> <span class="variable">requestedfilepath</span>
</pre>
<div class="infobox-note" id="GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__IFYOUARECONNECTINGTOTHECLASSFILESER-32D0BDD3">
<p class="notep1">Note:</p>
If you are connecting to the <span class="apiname">ClassFileServer</span> application above, be sure that it can find the credentials for the <code class="codeph">duke</code> user. See <a href="sample-truststores.htm">Sample Truststores</a>.</div>
</div>
<!-- class="section" -->
<div class="section" id="GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__SSLSOCKETCLIENTWITHCLIENTAUTH.JAVA-32D0CA6C">
<p class="subhead2">SSLSocketClientWithClientAuth.java</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
import java.net.*;
import java.io.*;
import javax.net.ssl.*;
import javax.security.cert.X509Certificate;
import java.security.KeyStore;

/*
 * This example shows how to set up a key manager to do client
 * authentication if required by server.
 *
 * This program assumes that the client is not inside a firewall.
 * The application can be modified to connect to a server outside
 * the firewall by following SSLSocketClientWithTunneling.java.
 */
public class SSLSocketClientWithClientAuth {

    public static void main(String[] args) throws Exception {
        String host = null;
        int port = -1;
        String path = null;
        for (int i = 0; i &lt; args.length; i++)
            System.out.println(args[i]);

        if (args.length &lt; 3) {
            System.out.println(
                "USAGE: java SSLSocketClientWithClientAuth " +
                "host port requestedfilepath");
            System.exit(-1);
        }

        try {
            host = args[0];
            port = Integer.parseInt(args[1]);
            path = args[2];
        } catch (IllegalArgumentException e) {
             System.out.println("USAGE: java SSLSocketClientWithClientAuth " +
                 "host port requestedfilepath");
             System.exit(-1);
        }

        try {

            /*
             * Set up a key manager for client authentication
             * if asked by the server.  Use the implementation's
             * default TrustStore and secureRandom routines.
             */
            SSLSocketFactory factory = null;
            try {
                SSLContext ctx;
                KeyManagerFactory kmf;
                KeyStore ks;
                char[] passphrase = "passphrase".toCharArray();

                ctx = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                ks.load(new FileInputStream("testkeys"), passphrase);

                kmf.init(ks, passphrase);
                ctx.init(kmf.getKeyManagers(), null, null);

                factory = ctx.getSocketFactory();
            } catch (Exception e) {
                throw new IOException(e.getMessage());
            }

            SSLSocket socket = (SSLSocket)factory.createSocket(host, port);

            /*
             * send http request
             *
             * See SSLSocketClient.java for more information about why
             * there is a forced handshake here when using PrintWriters.
             */
            socket.startHandshake();

            PrintWriter out = new PrintWriter(
                                  new BufferedWriter(
                                  new OutputStreamWriter(
                                  socket.getOutputStream())));
            out.println("GET " + path + " HTTP/1.0");
            out.println();
            out.flush();

            /*
             * Make sure there were no surprises
             */
            if (out.checkError())
                System.out.println(
                    "SSLSocketClient: java.io.PrintWriter error");

            /* read response */
            BufferedReader in = new BufferedReader(
                                    new InputStreamReader(
                                    socket.getInputStream()));

            String inputLine;

            while ((inputLine = in.readLine()) != null)
                System.out.println(inputLine);

            in.close();
            out.close();
            socket.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</pre></div>
</div>
<div class="sect2"><a id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C"></a>
<h2 id="JSSEC-GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C" class="sect2">Running ClassFileServer</h2>
<div>
<p>This example, which consists of <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSFILESERVER.JAVA-3314B74B"><code>ClassFileServer.java</code></a> and <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSSERVER.JAVA-3314BE5B"><code>ClassServer.java</code></a>, demonstrates the implementation of a mini-webserver, which can service simple HTTP or HTTPS requests (only the GET method is supported). By default, the server does not use SSL/TLS. However, a command-line option enables SSL/TLS. Requests must be of the form:</p>
<pre dir="ltr">
GET /<span class="variable">&lt;filename&gt;</span>
</pre>
<div class="section">
<p class="subhead2">Usage</p>
<pre dir="ltr">
java ClassFileServer <span class="variable">port</span> <span class="variable">docroot</span> [TLS [true]]
</pre>
<ul style="list-style-type: disc;">
<li><code class="codeph"><span class="variable">port</span></code>: The port on which the server resides. It can be any available unused port number, for example, you can use the number <code class="codeph">2001</code>.</li>
<li><code class="codeph"><span class="variable">docroot</span></code>: The root of the local directory hierarchy. It indicates the directory on the server that contains the file you want to retrieve. For example, on Linux, you can use <code>/home/<span class="variable">userid</span>/</code> (where <code><span class="variable">userid</span></code> refers to your particular UID), whereas on Windows systems, you can use <code>C:\</code>.</li>
<li><code class="codeph">TLS</code>: An optional flag which enables SSL/TLS services. If you omit the <code class="codeph">TLS</code> and <code class="codeph">true</code> parameters, which indicates that an ordinary (not TLS) file server should be used, without authentication, then nothing happens. This is because one side (the client) is trying to negotiate with TLS, while the other (the server) is not, so they cannot communicate.</li>
<li><code class="codeph">true</code>: An optional flag which requires that clients authenticate themselves. This option requires that SSL/TLS support be enabled.</li>
</ul>
<p>The secure server comes preinstalled with a certificate for <code class="codeph">localhost</code>. If the server is on the same host as the client, URLs of the form <code class="codeph">https://localhost:<span class="variable">port</span>/<span class="variable">file</span></code> should pass hostname verification. If you choose to run on separate hosts, you should create a new host certificate for the https hostname being used, otherwise there will be hostname mismatch problems. (Note: in Java, this can be corrected in the <span class="apiname">HttpsURLConnection</span> class by providing a custom <span class="apiname">HostnameVerifier</span> implementation, or in a browser by accepting the dialog box that describes the hostname mismatch.)</p>
<p>If you are using the TLS variant (HTTPS), remember to specify the https protocol:</p>
<pre dir="ltr">
<span class="bold">https</span>://hostname:2001/dir1/file1
</pre>
<div class="infobox-note" id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__GUID-9BE85FD2-AF32-451A-855F-132DF2E35267">
<p class="notep1">Note:</p>
If you use a browser, you will see a dialog popup with the message that the application doesn't recognize the <code class="codeph">localhost</code> certificate. This is normal because the self-signed certificate being presented to the browser is not initially trusted. If desired, you could import the <code class="codeph">localhost</code> certificate into the browser's truststore.</div>
</div>
<!-- class="section" -->
<div class="section" id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSFILESERVER.JAVA-3314B74B">
<p class="subhead2">ClassFileServer.java</p>
<pre dir="ltr">
import java.io.*;
import java.net.*;
import java.security.KeyStore;
import javax.net.*;
import javax.net.ssl.*;
import javax.security.cert.X509Certificate;

/* ClassFileServer.java -- a simple file server that can server
 * Http get request in both clear and secure channel
 *
 * The ClassFileServer implements a ClassServer that
 * reads files from the file system. See the
 * doc for the "Main" method for how to run this
 * server.
 */

public class ClassFileServer extends ClassServer {

    private String docroot;

    private static int DefaultServerPort = 2001;

    /**
     * Constructs a ClassFileServer.
     *
     * @param path the path where the server locates files
     */
    public ClassFileServer(ServerSocket ss, String docroot) throws IOException
    {
        super(ss);
        this.docroot = docroot;
    }

    /**
     * Returns an array of bytes containing the bytes for
     * the file represented by the argument &lt;b&gt;path&lt;/b&gt;.
     *
     * @return the bytes for the file
     * @exception FileNotFoundException if the file corresponding
     * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
     */
    public byte[] getBytes(String path)
        throws IOException
    {
        System.out.println("reading: " + path);
        File f = new File(docroot + File.separator + path);
        int length = (int)(f.length());
        if (length == 0) {
            throw new IOException("File length is zero: " + path);
        } else {
            FileInputStream fin = new FileInputStream(f);
            DataInputStream in = new DataInputStream(fin);

            byte[] bytecodes = new byte[length];
            in.readFully(bytecodes);
            return bytecodes;
        }
    }

    /**
     * Main method to create the class server that reads
     * files. This takes two command line arguments, the
     * port on which the server accepts requests and the
     * root of the path. To start up the server: &lt;br&gt;&lt;br&gt;
     *
     * &lt;code&gt;   java ClassFileServer &lt;port&gt; &lt;path&gt;
     * &lt;/code&gt;&lt;br&gt;&lt;br&gt;
     *
     * &lt;code&gt;   new ClassFileServer(port, docroot);
     * &lt;/code&gt;
     */
    public static void main(String args[])
    {
        System.out.println(
            "USAGE: java ClassFileServer port docroot [TLS [true]]");
        System.out.println("");
        System.out.println(
            "If the third argument is TLS, it will start as\n" +
            "a TLS/SSL file server, otherwise, it will be\n" +
            "an ordinary file server. \n" +
            "If the fourth argument is true,it will require\n" +
            "client authentication as well.");

        int port = DefaultServerPort;
        String docroot = "";

        if (args.length &gt;= 1) {
            port = Integer.parseInt(args[0]);
        }

        if (args.length &gt;= 2) {
            docroot = args[1];
        }
        String type = "PlainSocket";
        if (args.length &gt;= 3) {
            type = args[2];
        }
        try {
            ServerSocketFactory ssf =
                ClassFileServer.getServerSocketFactory(type);
            ServerSocket ss = ssf.createServerSocket(port);
            if (args.length &gt;= 4 &amp;&amp; args[3].equals("true")) {
                ((SSLServerSocket)ss).setNeedClientAuth(true);
            }
            new ClassFileServer(ss, docroot);
        } catch (IOException e) {
            System.out.println("Unable to start ClassServer: " +
                               e.getMessage());
            e.printStackTrace();
        }
    }

    private static ServerSocketFactory getServerSocketFactory(String type) {
        if (type.equals("TLS")) {
            SSLServerSocketFactory ssf = null;
            try {
                // set up key manager to do server authentication
                SSLContext ctx;
                KeyManagerFactory kmf;
                KeyStore ks;
                char[] passphrase = "passphrase".toCharArray();

                ctx = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                ks.load(new FileInputStream("testkeys"), passphrase);
                kmf.init(ks, passphrase);
                ctx.init(kmf.getKeyManagers(), null, null);

                ssf = ctx.getServerSocketFactory();
                return ssf;
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            return ServerSocketFactory.getDefault();
        }
        return null;
    }
}
</pre></div>
<!-- class="section" -->
<div class="section" id="GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSSERVER.JAVA-3314BE5B">
<p class="subhead2">ClassServer.java</p>
<pre dir="ltr">
import java.io.*;
import java.net.*;
import javax.net.*;

/*
 * ClassServer.java -- a simple file server that can serve
 * Http get request in both clear and secure channel
 */

public abstract class ClassServer implements Runnable {

    private ServerSocket server = null;
    /**
     * Constructs a ClassServer based on &lt;b&gt;ss&lt;/b&gt; and
     * obtains a file's bytecodes using the method &lt;b&gt;getBytes&lt;/b&gt;.
     *
     */
    protected ClassServer(ServerSocket ss)
    {
        server = ss;
        newListener();
    }

    /**
     * Returns an array of bytes containing the bytes for
     * the file represented by the argument &lt;b&gt;path&lt;/b&gt;.
     *
     * @return the bytes for the file
     * @exception FileNotFoundException if the file corresponding
     * to &lt;b&gt;path&lt;/b&gt; could not be loaded.
     * @exception IOException if error occurs reading the class
     */
    public abstract byte[] getBytes(String path)
        throws IOException, FileNotFoundException;

    /**
     * The "listen" thread that accepts a connection to the
     * server, parses the header to obtain the file name
     * and sends back the bytes for the file (or error
     * if the file is not found or the response was malformed).
     */
    public void run()
    {
        Socket socket;

        // accept a connection
        try {
            socket = server.accept();
        } catch (IOException e) {
            System.out.println("Class Server died: " + e.getMessage());
            e.printStackTrace();
            return;
        }

        // create a new thread to accept the next connection
        newListener();

        try {
            OutputStream rawOut = socket.getOutputStream();

            PrintWriter out = new PrintWriter(
                                new BufferedWriter(
                                new OutputStreamWriter(
                                rawOut)));
            try {
                // get path to class file from header
                BufferedReader in =
                    new BufferedReader(
                        new InputStreamReader(socket.getInputStream()));
                String path = getPath(in);
                // retrieve bytecodes
                byte[] bytecodes = getBytes(path);
                // send bytecodes in response (assumes HTTP/1.0 or later)
                try {
                    out.print("HTTP/1.0 200 OK\r\n");
                    out.print("Content-Length: " + bytecodes.length +
                                   "\r\n");
                    out.print("Content-Type: text/html\r\n\r\n");
                    out.flush();
                    rawOut.write(bytecodes);
                    rawOut.flush();
                } catch (IOException ie) {
                    ie.printStackTrace();
                    return;
                }

            } catch (Exception e) {
                e.printStackTrace();
                // write out error response
                out.println("HTTP/1.0 400 " + e.getMessage() + "\r\n");
                out.println("Content-Type: text/html\r\n\r\n");
                out.flush();
            }

        } catch (IOException ex) {
            // eat exception (could log error to log file, but
            // write out to stdout for now).
            System.out.println("error writing response: " + ex.getMessage());
            ex.printStackTrace();

        } finally {
            try {
                socket.close();
            } catch (IOException e) {
            }
        }
    }

    /**
     * Create a new thread to listen.
     */
    private void newListener()
    {
        (new Thread(this)).start();
    }

    /**
     * Returns the path to the file obtained from
     * parsing the HTML header.
     */
    private static String getPath(BufferedReader in)
        throws IOException
    {
        String line = in.readLine();
        String path = "";
        // extract class from GET line
        if (line.startsWith("GET /")) {
            line = line.substring(5, line.length()-1).trim();
            int index = line.indexOf(' ');
            if (index != -1) {
                path = line.substring(0, index);
            }
        }

        // eat the rest of header
        do {
            line = in.readLine();
        } while ((line.length() != 0) &amp;&amp;
                 (line.charAt(0) != '\r') &amp;&amp; (line.charAt(0) != '\n'));

        if (path.length() != 0) {
            return path;
        } else {
            throw new IOException("Malformed Header");
        }
    }
}
</pre></div>
<!-- class="section" --></div>
</div>
<div class="sect2"><a id="GUID-1B7038DC-7564-4EE6-A1DF-6B1445077E2E"></a>
<h2 id="JSSEC-GUID-1B7038DC-7564-4EE6-A1DF-6B1445077E2E" class="sect2">Running SSLSocketClientWithClientAuth with ClassFileServer</h2>
<div>
<p>You can use the sample programs <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-756AE510-E1BF-42FE-92FC-B9BE3EC31C7B__SSLSOCKETCLIENTWITHCLIENTAUTH.JAVA-32D0CA6C"><code>SSLSocketClientWithClientAuth.java</code></a> and <a href="sample-code-illustrating-secure-socket-connection-client-and-server.htm#GUID-3561ED02-174C-4E65-8BB1-5995E9B7282C__CLASSFILESERVER.JAVA-3314B74B"><code class="codeph">ClassFileServer.;ava</code></a> to set up authenticated communication, where the client and server are authenticated to each other. You can run both sample programs on different machines connected to the same network, or you can run them both on one machine but from different terminal windows or command prompt windows. To set up both the client and the server, do the following:</p>
<ol>
<li>Run the program <code class="codeph">ClassFileServer</code> from one machine or terminal window. See <a href="java-secure-socket-extension-jsse-reference-guide.htm#GUID-1E8A0301-BD82-4E6A-BEB7-B76FE8F554BA__RUNNINGCLASSFILESERVER-7D23BEFC">Running ClassFileServer</a>.</li>
<li>Run the program <code class="codeph">SSLSocketClientWithClientAuth</code> on another machine or terminal window. <code class="codeph">SSLSocketClientWithClientAuth</code> requires the following parameters:
<ul style="list-style-type: disc;">
<li><code class="codeph">host</code> is the host name of the machine that you are using to run <code class="codeph">ClassFileServer</code>.</li>
<li><code class="codeph">port</code> is the same port that you specified for <code class="codeph">ClassFileServer</code>.</li>
<li><code class="codeph">requestedfilepath</code> indicates the path to the file that you want to retrieve from the server. You must give this parameter as <code class="codeph">/filepath</code>. Forward slashes are required in the file path because it is used as part of a GET statement, which requires forward slashes regardless of what type of operating system you are running. The statement is formed as follows:
<pre class="codeblock" dir="ltr">
"GET " + requestedfilepath + " HTTP/1.0"
</pre></li>
</ul>
</li>
</ol>
<div class="infobox-note" id="GUID-1B7038DC-7564-4EE6-A1DF-6B1445077E2E__GUID-80571B4D-FD52-412D-80AF-BB6FF98147C3">
<p class="notep1">Note:</p>
You can modify the other <code class="codeph">SSLClient*</code> applications' <code class="codeph">GET</code> commands to connect to a local machine running <code class="codeph">ClassFileServer</code>.</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment455">
<tr>
<td class="cellalignment462">
<table class="cellalignment460">
<tr>
<td class="cellalignment459"><a href="sample-truststores.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment459"><a href="sample-code-illustrating-https-connections.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment464">
<table class="cellalignment458">
<tr>
<td class="cellalignment459"><a href="http://docs.oracle.com/javase/10/index.html"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment459"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment459"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
