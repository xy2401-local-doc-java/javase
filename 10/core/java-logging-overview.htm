<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Java Logging Overview</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="dcterms.created" content="2018-03-12T23:55:42Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Java Platform, Standard Edition Core Libraries" />
<meta name="dcterms.identifier" content="E91241-01" />
<meta name="dcterms.isVersionOf" content="JSCOR" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2017, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="http://docs.oracle.com/javase/10/index.html" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="process-api1.htm" title="Previous" type="text/html" />
<link rel="alternate" href="JSCOR.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA"></a> <span id="PAGE" style="display:none;">10/10</span> <!-- End Header -->
<h1 id="JSCOR-GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA" class="sect1"><span class="enumeration_chapter">7</span> Java Logging Overview</h1>
<div>
<p>The Java Logging APIs, contained in the package <a href="https://docs.oracle.com/javase/10/docs/api/java/util/logging/package-summary.html" target="_blank"><span class="apiname">java.util.logging</span></a>, facilitate software servicing and maintenance at customer sites by producing log reports suitable for analysis by end users, system administrators, field service engineers, and software development teams. The Logging APIs capture information such as security failures, configuration errors, performance bottlenecks, and/or bugs in the application or platform.</p>
<p>The core package includes support for delivering plain text or XML-formatted log records to memory, output streams, consoles, files, and sockets. In addition, the logging APIs are capable of interacting with logging services that already exist on the host operating system.</p>
<div class="section">
<p class="subhead1">Topics</p>
<ul style="list-style-type: disc;">
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__OVERVIEWOFCONTROLFLOW-4D022D4F">Overview of Control Flow</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGLEVELS-4D023007">Log Levels</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGGERS-4D023227">Loggers</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGGINGMETHODS-4D0234DF">Logging Methods</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__HANDLERS-4D023767">Handlers</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__FORMATTERS-4D023953">Formatters</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__THELOGMANAGER-4D023AE3">The LogManager</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONFILE-4C48BDCE">Configuration File</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__DEFAULTCONFIGURATION-4D023EDA">Default Configuration</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__DYNAMICCONFIGURATIONUPDATES-4D0240C7">Dynamic Configuration Updates</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__NATIVEMETHODS-4D0242BC">Native Methods</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__XMLDTD-4D0243CB">XML DTD</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__UNIQUEMESSAGEIDS-4D024671">Unique Message IDs</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__SECURITY-4C4493F9">Security</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONMANAGEMENT-4D02480C">Configuration Management</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__PACKAGING-4D024A51">Packaging</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOCALIZATION-4D024B46">Localization</a></li>
<li><a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__REMOTEACCESSANDSERIALIZATION-4D024D3A">Remote Access and Serialization</a></li>
<li><a href="java-logging-overview.htm#GUID-48004124-2C00-49F7-A640-0C0DDA271DBC">Java Logging Examples</a></li>
<li><a href="java-logging-overview.htm#GUID-84971801-F327-4F96-8F35-DA4D6737F857">Appendix A: DTD for XMLFormatter Output</a></li>
</ul>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__OVERVIEWOFCONTROLFLOW-4D022D4F">
<p class="subhead1">Overview of Control Flow</p>
<p>Applications make logging calls on <span class="apiname">Logger</span> objects. <span class="apiname">Logger</span> objects are organized in a hierarchical namespace and child <span class="apiname">Logger</span> objects may inherit some logging properties from their parents in the namespace.</p>
<p>Applications make logging calls on <span class="apiname">Logger</span> objects. These <span class="apiname">Logger</span> objects allocate <span class="apiname">LogRecord</span> objects which are passed to <span class="apiname">Handler</span> objects for publication. Both <span class="apiname">Logger</span> and <span class="apiname">Handler</span> objects may use logging <span class="apiname">Level</span> objects and (optionally) <span class="apiname">Filter</span> objects to decide if they are interested in a particular <span class="apiname">LogRecord</span> object. When it is necessary to publish a <span class="apiname">LogRecord</span> object externally, a <span class="apiname">Handler</span> object can (optionally) use a <span class="apiname">Formatter</span> object to localize and format the message before publishing it to an I/O stream.</p>
<div class="figure" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-45676A2F-2702-43EA-B3FB-22D6EF7C50E5">
<p class="titleinfigure">Figure 7-1 Java Logging Control Flow</p>
<img width="537" height="104" src="img/java_pb_001a.png" alt="This figure illustrates the previous paragraph." title="This figure illustrates the previous paragraph." /></div>
<!-- class="figure" -->
<p>Each <span class="apiname">Logger</span> object keeps track of a set of output <span class="apiname">Handler</span> objects. By default all <span class="apiname">Logger</span> objects also send their output to their parent <span class="apiname">Logger</span>. But <span class="apiname">Logger</span> objects may also be configured to ignore <span class="apiname">Handler</span> objects higher up the tree.</p>
<p>Some <span class="apiname">Handler</span> objects may direct output to other <span class="apiname">Handler</span> objects. For example, the <span class="apiname">MemoryHandler</span> maintains an internal ring buffer of <span class="apiname">LogRecord</span> objects, and on trigger events, it publishes its <span class="apiname">LogRecord</span> object through a target <span class="apiname">Handler</span>. In such cases, any formatting is done by the last <span class="apiname">Handler</span> in the chain.</p>
<div class="figure" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__GUID-56BC5167-3EDF-44DF-88F7-A8F3D2BD40B3">
<p class="titleinfigure">Figure 7-2 Java Logging Control Flow with MemoryHandler</p>
<img width="705" height="104" src="img/java_pb_002a.png" alt="This figure illustrates the previous paragraph." title="This figure illustrates the previous paragraph." /></div>
<!-- class="figure" -->
<p>The APIs are structured so that calls on the Logger APIs can be cheap when logging is disabled. If logging is disabled for a given log level, then the Logger can make a cheap comparison test and return. If logging is enabled for a given log level, the Logger is still careful to minimize costs before passing the <span class="apiname">LogRecord</span> into the <span class="apiname">Handler</span>. In particular, localization and formatting (which are relatively expensive) are deferred until the <span class="apiname">Handler</span> requests them. For example, a <span class="apiname">MemoryHandler</span> can maintain a circular buffer of <span class="apiname">LogRecord</span> objects without having to pay formatting costs.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGLEVELS-4D023007">
<p class="subhead1">Log Levels</p>
<p>Each log message has an associated log <span class="apiname">Level</span> object. The <span class="apiname">Level</span> gives a rough guide to the importance and urgency of a log message. Log <span class="apiname">Level</span> objects encapsulate an integer value, with higher values indicating higher priorities.</p>
<p>The <span class="apiname">Level</span> class defines seven standard log levels, ranging from <span class="apiname">FINEST</span> (the lowest priority, with the lowest value) to <span class="apiname">SEVERE</span> (the highest priority, with the highest value).</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGGERS-4D023227">
<p class="subhead1">Loggers</p>
<p>As stated earlier, client code sends log requests to <span class="apiname">Logger</span> objects. Each logger keeps track of a log level that it is interested in, and discards log requests that are below this level.</p>
<p><span class="apiname">Logger</span> objects are normally named entities, using dot-separated names such as <span class="apiname">java.awt</span>. The namespace is hierarchical and is managed by the <span class="apiname">LogManager</span>. The namespace should typically be aligned with the Java packaging namespace, but is not required to follow it exactly. For example, a Logger called <span class="apiname">java.awt</span> might handle logging requests for classes in the <span class="apiname">java.awt</span> package, but it might also handle logging for classes in <span class="apiname">sun.awt</span> that support the client-visible abstractions defined in the <span class="apiname">java.awt</span> package.</p>
<p>In addition to named <span class="apiname">Logger</span> objects, it is also possible to create anonymous <span class="apiname">Logger</span> objects that don't appear in the shared namespace. See the <a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__SECURITY-4C4493F9">Security</a> section.</p>
<p>Loggers keep track of their parent loggers in the logging namespace. A logger's parent is its nearest extant ancestor in the logging namespace. The root logger (named "") has no parent. Anonymous loggers are all given the root logger as their parent. Loggers may inherit various attributes from their parents in the logger namespace. In particular, a logger may inherit:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Logging level</span>: If a logger's level is set to be null, then the logger will use an effective <span class="apiname">Level</span> that will be obtained by walking up the parent tree and using the first non-null <span class="apiname">Level</span>.</p>
</li>
<li>
<p><span class="bold">Handlers</span>: By default, a <span class="apiname">Logger</span> will log any output messages to its parent's handlers, and so on recursively up the tree.</p>
</li>
<li>
<p><span class="bold">Resource bundle names</span>: If a logger has a null resource bundle name, then it will inherit any resource bundle name defined for its parent, and so on recursively up the tree.</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOGGINGMETHODS-4D0234DF">
<p class="subhead1">Logging Methods</p>
<p>The <span class="apiname">Logger</span> class provides a large set of convenience methods for generating log messages. For convenience, there are methods for each logging level, named after the logging level name. Thus rather than calling <span class="apiname">logger.log(Level.WARNING, ...)</span>, a developer can simply call the convenience method <span class="apiname">logger.warning(...)</span>.</p>
<p>There are two different styles of logging methods, to meet the needs of different communities of users.</p>
<p>First, there are methods that take an explicit source class name and source method name. These methods are intended for developers who want to be able to quickly locate the source of any given logging message. An example of this style is:</p>
<pre dir="ltr">
void warning(String sourceClass, String sourceMethod, String msg);
</pre>
<p>Second, there are a set of methods that do not take explicit source class or source method names. These are intended for developers who want easy-to-use logging and do not require detailed source information.</p>
<pre dir="ltr">
void warning(String msg);
</pre>
<p>For this second set of methods, the Logging framework will make a "best effort" to determine which class and method called into the logging framework and will add this information into the <span class="apiname">LogRecord</span>. However, it is important to realize that this automatically inferred information may only be approximate. Virtual machines perform extensive optimizations when just-in-time compiling and may entirely remove stack frames, making it impossible to reliably locate the calling class and method.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__HANDLERS-4D023767">
<p class="subhead1">Handlers</p>
<p>Java SE provides the following <span class="apiname">Handler</span> classes:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="apiname">StreamHandler</span>: A simple handler for writing formatted records to an <span class="apiname">OutputStream</span>.</p>
</li>
<li>
<p><span class="apiname">ConsoleHandler</span>: A simple handler for writing formatted records to <span class="apiname">System.err</span></p>
</li>
<li>
<p><span class="apiname">FileHandler</span>: A handler that writes formatted log records either to a single file, or to a set of rotating log files.</p>
</li>
<li>
<p><span class="apiname">SocketHandler</span>: A handler that writes formatted log records to remote TCP ports.</p>
</li>
<li>
<p><span class="apiname">MemoryHandler</span>: A handler that buffers log records in memory.</p>
</li>
</ul>
<p>It is fairly straightforward to develop new <span class="apiname">Handler</span> classes. Developers requiring specific functionality can either develop a handler from scratch or subclass one of the provided handlers.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__FORMATTERS-4D023953">
<p class="subhead1">Formatters</p>
<p>Java SE also includes two standard <span class="apiname">Formatter</span> classes:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="apiname">SimpleFormatter</span>: Writes brief "human-readable" summaries of log records.</p>
</li>
<li>
<p><span class="apiname">XMLFormatter</span>: Writes detailed XML-structured information.</p>
</li>
</ul>
<p>As with handlers, it is fairly straightforward to develop new formatters.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__THELOGMANAGER-4D023AE3">
<p class="subhead1">The LogManager</p>
<p>There is a global <span class="apiname">LogManager</span> object that keeps track of global logging information. This includes:</p>
<ul style="list-style-type: disc;">
<li>
<p>A hierarchical namespace of named Loggers.</p>
</li>
<li>
<p>A set of logging control properties read from the configuration file. See the section <a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONFILE-4C48BDCE">Configuration File</a>.</p>
</li>
</ul>
<p>There is a single <span class="apiname">LogManager</span> object that can be retrieved using the static <span class="apiname">LogManager.getLogManager</span> method. This is created during <span class="apiname">LogManager</span> initialization, based on a system property. This property allows container applications (such as EJB containers) to substitute their own subclass of <span class="apiname">LogManager</span> in place of the default class.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONFILE-4C48BDCE">
<p class="subhead1">Configuration File</p>
<p>The logging configuration can be initialized using a logging configuration file that will be read at startup. This logging configuration file is in standard <span class="apiname">java.util.Properties</span> format.</p>
<p>Alternatively, the logging configuration can be initialized by specifying a class that can be used for reading initialization properties. This mechanism allows configuration data to be read from arbitrary sources, such as LDAP and JDBC. See the <a href="java-logging-overview.htm#GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONFILE-4C48BDCE">Configuration File</a> section.</p>
<p>There is a small set of global configuration information. This is specified in the description of the <span class="apiname">LogManager</span> class and includes a list of root-level handlers to install during startup.</p>
<p>The initial configuration may specify levels for particular loggers. These levels are applied to the named logger and any loggers below it in the naming hierarchy. The levels are applied in the order they are defined in the configuration file.</p>
<p>The initial configuration may contain arbitrary properties for use by handlers or by subsystems doing logging. By convention, these properties should use names starting with the name of the handler class or the name of the main <span class="apiname">Logger</span> for the subsystem.</p>
<p>For example, the <span class="apiname">MemoryHandler</span> uses a property <span class="apiname">java.util.logging.MemoryHandler.size</span> to determine the default size for its ring buffer.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__DEFAULTCONFIGURATION-4D023EDA">
<p class="subhead1">Default Configuration</p>
<p>The default logging configuration that ships with the JRE is only a default and can be overridden by ISVs, system administrators, and end users.</p>
<p>The default configuration makes only limited use of disk space. It doesn't flood the user with information, but does make sure to always capture key failure information.</p>
<p>The default configuration establishes a single handler on the root logger for sending output to the console.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__DYNAMICCONFIGURATIONUPDATES-4D0240C7">
<p class="subhead1">Dynamic Configuration Updates</p>
<p>Programmers can update the logging configuration at run time in a variety of ways:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="apiname">FileHandler</span>, <span class="apiname">MemoryHandler</span>, and <span class="apiname">ConsoleHandler</span> objects can all be created with various attributes.</p>
</li>
<li>
<p>New <span class="apiname">Handler</span> objects can be added and old ones removed.</p>
</li>
<li>
<p>New <span class="apiname">Logger</span> object can be created and can be supplied with specific Handlers.</p>
</li>
<li>
<p><span class="apiname">Level</span> objects can be set on target <span class="apiname">Handler</span> objects.</p>
</li>
</ul>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__NATIVEMETHODS-4D0242BC">
<p class="subhead1">Native Methods</p>
<p>There are no native APIs for logging.</p>
<p>Native code that wishes to use the Java Logging mechanisms should make normal JNI calls into the Java Logging APIs.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__XMLDTD-4D0243CB">
<p class="subhead1">XML DTD</p>
<p>The XML DTD used by the <span class="apiname">XMLFormatter</span> is specified in <a href="java-logging-overview.htm#GUID-84971801-F327-4F96-8F35-DA4D6737F857">Appendix A: DTD for XMLFormatter Output</a>.</p>
<p>The DTD is designed with a <code class="codeph">&lt;log&gt;</code> element as the top-level document. Individual log records are then written as <code class="codeph">&lt;record&gt;</code> elements.</p>
<p>Note that in the event of JVM crashes it may not be possible to cleanly terminate an <span class="apiname">XMLFormatter</span> stream with the appropriate closing <code class="codeph">&lt;/log&gt;</code>. Therefore, tools that are analyzing log records should be prepared to cope with un-terminated streams.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__UNIQUEMESSAGEIDS-4D024671">
<p class="subhead1">Unique Message IDs</p>
The Java Logging APIs do not provide any direct support for unique message IDs. Those applications or subsystems requiring unique message IDs should define their own conventions and include the unique IDs in the message strings as appropriate.</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__SECURITY-4C4493F9">
<p class="subhead1">Security</p>
<p>The principal security requirement is that untrusted code should not be able to change the logging configuration. Specifically, if the logging configuration has been set up to log a particular category of information to a particular Handler, then untrusted code should not be able to prevent or disrupt that logging.</p>
<p>The security permission <span class="apiname">LoggingPermission</span> controls updates to the logging configuration.</p>
<p>Trusted applications are given the appropriate <span class="apiname">LoggingPermission</span> so they can call any of the logging configuration APIs. Untrusted applets are a different story. Untrusted applets can create and use named loggers in the normal way, but they are not allowed to change logging control settings, such as adding or removing handlers, or changing log levels. However, untrusted applets are able to create and use their own "anonymous" loggers, using <span class="apiname">Logger.getAnonymousLogger</span>. These anonymous loggers are not registered in the global namespace, and their methods are not access-checked, allowing even untrusted code to change their logging control settings.</p>
<p>The logging framework does not attempt to prevent spoofing. The sources of logging calls cannot be determined reliably, so when a <span class="apiname">LogRecord</span> is published that claims to be from a particular source class and source method, it may be a fabrication. Similarly, formatters such as the <span class="apiname">XMLFormatter</span> do not attempt to protect themselves against nested log messages inside message strings. Thus, a spoof <span class="apiname">LogRecord</span> might contain a spoof set of XML inside its message string to make it look as if there was an additional XML record in the output.</p>
<p>In addition, the logging framework does not attempt to protect itself against denial of service attacks. Any given logging client can flood the logging framework with meaningless messages in an attempt to conceal some important log message.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__CONFIGURATIONMANAGEMENT-4D02480C">
<p class="subhead1">Configuration Management</p>
<p>The APIs are structured so that an initial set of configuration information is read as properties from a configuration file. The configuration information may then be changed programatically by calls on the various logging classes and objects.</p>
<p>In addition, there are methods on <span class="apiname">LogManager</span> that allow the configuration file to be re-read. When this happens, the configuration file values will override any changes that have been made programatically.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__PACKAGING-4D024A51">
<p class="subhead1">Packaging</p>
<p>All of the logging class are in the <code class="codeph">java.*</code> part of the namespace, in the <span class="apiname">java.util.logging</span> package.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__LOCALIZATION-4D024B46">
<p class="subhead1">Localization</p>
<p>Log messages may need to be localized.</p>
<p>Each logger may have a <span class="apiname">ResourceBundle</span> name associated with it. The corresponding <span class="apiname">ResourceBundle</span> can be used to map between raw message strings and localized message strings.</p>
<p>Normally, formatters perform localization. As a convenience, the <span class="apiname">Formatter</span> class provides a <span class="apiname">formatMessage</span> method that provides some basic localization and formatting support.</p>
</div>
<!-- class="section" -->
<div class="section" id="GUID-B83B652C-17EA-48D9-93D2-563AE1FF8EDA__REMOTEACCESSANDSERIALIZATION-4D024D3A">
<p class="subhead1">Remote Access and Serialization</p>
<p>As with most Java platform APIs, the logging APIs are designed for use inside a single address space. All calls are intended to be local. However, it is expected that some handlers will want to forward their output to other systems. There are a variety of ways of doing this:</p>
<p>Some handlers (such as the <span class="apiname">SocketHandler</span>) may write data to other systems using the <span class="apiname">XMLFormatter</span>. This provides a simple, standard, inter-change format that can be parsed and processed on a variety of systems.</p>
<p>Some handlers may wish to pass <span class="apiname">LogRecord</span> objects over RMI. The <span class="apiname">LogRecord</span> class is therefore serializable. However, there is a problem in how to deal with the <span class="apiname">LogRecord</span> parameters. Some parameters may not be serializable and other parameters may have been designed to serialize much more state than is required for logging. To avoid these problems, the <span class="apiname">LogRecord</span> class has a custom <span class="apiname">writeObject</span> method that converts the parameters to strings (using <span class="apiname">Object.toString()</span>) before writing them out.</p>
<p>Most of the logging classes are not intended to be serializable. Both loggers and handlers are stateful classes that are tied into a specific virtual machine. In this respect they are analogous to the <span class="apiname">java.io</span> classes, which are also not serializable.</p>
</div>
<!-- class="section" --></div>
<div class="sect2"><a id="GUID-48004124-2C00-49F7-A640-0C0DDA271DBC"></a>
<h2 id="JSCOR-GUID-48004124-2C00-49F7-A640-0C0DDA271DBC" class="sect2">Java Logging Examples</h2>
<div>
<div class="section">
<p class="subhead2">Simple Use</p>
<p>The following is a small program that performs logging using the default configuration.</p>
<p>This program relies on the root handlers that were established by the <span class="apiname">LogManager</span> based on the configuration file. It creates its own <span class="apiname">Logger</span> object and then makes calls to that <span class="apiname">Logger</span> object to report various events.</p>
<pre dir="ltr">
package com.wombat;
import java.util.logging.*;

public class Nose {
    // Obtain a suitable logger.
    private static Logger logger = Logger.getLogger("com.wombat.nose");
    public static void main(String argv[]) {
        // Log a FINE tracing message
        logger.fine("doing stuff");
        try {
            Wombat.sneeze();
        } catch (Exception ex) {
            // Log the exception
            logger.log(Level.WARNING, "trouble sneezing", ex);
        }
        logger.fine("done");
    }
}
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Changing the Configuration</p>
<p>Here's a small program that dynamically adjusts the logging configuration to send output to a specific file and to get lots of information on wombats. The pattern <code class="codeph">%t</code> means the system temporary directory.</p>
<pre dir="ltr">
public static void main(String[] args) {
    Handler fh = new FileHandler("%t/wombat.log");
    Logger.getLogger("").addHandler(fh);
    Logger.getLogger("com.wombat").setLevel(Level.FINEST);
    ...
}
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Simple Use, Ignoring Global Configuration</p>
<p>Here's a small program that sets up its own logging <span class="apiname">Handler</span> and ignores the global configuration.</p>
<pre dir="ltr">
package com.wombat;

import java.util.logging.*;

public class Nose {
    private static Logger logger = Logger.getLogger("com.wombat.nose");
    private static FileHandler fh = new FileHandler("mylog.txt");
    public static void main(String argv[]) {
        // Send logger output to our FileHandler.
        logger.addHandler(fh);
        // Request that every detail gets logged.
        logger.setLevel(Level.ALL);
        // Log a simple INFO message.
        logger.info("doing stuff");
        try {
            Wombat.sneeze();
        } catch (Exception ex) {
            logger.log(Level.WARNING, "trouble sneezing", ex);
        }
        logger.fine("done");
    }
}
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead2">Sample XML Output</p>
<p>Here's a small sample of what some <span class="apiname">XMLFormatter</span> XML output looks like:</p>
<pre dir="ltr">
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE log SYSTEM "logger.dtd"&gt;
&lt;log&gt;
  &lt;record&gt;
    &lt;date&gt;2015-02-27T09:35:44.885562Z&lt;/date&gt;
    &lt;millis&gt;1425029744885&lt;/millis&gt;
    &lt;nanos&gt;562000&lt;/nanos&gt;
    &lt;sequence&gt;1256&lt;/sequence&gt;
    &lt;logger&gt;kgh.test.fred&lt;/logger&gt;
    &lt;level&gt;INFO&lt;/level&gt;
    &lt;class&gt;kgh.test.XMLTest&lt;/class&gt;
    &lt;method&gt;writeLog&lt;/method&gt;
    &lt;thread&gt;10&lt;/thread&gt;
    &lt;message&gt;Hello world!&lt;/message&gt;
  &lt;/record&gt;
&lt;/log&gt;
</pre></div>
<!-- class="section" --></div>
</div>
<div class="sect2"><a id="GUID-84971801-F327-4F96-8F35-DA4D6737F857"></a>
<h2 id="JSCOR-GUID-84971801-F327-4F96-8F35-DA4D6737F857" class="sect2">Appendix A: DTD for XMLFormatter Output</h2>
<div>
<pre dir="ltr">
&lt;!-- DTD used by the java.util.logging.XMLFormatter --&gt;
&lt;!-- This provides an XML formatted log message. --&gt;

&lt;!-- The document type is "log" which consists of a sequence
of record elements --&gt;
&lt;!ELEMENT log (record*)&gt;

&lt;!-- Each logging call is described by a record element. --&gt;
&lt;!ELEMENT record (date, millis, nanos?, sequence, logger?, level,
class?, method?, thread?, message, key?, catalog?, param*, exception?)&gt;

&lt;!-- Date and time when LogRecord was created in ISO 8601 format --&gt;
&lt;!ELEMENT date (#PCDATA)&gt;

&lt;!-- Time when LogRecord was created in milliseconds since
midnight January 1st, 1970, UTC. --&gt;
&lt;!ELEMENT millis (#PCDATA)&gt;

&lt;!-- Nano second adjustement to add to the time in milliseconds. 
This is an optional element, added since JDK 9, which adds further
precision to the time when LogRecord was created.
 --&gt;
&lt;!ELEMENT nanos (#PCDATA)&gt;

&lt;!-- Unique sequence number within source VM. --&gt;
&lt;!ELEMENT sequence (#PCDATA)&gt;

&lt;!-- Name of source Logger object. --&gt;
&lt;!ELEMENT logger (#PCDATA)&gt;

&lt;!-- Logging level, may be either one of the constant
names from java.util.logging.Level (such as "SEVERE"
or "WARNING") or an integer value such as "20". --&gt;
&lt;!ELEMENT level (#PCDATA)&gt;

&lt;!-- Fully qualified name of class that issued
logging call, e.g. "javax.marsupial.Wombat". --&gt;
&lt;!ELEMENT class (#PCDATA)&gt;

&lt;!-- Name of method that issued logging call.
It may be either an unqualified method name such as
"fred" or it may include argument type information
in parenthesis, for example "fred(int,String)". --&gt;
&lt;!ELEMENT method (#PCDATA)&gt;

&lt;!-- Integer thread ID. --&gt;
&lt;!ELEMENT thread (#PCDATA)&gt;

&lt;!-- The message element contains the text string of a log message. --&gt;
&lt;!ELEMENT message (#PCDATA)&gt;

&lt;!-- If the message string was localized, the key element provides
the original localization message key. --&gt;
&lt;!ELEMENT key (#PCDATA)&gt;

&lt;!-- If the message string was localized, the catalog element provides
the logger's localization resource bundle name. --&gt;
&lt;!ELEMENT catalog (#PCDATA)&gt;

&lt;!-- If the message string was localized, each of the param elements
provides the String value (obtained using Object.toString())
of the corresponding LogRecord parameter. --&gt;
&lt;!ELEMENT param (#PCDATA)&gt;

&lt;!-- An exception consists of an optional message string followed
by a series of StackFrames. Exception elements are used
for Java exceptions and other java Throwables. --&gt;
&lt;!ELEMENT exception (message?, frame+)&gt;

&lt;!-- A frame describes one line in a Throwable backtrace. --&gt;
&lt;!ELEMENT frame (class, method, line?)&gt;

&lt;!-- an integer line number within a class's source file. --&gt;
&lt;!ELEMENT line (#PCDATA)&gt;
</pre></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment167">
<tr>
<td class="cellalignment174">
<table class="cellalignment178">
<tr>
<td class="cellalignment171"><a href="process-api1.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2017, 2018, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment176">
<table class="cellalignment170">
<tr>
<td class="cellalignment171"><a href="http://docs.oracle.com/javase/10/index.html"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment171"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment171"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
