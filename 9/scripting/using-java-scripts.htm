<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Using Java from Scripts</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="description" content="This section describes how to access Java classes and interfaces from scripts." />
<meta name="dcterms.created" content="2017-09-14T18:11:26Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Java Platform, Standard Edition Java Scripting Programmer's Guide" />
<meta name="dcterms.identifier" content="E61650-02" />
<meta name="dcterms.isVersionOf" content="JSJSG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2015, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../index.html" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="java-scripting-api.htm" title="Previous" type="text/html" />
<link rel="alternate" href="JSJSG.pdf" title="PDF version" type="application/pdf" />
<link rel="alternate" href="JSJSG.epub" title="ePub version" type="application/epub+zip" />
<link rel="alternate" href="JSJSG.mobi" title="Mobipocket version" type="application/x-mobipocket-ebook" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-AB5FB8B1-AEE4-4ECE-9ECE-06E1A66F0291"></a> <span id="PAGE" style="display:none;">6/6</span> <!-- End Header -->
<a id="JSJSG115"></a><a id="JSJSG114"></a>
<h1 id="JSJSG-GUID-AB5FB8B1-AEE4-4ECE-9ECE-06E1A66F0291" class="sect1"><span class="enumeration_chapter">3</span> Using Java from Scripts</h1>
<div>
<div><span>This section describes how to access Java classes and interfaces from scripts.</span></div>
<p>The code snippets are written in JavaScript, but you can use any scripting language compliant with JSR 223. Examples can be used as script files, or can be run in an interactive shell one expression at a time. The syntax for accessing fields and methods of objects is the same in JavaScript as it is in Java.</p>
<div class="section">
<p class="subhead1">Topics</p>
<ul style="list-style-type: disc;">
<li><a href="using-java-scripts.htm#GUID-16CE53A6-3DE4-41CD-8251-BE8F748987BC">Accessing Java Classes</a></li>
<li><a href="using-java-scripts.htm#GUID-F725315F-2F0C-48EF-A48B-5E0333B13209">Importing Java Packages and Classes</a></li>
<li><a href="using-java-scripts.htm#GUID-EE70B448-4E7B-4F3B-B534-C5059EC9C8AD">Using Java Arrays</a></li>
<li><a href="using-java-scripts.htm#GUID-CB28D34D-BEDD-49B6-ACC8-E1CCD82694F6">Implementing Java Interfaces</a></li>
<li><a href="using-java-scripts.htm#GUID-2DBF66C2-D89F-4B74-B80C-A5B465E4D1AB">Extending Abstract Java Classes</a></li>
<li><a href="using-java-scripts.htm#GUID-F7E5092F-761B-4C21-83F1-78495AA50DE8">Extending Concrete Java Classes</a></li>
<li><a href="using-java-scripts.htm#GUID-16CE53A6-3DE4-41CD-8251-BE8F748987BC">Accessing Java Classes</a></li>
<li><a href="using-java-scripts.htm#GUID-B2026F05-879F-4AE3-BF12-987E9DBC48D0">Binding Implementations to Classes</a></li>
<li><a href="using-java-scripts.htm#GUID-CD093FF5-43CB-41F4-9975-2D009AEA2494">Selecting Method Overload Variant</a></li>
<li><a href="using-java-scripts.htm#GUID-68CCFBC3-E0F7-45FE-8CCC-CF1A82D91D9A">Mapping Data Types</a></li>
<li><a href="using-java-scripts.htm#GUID-12536D6E-1D76-4E05-8C74-DD7F44DFF167" title="The function Java.asJSONCompatible(obj) accepts a script object and returns an object that is compatible with the expectations of most Java JSON libraries: it exposes all arrays as List objects (rather than Map objects) and all other objects as Map objects.">Passing JSON Objects to Java</a></li>
</ul>
</div>
<!-- class="section" --></div>
<a id="JSJSG116"></a>
<div class="props_rev_3"><a id="GUID-16CE53A6-3DE4-41CD-8251-BE8F748987BC"></a>
<h2 id="JSJSG-GUID-16CE53A6-3DE4-41CD-8251-BE8F748987BC" class="sect2">Accessing Java Classes</h2>
<div>
<p>To access primitive and reference Java types from JavaScript, call the <code class="codeph">Java.type()</code> function, which returns a type object that corresponds to the full name of the class passed in as a string. The following example shows you how to get various type objects:</p>
<pre dir="ltr">
var ArrayList = Java.type("java.util.ArrayList");
var intType = Java.type("int");
var StringArrayType = Java.type("java.lang.String[]");
var int2DArrayType = Java.type("int[][]");
</pre>
<p>The type object returned by the <code class="codeph">Java.type()</code> function can be used in JavaScript code similar to how a class name is used in Java. For example, you can can use it to instantiate new objects as follows:</p>
<pre dir="ltr">
var anArrayList = new Java.type("java.util.ArrayList");
</pre>
<p>Java type objects can be used to instantiate new Java objects. The following example shows you how to instantiate new objects using the default constructor and by passing arguments to another constructor:</p>
<pre dir="ltr">
var ArrayList = Java.type("java.util.ArrayList");
var defaultSizeArrayList = new ArrayList;
var customSizeArrayList = new ArrayList(16);
</pre>
<p>You can use the type object returned by the <code class="codeph">Java.type()</code> function to access static fields and methods as follows:</p>
<pre dir="ltr">
var File = Java.type("java.io.File");
File.createTempFile("nashorn", ".tmp");
</pre>
<p>To access a static inner class, use the dollar sign ($) in the argument passed to the <code class="codeph">Java.type()</code> method. The following example shows how to return the type object of the <code class="codeph">Float</code> inner class in <code class="codeph">java.awt.geom.Arc2D</code>:</p>
<pre dir="ltr">
var Float = Java.type("java.awt.geom.Arc2D$Float");
</pre>
<p>If you already have the outer class type object, then you can access the inner class as a property of the outer class as follows:</p>
<pre dir="ltr">
var Arc2D = Java.type("java.awt.geom.Arc2D")
var Float = Arc2D.Float
</pre>
<p>In case of a nonstatic inner class, you must pass an instance of the outer class as the first argument to the constructor.</p>
<p>Although a type object in JavaScript is used similar to the Java class, it is distinct from the <code class="codeph">java.lang.Class</code> object, which is returned by the <code class="codeph">getClass()</code> method. You can obtain one from the other using the <code class="codeph">class</code> and <code class="codeph">static</code> properties. The following example shows this distinction:</p>
<pre dir="ltr">
var ArrayList = Java.type("java.util.ArrayList");
var a = new ArrayList;

// All of the following are true:
print("Type acts as target of instanceof: " + (a instanceof ArrayList));
print("Class doesn't act as target of instanceof: " + !(a instanceof a.getClass()));
print("Type is not the same as instance's getClass(): " + (a.getClass() !== ArrayList));
print("Type's `class` property is the same as instance's getClass(): " + (a.getClass() === ArrayList.class));
print("Type is the same as the `static` property of the instance's getClass(): " + (a.getClass().static === ArrayList));
</pre>
<p>Syntactically and semantically, this distinction between compile-time class expressions and runtime class objects makes JavaScript similar to Java code. However, there is no equivalent of the <code class="codeph">static</code> property for a <code class="codeph">Class</code> object in Java, because compile-time class expressions are never expressed as objects.</p>
</div>
</div>
<a id="JSJSG117"></a>
<div class="props_rev_3"><a id="GUID-F725315F-2F0C-48EF-A48B-5E0333B13209"></a>
<h2 id="JSJSG-GUID-F725315F-2F0C-48EF-A48B-5E0333B13209" class="sect2">Importing Java Packages and Classes</h2>
<div>
<p>To access Java classes by their simple names, you can use the <code class="codeph">importPackage()</code> and <code class="codeph">importClass()</code> functions to import Java packages and classes. These functions are built into the compatibility script (<code class="codeph">mozilla_compat.js</code>). The following example shows you how to use the <code class="codeph">importPackage()</code> and <code class="codeph">importClass()</code> functions:</p>
<pre dir="ltr">
// Load compatibility script
load("nashorn:mozilla_compat.js");
// Import the java.awt package
importPackage(java.awt);
// Import the java.awt.Frame class
importClass(java.awt.Frame);
// Create a new Frame object
var frame = new java.awt.Frame("hello");
// Call the setVisible() method
frame.setVisible(true);
// Access a JavaBean property
print(frame.title);
</pre>
<p>You can access Java packages using the <code class="codeph">Packages</code> global variable (for example, <code class="codeph">Packages.java.util.Vector</code> or <code class="codeph">Packages.javax.swing.JFrame</code>), but standard Java SE packages have shortcuts (<code class="codeph">java</code> for <code class="codeph">Packages.java</code>, <code class="codeph">javax</code> for <code class="codeph">Packages.javax</code>, and <code class="codeph">org</code> for <code class="codeph">Packages.org</code>).</p>
<p>The <code class="codeph">java.lang</code> package is not imported by default, because its classes would conflict with <code class="codeph">Object</code>, <code class="codeph">Boolean</code>, <code class="codeph">Math</code>, and other built-in JavaScript objects. Furthermore, importing any Java package or class can lead to conflicts with the global variable scope in JavaScript. To avoid this, define a <code class="codeph">JavaImporter</code> object and use the <code class="codeph">with</code> statement to limit the scope of the imported Java packages and classes, as shown in the following example:</p>
<pre dir="ltr">
// Create a JavaImporter object with specified packages and classes to import
var Gui = new JavaImporter(java.awt, javax.swing);

// Pass the JavaImporter object to the "with" statement and access the classes
// from the imported packages by their simple names within the statement's body
with (Gui) {
    var awtframe = new Frame("AWT Frame");
    var jframe = new JFrame("Swing JFrame");
};
</pre></div>
</div>
<a id="JSJSG118"></a>
<div class="props_rev_3"><a id="GUID-EE70B448-4E7B-4F3B-B534-C5059EC9C8AD"></a>
<h2 id="JSJSG-GUID-EE70B448-4E7B-4F3B-B534-C5059EC9C8AD" class="sect2">Using Java Arrays</h2>
<div>
<p>To create a Java array object, you first have to get the Java array type object, and then instantiate it. The syntax for accessing array elements and the <code class="codeph">length</code> property in JavaScript is the same as in Java, as shown in the following example:</p>
<pre dir="ltr">
var StringArray = Java.type("java.lang.String[]");
var a = new StringArray(5);

// Set the value of the first element
a[0] = "Scripting is great!";
// Print the length of the array
print(a.length);
// Print the value of the first element
print(a[0]);
</pre>
<p>Given a JavaScript array, you can convert it to a Java array using the <code class="codeph">Java.to()</code> method. You must pass the JavaScript array variable to this method and the type of array to be returned, either as a string or a type object. You can also omit the array type argument to return an <code class="codeph">Object[]</code> array. Conversion is performed according to the ECMAScript conversion rules. The following example shows you how to convert a JavaScript array to a Java array using various <code class="codeph">Java.to()</code> method arguments:</p>
<pre dir="ltr">
// Create a JavaScript array
var anArray = [1, "13", false];

// Convert the JavaScript array to a Java int[] array
var javaIntArray = Java.to(anArray, "int[]");
print(javaIntArray[0]); // prints the number 1
print(javaIntArray[1]); // prints the number 13
print(javaIntArray[2]); // prints the number 0

// Convert the JavaScript array to a Java String[] array
var javaStringArray = Java.to(anArray, Java.type("java.lang.String[]"));
print(javaStringArray[0]); // prints the string "1"
print(javaStringArray[1]); // prints the string "13"
print(javaStringArray[2]); // prints the string "false"

// Convert the JavaScript array to a Java Object[] array
var javaObjectArray = Java.to(anArray);
print(javaObjectArray[0]); // prints the number 1
print(javaObjectArray[1]); // prints the string "13"
print(javaObjectArray[2]); // prints the boolean value "false"
</pre>
<p>Given a Java array, you can convert it to a JavaScript array using the <code class="codeph">Java.from()</code> method. The following example shows you how to convert a Java array that contains a list of files in the current directory to a JavaScript array with the same contents:</p>
<pre dir="ltr">
// Get the Java File type object
var File = Java.type("java.io.File");
// Create a Java array of File objects
var listCurDir = new File(".").listFiles();
// Convert the Java array to a JavaScript array
var jsList = Java.from(listCurDir);
// Print the JavaScript array
print(jsList);
</pre>
<div class="infobox-note" id="GUID-EE70B448-4E7B-4F3B-B534-C5059EC9C8AD__GUID-952A75B6-346D-437F-B4CF-0B67964CC0BF">
<p class="notep1">Note:</p>
<p>In most cases, you can use the Java array in scripts without converting the Java array to a JavaScript array.</p>
</div>
</div>
</div>
<a id="JSJSG119"></a>
<div class="props_rev_3"><a id="GUID-CB28D34D-BEDD-49B6-ACC8-E1CCD82694F6"></a>
<h2 id="JSJSG-GUID-CB28D34D-BEDD-49B6-ACC8-E1CCD82694F6" class="sect2">Implementing Java Interfaces</h2>
<div>
<p>The syntax for implementing a Java interface in JavaScript is similar to how anonymous classes are declared in Java. You instantiate an interface and implement its methods (as JavaScript functions) in the same expression. The following example shows you how to implement the <code class="codeph">Runnable</code> interface:</p>
<pre dir="ltr">
// Create an object that implements the Runnable interface by implementing
// the run() method as a JavaScript function
var r  = new java.lang.Runnable() {
    run: function() {
        print("running...\n");
    }
};

// The r variable can be passed to Java methods that expect an object implementing
// the java.lang.Runnable interface
var th = new java.lang.Thread(r);
th.start();
th.join();
</pre>
<p>If a method expects an object that implements an interface with only one method, you can pass a script function to this method instead of the object. For instance, in the previous example, the <code class="codeph">Thread()</code> constructor expects an object that implements the <code class="codeph">Runnable</code> interface, which defines only one method. You can take advantage of automatic conversion and pass a script function to the <code class="codeph">Thread()</code> constructor instead of the object. The following example shows you how you can create a <code class="codeph">Thread</code> object without implementing the <code class="codeph">Runnable</code> interface:</p>
<pre dir="ltr">
// Define a JavaScript function
function func() {
    print("I am func!");
};

// Pass the JavaScript function instead of an object that implements
// the java.lang.Runnable interface
var th = new java.lang.Thread(func);
th.start();
th.join();
</pre>
<p>You can implement multiple interfaces in a subclass by passing the relevant type objects to the <code class="codeph">Java.extend()</code> function; see <a href="using-java-scripts.htm#GUID-F7E5092F-761B-4C21-83F1-78495AA50DE8">Extending Concrete Java Classes</a>.</p>
</div>
</div>
<a id="JSJSG120"></a>
<div class="props_rev_3"><a id="GUID-2DBF66C2-D89F-4B74-B80C-A5B465E4D1AB"></a>
<h2 id="JSJSG-GUID-2DBF66C2-D89F-4B74-B80C-A5B465E4D1AB" class="sect2">Extending Abstract Java Classes</h2>
<div>
<p>You can instantiate an anonymous subclass of an abstract Java class by passing to its constructor a JavaScript object with properties whose values are functions that implement the abstract methods. If a method is overloaded, then the JavaScript function will provide implementations for all variants of the method. The following example shows you how to instantiate a subclass of the abstract <code class="codeph">TimerTask</code> class:</p>
<pre dir="ltr">
var TimerTask =  Java.type("java.util.TimerTask");
var task = new TimerTask({ run: function() { print("Hello World!") } });
</pre>
<p>Instead of invoking the constructor and passing an argument to it, you can provide the argument directly after the <code class="codeph">new</code> expression. The following example shows you how this syntax (similar to Java anonymous inner class definition) can simplify the second line in the previous example:</p>
<pre dir="ltr">
var task = new TimerTask {
    run: function() {
        print("Hello World!")
    }
};
</pre>
<p>If the abstract class is a functional interface (it has a single abstract method), then instead of passing a JavaScript object to the constructor, you can pass the function that implements the method. The following example shows how you can simplify the syntax when using a functional interface:</p>
<pre dir="ltr">
var task = new TimerTask(function() { print("Hello World!") });
</pre>
<p>Whichever syntax you choose, if you need to invoke a constructor with arguments, you can specify the arguments before the implementation object or function.</p>
<p>If you want to invoke a Java method that takes a functional interface as the argument, you can pass a JavaScript function to the method. Nashorn will instantiate a subclass of the expected class and use the function to implement its only abstract method. The following example shows you how to invoke the <code class="codeph">Timer.schedule()</code> method, which expects a <code class="codeph">TimerTask</code> object as the argument:</p>
<pre dir="ltr">
var Timer = Java.type("java.util.Timer");
Timer.schedule(function() { print("Hello World!") });
</pre>
<div class="infobox-note" id="GUID-2DBF66C2-D89F-4B74-B80C-A5B465E4D1AB__GUID-A4E20A50-A8BD-4BA8-ABA5-242AB2505941">
<p class="notep1">Note:</p>
<p>The previous syntax assumes that the expected functional interface is either an interface or it has a default constructor, which is used by Nashorn to instantiate a subclass of the expected class. It is not possible to use a non-default constructor.</p>
</div>
</div>
</div>
<a id="JSJSG121"></a>
<div class="props_rev_3"><a id="GUID-F7E5092F-761B-4C21-83F1-78495AA50DE8"></a>
<h2 id="JSJSG-GUID-F7E5092F-761B-4C21-83F1-78495AA50DE8" class="sect2">Extending Concrete Java Classes</h2>
<div>
<p>To avoid ambiguity, the syntax for extending abstract classes is not allowed for concrete classes. Because a concrete class can be instantiated, such syntax may be interpreted as an attempt to create a new instance of the class and pass to it an object of the type expected by the constructor (in case when the expected object type is an interface). As an illustration of this, consider the following example:</p>
<pre dir="ltr">
var t = new java.lang.Thread({ run: function() { print("Thread running!") } });
</pre>
<p>This code can be interpreted both as extending the <code class="codeph">Thread</code> class with the specified implementation of the <code class="codeph">run()</code> method, and the instantiation of the <code class="codeph">Thread</code> class by passing to its constructor an object that implenents the <code class="codeph">Runnable</code> interface. See <a href="using-java-scripts.htm#GUID-CB28D34D-BEDD-49B6-ACC8-E1CCD82694F6">Implementing Java Interfaces</a>.</p>
<p>To extend a concrete Java class, pass its type object to the <code class="codeph">Java.extend()</code> function that returns a type object of the subclass. Then, use the type object of the subclass as a JavaScript-to-Java adapter to create instances of the subclass with the specified method implementations. The following example shows you how to extend the <code class="codeph">Thread</code> class with the specified implementation of the <code class="codeph">run()</code> method:</p>
<pre dir="ltr">
var Thread = Java.type("java.lang.Thread");
var threadExtender = Java.extend(Thread);
var t = new threadExtender() {
    run: function() { print("Thread running!") }};
</pre>
<p>The <code class="codeph">Java.extend()</code> function can take a list of multiple type objects. You can specify no more than one type object of a Java class, and as many type objects of Java interfaces as you want. The returned type object extends the specified class (or <code class="codeph">java.lang.Object</code> if no class is specified) and implements all interfaces. The class type object does not have to be first in the list.</p>
</div>
</div>
<a id="JSJSG123"></a><a id="JSJSG122"></a>
<div class="props_rev_3"><a id="GUID-14527FC1-202D-40B7-9128-70788BF534F2"></a>
<h2 id="JSJSG-GUID-14527FC1-202D-40B7-9128-70788BF534F2" class="sect2">Accessing Methods of a Superclass</h2>
<div>
<p>To access methods in the superclass, you can use the <code class="codeph">Java.super()</code> function. <a href="using-java-scripts.htm#GUID-14527FC1-202D-40B7-9128-70788BF534F2__BCEDGBEA">Example 3-1</a> shows you how to extend the <code class="codeph">java.lang.Exception</code> class and access the methods in the superclass.</p>
<p>If you run the code in <a href="using-java-scripts.htm#GUID-14527FC1-202D-40B7-9128-70788BF534F2__BCEDGBEA">Example 3-1</a>, the following will be printed to standard output:</p>
<pre dir="ltr">
jdk.nashorn.javaadapters.java.lang.Exception: MY EXCEPTION MESSAGE
</pre>
<div class="example" id="GUID-14527FC1-202D-40B7-9128-70788BF534F2__BCEDGBEA">
<p class="titleinexample">Example 3-1 Accessing Methods of a Supreclass (super.js)</p>
<pre dir="ltr">
var Exception = Java.type("java.lang.Exception");
var ExceptionAdapter = Java.extend(Exception);

var exception = new ExceptionAdapter("My Exception Message") {
    getMessage: function() {
        var _super_ = Java.super(exception);
        return _super_.getMessage().toUpperCase();
    }
}

try {
    throw exception;
} catch (ex) {
    print(exception);
}
</pre></div>
<!-- class="example" --></div>
</div>
<a id="JSJSG124"></a>
<div class="props_rev_3"><a id="GUID-B2026F05-879F-4AE3-BF12-987E9DBC48D0"></a>
<h2 id="JSJSG-GUID-B2026F05-879F-4AE3-BF12-987E9DBC48D0" class="sect2">Binding Implementations to Classes</h2>
<div>
<p>The previous sections described how to extend Java classes and implement interfaces using an extra JavaScript object parameter in the constructor that specifies the implementation. The implementation is therefore bound to the actual instance created with <code class="codeph">new</code>, and not to the whole class. This has some advantages, for example, in the memory footprint of the runtime, because Nashorn can create a single universal adapter for every combination of types being implemented. However, the following example shows that different instances have the same Java class regardless of them having different JavaScript implementation objects:</p>
<pre dir="ltr">
var Runnable = java.lang.Runnable;
var r1 = new Runnable(function() { print("I'm runnable 1!") });
var r2 = new Runnable(function() { print("I'm runnable 2!") });
r1.run();
r2.run();
print("We share the same class: " + (r1.class === r2.class));
</pre>
<p>The previous example prints the following:</p>
<pre dir="ltr">
I'm runnable 1!
I'm runnable 2!
We share the same class: true
</pre>
<p>If you want to pass the class for instantiation to an external API (for example, when using the JavaFX framework, the <code class="codeph">Application</code> class is passed to the JavaFX API, which instantiates it), you must extend a Java class or implement an interface with the implementation bound to the class, rather than to its instances. You can bind the implementation to the class by passing a JavaScript object with the implementation as the last argument to the <code class="codeph">Java.extend()</code> function. This creates a class with the same constructors as the original class, because they do not need an extra implementation object parameter. The following example shows you how to bind implementations to the class, and demonstrates that in this case the implementation classes for different invocations are different:</p>
<pre dir="ltr">
var RunnableImpl1 = Java.extend(java.lang.Runnable, function() { print("I'm runnable 1!") });
var RunnableImpl2 = Java.extend(java.lang.Runnable, function() { print("I'm runnable 2!") });
var r1 = new RunnableImpl1();var r2 = new RunnableImpl2();
r1.run();
r2.run();
print("We share the same class: " + (r1.class === r2.class));
</pre>
<p>The previous example prints the following:</p>
<pre dir="ltr">
I'm runnable 1!
I'm runnable 2!
We share the same class: false
</pre>
<p>Moving the implementation objects from the constructor invocations to the invocations of the <code class="codeph">Java.extend()</code> functions eliminates the need for an extra argument in the constructor invocations. Every invocation of the <code class="codeph">Java.extend()</code> function with a class-specific implementation object produces a new Java adapter class.The adapter classes with class-bound implementations can still take an additional constructor argument to further override the behavior for certain instances. Thus, you can combine the two approaches: you can provide part of the implementation in a class-based JavaScript implementation object passed to the <code class="codeph">Java.extend()</code> function, and provide implementations for instances in objects passed to the constructor. A function defined by the object passed to the constructer overrides the function defined by the class-bound object. The following example shows you how to override the function defined in the class-bound object with a function passed to the constructor:</p>
<pre dir="ltr">
var RunnableImpl = Java.extend(java.lang.Runnable, function() { print("I'm runnable 1!") });
var r1 = new RunnableImpl();
var r2 = new RunnableImpl(function() { print("I'm runnable 2!") });
r1.run();
r2.run();
print("We share the same class: " + (r1.class === r2.class));
</pre>
<p>The previous example prints the following:</p>
<pre dir="ltr">
I'm runnable 1!
I'm runnable 2!
We share the same class: true
</pre></div>
</div>
<a id="JSJSG125"></a>
<div class="props_rev_3"><a id="GUID-CD093FF5-43CB-41F4-9975-2D009AEA2494"></a>
<h2 id="JSJSG-GUID-CD093FF5-43CB-41F4-9975-2D009AEA2494" class="sect2">Selecting Method Overload Variant</h2>
<div>
<p>Java methods can be overloaded by argument types. The Java Compiler (<code class="codeph">javac</code>) selects the correct method variant during compilation. Overload resolution for Java methods called from Nashorn is performed when the method is invoked. The correct variant is selected automatically based on the argument types. However, if you run into genuine ambiguity with actual argument types, you can specify a particular overload variant explicitly. This may also improve performance, because the Nashorn engine will not need to perform overload resolution during invocation.</p>
<p>Overload variants are exposed as special properties. You can refer to them in the form of strings that contain the name of the method followed by the argument types within parantheses. The following example shows how to invoke the variant of the <code class="codeph">System.out.println()</code> method that expects an <code class="codeph">Object</code> class as the argument, and pass <code class="codeph">"hello"</code> to it:</p>
<pre dir="ltr">
var out = java.lang.System.out;
out["println(Object)"]("hello");
</pre>
<p>In the previous example, the unqualified class name (<code class="codeph">Object</code>) is sufficient, because it uniquely identifies the correct signature. The only case when you must use the fully qualified class names in the signature is when two overload variants use different parameter types with identical unqualified names (this is possible if parameter types with the same name are from different packages).</p>
</div>
</div>
<a id="JSJSG126"></a>
<div class="props_rev_3"><a id="GUID-68CCFBC3-E0F7-45FE-8CCC-CF1A82D91D9A"></a>
<h2 id="JSJSG-GUID-68CCFBC3-E0F7-45FE-8CCC-CF1A82D91D9A" class="sect2">Mapping Data Types</h2>
<div>
<p>Most conversions between Java and JavaScript work as you expect. Previous sections described some of the less evident data type mappings between Java and JavaScript. Arays are automatically converted to Java array types such as <code class="codeph">java.util.List</code>, <code class="codeph">java.util.Collection</code>, <code class="codeph">java.util.Queue</code>, and <code class="codeph">java.util.Deque</code>. JavaScript functions are automatically converted to SAM types when they are passed as parameters to Java methods. Every JavaScript object implements the <code class="codeph">java.util.Map</code> interface to enable APIs to receive maps directly. When numbers are passed to a Java API, they are converted to the expected target numeric type, either boxed or primitive. However, if the target type is less specific (for example, <code class="codeph">Number</code>), you can only expect them to be of type <code class="codeph">Number</code>, and must test specifically for whether the type is a boxed <code class="codeph">Double</code>, <code class="codeph">Integer</code>, <code class="codeph">Long</code>, and so on. The number can be any boxed type due to internal optimizations. Also, you can pass any JavaScript value to a Java API expecting either a boxed or primitive number, because the <code class="codeph">ToNumber</code> conversion algorithm defined by the JavaScript specification will be applied to the value. If a Java method expects a <code class="codeph">String</code> or a <code class="codeph">Boolean</code> object, the values will be converted using all conversions allowed by the <code class="codeph">ToString</code> and <code class="codeph">ToBoolean</code> conversions defined by the JavaScript specification. Nashorn ensures that internal JavaScript strings are converted to <code class="codeph">java.lang.String</code> when exposed externally.</p>
</div>
</div>
<div class="sect2"><a id="GUID-12536D6E-1D76-4E05-8C74-DD7F44DFF167"></a>
<h2 id="JSJSG-GUID-12536D6E-1D76-4E05-8C74-DD7F44DFF167" class="sect2">Passing JSON Objects to Java</h2>
<div>
<p>The function <code class="codeph">Java.asJSONCompatible(obj)</code> accepts a script object and returns an object that is compatible with the expectations of most Java JSON libraries: it exposes all arrays as <code class="codeph">List</code> objects (rather than <code class="codeph">Map</code> objects) and all other objects as <code class="codeph">Map</code> objects.</p>
<p><a href="using-java-scripts.htm#GUID-68CCFBC3-E0F7-45FE-8CCC-CF1A82D91D9A">Mapping Data Types</a> mentions that every JavaScript object, when exposed to Java APIs, implements the <code class="codeph">java.util.Map</code> interface. This is true even for JavaScript arrays. However, this behavior is often not desired or expected when Java code expects JSON-parsed objects. Java libraries that manipulate JSON-parsed objects usually expect arrays to expose the <code class="codeph">java.util.List</code> interface instead. If you need to expose your JavaScript objects in such a manner that arrays are exposed as lists and not maps, use the <code class="codeph">Java.asJSONCompatible(obj)</code> function, where <code class="codeph">obj</code> is the root of your JSON object tree.</p>
<div class="example" id="GUID-12536D6E-1D76-4E05-8C74-DD7F44DFF167__GUID-D0548DFF-0B03-4D66-AC50-2F2C95410AF7">
<p class="titleinexample">Example 3-2 Example of Java.asJSONCompatible() Function</p>
<p>The following example calls the functions <code class="codeph">JSON.parse()</code> and <code class="codeph">Java.asJSONCompatible()</code> on the same JSON object. The function <code class="codeph">JSON.parse()</code> parses the array <code class="codeph">[2,4,5]</code> as a map while the function <code class="codeph">Java.asJSONCompatible()</code> parses the same array as a list.</p>
<pre dir="ltr">
import javax.script.*;
import java.util.*;

public class JSONTest {
  public static void main(String[] args) throws Exception {
    ScriptEngineManager m = new ScriptEngineManager();
    ScriptEngine e = m.getEngineByName("nashorn");

    Object obj1 = e.eval(
      "JSON.parse('{ \"x\": 343, \"y\": \"hello\", \"z\": [2,4,5] }');");
    Map&lt;String, Object&gt; map1 = (Map&lt;String, Object&gt;)obj1;
    System.out.println(map1.get("x"));
    System.out.println(map1.get("y"));
    System.out.println(map1.get("z"));
    Map&lt;Object, Object&gt; array1 = (Map&lt;Object, Object&gt;)map1.get("z");
    array1.forEach((a, b) -&gt; System.out.println("z[" + a + "] = " + b));

    System.out.println();
    
    Object obj2 = e.eval(
      "Java.asJSONCompatible({ \"x\": 343, \"y\": \"hello\", \"z\": [2,4,5] })");
    Map&lt;String, Object&gt; map2 = (Map&lt;String, Object&gt;)obj2;
    System.out.println(map2.get("x"));
    System.out.println(map2.get("y"));
    System.out.println(map2.get("z"));
    List&lt;Object&gt; array2 = (List&lt;Object&gt;)map2.get("z");
    array2.forEach(a -&gt; System.out.println(a));
  }
}
</pre>
<p>This example prints the following:</p>
<pre dir="ltr">
343
hello
[object Array]
z[0] = 2
z[1] = 4
z[2] = 5

343
hello
[2, 4, 5]
2
4
5
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment22">
<tr>
<td class="cellalignment29">
<table class="cellalignment27">
<tr>
<td class="cellalignment26"><a href="java-scripting-api.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2015, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment31">
<table class="cellalignment32">
<tr>
<td class="cellalignment26"><a href="../index.html"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment26"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment26"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
